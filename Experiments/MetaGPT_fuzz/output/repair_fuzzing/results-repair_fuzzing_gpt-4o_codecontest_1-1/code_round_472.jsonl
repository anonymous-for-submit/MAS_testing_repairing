{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, there are N residents, identified from 1 to N, and there are exactly M pairs of friends among them. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with, or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You need to determine if there is a combination of 5 people that satisfies these strict party conditions.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, there are N residents, identified from 1 to N, and there are exactly M pairs of friends among them. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with, or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You need to determine if there is a combination of 5 people that satisfies these strict party conditions.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there are N residents, identified from 1 to N, and there are exactly M pairs of friends among them. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other. This means they can all talk to each other without having to worry about talking to someone they are not friends with. Or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You need to determine if there is a combination of 5 people that satisfies these strict party conditions.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there are N residents, identified from 1 to N, and there are exactly M pairs of friends among them. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. A party is a gathering of exactly 5 people, and it is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with, or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You need to determine if there is a combination of 5 people that satisfies these strict party conditions.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom itertools import combinations\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n (int): Number of residents.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Generate all combinations of 5 people\n    for combination in combinations(range(1, n + 1), 5):\n        # Check if the combination is a clique (all are friends)\n        if all(v in adjacency_list[u] for u in combination for v in combination if u != v):\n            return list(combination)\n        \n        # Check if the combination is an independent set (none are friends)\n        if all(v not in adjacency_list[u] for u in combination for v in combination if u != v):\n            return list(combination)\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\n\ndef successful_party(N: int, M: int, friendships: list) -> list:\n    \"\"\"Determine if a successful party can be organized.\n\n    A successful party is defined as a gathering of exactly 5 people where\n    either all attendees are friends with each other or none are friends\n    with each other.\n\n    Args:\n        N: The number of residents.\n        M: The number of friendships.\n        friendships: A list of tuples representing pairs of friends.\n\n    Returns:\n        A list of 5 people for a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph to represent friendships\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    all_nodes = set(G.nodes())\n    for combination in combinations(all_nodes, 5):\n        subgraph = G.subgraph(combination)\n        if subgraph.number_of_edges() == 0:\n            return list(combination)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\nN, M = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Call the function\nresult = successful_party(N, M, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n: Number of residents.\n        m: Number of friendships.\n        friendships: List of tuples representing friendships.\n\n    Returns:\n        A list of 5 integers if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create adjacency list for the graph representation\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Iterate over all combinations of 5 residents\n    for combination in combinations(range(1, n + 1), 5):\n        # Check if the combination forms a clique\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n        \n        # Check if the combination forms an independent set\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no valid combination is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of 5 residents based on friendship conditions.\n\n    Args:\n        n (int): Number of residents.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 residents forming a successful party or -1 if impossible.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Iterate through all combinations of 5 residents\n    for combination in combinations(graph.nodes, 5):\n        subgraph = graph.subgraph(combination)\n        \n        # Check if the combination forms a complete subgraph (clique)\n        if nx.is_clique(subgraph):\n            return list(combination)\n        \n        # Check if the combination forms an independent set\n        if nx.is_empty(subgraph):\n            return list(combination)\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendship conditions.\n\n    Args:\n        N: The number of residents on the island.\n        M: The number of friendship pairs.\n        friendships: A list of tuples representing friendship pairs.\n\n    Returns:\n        A list of 5 integers representing the residents forming a successful party,\n        or -1 if no such party can be formed.\n    \"\"\"\n    # Create adjacency list for the graph representation of friendships\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Iterate over all combinations of 5 residents\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        # Check if the combination forms a clique\n        if all(v in adjacency_list[u] for u, v in itertools.combinations(combination, 2)):\n            return list(combination)\n        \n        # Check if the combination forms an independent set\n        if all(v not in adjacency_list[u] for u, v in itertools.combinations(combination, 2)):\n            return list(combination)\n\n    # If no valid combination is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n (int): Number of residents.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Iterate over all combinations of 5 nodes\n    for combo in combinations(G.nodes, 5):\n        subgraph = G.subgraph(combo)\n        # Check if the subgraph is a clique or an independent set\n        if nx.is_clique(subgraph) or nx.is_empty(subgraph):\n            return list(combo)\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, friendships: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Find a successful party of 5 people based on friendship rules.\n\n    Args:\n        n (int): Number of residents.\n        friendships (list[tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        list[int]: List of 5 people if a successful party can be organized, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\nimport itertools\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n (int): Number of residents.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Iterate through all combinations of 5 nodes\n    for combination in itertools.combinations(graph.nodes, 5):\n        subgraph = graph.subgraph(combination)\n        \n        # Check if the subgraph is a complete graph (clique)\n        if nx.is_clique(subgraph):\n            return list(combination)\n        \n        # Check if the subgraph is an independent set (no edges)\n        if subgraph.number_of_edges() == 0:\n            return list(combination)\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on the given friendships.\n\n    Args:\n        n (int): The number of people in Baltia.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in a graph is a set of vertices no two of which are adjacent.\n    # We can find independent sets by checking the complement graph for cliques.\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Find a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n (int): Number of residents.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of 5 people for a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires determining if a group of 5 people can form a successful party based on strict friendship conditions. The solution must efficiently handle up to 200,000 residents and friendships, ensuring it can process large datasets quickly. The output must be clear and adhere to the specified format, providing either a valid group of 5 or indicating impossibility.\nrequirement pool:\n- Develop an algorithm to check for a successful party of 5 people.\n- Ensure the solution is optimized for large input sizes.\n- Provide clear and formatted output as per requirements.\n- Handle edge cases where no friendships exist or all are friends.\n- Consider multiple valid outputs if possible.\nWe will use graph theory to solve this problem. The residents and their friendships can be represented as a graph where each resident is a node and each friendship is an edge. The problem then reduces to finding a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). Given the constraints, we will use adjacency lists to represent the graph and check combinations of 5 nodes to see if they meet the criteria. This approach is efficient given the constraints and will utilize Python's itertools library to generate combinations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'no two people': Indicates that none of the attendees should be friends with each other for one of the conditions of a successful party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the residents and friendships as a graph using adjacency lists.\n    2. Use combinations to generate all possible sets of 5 people.\n    3. For each combination, check if all members are friends (clique) or none are friends (independent set).\n    4. If a valid combination is found, print the 5 people; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people will form an independent set.\n    \n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can exist, and a clique of size 5 is impossible if N=6.\n    \n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 people will form an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations of 5 nodes for either a clique or an independent set will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining if a successful party can be organized based on strict friendship conditions. The solution must efficiently handle large inputs and provide clear outputs. The challenge lies in the graph theory aspect of finding cliques or independent sets of size 5.\nrequirement pool:\n- Implement graph traversal to find cliques of size 5.\n- Check for independent sets of size 5.\n- Optimize for large input sizes.\n- Ensure no duplicate friendship pairs are processed.\n- Provide user-friendly output format.\nWe will use graph theory to solve this problem. Specifically, we will utilize the NetworkX library to efficiently handle graph operations. The approach involves checking for cliques of size 5 using the find_cliques function and verifying independent sets by checking combinations of nodes with no edges between them.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'no two people': Indicates that none of the attendees should be friends with each other for one type of successful party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using a graph where nodes are people and edges are friendships.\n    2. Check for cliques of size 5 (where all members are friends with each other).\n    3. Check for independent sets of size 5 (where no members are friends with each other).\n    4. If either condition is met, print the 5 people involved; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is a friendship, no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can form a successful party based on strict friendship conditions. The solution must efficiently handle up to 200,000 residents and friendships, ensuring scalability and performance. The output must be clear, either providing a valid group of 5 or indicating impossibility with -1.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party conditions among 5 people.\n- Ensure the solution can handle the maximum constraints of N and M efficiently.\n- Provide clear and concise output as per the specified format.\n- Optimize the algorithm to handle edge cases, such as no friendships or all residents being friends.\n- Consider user-friendly documentation for understanding the solution approach.\nWe will use a graph-based approach to solve this problem. The residents and their friendships can be represented as a graph where each resident is a node and each friendship is an edge. We need to find a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). Given the constraints, we will use adjacency lists for efficient graph representation and leverage combinations to check possible groups of 5 people. The solution will be optimized to handle the maximum constraints efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means a group of 5 people where everyone is friends with everyone else.\n\n    'independent set'\n    Explanation: An independent set in a graph is a set of vertices no two of which are adjacent. Here, it means a group of 5 people where no one is friends with anyone else in the group.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    'no two people': This implies that in the independent set, there should be no friendships between any pair of the 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the residents and friendships as a graph using adjacency lists.\n2. Iterate over all possible combinations of 5 residents.\n3. For each combination, check if it forms a clique by verifying if every pair of people in the combination are friends.\n4. If not a clique, check if it forms an independent set by verifying if no pair of people in the combination are friends.\n5. If either condition is satisfied, print the combination and exit.\n6. If no valid combination is found after checking all possibilities, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 10 0\n    Output: Any combination of 5 people\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from N residents such that either all are friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to find a successful party configuration.\n- Ensure the solution handles edge cases, such as minimum and maximum values of N and M.\n- Provide clear output format as specified in the requirements.\n- Optimize the solution for performance with large datasets.\n- Include error handling for invalid inputs.\nWe will use a graph-based approach to solve this problem. The residents and their friendships can be represented as a graph where each resident is a node and each friendship is an edge. We need to find a subset of 5 nodes (residents) such that either all nodes are connected (a complete subgraph or clique) or none of the nodes are connected (an independent set). Given the constraints, we will use efficient graph traversal techniques to check for these conditions. NetworkX, a Python library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks, will be used to handle the graph operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'no two people': Indicates that none of the attendees should be friends with each other for one of the conditions of a successful party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the residents and friendships as a graph using NetworkX.\n    2. Iterate through all possible combinations of 5 residents.\n    3. For each combination, check if it forms a complete subgraph (clique) or an independent set.\n    4. If a successful party is found, print the combination of residents.\n    5. If no successful party is found after checking all combinations, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any combination of 5 people will form an independent set, satisfying the successful party condition.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can be formed, and if any subset of 5 forms a clique, it would be impossible due to the constraint of having exactly 6 people.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any combination of 5 people will form an independent set, satisfying the successful party condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for cliques or independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from N residents such that either all are friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently due to the large possible input size. The solution must handle edge cases where M is 0 or very large, and ensure that the output format is strictly followed.\nrequirement pool:\n- Develop an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles maximum constraints of N and M efficiently.\n- Optimize the algorithm to minimize time complexity.\n- Provide clear documentation and comments in the code for maintainability.\n- Consider edge cases and test thoroughly with various inputs.\nWe will use a graph-based approach to solve this problem. The residents and their friendships can be represented as a graph where each resident is a node and each friendship is an edge. The task is to find a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). Given the constraints, we will use adjacency lists to represent the graph and employ efficient graph traversal techniques to check for these conditions. We will leverage the itertools library to generate combinations of nodes and check the conditions efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all 5 people are friends with each other or no two people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'all the people at the party are friends with each other': This implies a complete subgraph (clique) of 5 nodes.\n    'no two people at the party are friends with each other': This implies an independent set of 5 nodes.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the residents and friendships as a graph using adjacency lists.\n2. Iterate over all possible combinations of 5 residents.\n3. For each combination, check if it forms a clique (all nodes are connected) or an independent set (no nodes are connected).\n4. If a valid combination is found, print the 5 residents.\n5. If no valid combination is found after checking all possibilities, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 residents\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 10 0\n    Output: Any combination of 5 residents\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations of 5 residents will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from N residents such that either all are friends or none are friends. This involves checking combinations and ensuring the solution is efficient given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to check combinations of 5 people.\n- Ensure the solution handles edge cases like minimum and maximum values of N and M.\n- Optimize for time complexity to handle large inputs.\n- Provide clear output format as specified in the requirements.\n- Consider multiple successful party combinations if possible.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by representing the residents and their friendships as a graph, where nodes represent residents and edges represent friendships. We will use the NetworkX library to handle graph operations efficiently. The solution involves checking combinations of 5 nodes to see if they form a complete subgraph (clique) or an independent set (no edges between them). Given the constraints, we will optimize the search using graph properties and efficient traversal methods.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all 5 people are friends with each other (a clique) or no two people are friends with each other (an independent set).\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'all the people': All 5 individuals must be friends with each other for a successful party.\n    'no two people': None of the 5 individuals should be friends with each other for a successful party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the residents and friendships as a graph using an adjacency list or matrix.\n2. Iterate over all possible combinations of 5 residents.\n3. For each combination, check if it forms a clique (all pairs are friends) or an independent set (no pairs are friends).\n4. If a successful party is found, print the combination of 5 residents.\n5. If no successful party is found after checking all combinations, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 7 0\n    Output: Any combination of 5 people\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations of 5 residents will naturally handle these cases.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people from N residents such that they are either all friends or none are friends. The constraints on N and M suggest the need for an efficient algorithm, likely involving graph theory concepts such as cliques or independent sets.\nrequirement pool:\n- Develop an algorithm to find a successful party of 5 people.\n- Ensure the solution is efficient for large values of N and M.\n- Handle edge cases where M is 0 or very large.\n- Provide clear and concise output as per the format.\n- Optimize for readability and maintainability of the code.\nWe will use graph theory concepts to solve this problem efficiently. Specifically, we will utilize adjacency lists to represent friendships and check for cliques or independent sets of size 5. The NetworkX library can be used to handle graph operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all 5 people are friends with each other or no two people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of exactly 5 people, no more, no less.\n    'no two': In one scenario, none of the 5 people should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for cliques of size 5 where all members are friends with each other.\n    3. Check for independent sets of size 5 where no members are friends with each other.\n    4. If either condition is met, print the 5 people involved; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can exist, and a clique of size 5 is impossible if N < 6.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M. The solution must be optimized for large inputs and provide a clear output format.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party conditions.\n- Ensure the solution handles edge cases, such as minimum and maximum values of N and M.\n- Optimize the algorithm for performance with large datasets.\n- Provide clear documentation and examples for understanding the solution.\n- Implement additional features for user interaction, if needed.\nWe will use graph theory principles to solve this problem efficiently. The problem can be approached by representing the residents and their friendships as a graph, where nodes represent residents and edges represent friendships. We will use the NetworkX library to handle graph operations efficiently. The solution involves checking combinations of 5 nodes to see if they form a complete subgraph (clique) or an independent set (no edges between them). Given the constraints, we need to ensure the algorithm is optimized to handle large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all attendees are friends with each other or none are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of precisely 5 people.\n    'no two people': Indicates that none of the attendees should be friends with each other in one of the successful party conditions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the residents and friendships as a graph using NetworkX.\n    2. Iterate through combinations of 5 nodes (people) in the graph.\n    3. For each combination, check if it forms a complete subgraph (clique) or an independent set (no edges between them).\n    4. If a successful party is found, print the combination of 5 people.\n    5. If no successful party is found after checking all combinations, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any combination of 5 people will satisfy the condition of no two people being friends.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, it's impossible to have a combination where no two people are friends.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any combination of 5 people will satisfy the condition of no two people being friends.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations of nodes for cliques or independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles edge cases, such as minimum and maximum values of N and M.\n- Optimize the solution to run within time limits for large inputs.\n- Provide clear and concise output as per the problem statement.\n- Consider multiple successful configurations if they exist.\nWe will use graph theory to model the friendships as an undirected graph. The problem can be solved by checking for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We will use the NetworkX library to efficiently handle graph operations and check for these conditions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques of size 5'\n    Explanation: A clique of size 5 means a subset of 5 people where every pair of people are friends with each other.\n\n    'independent sets of size 5'\n    Explanation: An independent set of size 5 means a subset of 5 people where no two people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of exactly 5 people, no more, no less.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Model the friendships as an undirected graph using NetworkX.\n    2. Check for cliques of size 5 in the graph.\n    3. If a clique is found, return the nodes in the clique.\n    4. If no clique is found, check for independent sets of size 5.\n    5. If an independent set is found, return the nodes in the set.\n    6. If neither is found, return -1.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships (a complete graph), no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining if a successful party can be organized under strict conditions. The solution must efficiently handle large inputs and provide clear outputs. The challenge lies in checking combinations of friendships and ensuring scalability.\nrequirement pool:\n- Implement algorithm to check all-friends or no-friends conditions for party success.\n- Optimize for large datasets to ensure quick processing.\n- Provide clear output format as specified in requirements.\n- Handle edge cases where no party is possible.\n- Consider multiple successful party combinations if possible.\nWe will use graph theory to solve this problem. Specifically, we will represent the residents and their friendships as a graph, where nodes are residents and edges are friendships. We will then check for cliques of size 5 (where all nodes are connected) or independent sets of size 5 (where no nodes are connected). The NetworkX library will be used to efficiently handle graph operations and check for these conditions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 people.\n    'successful party': A party where either all 5 people are friends with each other or none of them are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of precisely 5 individuals.\n    'all the people at the party are friends with each other': All 5 people must have direct friendships with each other.\n    'no two people at the party are friends with each other': None of the 5 people should have a direct friendship with any other in the group.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the residents and friendships as a graph using nodes and edges.\n2. Check for cliques of size 5, where all nodes are connected.\n3. Check for independent sets of size 5, where no nodes are connected.\n4. If either condition is met, print the 5 people involved.\n5. If neither condition is met, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible friendship present, no group of 5 can be an independent set.\n\n    Input: 7 10\n    Output: -1\n    Explanation: If no clique or independent set of size 5 exists, the output should be -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement a function to check for cliques of size 5.\n    - Implement a function to check for independent sets of size 5.\n    - Use these functions to determine if a successful party is possible.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 472, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "rephrase_one", "parent_index": 304}
