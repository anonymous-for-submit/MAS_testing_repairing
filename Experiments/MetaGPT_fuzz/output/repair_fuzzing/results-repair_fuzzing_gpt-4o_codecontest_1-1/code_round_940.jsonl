{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM found a rectangle A of dimensions n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. Additionally, CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions: a \u2265 5, b \u2265 4. For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. For all 1<x<a,1<y<b, block M_{x,y} is an empty block. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that the rectangle must have a rows and b columns, not b rows and a columns. CQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. To achieve this, determine the optimal choice of sub-rectangle that minimizes the required operations.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM found a rectangle A of dimensions n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. Additionally, CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions: a \u2265 5, b \u2265 4. For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. For all 1<x<a,1<y<b, block M_{x,y} is an empty block. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that the rectangle must have a rows and b columns, not b rows and a columns. CQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. To achieve this, determine the optimal choice of sub-rectangle that minimizes the required operations.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM found a rectangle A of dimensions n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. Additionally, CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions: a \u2265 5, b \u2265 4. For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. It is important that for all 1 < x < a and 1 < y < b, block M_{x,y} is an empty block. This requirement is necessary for satisfying the portal condition. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that the rectangle must have a rows and b columns, not b rows and a columns. CQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal. To achieve this, determine the optimal choice of sub-rectangle that minimizes the required operations.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM found a rectangle A of dimensions n \u00d7 m with n rows and m columns of blocks, where each block of the rectangle is either an obsidian block or empty, and additionally, CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation. A rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions: a \u2265 5, b \u2265 4, for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks, for all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks, and for all 1<x<a,1<y<b, block M_{x,y} is an empty block, and M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. Note that the rectangle must have a rows and b columns, not b rows and a columns. CQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal, so to achieve this, determine the optimal choice of sub-rectangle that minimizes the required operations.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n\n                        # Check the border conditions\n                        for x in range(start_row, start_row + a):\n                            if x == start_row or x == start_row + a - 1:\n                                # Top and bottom borders\n                                for y in range(start_col + 1, start_col + b - 1):\n                                    if case[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right borders\n                                if case[x][start_col] != '1':\n                                    operations += 1\n                                if case[x][start_col + b - 1] != '1':\n                                    operations += 1\n\n                        # Check the inner conditions\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if case[x][y] != '0':\n                                    operations += 1\n\n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings representing the rectangle\n    :return: List of integers, each representing the minimum operations for the corresponding test case\n    \"\"\"\n    results = []\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        # Check border conditions\n                        for x in range(start_row, start_row + a):\n                            if x == start_row or x == start_row + a - 1:\n                                # Top and bottom borders\n                                for y in range(start_col, start_col + b):\n                                    if grid_array[x, y] != 1:\n                                        operations += 1\n                            else:\n                                # Left and right borders\n                                if grid_array[x, start_col] != 1:\n                                    operations += 1\n                                if grid_array[x, start_col + b - 1] != 1:\n                                    operations += 1\n                        # Check inner conditions\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid_array[x, y] != 0:\n                                    operations += 1\n                        min_operations = min(min_operations, operations)\n        results.append(min_operations)\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing the dimensions and the grid.\n\n    Returns:\n        list: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed to make this sub-rectangle a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check border conditions\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n\n    # Check inner conditions\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    results = find_min_operations(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n    :param t: Number of test cases.\n    :param test_cases: List of tuples, each containing n, m, and the grid.\n    :return: List of minimum operations for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size a \u00d7 b\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate the number of changes needed for the current sub-rectangle\n                operations = calculate_operations(grid_array, start_row, start_col)\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(grid_array: np.ndarray, start_row: int, start_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n    :param grid_array: The grid as a numpy array.\n    :param start_row: Starting row of the sub-rectangle.\n    :param start_col: Starting column of the sub-rectangle.\n    :return: Number of operations needed.\n    \"\"\"\n    a, b = 5, 4  # Dimensions of the portal\n    operations = 0\n    \n    # Check border conditions\n    for i in range(1, a - 1):\n        if grid_array[start_row + i, start_col] != 1:\n            operations += 1\n        if grid_array[start_row + i, start_col + b - 1] != 1:\n            operations += 1\n    \n    for j in range(1, b - 1):\n        if grid_array[start_row, start_col + j] != 1:\n            operations += 1\n        if grid_array[start_row + a - 1, start_col + j] != 1:\n            operations += 1\n    \n    # Check interior conditions\n    for i in range(1, a - 1):\n        for j in range(1, b - 1):\n            if grid_array[start_row + i, start_col + j] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix) for each test case\n    :return: List of minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array([[int(char) for char in row] for row in matrix])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param grid: The numpy array representing the matrix\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for i in range(start_row + 1, end_row):\n        if grid[i, start_col] != 1:\n            operations += 1\n        if grid[i, end_col] != 1:\n            operations += 1\n\n    for j in range(start_col + 1, end_col):\n        if grid[start_row, j] != 1:\n            operations += 1\n        if grid[end_row, j] != 1:\n            operations += 1\n\n    # Check the inner conditions\n    for i in range(start_row + 1, end_row):\n        for j in range(start_col + 1, end_col):\n            if grid[i, j] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the rectangle.\n            - m (int): Number of columns in the rectangle.\n            - grid (list[str]): List of strings representing the rectangle.\n\n    Returns:\n        list[int]: List of integers, each representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of changes needed to satisfy the portal conditions\n                        changes = 0\n                        # Check border conditions\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom rows\n                                for y in range(b):\n                                    if matrix[i + x, j + y] != 1:\n                                        changes += 1\n                            else:\n                                # Middle rows\n                                if matrix[i + x, j] != 1:\n                                    changes += 1\n                                if matrix[i + x, j + b - 1] != 1:\n                                    changes += 1\n                        for y in range(b):\n                            if y == 0 or y == b - 1:\n                                # Left and right columns\n                                for x in range(a):\n                                    if matrix[i + x, j + y] != 1:\n                                        changes += 1\n                            else:\n                                # Middle columns\n                                if matrix[i, j + y] != 1:\n                                    changes += 1\n                                if matrix[i + a - 1, j + y] != 1:\n                                    changes += 1\n                        # Check inner conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if matrix[i + x, j + y] != 0:\n                                    changes += 1\n                        # Track the minimum number of changes required\n                        min_operations = min(min_operations, changes)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix) where matrix is a list of strings\n    :return: List of integers, each representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient manipulation\n        grid = np.array([[int(char) for char in row] for row in matrix])\n        min_operations = float('inf')\n        no_possible_portal = True\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible dimensions of sub-rectangles\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, a, b)\n                        if operations != -1:\n                            no_possible_portal = False\n                            min_operations = min(min_operations, operations)\n\n        if no_possible_portal:\n            results.append(-1)\n        else:\n            results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param grid: The numpy array representing the matrix\n    :param start_row: The starting row of the sub-rectangle\n    :param start_col: The starting column of the sub-rectangle\n    :param a: The number of rows in the sub-rectangle\n    :param b: The number of columns in the sub-rectangle\n    :return: The number of operations needed, or -1 if it cannot be transformed into a portal\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions for the portal\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            operations += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            operations += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            operations += 1\n\n    # Check the inner conditions for the portal\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Process and Output\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_for_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing the grid dimensions and the grid itself.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a x b\n        for i in range(n - 4):\n            for j in range(m - 3):\n                sub_rect = grid_array[i:i+5, j:j+4]\n                operations = calculate_operations(sub_rect)\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef is_portal(sub_rect: np.ndarray) -> bool:\n    \"\"\"Check if the sub-rectangle is already a portal.\n\n    Args:\n        sub_rect (np.ndarray): Sub-rectangle to check.\n\n    Returns:\n        bool: True if already a portal, False otherwise.\n    \"\"\"\n    # Check border conditions\n    if not np.all(sub_rect[1:-1, 0] == 1) or not np.all(sub_rect[1:-1, -1] == 1):\n        return False\n    if not np.all(sub_rect[0, 1:-1] == 1) or not np.all(sub_rect[-1, 1:-1] == 1):\n        return False\n\n    # Check interior conditions\n    if not np.all(sub_rect[1:-1, 1:-1] == 0):\n        return False\n\n    return True\n\ndef calculate_operations(sub_rect: np.ndarray) -> int:\n    \"\"\"Calculate the number of operations needed for non-portal sub-rectangle.\n\n    Args:\n        sub_rect (np.ndarray): Sub-rectangle to transform.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Calculate operations for borders\n    operations += np.sum(sub_rect[1:-1, 0] != 1)\n    operations += np.sum(sub_rect[1:-1, -1] != 1)\n    operations += np.sum(sub_rect[0, 1:-1] != 1)\n    operations += np.sum(sub_rect[-1, 1:-1] != 1)\n\n    # Calculate operations for interior\n    operations += np.sum(sub_rect[1:-1, 1:-1] != 0)\n\n    return operations\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    results = min_operations_for_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a matrix of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n\n                        # Calculate operations needed for current sub-rectangle\n                        for x in range(a):\n                            for y in range(b):\n                                current_block = case[i + x][j + y]\n                                if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                                    # Border blocks should be obsidian\n                                    if current_block == '0':\n                                        operations += 1\n                                else:\n                                    # Inner blocks should be empty\n                                    if current_block == '1':\n                                        operations += 1\n\n                        # Update minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append(matrix)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the grid as a list of strings\n    :return: List of integers, each representing the minimum operations for a test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param matrix: The grid as a numpy array\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check edges and corners\n    for row in range(start_row, end_row + 1):\n        for col in range(start_col, end_col + 1):\n            if row == start_row or row == end_row or col == start_col or col == end_col:\n                # Edge block should be obsidian (1)\n                if matrix[row, col] == 0:\n                    operations += 1\n            else:\n                # Interior block should be empty (0)\n                if matrix[row, col] == 1:\n                    operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must be efficient to handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the operations needed efficiently.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations.\n- Ensure the solution is efficient for large inputs.\n- Optimize the algorithm for edge cases.\n- Provide clear and formatted output.\n- Include comments and documentation for maintainability.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to convert each into a portal. We will use a brute-force method with optimizations to ensure efficiency within the given constraints. The solution will be implemented in Python, leveraging basic data structures like lists for grid representation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the grid of blocks with n rows and m columns, where each block can either be an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific conditions: a \u2265 5, b \u2265 4, with specific blocks being obsidian or empty as described.\n\n    'minimum number of operations'\n    Explanation: The least number of changes needed to convert a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles that meet these size constraints.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The smallest number of operations required. In code, this involves keeping track of the lowest count of changes needed across all possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the dimensions n and m, and the grid configuration.\n3. Iterate over all possible sub-rectangles of size at least 5x4.\n4. For each sub-rectangle, calculate the number of changes needed to convert it into a portal:\n   - Ensure the border conditions for obsidian blocks are met.\n   - Ensure the inner conditions for empty blocks are met.\n5. Track the minimum number of changes required for each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case] \n    Edge Case 1: A grid that is already a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Edge Case 2: A grid with all blocks as obsidian.\n    Example:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The inner blocks need to be converted to empty blocks, requiring multiple changes.\n\n    Edge Case 3: A grid with all blocks as empty.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 16\n    Explanation: The border blocks need to be converted to obsidian blocks, requiring multiple changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum number of changes will naturally handle these cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input size. The key challenge is to identify the optimal sub-rectangle and calculate the operations needed.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations\n- Optimize the algorithm for large input sizes\n- Ensure the solution is easy to understand and maintain\n- Test the solution with edge cases and maximum constraints\n- Document the solution and provide usage examples\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to convert each into a portal. We will use a brute-force method with optimizations to ensure it runs efficiently within the given constraints. The solution will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where each cell can either be an obsidian block (1) or an empty block (0).\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific conditions: a \u2265 5, b \u2265 4, with specific blocks being obsidian and others empty.\n\n    'minimum number of operations'\n    Explanation: The least number of changes needed to convert a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest possible number of operations required. In code, this involves finding the sub-rectangle with the least changes needed.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, read the n \u00d7 m grid.\n3. Iterate over all possible sub-rectangles of size at least 5x4.\n4. For each sub-rectangle, calculate the number of changes needed to convert it into a portal:\n   - Ensure the border conditions for obsidian blocks are met.\n   - Ensure the inner conditions for empty blocks are met.\n5. Track the minimum number of operations required for each test case.\n6. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Explanation: If the grid already satisfies the portal conditions, no operations are needed. Expected output is 0.\n\n    Case 2: A grid with all blocks as obsidian.\n    Explanation: The maximum number of changes will be needed to create empty spaces inside the portal. Expected output will depend on the specific dimensions.\n\n    Case 3: A grid with all blocks as empty.\n    Explanation: The maximum number of changes will be needed to create obsidian borders. Expected output will depend on the specific dimensions.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid is already a portal or entirely filled with one type of block.\n    \n```python\ndef min_operations_to_portal(test_cases):\n    results = []\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n                        # Check border conditions\n                        for x in range(start_row, start_row + a):\n                            if x == start_row or x == start_row + a - 1:\n                                # Top and bottom borders\n                                for y in range(start_col, start_col + b):\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right borders\n                                if grid[x][start_col] != '1':\n                                    operations += 1\n                                if grid[x][start_col + b - 1] != '1':\n                                    operations += 1\n                        # Check inner conditions\n                        for x in range(start_row + 1, start_row + a - 1):\n                            for y in range(start_col + 1, start_col + b - 1):\n                                if grid[x][y] != '0':\n                                    operations += 1\n                        min_operations = min(min_operations, operations)\n        results.append(min_operations)\n    return results\n```\nThis code iterates over all possible sub-rectangles and calculates the number of changes needed to convert each into a portal, keeping track of the minimum number of operations required.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the optimal sub-rectangle. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for portal creation.\n- Optimize the algorithm for performance with large inputs.\n- Ensure the solution handles edge cases accurately.\n- Develop a user-friendly interface for input and output.\n- Include detailed documentation for understanding the solution process.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations and slicing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where each cell can either be an obsidian block (represented by '1') or an empty block (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific conditions: it must be at least 5 rows high and 4 columns wide, with specific blocks being obsidian and others empty.\n\n    'minimum number of operations'\n    Explanation: The task is to find the least number of changes needed to transform a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': \n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles that meet these size constraints.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to find the smallest number of changes needed. In code, this involves keeping track of the minimum number of operations found across all possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the dimensions n and m, and then the grid itself.\n3. Iterate over all possible sub-rectangles of size at least 5x4.\n4. For each sub-rectangle, calculate the number of changes needed to make it a portal:\n   - Ensure the border conditions are met with obsidian blocks.\n   - Ensure the inner blocks are empty.\n5. Track the minimum number of changes required for each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case] \n    Edge Case 1: A grid that is exactly 5x4 with all blocks already meeting portal conditions.\n    Expected Output: 0\n    Explanation: No changes are needed as it already satisfies the portal conditions.\n\n    Edge Case 2: A grid that is exactly 5x4 with all blocks being empty.\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, requiring 12 changes.\n\n    Edge Case 3: A grid that is larger than 5x4 but has no possible sub-rectangle that can be transformed into a portal without exceeding the maximum allowed operations.\n    Expected Output: Depends on specific grid configuration; generally, it would be a high number if no efficient transformation is possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations inherently handles these cases.\n", "requirement analysis:\nThe problem requires identifying the minimum number of operations to transform a sub-rectangle into a portal. The constraints on dimensions and block types must be carefully managed to ensure the solution is both efficient and correct. The solution should handle multiple test cases and provide results in a clear format.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal transformation.\n- Ensure solution handles maximum constraints effectively.\n- Provide clear output format for easy verification.\n- Optimize code for performance with large inputs.\n- Include edge case handling for varied input scenarios.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m grid and calculate the number of changes needed to satisfy the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of dimensions a \u00d7 b where specific conditions are met regarding the placement of obsidian and empty blocks.\n\n    'obsidian block'\n    Explanation: In the context, an obsidian block is represented by '1' and must be placed at specific positions to form a portal.\n\n    'empty block'\n    Explanation: An empty block is represented by '0' and must fill the interior of the portal rectangle.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b \u2265 4': The number of columns in the portal must be at least 4.\n    'minimum number of operations': The goal is to find the least number of changes needed to form a portal.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m grid.\n    3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n       - Ensure the border blocks are obsidian ('1') except for corners which can be any type.\n       - Ensure all interior blocks are empty ('0').\n    4. Track the minimum number of operations required across all sub-rectangles.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already obsidian.\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The entire interior needs to be converted to empty blocks.\n\n    Case 2: A grid where all blocks are already empty.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: The border needs to be converted to obsidian blocks.\n\n    Case 3: A grid with alternating obsidian and empty blocks.\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on optimal sub-rectangle choice.\n    Explanation: The optimal choice will minimize changes by leveraging existing obsidian blocks on borders.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on matrix dimensions and block types are clear, ensuring the solution must efficiently handle edge cases and large inputs. The output format is crucial for user understanding and must be strictly followed.\nrequirement pool:\n- Implement efficient matrix transformation algorithm\n- Ensure accurate computation for all test cases\n- Optimize for large input sizes\n- Provide clear output format\n- Include detailed comments for code clarity\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle of a given matrix into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where each cell can either be an obsidian block (1) or an empty block (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific conditions: it must be at least 5 rows high and 4 columns wide, with specific blocks being obsidian and others empty.\n\n    'operation'\n    Explanation: Changing a block from obsidian to empty or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles that meet these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the sub-rectangle that requires the fewest changes to become a portal. In code, this involves keeping track of the smallest number of operations needed across all possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal conditions:\n   - Ensure the border blocks are obsidian.\n   - Ensure the inner blocks are empty.\n4. Keep track of the minimum number of changes needed for any sub-rectangle in each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No changes are needed as it already meets the portal conditions.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: All inner blocks need to be changed to empty, and some border blocks need to be changed to obsidian.\n\n    Case 3: A rectangle with all blocks as empty.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the required changes will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the optimal solution. The solution must efficiently handle multiple test cases and large input sizes while providing clear output.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation\n- Ensure solution handles maximum input sizes within constraints\n- Provide clear output format for user understanding\n- Optimize for speed and accuracy in computation\n- Include detailed comments and documentation for code clarity\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of valid dimensions and calculating the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix where each cell can either be an obsidian block (1) or an empty block (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific conditions: it has dimensions a \u00d7 b with a \u2265 5 and b \u2265 4, and specific blocks must be obsidian or empty as described.\n\n    'minimum number of operations'\n    Explanation: The least number of changes needed to transform a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    \n    '1 < x < a': For rows, this means all rows except the first and last must have specific conditions.\n    \n    '1 < x < b': For columns, this means all columns except the first and last must have specific conditions.\n\n# [degree adverb]\n    'minimum': Refers to the smallest number of operations needed to achieve the goal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions a \u00d7 b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n   - Ensure the border blocks are obsidian.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Explanation: If a sub-rectangle already meets all portal conditions, the expected output is 0 operations.\n\n    Case 2: A rectangle with maximum dimensions (400x400) filled entirely with obsidian blocks.\n    Explanation: The expected output would be the maximum number of changes needed to create a portal, as all inner blocks need to be changed to empty.\n\n    Case 3: A rectangle with minimum dimensions (5x4) filled entirely with empty blocks.\n    Explanation: The expected output would be the number of changes needed to make the border blocks obsidian.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the portal structure. The solution must efficiently handle multiple test cases and large matrices, ensuring both speed and accuracy.\nrequirement pool:\n- Implement efficient matrix transformation algorithm\n- Ensure accurate portal identification\n- Optimize for large input sizes\n- Provide clear and concise output\n- Handle edge cases and unusual input scenarios\nWe will implement a function that iterates over all possible sub-rectangles of the given matrix that can potentially be a portal. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will return the minimum number of operations required. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, where each block can be either an obsidian block or empty.\n    'portal': A specific sub-rectangle with dimensions a \u00d7 b that meets certain conditions to be considered a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b \u2265 4': The number of columns in the portal must be at least 4.\n    'for every 1 < x < a': Indicates a range for x, meaning x must be greater than 1 and less than a.\n    'for all 1 < x < b': Indicates a range for x, meaning x must be greater than 1 and less than b.\n\n# [degree adverb]\n    'minimum': We need to find the smallest number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles that can potentially be a portal.\n    3. For each sub-rectangle, check if it meets the portal conditions and calculate the number of operations needed.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle with dimensions exactly 5 \u00d7 4 where all blocks are already in portal configuration.\n    Expected output: 0\n    Explanation: No operations are needed as the rectangle already satisfies the portal conditions.\n\n    Case 2: A rectangle with dimensions larger than 5 \u00d7 4 but no possible sub-rectangle can be transformed into a portal.\n    Expected output: -1\n    Explanation: If no sub-rectangle can be transformed into a portal, we might need to handle this as an error or special case.\n\n    Case 3: A rectangle with dimensions exactly 5 \u00d7 4 where all blocks are empty.\n    Expected output: Number of operations needed to transform all required blocks into obsidian blocks.\n    Explanation: Calculate the number of changes needed to meet the portal conditions.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where no sub-rectangle can be transformed into a portal.\n        if no_possible_portal:\n            return -1\n        (other code)\n", "requirement analysis:\nThe requirements focus on transforming a grid of blocks into a portal with minimal operations. The constraints on grid size and block types are clear, and the solution must efficiently handle multiple test cases while ensuring accurate results. The output format is crucial for user understanding.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation.\n- Ensure solution handles maximum grid size constraints effectively.\n- Provide clear output format for user understanding.\n- Optimize computation for large number of test cases.\n- Include detailed explanation of results in output.\nWe will implement a function that iterates over all possible sub-rectangles of size a x b within the given n x m grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will keep track of the minimum number of operations required across all sub-rectangles. We will use numpy for efficient matrix operations and slicing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle with specific conditions on its borders and interior.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b \u2265 4': The number of columns in the portal must be at least 4.\n    'for every 1 < x < a': Indicates a range of rows within the portal.\n    'for all 1 < x < b': Indicates a range of columns within the portal.\n\n# [degree adverb]\n    'minimum': We need to find the smallest number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size a x b within the n x m grid.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the borders are obsidian blocks as per the portal conditions.\n   - Ensure the interior blocks are empty.\n4. Keep track of the minimum number of operations required across all sub-rectangles.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    8\n    Explanation: The entire rectangle is obsidian blocks, requiring conversion of interior blocks to empty.\n\n    Test case with alternating blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output: \n    12\n    Explanation: Requires conversion of alternating blocks to meet portal conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        # Check if the sub-rectangle is already a portal, if not calculate operations needed.\n        def is_portal(sub_rect):\n            # Check border conditions and interior conditions\n            # Return True if already a portal, False otherwise\n\n        # Calculate operations needed for non-portal sub-rectangle\n        def calculate_operations(sub_rect):\n            # Count mismatches with portal conditions and return count\n\n        # Main function logic\n        for test_case in test_cases:\n            min_operations = float('inf')\n            for sub_rect in possible_sub_rectangles:\n                if not is_portal(sub_rect):\n                    operations = calculate_operations(sub_rect)\n                    min_operations = min(min_operations, operations)\n            print(min_operations)\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the optimal sub-rectangle. Efficient algorithms are needed to handle the maximum input size within the given limits.\nrequirement pool:\n- Develop an algorithm to find the minimum operations needed for portal creation.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear output format as specified in the requirements.\n- Optimize the algorithm for speed and accuracy.\n- Include detailed comments and documentation for user understanding.\nWe will use a dynamic programming approach to efficiently compute the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size a \u00d7 b within the given matrix and calculate the number of changes needed to satisfy the portal conditions. Libraries such as NumPy can be used for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions, n \u00d7 m, where n is the number of rows and m is the number of columns.\n    'obsidian block': A block represented by '1' in the matrix.\n    'empty block': A block represented by '0' in the matrix.\n    'portal': A sub-rectangle of size a \u00d7 b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b \u2265 4': The number of columns in the portal must be at least 4.\n    '1 < x < a': For rows between 2 and a-1, specific blocks must be obsidian.\n    '1 < y < b': For columns between 2 and b-1, specific blocks must be empty.\n\n# [degree adverb]\n    'minimum': The goal is to find the sub-rectangle that requires the least number of operations to become a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions for each test case.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the given matrix.\n    3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n        - Ensure the border blocks are obsidian as required.\n        - Ensure the inner blocks are empty as required.\n    4. Use dynamic programming to store and update the minimum number of operations needed for each sub-rectangle.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    0\n    Explanation: The entire rectangle already satisfies the portal conditions, so no operations are needed.\n\n    Test case with alternating blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output: \n    8\n    Explanation: The alternating pattern requires changing all inner blocks to empty and ensuring border blocks are obsidian.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently considers all possible sub-rectangles and calculates the minimum operations needed.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the optimal sub-rectangle. The solution must efficiently handle multiple test cases and large input sizes while ensuring accuracy.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations\n- Ensure accurate identification of portal sub-rectangles\n- Optimize performance for large input sizes\n- Provide clear and concise output\n- Handle edge cases and unusual input scenarios\nWe will implement a function to find the minimum number of operations needed to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes required to meet the portal conditions. We will use numpy for efficient matrix operations and to handle large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of dimensions a \u00d7 b where a \u2265 5 and b \u2265 4. The edges of the portal must be obsidian blocks, except for the corners which can be any type, and the interior must be empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5': The number of rows in the portal must be at least 5.\n    'b \u2265 4': The number of columns in the portal must be at least 4.\n    Implementation: Use loops to iterate over possible sub-rectangles with dimensions satisfying these conditions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already satisfies the portal conditions.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No operations are needed as it already forms a portal.\n\n    Case 2: A rectangle with all empty blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Minimum operations needed to form a portal by changing edge blocks to obsidian.\n\n    Case 3: A rectangle with all obsidian blocks.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: Minimum operations needed to form a portal by changing interior blocks to empty.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if all blocks in a sub-rectangle already satisfy portal conditions:\n            return 0 for that sub-rectangle\n        elif all blocks are empty or all are obsidian:\n            calculate minimum operations needed to transform edges or interior accordingly\n"], "scores": [], "pass_results": [false, false, true, true, false, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 940, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "condense_two2one", "parent_index": 524}
