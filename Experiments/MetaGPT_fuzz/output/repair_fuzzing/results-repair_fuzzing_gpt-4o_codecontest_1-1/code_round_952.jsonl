{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant. CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns. The requirement is not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant. CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns. The requirement is not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant. CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. In the rectangle M, these specific blocks play a crucial role in its qualification as a portal. Their presence as obsidian blocks ensures the integrity of the portal structure.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns. The requirement is not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria: a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block, while M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_changes(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform sub-rectangles into portals.\n    \n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing n, m, and the matrix.\n    \n    Returns:\n        list: List of integers representing the minimum changes for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array([[int(char) for char in row] for row in matrix])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of at least 5x4 dimensions\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for this sub-rectangle\n                        changes = calculate_changes(grid, start_row, start_col, end_row, end_col)\n                        # Update the minimum changes if this is a better solution\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n    \n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n    \n    Returns:\n        int: The number of changes needed.\n    \"\"\"\n    changes = 0\n    \n    # Check the top and bottom borders\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            changes += 1\n        if grid[end_row, col] != 1:\n            changes += 1\n    \n    # Check the left and right borders\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            changes += 1\n        if grid[row, end_col] != 1:\n            changes += 1\n    \n    # Check the interior\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = find_min_changes(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix) where matrix is a list of strings\n    :return: List of integers, each representing the minimum number of changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, matrix in test_cases:\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_rect = grid[i:i+a, j:j+b]\n                        changes = calculate_changes(sub_rect, a, b)\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform the sub-rectangle into a portal.\n\n    :param sub_rect: The sub-rectangle of the grid\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes required\n    \"\"\"\n    changes = 0\n    \n    # Check border conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n    \n    # Check inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_minimal_changes(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: A list of integers representing the minimal changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for this sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: The number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check and change the borders to obsidian (1)\n    # Top and bottom borders\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            changes += 1\n        if grid[end_row, col] != 1:\n            changes += 1\n\n    # Left and right borders\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            changes += 1\n        if grid[row, end_col] != 1:\n            changes += 1\n\n    # Check and change the interior to vacant (0)\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = find_minimal_changes(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_minimal_changes(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions (n, m) and the matrix.\n\n    Returns:\n        list: Minimal number of changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array([list(row) for row in matrix], dtype=int)\n\n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of at least 5x4\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Check sub-rectangle from (i, j) to (i+4, j+3)\n                changes = calculate_changes(grid, i, j)\n                min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the borders and interior of the 5x4 sub-rectangle\n    for i in range(5):\n        for j in range(4):\n            current_value = grid[start_row + i, start_col + j]\n            if i == 0 or i == 4 or j == 0 or j == 3:\n                # Border condition: should be obsidian (1)\n                if current_value == 0:\n                    changes += 1\n            else:\n                # Interior condition: should be vacant (0)\n                if current_value == 1:\n                    changes += 1\n\n    return changes\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n and m followed by n lines of m characters\n# Store them in a list of tuples (n, m, matrix)\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and print the results\nresults = find_minimal_changes(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_minimal_changes(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing dimensions and grid for each test case.\n\n    Returns:\n        list: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, a, b)\n                        # Update the minimum changes if current changes are less\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check and count changes for the borders\n    for x in range(start_row + 1, start_row + a - 1):\n        if grid[x, start_col] != 1:\n            changes += 1\n        if grid[x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(start_col + 1, start_col + b - 1):\n        if grid[start_row, y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, y] != 1:\n            changes += 1\n\n    # Check and count changes for the interior\n    for x in range(start_row + 1, start_row + a - 1):\n        for y in range(start_col + 1, start_col + b - 1):\n            if grid[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = find_minimal_changes(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for case_index in range(t):\n        grid = test_cases[case_index]\n        n = len(grid)\n        m = len(grid[0])\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate changes needed for this sub-rectangle\n                        changes = calculate_changes_for_subrectangle(grid, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes_for_subrectangle(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check top and bottom borders (excluding corners)\n    for col in range(start_col + 1, end_col):\n        if grid[start_row][col] != '1':  # Top border\n            changes += 1\n        if grid[end_row][col] != '1':  # Bottom border\n            changes += 1\n\n    # Check left and right borders (excluding corners)\n    for row in range(start_row + 1, end_row):\n        if grid[row][start_col] != '1':  # Left border\n            changes += 1\n        if grid[row][end_col] != '1':  # Right border\n            changes += 1\n\n    # Check interior blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row][col] != '0':  # Interior should be vacant\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = minimal_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_minimal_changes(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimal changes required to transform sub-rectangles into portals.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing dimensions and grid for each test case.\n\n    Returns:\n        list: List of integers representing the minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Extract sub-rectangle\n                sub_rectangle = matrix[i:i+5, j:j+4]\n                changes = calculate_changes(sub_rectangle)\n                min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(sub_rectangle: np.ndarray) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rectangle (np.ndarray): The sub-rectangle to be transformed.\n\n    Returns:\n        int: The number of changes required.\n    \"\"\"\n    changes = 0\n    a, b = sub_rectangle.shape\n\n    # Ensure the first and last rows and columns have obsidian blocks where required\n    for x in range(1, a-1):\n        if sub_rectangle[x, 0] != 1:\n            changes += 1\n        if sub_rectangle[x, b-1] != 1:\n            changes += 1\n\n    for y in range(1, b-1):\n        if sub_rectangle[0, y] != 1:\n            changes += 1\n        if sub_rectangle[a-1, y] != 1:\n            changes += 1\n\n    # Ensure the inner blocks are vacant\n    for x in range(1, a-1):\n        for y in range(1, b-1):\n            if sub_rectangle[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Initialize list to store test cases\n    test_cases = []\n\n    # Read each test case\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = find_minimal_changes(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        \n        # Initialize prefix sum array\n        prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n        \n        # Fill prefix sum array\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                prefix_sum[i][j] = (int(test_case[i - 1][j - 1]) +\n                                    prefix_sum[i - 1][j] +\n                                    prefix_sum[i][j - 1] -\n                                    prefix_sum[i - 1][j - 1])\n        \n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate number of obsidian blocks in the sub-rectangle\n                        total_obsidian = (prefix_sum[i + a][j + b] -\n                                          prefix_sum[i][j + b] -\n                                          prefix_sum[i + a][j] +\n                                          prefix_sum[i][j])\n                        \n                        # Calculate number of changes needed\n                        changes = total_obsidian\n                        \n                        # Calculate the number of obsidian blocks required for the portal\n                        required_obsidian = 2 * (a - 2) + 2 * (b - 2)\n                        \n                        # Calculate the number of vacant blocks required for the portal\n                        required_vacant = (a - 2) * (b - 2)\n                        \n                        # Calculate changes needed to form the portal\n                        changes = (required_obsidian - total_obsidian) + (required_vacant - (a * b - total_obsidian))\n                        \n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = minimal_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef find_min_changes(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform sub-rectangles into portals.\n    \n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the grid as a list of strings\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(map(int, row)) for row in grid])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size a by b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = calculate_changes(matrix, i, j, a, b)\n                        # Update the minimum changes if the current changes are fewer\n                        min_changes = min(min_changes, changes)\n        \n        # Append the result for the current test case\n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(matrix: np.ndarray, i: int, j: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n    \n    :param matrix: The grid as a numpy array\n    :param i: Top-left row index of the sub-rectangle\n    :param j: Top-left column index of the sub-rectangle\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes needed\n    \"\"\"\n    changes = 0\n    \n    # Check the first and last rows\n    for x in range(1, b - 1):\n        if matrix[i, j + x] != 1:\n            changes += 1\n        if matrix[i + a - 1, j + x] != 1:\n            changes += 1\n    \n    # Check the first and last columns\n    for y in range(1, a - 1):\n        if matrix[i + y, j] != 1:\n            changes += 1\n        if matrix[i + y, j + b - 1] != 1:\n            changes += 1\n    \n    # Check the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[i + x, j + y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input()) for i in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = find_min_changes(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef find_minimal_changes(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: List of integers representing the minimal changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Define the sub-rectangle\n                sub_rect = grid_array[start_row:start_row + 5, start_col:start_col + 4]\n                \n                # Calculate the number of changes needed to meet the portal criteria\n                changes = calculate_changes(sub_rect)\n                \n                # Update the minimum changes\n                min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(sub_rect: np.ndarray) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be transformed.\n\n    Returns:\n        int: The number of changes required.\n    \"\"\"\n    changes = 0\n    rows, cols = sub_rect.shape\n\n    # Ensure the borders (except corners) are obsidian blocks\n    for i in range(1, rows - 1):\n        if sub_rect[i, 0] != 1:\n            changes += 1\n        if sub_rect[i, cols - 1] != 1:\n            changes += 1\n\n    for j in range(1, cols - 1):\n        if sub_rect[0, j] != 1:\n            changes += 1\n        if sub_rect[rows - 1, j] != 1:\n            changes += 1\n\n    # Ensure the interior is vacant\n    for i in range(1, rows - 1):\n        for j in range(1, cols - 1):\n            if sub_rect[i, j] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = find_minimal_changes(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a sub-rectangle within a larger matrix into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal configuration. The solution must efficiently handle multiple test cases and large matrices, ensuring scalability and performance.\nrequirement pool:\n- Develop an algorithm to identify sub-rectangles that can be transformed into portals.\n- Optimize the algorithm for minimal changes required.\n- Ensure the solution handles large matrices efficiently.\n- Provide clear output for each test case.\n- Implement user-friendly input and output handling.\nWe will use a dynamic programming approach to efficiently identify sub-rectangles that can be transformed into portals with minimal changes. The algorithm will iterate over possible sub-rectangles and calculate the number of changes required to meet the portal criteria. We will leverage numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific criteria regarding the arrangement of obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': The dimension 'b' of the portal must be at least 4.\n    'fewest number of changes': The goal is to minimize the number of block changes needed to form a portal.\n\n# [degree adverb]\n    'minimal': Refers to the smallest number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions for each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n       - Ensure the borders are obsidian blocks as specified.\n       - Ensure the interior is vacant.\n    4. Use dynamic programming to store and update the minimum number of changes required for each sub-rectangle.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meeting portal criteria\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No changes are needed as it already meets the portal criteria.\n\n    Case 2: A rectangle with all vacant blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in a total of 12 changes.\n\n    Case 3: A rectangle with alternating blocks\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on specific arrangement; requires calculation.\n    Explanation: The alternating pattern requires specific changes to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where rectangles already meet portal criteria or have specific patterns:\n    \n```python\ndef handle_edge_cases(rectangle):\n    # Check if rectangle already meets portal criteria\n    if is_portal(rectangle):\n        return 0\n    \n    # Calculate changes for specific patterns like all vacant or alternating blocks\n    changes = calculate_changes(rectangle)\n    \n    return changes\n\ndef is_portal(rectangle):\n    # Implement logic to check if rectangle meets portal criteria without changes\n    pass\n\ndef calculate_changes(rectangle):\n    # Implement logic to calculate changes needed for specific patterns\n    pass\n```\n\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given matrix into a portal with minimal changes. The constraints on the dimensions and the specific block requirements for a portal are crucial. The solution must efficiently handle multiple test cases and large matrices, ensuring optimal performance.\nrequirement pool:\n- Implement the main algorithm to transform sub-rectangles into portals.\n- Optimize the algorithm for minimal changes.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear output for each test case.\n- Include user-friendly input and output format.\nWe will implement a function that iterates over all possible sub-rectangles of the given matrix that can potentially be transformed into a portal. For each sub-rectangle, we will calculate the number of changes required to meet the portal criteria. The function will return the minimum number of changes required for each test case. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the original grid of blocks, where n is the number of rows and m is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria, including having certain blocks as obsidian and others as vacant.\n\n    'obsidian block' and 'vacant'\n    Explanation: Obsidian block is represented by '1' and vacant by '0'.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5' and 'greater than or equal to 4'\n    Explanation: These phrases specify the minimum dimensions for a sub-rectangle to be considered a portal. In code, this can be checked using `>=` operator.\n\n# [degree adverb]\n    'fewest number of changes'\n    Explanation: This indicates the goal is to minimize the number of changes needed to transform a sub-rectangle into a portal. In code, this involves finding the minimum value among calculated changes.\n\n# [code logic]\n1. Parse the input to get the number of test cases and each test case's grid dimensions and block configuration.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure all required border blocks are obsidian.\n   - Ensure all required inner blocks are vacant.\n4. Track the minimum number of changes for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already meets the portal criteria, so no changes are needed.\n\n    Case 2: A grid with no possible portal.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 16\n    Explanation: All blocks need to be changed to meet the portal criteria.\n\n    Case 3: A grid with minimal changes needed.\n    Input:\n    1\n    5 4\n    1110\n    1000\n    1000\n    1000\n    1111\n    Expected Output: 3\n    Explanation: Only three changes are needed to make it a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these cases.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern called a portal with minimal changes. The constraints on the dimensions and the block types at specific positions define the portal. The solution needs to efficiently find the sub-rectangle that requires the fewest changes to meet the portal criteria.\nrequirement pool:\n- Implement the algorithm to find the minimal changes required to form a portal.\n- Optimize the algorithm for performance given the constraints.\n- Ensure the solution handles multiple test cases efficiently.\n- Design the solution to be easily adaptable for different input sizes.\n- Provide clear and concise output for each test case.\nWe will implement a function to find the minimal changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of the given dimensions and calculating the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A specific sub-rectangle configuration with obsidian blocks on the borders and vacant blocks inside, meeting certain size criteria.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The number of rows (a) in the portal must be at least 5.\n    'greater than or equal to 4': The number of columns (b) in the portal must be at least 4.\n\n# [degree adverb]\n    'fewest': The minimal number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n       - Ensure the borders are obsidian blocks.\n       - Ensure the interior is vacant.\n    4. Track the minimal number of changes across all sub-rectangles for each test case.\n    5. Output the minimal number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already configured as a portal.\n    Explanation: No changes are needed, so the output should be 0.\n    \n    Case 2: A rectangle with all blocks as obsidian.\n    Explanation: The interior needs to be vacant, requiring changes to all interior blocks.\n    \n    Case 3: A rectangle with all blocks vacant.\n    Explanation: The borders need to be obsidian, requiring changes to all border blocks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a sub-rectangle within a larger matrix into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal structure. Efficient algorithms are needed to handle the potential complexity of large matrices.\nrequirement pool:\n- Develop an algorithm to identify sub-rectangles that can be transformed into portals.\n- Optimize the algorithm to minimize the number of changes required.\n- Ensure the solution is scalable for matrices up to 400x400.\n- Provide clear output for each test case.\n- Implement error handling for invalid inputs.\nWe will use a dynamic programming approach to efficiently identify and transform sub-rectangles into portals. The algorithm will iterate over possible sub-rectangles and calculate the minimal changes required to meet the portal criteria. We will leverage numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific obsidian block requirements on its borders and vacant blocks inside.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': The dimension 'b' of the portal must be at least 4.\n    'fewest number of changes': The goal is to minimize the number of block changes needed to form a portal.\n\n# [degree adverb]\n    'minimal': Refers to the smallest number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and dimensions for each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure the borders have obsidian blocks as specified.\n   - Ensure the interior blocks are vacant.\n4. Use dynamic programming to store and update the minimal changes required for each sub-rectangle.\n5. Output the minimal number of changes for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Test case with maximum dimensions:\n    Input: \n    1\n    400 400\n    (all blocks are vacant)\n    Output: \n    (calculated number of changes)\n    Explanation: The entire rectangle is vacant, requiring maximum changes to form a portal.\n\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output: \n    (calculated number of changes)\n    Explanation: The smallest possible rectangle requires specific changes to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the rectangle already meets portal criteria or has specific dimensions.\n```python\ndef handle_edge_cases(n, m, matrix):\n    # Check if the rectangle already meets portal criteria\n    if n == 5 and m == 4:\n        if all(matrix[0][i] == '1' for i in range(1, m-1)) and \\\n           all(matrix[n-1][i] == '1' for i in range(1, m-1)) and \\\n           all(matrix[i][0] == '1' for i in range(1, n-1)) and \\\n           all(matrix[i][m-1] == '1' for i in range(1, n-1)) and \\\n           all(matrix[i][j] == '0' for i in range(1, n-1) for j in range(1, m-1)):\n            return 0\n    # Additional logic for handling maximum dimensions or other specific cases\n```\n\n", "requirement analysis:\nThe requirements focus on transforming a sub-rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal structure. The solution must efficiently handle multiple test cases and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to identify minimal changes.\n- Ensure scalability for large input sizes.\n- Optimize the algorithm for speed and efficiency.\n- Validate output format consistency.\n- Provide detailed documentation for the algorithm.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to transform a sub-rectangle into a portal. This approach will allow us to handle large inputs by breaking down the problem into smaller subproblems and storing intermediate results to avoid redundant calculations. We will utilize numpy for efficient array manipulations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific obsidian block requirements on its borders and vacant blocks inside.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': The dimension 'b' of the portal must be at least 4.\n    'fewest number of changes': The goal is to minimize the number of block changes needed to form a portal.\n\n# [degree adverb]\n    'minimal': Refers to the smallest number of changes required to achieve the desired configuration.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions for each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n       - Ensure the borders have obsidian blocks as specified.\n       - Ensure the interior blocks are vacant.\n    4. Use dynamic programming to store intermediate results and avoid redundant calculations.\n    5. Track the minimum number of changes required for each test case and output the result.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Test case with a rectangle having all vacant blocks:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output: \n    12\n    Explanation: All border blocks need to be changed to obsidian, resulting in a total of 12 changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will naturally account for these scenarios by calculating the number of changes needed for each possible sub-rectangle and selecting the minimum.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a portal with minimal changes. The constraints are well-defined, and the solution must efficiently handle the maximum input sizes. The algorithm should focus on identifying potential sub-rectangles and calculating the required changes to meet the portal criteria.\nrequirement pool:\n- Develop an algorithm to identify sub-rectangles efficiently.\n- Calculate the minimal changes required for each sub-rectangle.\n- Optimize the solution for performance with large inputs.\n- Ensure the solution is easy to understand and maintain.\n- Provide clear output for each test case.\nWe will implement a function to find the minimal number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal criteria. We will use a brute-force approach with optimizations to handle the constraints efficiently. The function will be designed to handle multiple test cases as input.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle with specific dimensions and block arrangements. It must have obsidian blocks on its borders except for the corners, which can be any type, and vacant blocks in the interior.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': The dimension 'b' of the portal must be at least 4.\n    Implementation: Ensure that any sub-rectangle considered has dimensions satisfying these conditions.\n\n# [degree adverb]\n    'fewest': The goal is to minimize the number of changes needed to transform a sub-rectangle into a portal.\n    Implementation: Use an algorithm to calculate the minimum number of changes required for each sub-rectangle and select the smallest value.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions for each test case.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n        - Ensure borders (except corners) are obsidian blocks.\n        - Ensure interior blocks are vacant.\n    4. Track the minimum number of changes required for each test case.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meeting portal criteria\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Case 2: A rectangle with all vacant blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in a total of 12 changes.\n\n    Case 3: A rectangle with alternating blocks\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Calculation needed based on specific arrangement.\n    Explanation: The number of changes depends on how many border blocks need to be changed to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the rectangle already meets portal criteria or has specific arrangements that minimize changes.\n        if sub_rectangle_already_meets_criteria:\n            return 0\n        else:\n            calculate_min_changes()\n", "requirement analysis:\nThe problem requires identifying sub-rectangles within a given grid and transforming them into portals with minimal changes. The constraints on dimensions and block types must be carefully considered to ensure the solution is both efficient and accurate.\nrequirement pool:\n- Develop an algorithm to identify potential portal sub-rectangles.\n- Implement a method to calculate the minimal changes required.\n- Optimize the solution for large grid dimensions.\n- Ensure the solution is scalable across multiple test cases.\n- Provide clear documentation and output format.\nWe will use a dynamic programming approach to efficiently identify and transform sub-rectangles into portals with minimal changes. The algorithm will iterate over all possible sub-rectangles and calculate the number of changes required to convert them into portals. We will leverage numpy for efficient matrix operations and use memoization to store intermediate results for faster computation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A specific type of rectangle with dimensions a by b, meeting certain criteria regarding block placement.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5.\n    'greater than or equal to 4': b must be at least 4.\n    'fewest number of changes': Minimize the number of block switches needed to form a portal.\n\n# [degree adverb]\n    'minimal': Refers to the least number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure the first and last rows and columns have obsidian blocks where required.\n   - Ensure the inner blocks are vacant.\n4. Use dynamic programming to store and reuse results for overlapping sub-rectangles.\n5. Return the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Test case with maximum dimensions:\n    Input: \n    1\n    400 400\n    (All blocks are vacant)\n    Output: \n    (Calculated number of changes needed to form a portal)\n    Explanation: The algorithm should efficiently handle large inputs and calculate the required changes.\n\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output: \n    (Calculated number of changes needed to form a portal)\n    Explanation: Even with minimum dimensions, the algorithm should correctly identify and transform the rectangle.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where rectangles already meet portal criteria or have maximum/minimum dimensions.\n        if sub_rectangle_already_meets_criteria(sub_rectangle):\n            return 0\n        # Additional logic for handling large inputs efficiently using dynamic programming and memoization.\n", "requirement analysis:\nThe requirements focus on transforming a sub-rectangle into a portal with minimal changes. The constraints are manageable, allowing for efficient algorithm design. The solution must handle multiple test cases and provide accurate results for each, ensuring scalability and clarity.\nrequirement pool:\n- Develop an efficient algorithm to identify minimal changes for portal transformation.\n- Ensure the solution is scalable for maximum constraints.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm for speed and efficiency.\n- Design the solution to be easy to understand and implement.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to convert each into a portal. We will use a 2D prefix sum array to quickly calculate the number of obsidian blocks in any sub-rectangle, which will help in determining the number of changes required. This approach ensures scalability and efficiency for the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m': This refers to the main grid or matrix that contains blocks, where n is the number of rows and m is the number of columns.\n    'portal': A sub-rectangle within the main rectangle that meets specific criteria regarding its dimensions and block configuration.\n    'obsidian block': A block represented by '1' in the matrix.\n    'vacant': A block represented by '0' in the matrix.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': This means that the dimension a of the portal must be at least 5.\n    'greater than or equal to 4': This means that the dimension b of the portal must be at least 4.\n    'fewest number of changes': This refers to minimizing the number of block switches needed to form a portal.\n\n# [degree adverb]\n    'minimal': This indicates that the solution should aim for the least number of changes possible.\n\n# [code logic]\n1. Parse the input to get the number of test cases and for each test case, read the dimensions n and m, followed by the n lines representing the grid.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed:\n   - Ensure the outer boundary conditions are met (obsidian blocks on specified edges).\n   - Ensure the inner area is vacant.\n4. Use a 2D prefix sum array to efficiently calculate the number of obsidian blocks in any sub-rectangle.\n5. Track the minimum number of changes required across all possible sub-rectangles for each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    12\n    Explanation: The entire grid is filled with obsidian blocks, requiring changes to make the inner area vacant.\n\n    Case 2: \n    Input: \n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: \n    16\n    Explanation: The entire grid is vacant, requiring changes to make the specified edges obsidian blocks.\n\n    Case 3: \n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: \n    8\n    Explanation: The alternating pattern requires specific changes to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the entire grid is either fully obsidian or fully vacant. This can be managed by ensuring that our logic checks both conditions and calculates changes accordingly. The original logic should be robust enough to handle these scenarios by iterating over all possible sub-rectangles and calculating necessary changes.\n", "requirement analysis:\nThe requirements focus on transforming a sub-rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal configuration. Efficient algorithms are needed to handle the maximum input sizes within the given limits.\nrequirement pool:\n- Develop an algorithm to identify sub-rectangles that can be transformed into portals.\n- Optimize the algorithm to minimize the number of changes required.\n- Ensure the solution is scalable for large n and m values.\n- Provide clear output for each test case.\n- Implement input validation to handle edge cases.\nWe will use a dynamic programming approach to efficiently identify sub-rectangles that can be transformed into portals with minimal changes. The algorithm will iterate over possible sub-rectangles and calculate the number of changes required to convert them into portals. We will leverage numpy for efficient matrix operations and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of size n rows and m columns, where each cell can either be an obsidian block (1) or vacant (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the main rectangle that meets specific criteria, including dimensions and block configurations, to be considered a portal.\n\n    'obsidian block'\n    Explanation: A block represented by '1' in the matrix, which can be switched to vacant or vice versa.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5'\n    Explanation: The dimension 'a' of the portal must be at least 5. In code, this can be checked using `a >= 5`.\n\n    'greater than or equal to 4'\n    Explanation: The dimension 'b' of the portal must be at least 4. In code, this can be checked using `b >= 4`.\n\n# [degree adverb]\n    'fewest'\n    Explanation: This indicates the need to minimize the number of changes required to transform a sub-rectangle into a portal. In code, this involves finding the minimum value of changes across all possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and for each test case, read the dimensions n and m, followed by the n lines representing the grid.\n2. For each possible sub-rectangle of size a by b (where a >= 5 and b >= 4), calculate the number of changes needed to make it a portal.\n3. Use dynamic programming to efficiently compute and store results for overlapping subproblems.\n4. For each sub-rectangle, ensure that:\n   - The first and last rows have obsidian blocks at specified positions.\n   - The first and last columns have obsidian blocks at specified positions.\n   - The inner blocks are vacant.\n5. Track the minimum number of changes required across all valid sub-rectangles for each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Edge Case 1: A grid where all blocks are already in the correct configuration for a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No changes are needed as it already forms a portal.\n\n    Edge Case 2: A grid with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Minimum changes needed to form a portal.\n\n    Edge Case 3: A grid with dimensions exactly matching the minimum required for a portal but with incorrect block configuration.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: Minimum changes needed to form a portal.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid is already a portal or has no obsidian blocks. This involves checking if any sub-rectangle already meets the portal criteria before calculating changes. If a sub-rectangle is already a portal, return 0 immediately for that test case.\n", "requirement analysis:\nThe requirements focus on transforming a sub-rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal configuration. Efficient algorithms are needed to handle the maximum constraints of n and m, ensuring scalability and accuracy.\nrequirement pool:\n- Develop an algorithm to identify the minimal changes required for portal transformation.\n- Ensure the solution handles maximum constraints efficiently.\n- Provide consistent and clear output format for each test case.\n- Optimize the solution for scalability across larger inputs.\n- Enhance user interface for better understanding of results.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of the given dimensions and calculate the number of changes needed to meet the portal criteria. We will leverage numpy for efficient matrix operations and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can be either an obsidian block (1) or vacant (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria regarding its dimensions and the arrangement of obsidian blocks and vacant spaces.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5\n    'greater than or equal to 4': b must be at least 4\n    'for every 1 < x < a': means for all rows except the first and last\n    'for each 1 < x < b': means for all columns except the first and last\n\n# [degree adverb]\n    'fewest': means the minimal number of changes required to transform a sub-rectangle into a portal\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the interior is vacant.\n4. Use dynamic programming to store and update the minimum changes required for each sub-rectangle.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Case 2: A rectangle with all blocks as obsidian\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 9\n    Explanation: The interior needs to be cleared, requiring changes to all interior blocks.\n\n    Case 3: A rectangle with all blocks vacant\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks (except corners) need to be changed to obsidian.\n\n# [extra code for edge case]\nWe do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimal changes will naturally handle these cases.\n"], "scores": [], "pass_results": [false, true, false, false, true, false, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 952, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "expand_one2two", "parent_index": 549}
