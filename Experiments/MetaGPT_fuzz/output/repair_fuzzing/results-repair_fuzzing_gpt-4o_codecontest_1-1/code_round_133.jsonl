{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Ensure to consider edge cases such as arrays that are already stable or require only a minimal number of eversions to stabilize.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Ensure to consider edge cases such as arrays that are already stable or require only a minimal number of eversions to stabilize.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation. In other words, the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Ensure to consider edge cases such as arrays that are already stable or require only a minimal number of eversions to stabilize.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are given an array a of length n. Let's define the eversion operation: let x = a_n, then array a is partitioned into two parts\u2014left, containing elements not greater than x (\u2264 x), and right, containing elements strictly greater than x (> x) while maintaining their original order, and the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions. Ensure to consider edge cases such as arrays that are already stable or require only a minimal number of eversions to stabilize.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        stabilized = False\n        \n        while not stabilized:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                stabilized = True\n            else:\n                a = new_a\n                k += 1\n        \n        results.append(k)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions needed for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            x = current_array[-1]\n            left_part = [element for element in current_array if element <= x]\n            right_part = [element for element in current_array if element > x]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        k = 0\n        current_array = case[:]\n        \n        while True:\n            x = current_array[-1]\n            left = [element for element in current_array if element <= x]\n            right = [element for element in current_array if element > x]\n            new_array = left + right\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        if n == 0:\n            results.append(0)\n            continue\n        \n        # Initialize the number of eversions\n        eversion_count = 0\n        # Start from the end of the array\n        last_element = case[-1]\n        # Track the maximum element seen from the end\n        max_from_end = last_element\n        \n        # Traverse the array from the second last element to the start\n        for i in range(n - 2, -1, -1):\n            if case[i] > max_from_end:\n                # If current element is greater than the max seen from the end,\n                # it means we need another eversion\n                eversion_count += 1\n                # Update the max_from_end to the last element of the current partition\n                max_from_end = last_element\n            else:\n                # Update the max_from_end if the current element is greater\n                max_from_end = max(max_from_end, case[i])\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case to stabilize.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            x = current_array[-1]\n            left_part = [element for element in current_array if element <= x]\n            right_part = [element for element in current_array if element > x]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        a = case\n        eversion_count = 0\n        \n        while True:\n            x = a[-1]  # Last element of the array\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        stabilized = False\n        \n        while not stabilized:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            \n            if new_a == a:\n                stabilized = True\n            else:\n                a = new_a\n                k += 1\n        \n        results.append(k)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Initialize an empty list to store test cases\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print the results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        eversion_count = 0\n        current_array = case\n        \n        while True:\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    test_cases = []\n    \n    # Read each test case\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on performing a series of operations on an array until it stabilizes. The key challenge is to efficiently partition the array based on the last element and determine the number of operations needed for stabilization. Edge cases such as already stable arrays or minimal operations required must be handled. The solution should be optimized for large datasets and ensure accurate results.\nrequirement pool:\n- Implement the eversion operation correctly\n- Handle large arrays efficiently\n- Ensure accurate results for edge cases\n- Optimize computational complexity\n- Maintain consistent output format\nWe will implement a function to perform the eversion operation on an array. The function will repeatedly partition the array based on the last element until the array stabilizes. We will use a simple loop to perform the eversions and check for stability by comparing the array before and after each eversion. The solution will be optimized to handle large datasets efficiently by minimizing unnecessary operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. Elements less than or equal to x form the left part, and elements greater than x form the right part. The array is then reformed by concatenating the left and right parts.\n\n    'stabilize'\n    Explanation: The array is considered stabilized when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements \u2264 x\n    'strictly greater than': means elements > x\n    'minimum number': refers to the smallest number of eversions needed for the array to stabilize\n\n# [degree adverb]\n    'minimum': refers to the least number of operations required for stabilization\n\n# [code logic]\n1. For each test case, read the number of elements, n, and the array, a.\n2. Initialize a counter for eversions, k = 0.\n3. Perform the eversion operation:\n   - Identify x as the last element of the array.\n   - Partition the array into left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n4. Increment k after each eversion.\n5. Check if the array has stabilized by comparing it with its previous state.\n6. If stabilized, record k as the result for that test case.\n7. Output the results for all test cases.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already stable as all elements are equal, so no eversions are needed.\n\n    Test case 2: [10, 9, 8, 7, 6] = 1\n    Explanation: The array is in descending order; one eversion will stabilize it by moving all elements to the left part.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already in non-decreasing order; no eversions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles arrays that are already stable or require minimal eversions.\n", "requirement analysis:\nThe requirements focus on performing eversions on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the minimum number of eversions needed. Edge cases such as already stable arrays or arrays requiring minimal eversions must be considered. The solution should handle large arrays up to the given constraints.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles all edge cases\n- Optimize the solution for large arrays\n- Maintain stable partitioning during eversions\n- Provide clear documentation for the algorithm\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. We will keep track of the number of eversions needed until the array stops changing. The solution will handle edge cases such as arrays that are already stable or require minimal eversions. The algorithm will be optimized to handle large arrays efficiently by using a stable partitioning approach.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements strictly greater than x. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements in the left part are less than or equal to x.\n    'strictly greater than': means elements in the right part are greater than x.\n\n# [degree adverb]\n    'minimum number': refers to the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. Perform the eversion operation by partitioning the array based on the last element.\n    3. Concatenate the left and right parts.\n    4. Check if the array has changed after the eversion.\n    5. Repeat steps 2-4 until the array stops changing.\n    6. Return the number of eversions performed.\n\n# [edge case]\n    Case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already stable as all elements are equal, so no eversions are needed.\n    \n    Case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: Similar to Case 1, all elements are equal, so no eversions are needed.\n    \n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles arrays that are already stable or require minimal eversions.\n", "requirement analysis:\nThe requirements focus on efficiently stabilizing an array through a series of eversions. The key challenge is to ensure the algorithm handles large inputs within the constraints and provides accurate results for all edge cases. The solution should be optimized for performance and scalability, considering the maximum constraints provided.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the algorithm handles large arrays efficiently\n- Optimize the code for performance\n- Handle all edge cases accurately\n- Provide clear documentation for the eversion process\nWe will implement the eversion operation using a simple loop to partition the array based on the last element. The approach will focus on efficiently processing each test case by iterating through the array and performing the partitioning operation until the array stabilizes. We will use Python's built-in list operations to handle the partitioning and concatenation efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. Elements less than or equal to x form the left part, and elements greater than x form the right part. The array is then reformed by concatenating the left and right parts.\n\n    'stabilize'\n    Explanation: The array is considered stabilized when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'greater than': Used to partition elements into the right part if they are strictly greater than x.\n    'not greater than': Used to partition elements into the left part if they are less than or equal to x.\n\n# [degree adverb]\n    'minimum number': Refers to the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for the number of eversions.\n3. Perform the eversion operation:\n   - Identify the last element, x.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n4. Check if the array has changed after the eversion. If not, stop; otherwise, increment the counter and repeat.\n5. Output the counter as the result for each test case.\n\n# [edge case]\n    Case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already stable as all elements are equal, so no eversions are needed.\n\n    Case 2: [5, 4, 3, 2, 1] = 1\n    Explanation: After one eversion with x = 1, all elements will be in the left part, and no further changes will occur.\n\n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already in a stable order with increasing elements, so no eversions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles arrays that are already stable or require minimal eversions.\n", "requirement analysis:\nThe requirements focus on processing arrays through a defined eversion operation until stabilization. The key challenge is ensuring the algorithm efficiently handles large inputs while providing accurate results across multiple test cases. Edge cases such as already stable arrays must be considered to avoid unnecessary computations.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the program handles multiple test cases efficiently\n- Optimize the algorithm for large inputs\n- Consider edge cases like already stable arrays\n- Provide clear output format for each test case\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array no longer changes. We will use a simple loop to count the number of eversions required for stabilization. The algorithm will efficiently handle multiple test cases by processing each independently and outputting the results in sequence.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. Elements less than or equal to x form the left part, and elements greater than x form the right part. The array is then reformed by concatenating the left and right parts.\n\n    'stabilize'\n    Explanation: The array is considered stabilized when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements that are less than or equal to x.\n    'strictly greater than': means elements that are greater than x.\n\n# [degree adverb] \n    'minimum number': means the smallest count of eversions needed for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. Perform the eversion operation:\n   - Identify the last element x = a[n-1].\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n   - Increment k.\n4. Repeat step 3 until the array no longer changes.\n5. Output k for each test case.\n\n# [edge case] \n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: Only one eversion is needed to stabilize the array as all elements are initially in descending order.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after an eversion. If it doesn't change, it stops further eversions.\n", "requirement analysis:\nThe requirements focus on implementing an eversion operation on arrays and determining the minimum number of operations needed for stabilization. The solution must handle multiple test cases efficiently, considering edge cases such as already stable arrays or those requiring minimal eversions. The output format is crucial and must be adhered to strictly.\nrequirement pool:\n- Implement eversion operation correctly\n- Ensure output format matches requirements\n- Optimize for large input sizes\n- Handle edge cases efficiently\n- Provide clear documentation for the algorithm\nWe will implement the eversion operation by iterating over the array from the end to the start, partitioning the array into two parts based on the last element, and counting the number of eversions required until the array stabilizes. We will use a simple loop and list operations to achieve this, ensuring the solution is efficient for large input sizes. The approach will handle edge cases by checking if the array is already stable or requires minimal eversions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements greater than x. The array is then replaced with the concatenation of these two parts.\n\n    'stabilize'\n    Explanation: The array is considered stabilized when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not greater than': Elements in the left part are less than or equal to x.\n    'strictly greater than': Elements in the right part are greater than x.\n\n# [degree adverb]\n    'minimum number': The smallest count of eversions needed for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for eversions.\n3. Perform the eversion operation:\n   - Identify the last element, x.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n4. Check if the array has changed after the eversion. If not, stop.\n5. Increment the eversion counter each time the array changes.\n6. Output the counter as the result for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: The array is already stable as all elements are equal, so no eversions are needed.\n\n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: After one eversion with x = 1, the array becomes [1, 5, 4, 3, 2], which is stable.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles arrays that are already stable or require minimal eversions.\n", "requirement analysis:\nThe requirements focus on efficiently stabilizing an array through a series of eversions. The solution must handle large inputs and edge cases effectively, ensuring the array stops changing after a minimal number of operations.\nrequirement pool:\n- Implement the eversion operation correctly\n- Optimize for large input sizes\n- Handle edge cases such as already stable arrays\n- Ensure the solution is scalable\n- Provide clear documentation for the algorithm\nWe will implement a function to perform the eversion operation on an array and determine the minimum number of eversions required for the array to stabilize. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array no longer changes. We will use a simple loop to track changes and ensure the solution is efficient for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. The left part contains elements not greater than x, and the right part contains elements strictly greater than x. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'greater than': Used to partition the array into elements strictly greater than x.\n    'not greater than': Used to partition the array into elements not greater than x.\n\n# [degree adverb]\n    'minimum': Refers to the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n    1. Initialize a counter to track the number of eversions.\n    2. Perform the eversion operation:\n        - Identify the last element of the array as x.\n        - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n        - Concatenate the left and right parts to form a new array.\n    3. Check if the new array is identical to the previous array.\n    4. If not, increment the counter and repeat the process.\n    5. Return the counter when the array stops changing.\n\n# [edge case]\n    Case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already stable as all elements are equal, so no eversions are needed.\n    \n    Case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversions are needed.\n    \n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in increasing order, so no eversions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles arrays that are already stable or require minimal eversions.\n", "requirement analysis:\nThe requirements focus on efficiently performing eversion operations on arrays until they stabilize. The solution must handle large input sizes and edge cases effectively, ensuring the array stops changing after the minimum number of eversions.\nrequirement pool:\n- Implement the eversion operation correctly.\n- Optimize for large input sizes.\n- Handle edge cases where arrays are already stable.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed documentation for the eversion process.\nWe will implement the eversion operation using a simple loop to partition the array based on the last element. The approach will efficiently handle large arrays by iterating through the array and performing the partitioning in linear time. We will use Python's list operations to maintain the order and perform concatenation. The solution will be optimized for performance and clarity, ensuring it handles edge cases such as already stable arrays.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. Elements not greater than x form the left part, and elements strictly greater than x form the right part. The array is then replaced with the concatenation of these two parts.\n\n# [phrase showing quantity relationship]\n    'not greater than': means elements \u2264 x\n    'strictly greater than': means elements > x\n\n# [degree adverb] \n    'minimum': means the smallest number of eversions needed for the array to stop changing\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n       - Identify the last element, x.\n       - Partition the array into left (elements \u2264 x) and right (elements > x).\n       - Concatenate left and right to form the new array.\n    4. Check if the array changes after the eversion. If it does, increment the counter.\n    5. Repeat until the array stops changing.\n    6. Output the counter as the result for each test case.\n\n# [edge case] \n    Input: 1\n    4\n    1 1 1 1\n    Output: 0\n    Explanation: The array is already stable as all elements are equal, so no eversions are needed.\n\n    Input: 1\n    3\n    3 2 1\n    Output: 1\n    Explanation: After one eversion, the array becomes [1, 2, 3], which is stable.\n\n    Input: 1\n    5\n    5 5 5 5 5\n    Output: 0\n    Explanation: The array is already stable as all elements are equal, so no eversions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles arrays that are already stable or require minimal eversions.\n", "requirement analysis:\nThe requirements focus on determining the minimum number of eversions needed for an array to stabilize. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results. Edge cases such as already stable arrays or minimal eversion requirements must be considered.\nrequirement pool:\n- Implement the eversion operation correctly.\n- Optimize the solution for large input sizes.\n- Ensure accurate output for each test case.\n- Handle edge cases gracefully.\n- Provide clear documentation for the eversion process.\nWe will implement a function that performs the eversion operation on the array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. We will use a loop to perform eversions until the array no longer changes, counting the number of eversions required. The solution will be optimized to handle large input sizes efficiently by minimizing unnecessary operations and using efficient list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. Elements not greater than x form the left part, and elements greater than x form the right part. The array is then replaced by the concatenation of these two parts.\n\n    'stabilize'\n    Explanation: The array is considered stabilized when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': Elements that are less than or equal to the last element of the array.\n    'strictly greater than (> x)': Elements that are greater than the last element of the array.\n\n# [degree adverb]\n    'minimum number': The smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Initialize a counter for eversions, k = 0.\n3. While the array is not stabilized:\n   - Set x as the last element of the array.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n   - Increment k by 1.\n4. Check if the new array is equal to the previous array. If so, break the loop.\n5. Output k for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n\n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: After one eversion, all elements will be in non-decreasing order, stabilizing the array.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already in non-decreasing order, so no eversion is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if further eversions change the array.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results and considering edge cases like already stable arrays.\nrequirement pool:\n- Implement the eversion operation efficiently.\n- Ensure the solution handles large input sizes within constraints.\n- Provide clear and accurate output for each test case.\n- Consider edge cases such as arrays that are already stable.\n- Optimize the algorithm for better performance.\nWe will implement a function to perform the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array no longer changes. We will use a simple loop to count the number of eversions needed for stabilization. The solution will handle multiple test cases efficiently by iterating through each test case and applying the eversion logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. Elements not greater than x form the left part, and elements greater than x form the right part. The array is then replaced by the concatenation of these two parts.\n\n    'stabilize'\n    Explanation: The array is considered stabilized when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': Elements that are less than or equal to the last element x.\n    'strictly greater than (> x)': Elements that are greater than the last element x.\n\n# [degree adverb]\n    'minimum number': The smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for the number of eversions.\n3. Perform the eversion operation:\n   - Identify the last element, x.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n4. Check if the array has changed after the eversion. If not, stop; otherwise, increment the counter and repeat.\n5. Output the counter as the result for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: The first eversion will sort the array in ascending order, and it will stabilize after that.\n\n    Test case: [1] = 0\n    Explanation: A single-element array is already stable.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of eversions on an array until it stabilizes. The key challenge is to efficiently determine the minimum number of eversions needed for stabilization, especially for large input sizes. The solution must handle multiple test cases and edge cases, such as already stable arrays or arrays with identical elements.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm for large input sizes up to 2 \u22c5 10^5 elements.\n- Provide clear and consistent output for each test case.\n- Consider edge cases such as arrays with identical elements.\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate through the array, partitioning it into two parts based on the last element, and then concatenate these parts. We will use a loop to perform eversions until the array no longer changes. The approach will efficiently handle large input sizes by minimizing unnecessary operations and using Python's list operations for partitioning.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two parts based on the last element, x. Elements less than or equal to x form the left part, and elements greater than x form the right part. The array is then replaced by the concatenation of these two parts.\n\n    'stabilize'\n    Explanation: The array is considered stabilized when further eversions do not change its order.\n\n# [phrase showing quantity relationship]\n    'not greater than (\u2264 x)': Elements that are less than or equal to the last element x.\n    'strictly greater than (> x)': Elements that are greater than the last element x.\n\n# [degree adverb]\n    'minimum number': The smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter k to track the number of eversions.\n3. Perform the eversion operation:\n   - Identify the last element x of the array.\n   - Partition the array into two parts: left (elements \u2264 x) and right (elements > x).\n   - Concatenate left and right to form the new array.\n4. Increment k after each eversion.\n5. Repeat until the array no longer changes.\n6. Output k for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: The array is already stable as all elements are equal, so no eversions are needed.\n\n    Test case: [5, 4, 3, 2, 1] = 1\n    Explanation: After one eversion, the array becomes [1, 2, 3, 4, 5], which is stable.\n\n    Test case: [1] = 0\n    Explanation: A single-element array is inherently stable, requiring no eversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles arrays that are already stable or require minimal eversions.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 133, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "add_1_sentence_at_end", "parent_index": 18}
