{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party. They have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends. This enables everyone to focus on their phones without interruptions. Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party. They have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends. This enables everyone to focus on their phones without interruptions. Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the big island of Baltia, there reside N individuals, numbered from 1 to N. There are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party. They have very strict regulations on what a party is. The regulations also specify when the party is successful. On the island of Baltia, a party includes exactly 5 persons. The party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends. This enables everyone to focus on their phones without interruptions. Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the big island of Baltia, there reside N individuals, numbered from 1 to N. The people of Baltia want to host a successful party, with exactly M pairs of people that are buddies with each other. They have very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons and is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends. This enables everyone to focus on their phones without interruptions. Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people either all friends or none friends.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 individuals forming a successful party or -1 if impossible.\n    \"\"\"\n    # Create a graph from the friendships\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people where either all are friends or none are friends.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Handle edge cases\n    if m == 0:\n        return list(range(1, 6)) if n >= 5 else -1\n    if m >= (n * (n - 1)) // 2 - (n - 5):\n        return -1\n\n    # Build adjacency list\n    adj_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Check for cliques or independent sets of size 5\n    for group in combinations(range(1, n + 1), 5):\n        if all(v in adj_list[u] for u in group for v in group if u != v):\n            return list(group)\n        if all(v not in adj_list[u] for u in group for v in group if u != v):\n            return list(group)\n\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of exactly 5 people.\n\n    Args:\n        n: The number of people on the island.\n        m: The number of friendships.\n        friendships: A list of tuples representing pairs of friends.\n\n    Returns:\n        A list of 5 integers representing the people to invite to the party,\n        or -1 if no successful party configuration is possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\nfrom typing import List, Tuple, Union\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> Union[List[int], int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship rules.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        Union[List[int], int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create a graph from the friendships\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Iterate over all combinations of 5 people\n    for combination in combinations(range(1, n + 1), 5):\n        subgraph = graph.subgraph(combination)\n        \n        # Check if the subgraph is a clique or an independent set\n        if nx.is_clique(subgraph) or nx.is_empty(subgraph):\n            return list(combination)\n    \n    # If no valid combination is found, return -1\n    return -1\n\ndef main():\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(result)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Find a successful party configuration of 5 individuals.\n\n    Args:\n        n (int): Number of individuals on the island.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Output interface\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendships.\n\n    Args:\n        n (int): The number of individuals on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for group in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(group, 2)):\n            return list(group)\n\n    # Check for an independent set of size 5\n    for group in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(group, 2)):\n            return list(group)\n\n    # If no successful party configuration is found\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party configuration in Baltia.\n\n    Args:\n        n (int): Number of individuals in Baltia.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    def is_clique(group: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if group[j] not in adjacency_list[group[i]]:\n                    return False\n        return True\n\n    # Check for an independent set of size 5\n    def is_independent_set(group: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if group[j] in adjacency_list[group[i]]:\n                    return False\n        return True\n\n    # Try to find a successful party\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for o in range(l + 1, n + 1):\n                        group = [i, j, k, l, o]\n                        if is_clique(group) or is_independent_set(group):\n                            return group\n\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of people on the island.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Provide the Interface using input() and print(), DO NOT use stdin\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration on the island of Baltia.\n\n    A successful party is defined as a gathering of exactly 5 people where either all attendees\n    are friends with each other (forming a clique) or none of them are friends (forming an independent set).\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party, or -1 if not possible.\n    \"\"\"\n    # Create a graph using the given friendships\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set of size 5 can be found by checking the complement graph\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship conditions.\n\n    Args:\n        n (int): The number of individuals on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for combo in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combo, 2)):\n            return list(combo)\n\n    # Check for an independent set of size 5\n    for combo in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combo, 2)):\n            return list(combo)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe requirements focus on determining a successful party configuration based on friendship pairs. The solution must efficiently handle large numbers of individuals and friendships, ensuring scalability and quick processing. The output should be clear, indicating either a successful party configuration or impossibility.\nrequirement pool:\n- Efficiently process large datasets to determine party configurations.\n- Ensure output clarity and adherence to format requirements.\n- Optimize algorithm for scalability and speed.\n- Handle edge cases where no successful party configuration is possible.\n- Provide multiple successful configurations if possible.\nWe will use graph theory to solve this problem. Specifically, we will utilize the NetworkX library to represent the friendships as a graph. The problem can be approached by checking for cliques of size 5 (where all attendees are friends) or independent sets of size 5 (where no attendees are friends). NetworkX provides efficient methods to find cliques and independent sets, which will help us handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all attendees are friends or none are friends.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must include precisely 5 people, no more, no less.\n    'no pair': Indicates that none of the attendees should be friends in one of the successful configurations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using NetworkX.\n2. Check for cliques of size 5 in the graph. If found, print the members of the clique.\n3. If no clique of size 5 is found, check for independent sets of size 5.\n4. If an independent set of size 5 is found, print the members of the set.\n5. If neither a clique nor an independent set of size 5 is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints of up to 200,000 people and friendships.\nrequirement pool:\n- Develop an algorithm to check for a successful party configuration.\n- Ensure the solution is efficient for large inputs.\n- Provide clear and formatted output as specified.\n- Consider edge cases with no friendships or maximum friendships.\n- Optimize for both time and space complexity.\nWe will use a graph-based approach to solve this problem. The task is to find a set of 5 people who are either all friends or none are friends. This can be efficiently checked using graph theory concepts. We will represent the friendships as an adjacency list and then check for cliques of size 5 or independent sets of size 5. Given the constraints, we will use a combination of depth-first search (DFS) and combinatorial checks to ensure the solution is efficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'party': A gathering of exactly 5 individuals.\n    'successful party': A party where either all attendees are friends or none are friends.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include precisely 5 people.\n    'no pair of people': Indicates that none of the selected individuals should be friends in one of the successful party configurations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using an adjacency list.\n2. Check for cliques of size 5 (all attendees are friends).\n   - Use combinatorial checks to find subsets of 5 people and verify if they form a clique.\n3. Check for independent sets of size 5 (none are friends).\n   - Use combinatorial checks to find subsets of 5 people and verify if they form an independent set.\n4. If a valid configuration is found, print the 5 individuals.\n5. If no valid configuration is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no group of 5 can be an independent set.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, we need to handle cases where M = 0 or M is very large (close to N choose 2), as these represent trivial independent sets or cliques respectively.\n\n```python\ndef find_successful_party(N, M, friendships):\n    if M == 0:\n        return list(range(1, 6)) if N >= 5 else -1\n    if M >= (N * (N - 1)) // 2 - (N - 5):\n        return -1\n\n    # Build adjacency list\n    adj_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Check for cliques or independent sets of size 5\n    from itertools import combinations\n\n    for group in combinations(range(1, N + 1), 5):\n        if all(v in adj_list[u] for u in group for v in group if u != v):\n            return list(group)\n        if all(v not in adj_list[u] for u in group for v in group if u != v):\n            return list(group)\n\n    return -1\n```\n\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship pairs. The solution must efficiently handle large inputs and provide clear outputs. Edge cases, such as no friendships or maximum friendships, must be considered.\nrequirement pool:\n- Efficiently determine if a successful party configuration is possible.\n- Handle large input sizes up to 200,000 individuals and friendships.\n- Provide clear output format as specified in the requirements.\n- Consider edge cases like no friendships or all individuals being friends.\n- Optimize for performance to handle maximum constraints.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these configurations using combinatorial techniques and graph traversal methods.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all 5 people at the party are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in a graph is a set of vertices no two of which are adjacent. In this context, it means none of the 5 people at the party are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This means the party must consist of exactly 5 individuals, no more, no less.\n    \n# [degree adverb] \n    'successful': This means the party must meet one of the two conditions (all friends or no friends) to be considered successful.\n\n# [code logic]\n1. Represent the friendships as a graph using adjacency lists.\n2. Check for a clique of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if every pair within the combination is friends.\n3. Check for an independent set of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if no pair within the combination is friends.\n4. If either condition is met, print the combination.\n5. If no such combination exists, print -1.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships (complete graph), no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining if a party can be organized under strict conditions. The solution must efficiently handle large inputs and provide clear outputs. The challenge lies in checking all possible combinations of attendees to meet the criteria.\nrequirement pool:\n- Develop an algorithm to check all combinations of 5 attendees.\n- Ensure the solution can handle up to 200,000 individuals and friendships.\n- Optimize the algorithm for performance and scalability.\n- Provide clear output format as specified.\n- Consider edge cases where no friendships exist.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use the NetworkX library to handle graph operations efficiently. The solution will involve checking combinations of 5 nodes to see if they form a clique or an independent set.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: A clique in a graph is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means all 5 people at the party are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in a graph is a subset of vertices such that no two vertices are adjacent. In this context, it means none of the 5 people at the party are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include exactly 5 people, no more, no less.\n    \n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as a graph where each person is a node and each friendship is an edge.\n    2. Iterate over all possible combinations of 5 people from the N individuals.\n    3. For each combination, check if it forms a clique (all nodes are connected) or an independent set (no nodes are connected).\n    4. If a valid combination is found, print the 5 people.\n    5. If no valid combination is found after checking all possibilities, print -1.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no group of 5 can be an independent set.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations of 5 people will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the given individuals. The solution must efficiently handle up to 200,000 individuals and friendships, suggesting the need for an optimized graph-based approach.\nrequirement pool:\n- Develop an algorithm to check for a successful party configuration.\n- Ensure the solution is optimized for large input sizes.\n- Provide clear and concise output as per the problem statement.\n- Handle edge cases such as no friendships or maximum friendships.\n- Consider multiple successful configurations if they exist.\nWe will use graph theory to solve this problem. Specifically, we will represent the individuals and their friendships as a graph, where nodes are individuals and edges are friendships. We will then check for cliques of size 5 (where all nodes are connected) or independent sets of size 5 (where no nodes are connected). The NetworkX library will be used to efficiently handle graph operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 individuals where either all attendees are friends with each other or none of them are friends.\n\n    'cliques' and 'independent sets'\n    Explanation: A clique is a subset of vertices in a graph such that every two distinct vertices are adjacent. An independent set is a subset of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any subset of individuals considered for the party has exactly 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the individuals and friendships as a graph using NetworkX.\n    2. Check for cliques of size 5 in the graph.\n    3. Check for independent sets of size 5 in the graph.\n    4. If either a clique or an independent set of size 5 is found, print the individuals involved.\n    5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: Any valid clique of size 5\n    Explanation: With maximum friendships, there will be multiple cliques of size 5.\n\n    Input: 7 0\n    Output: Any valid independent set of size 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can either all be friends or none be friends. This involves checking combinations of friendships and non-friendships among the given individuals. The solution must efficiently handle up to 200,000 individuals and friendships, suggesting the need for an optimized algorithm, likely involving graph theory concepts such as cliques and independent sets.\nrequirement pool:\n- Develop an algorithm to check for a successful party configuration.\n- Ensure the solution is optimized for large input sizes.\n- Provide clear and concise output as per the format.\n- Handle edge cases such as no friendships or maximum friendships.\n- Consider multiple successful configurations if possible.\nWe will use graph theory to solve this problem. Specifically, we will represent the individuals and their friendships as a graph, where each person is a node and each friendship is an edge. The task is to find either a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). Given the constraints, we will use adjacency lists for efficient graph representation and employ a combination of depth-first search (DFS) and combinatorial checks to find the required configuration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this requirement, it means a group of 5 people where everyone is friends with each other.\n    \n    'independent set': An independent set in graph theory is a set of vertices in a graph, no two of which are adjacent. In this requirement, it means a group of 5 people where no one is friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This indicates that the party must consist of precisely 5 individuals.\n    \n    'no pairs are repeated': This means that each friendship is unique and not duplicated in the input data.\n\n# [degree adverb]\n    'successful': This means the party meets the criteria of either all attendees being friends or none being friends.\n\n# [code logic]\n    1. Represent the individuals and friendships as a graph using adjacency lists.\n    2. Check for a clique of size 5 using combinatorial checks on subsets of nodes.\n    3. Check for an independent set of size 5 using DFS and combinatorial checks.\n    4. If either configuration is found, print the 5 individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 individuals\n    Explanation: With maximum friendships, any group of 5 individuals forms a clique.\n\n    Input: 7 0\n    Output: -1\n    Explanation: Although there are more than 5 individuals, no friendships exist to form a clique, and the independent set condition is trivially met but not unique.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles the maximum constraints effectively.\n- Provide clear output as specified in the requirements.\n- Optimize the code for readability and maintainability.\n- Consider edge cases and test thoroughly.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we need to ensure our solution is optimized for both time and space.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party in Baltia is defined as a gathering of exactly 5 people where either all attendees are friends with each other or none of them are friends.\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices such that every two distinct vertices are adjacent. In this context, it means all 5 people are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a subset of vertices such that no two vertices are adjacent. In this context, it means none of the 5 people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This indicates that the party must consist of precisely 5 individuals.\n    'M pairs': This indicates the number of friendships or buddy pairs available.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of individuals (N) and the number of friendships (M).\n    2. Construct an adjacency list to represent the friendships.\n    3. Check for a clique of size 5:\n        - Iterate through each person and their friends to see if a group of 5 can be formed where everyone is friends with each other.\n    4. Check for an independent set of size 5:\n        - Iterate through each person and ensure no two people in the group are friends.\n    5. If either condition is met, print the group of 5 people. If neither condition is met, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is a friendship, it's impossible to form an independent set of size 5.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers both cliques and independent sets, which covers all possible configurations.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints of up to 200,000 people and friendships.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles edge cases, such as no friendships or maximum friendships.\n- Optimize the solution for performance with large inputs.\n- Provide clear error messages or outputs when a successful party is not possible.\n- Consider user-friendly documentation or comments in the code for maintainability.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these sets using combinatorial techniques and graph traversal methods.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': A subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n    'independent set': A set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must consist of exactly 5 individuals.\n    'exactly M pairs': There are exactly M friendships, which are pairs of people who are friends.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of people (N) and the number of friendships (M).\n2. Construct an adjacency list to represent the friendships as a graph.\n3. Check for a clique of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if every pair within the combination is friends (i.e., check if the subgraph is a complete graph).\n4. Check for an independent set of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if no pair within the combination is friends (i.e., check if the subgraph has no edges).\n5. If either a clique or an independent set is found, print the indices of the 5 people.\n6. If no such configuration is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum possible friendships, no group of 5 can be an independent set, and if no clique of size 5 exists, return -1.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers both cliques and independent sets, which covers all possible configurations for a successful party.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that either all are friends or none are friends. This involves checking combinations of friendships and ensuring the constraints are met efficiently given the large possible input size.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles maximum constraints (N and M up to 200,000).\n- Provide clear output format as specified in requirements.\n- Optimize for performance to handle edge cases.\n- Consider multiple successful configurations if possible.\nWe will use graph theory to solve this problem efficiently. The key is to check for cliques of size 5 or independent sets of size 5 within the graph formed by the friendships. We can utilize networkx, a powerful library for graph analysis, to help identify these structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party on the island of Baltia is defined as a gathering of exactly 5 people where either all attendees are friends with each other (forming a clique) or none of them are friends (forming an independent set).\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all 5 people are friends with each other.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a set of vertices in a graph, no two of which are adjacent. In this context, it means none of the 5 people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This indicates that the party must consist of precisely 5 individuals.\n    \n    'exactly M pairs': This indicates that there are exactly M friendships among the N individuals.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of people (N) and the number of friendships (M).\n    2. Construct a graph using the given friendships.\n    3. Check for cliques of size 5 in the graph.\n    4. If a clique is found, print the 5 people in the clique.\n    5. If no clique is found, check for independent sets of size 5.\n    6. If an independent set is found, print the 5 people in the set.\n    7. If neither a clique nor an independent set is found, print -1.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible pair being friends, no independent set can exist, but a clique of size 5 can be formed.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the feasibility of organizing a party with specific friendship conditions. The solution must efficiently handle large inputs and provide clear outputs. Edge cases, such as no friendships or maximum friendships, must be considered.\nrequirement pool:\n- Efficiently determine if a successful party configuration is possible.\n- Handle large input sizes up to 200,000 individuals and friendships.\n- Provide clear output format as specified.\n- Consider edge cases like no friendships or all individuals being friends.\n- Optimize for performance and memory usage.\nWe will use graph theory to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we need an efficient algorithm, possibly using combinations and checking conditions for small subsets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': A subset of vertices in a graph such that every two distinct vertices are adjacent.\n    'independent set': A subset of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5': The party must consist of exactly 5 individuals.\n    'no pairs are repeated': Each friendship is unique and not repeated.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for a clique of size 5 by iterating through combinations of 5 individuals and verifying if all are friends.\n    3. Check for an independent set of size 5 by iterating through combinations of 5 individuals and verifying if none are friends.\n    4. If either condition is met, print the individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can exist.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for cliques and independent sets will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, true, true, true, false, false, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 723, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "expand_one2two", "parent_index": 439}
