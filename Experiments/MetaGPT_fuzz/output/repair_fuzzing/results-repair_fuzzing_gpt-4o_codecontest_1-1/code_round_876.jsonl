{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is engaged in yet another computer game adventure. In this game, his character must defeat a dragon. The confrontation with the dragon stretches 100^{500} seconds. Throughout this duration, Monocarp assails the dragon using a poisoned dagger. The i-th attack occurs at the onset of the a_i-th second from the commencement of the conflict. The dagger itself inflicts no damage, but it unleashes a poison effect on the dragon. This poison effect inflicts 1 damage during each of the following k seconds. The poison effect kicks off with the same second when the dragon was pierced by the dagger. On the contrary, if the dragon has been poisoned already, then the dagger renews the poison effect (i.e. negates the existing poison effect and initiates a fresh one).\n\nFor instance, consider k = 4, and Monocarp pierces the dragon at seconds 2, 4 and 10. Consequently, the poison effect begins at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the onset of the 4-th second, the poison effect is reactivated, so it precisely inflicts 1 damage during the seconds 4, 5, 6 and 7; subsequently, during the 10-th second, the poison effect is triggered afresh, and it delivers 1 damage during the seconds 10, 11, 12 and 13. In totality, the dragon suffers 10 damage.\n\nMonocarp is aware that the dragon holds h hit points, and if he administers at least h damage to the dragon during the duel \u2014 he conquers the dragon. Monocarp remains undecided about the potency of the poison he will deploy during the encounter. Therefore, he aspires to determine the minimum viable value of k (the number of seconds the poison effect lasts) that suffices to inflict a minimum of h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is engaged in yet another computer game adventure. In this game, his character must defeat a dragon. The confrontation with the dragon stretches 100^{500} seconds. Throughout this duration, Monocarp assails the dragon using a poisoned dagger. The i-th attack occurs at the onset of the a_i-th second from the commencement of the conflict. The dagger itself inflicts no damage, but it unleashes a poison effect on the dragon. This poison effect inflicts 1 damage during each of the following k seconds. The poison effect kicks off with the same second when the dragon was pierced by the dagger. On the contrary, if the dragon has been poisoned already, then the dagger renews the poison effect (i.e. negates the existing poison effect and initiates a fresh one).\n\nFor instance, consider k = 4, and Monocarp pierces the dragon at seconds 2, 4 and 10. Consequently, the poison effect begins at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the onset of the 4-th second, the poison effect is reactivated, so it precisely inflicts 1 damage during the seconds 4, 5, 6 and 7; subsequently, during the 10-th second, the poison effect is triggered afresh, and it delivers 1 damage during the seconds 10, 11, 12 and 13. In totality, the dragon suffers 10 damage.\n\nMonocarp is aware that the dragon holds h hit points, and if he administers at least h damage to the dragon during the duel \u2014 he conquers the dragon. Monocarp remains undecided about the potency of the poison he will deploy during the encounter. Therefore, he aspires to determine the minimum viable value of k (the number of seconds the poison effect lasts) that suffices to inflict a minimum of h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in yet another computer game adventure. In this game, his character must defeat a dragon. The confrontation with the dragon stretches 100^{500} seconds. Throughout this duration, Monocarp assails the dragon using a poisoned dagger. The i-th attack occurs at the onset of the a_i-th second from the commencement of the conflict. The dagger itself inflicts no damage, but it unleashes a poison effect on the dragon. This poison effect inflicts 1 damage during each of the following k seconds. The poison effect kicks off with the same second when the dragon was pierced by the dagger. On the contrary, if the dragon has been poisoned already, then the dagger renews the poison effect. That is, the existing poison effect is negated, and a fresh one is initiated immediately.\n\nFor instance, consider k = 4, and Monocarp pierces the dragon at seconds 2, 4 and 10. Consequently, the poison effect begins at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the onset of the 4-th second, the poison effect is reactivated, so it precisely inflicts 1 damage during the seconds 4, 5, 6 and 7; subsequently, during the 10-th second, the poison effect is triggered afresh, and it delivers 1 damage during the seconds 10, 11, 12 and 13. In totality, the dragon suffers 10 damage.\n\nMonocarp is aware that the dragon holds h hit points, and if he administers at least h damage to the dragon during the duel \u2014 he conquers the dragon. Monocarp remains undecided about the potency of the poison he will deploy during the encounter. Therefore, he aspires to determine the minimum viable value of k (the number of seconds the poison effect lasts) that suffices to inflict a minimum of h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in yet another computer game adventure, where his character must defeat a dragon, and the confrontation stretches 100^{500} seconds. Throughout this duration, Monocarp assails the dragon using a poisoned dagger; the dagger itself inflicts no damage, but it unleashes a poison effect on the dragon that inflicts 1 damage during each of the following k seconds, kicking off with the same second when the dragon was pierced by the dagger. On the contrary, if the dragon has been poisoned already, then the dagger renews the poison effect (i.e. negates the existing poison effect and initiates a fresh one).\n\nFor instance, consider k = 4, and Monocarp pierces the dragon at seconds 2, 4 and 10. Consequently, the poison effect begins at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; subsequently, at the onset of the 4-th second, the poison effect is reactivated, so it precisely inflicts 1 damage during the seconds 4, 5, 6 and 7; subsequently, during the 10-th second, the poison effect is triggered afresh, and it delivers 1 damage during the seconds 10, 11, 12 and 13. In totality, the dragon suffers 10 damage.\n\nMonocarp is aware that the dragon holds h hit points, and if he administers at least h damage to the dragon during the duel \u2014 he conquers the dragon. Monocarp remains undecided about the potency of the poison he will deploy during the encounter, so he aspires to determine the minimum viable value of k (the number of seconds the poison effect lasts) that suffices to inflict a minimum of h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_k(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp inflicts at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # k cannot be more than h because each attack can at most contribute k damage\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum k for each test case.\n    \"\"\"\n    def calculate_damage(k: int, attack_times: List[int]) -> int:\n        \"\"\"Calculate the total damage inflicted for a given k.\n\n        Args:\n            k (int): Duration of poison effect.\n            attack_times (List[int]): List of attack times.\n\n        Returns:\n            int: Total damage inflicted.\n        \"\"\"\n        total_damage = 0\n        n = len(attack_times)\n        \n        for i in range(n - 1):\n            total_damage += min(k, attack_times[i + 1] - attack_times[i])\n        \n        total_damage += k  # Add damage for the last attack\n        return total_damage\n\n    results = []\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(mid, attack_times) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n    \n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of n, h, and a list of attack times\n# Collect all test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attack_times = list(map(int, input().split()))\n    test_cases.append((n, h, attack_times))\n\n# Call the function and print the results\nresults = minimum_k(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, attacks[-1] - attacks[0] + 1\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to defeat the dragon.\n            - a: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage with current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, a[i + 1] - a[i])\n\n            # Check if the total damage is at least h\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: The number of attacks.\n            - h: The required damage to defeat the dragon.\n            - attacks: A list of integers representing the seconds when each attack occurs.\n\n    Returns:\n        A list of integers where each integer is the minimum value of k for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search boundaries based on total damage\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        # Append the minimum viable k for this test case\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on damage calculation\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_damage(k: int, attacks: List[int]) -> int:\n    \"\"\"Calculate the total damage inflicted with a given k.\n\n    Args:\n        k (int): The duration of the poison effect in seconds.\n        attacks (List[int]): The list of attack times.\n\n    Returns:\n        int: The total damage inflicted.\n    \"\"\"\n    total_damage = 0\n    n = len(attacks)\n    \n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    \n    total_damage += k  # Add damage for the last attack\n    return total_damage\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Determine the minimum viable value of k for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): Each test case contains:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: The minimum value of k for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        low, high = 1, h  # Initialize binary search boundaries\n        \n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(mid, attacks) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    \n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_k(t, test_cases)\n    \n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    def calculate_damage(k: int, attack_times: List[int]) -> int:\n        \"\"\"Calculate the total damage inflicted with a given poison duration k.\n\n        Args:\n            k (int): Duration of the poison effect.\n            attack_times (List[int]): List of attack times.\n\n        Returns:\n            int: Total damage inflicted.\n        \"\"\"\n        total_damage = 0\n        n = len(attack_times)\n        \n        for i in range(n - 1):\n            total_damage += min(k, attack_times[i + 1] - attack_times[i])\n        \n        total_damage += k  # Add damage for the last attack\n        return total_damage\n\n    results = []\n    \n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            if calculate_damage(mid, attack_times) >= h:\n                right = mid\n            else:\n                left = mid + 1\n        \n        results.append(left)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n    \n    # Call the function and print the results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum viable value of k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # high can be set to h because k must be at least h to ensure h damage\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, a[i + 1] - a[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on determining the minimum value of k that ensures Monocarp inflicts at least h damage to the dragon. The solution must efficiently handle multiple test cases and large input values, ensuring the output format is consistent with the given examples.\nrequirement pool:\n- Implement efficient game logic to calculate minimum k\n- Ensure output format matches requirements\n- Optimize algorithm for large input values\n- Handle edge cases effectively\n- Provide detailed comments and documentation\nWe will implement a binary search algorithm to efficiently determine the minimum value of k that ensures Monocarp inflicts at least h damage to the dragon. This approach is chosen because it allows us to efficiently search through possible values of k, leveraging the sorted nature of attack times and the cumulative damage calculation. We will use Python's built-in capabilities to handle large integers and ensure the solution is scalable for large input values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is triggered by Monocarp's dagger and inflicts 1 damage per second for k seconds. If the dragon is already poisoned, the effect is renewed, starting a new k-second duration.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest number of seconds the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. In code, this can be implemented using a condition that checks if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition. In code, this can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Implement a binary search for k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k, calculate the total damage:\n     - Initialize total damage to 0.\n     - Iterate over attack times and calculate damage intervals.\n     - Accumulate damage for each interval, considering overlaps.\n   - If total damage >= h, adjust the search range to find a smaller k.\n   - If total damage < h, increase k.\n5. Output the minimum k for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] = 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to inflict the required damage.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] = 1\n    Explanation: The attacks are far apart, so k = 1 is sufficient as each attack can independently inflict 1 damage.\n\n    Test case 3: n = 3, h = 10^18, a = [1, 2, 3] = very large\n    Explanation: With extremely high h and closely spaced attacks, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles different scenarios by adjusting k based on the accumulated damage compared to h.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that the total damage inflicted by the poison effect is at least h. The challenge lies in efficiently calculating the damage over potentially large time spans and ensuring the solution is optimal for all test cases.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k for each test case.\n- Optimize the algorithm to handle large input sizes efficiently.\n- Ensure the solution is robust and handles edge cases correctly.\n- Provide clear documentation and examples for understanding the game mechanics.\n- Enhance user experience with visual feedback on damage dealt.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k for each test case. The binary search will help in optimizing the performance for large input sizes by narrowing down the possible values of k quickly. We will also use a helper function to calculate the total damage inflicted for a given k and check if it meets the required damage h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp inflicts damage on the dragon. It lasts for k seconds and can be renewed by subsequent attacks.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration of the poison effect that is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage inflicted must be greater than or equal to h.\n    Implementation: Ensure the calculated damage for a given k meets or exceeds h.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Define a helper function to calculate total damage for a given k.\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - Use binary search to adjust k based on whether the calculated damage meets or exceeds h.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to inflict any damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value close to h/n\n    Explanation: The attacks are closely spaced, requiring a large k to accumulate enough damage.\n\n    Case 3: n = 2, h = 10^9, a = [1, 10^9]\n    Expected output: 10^9\n    Explanation: The attacks are far apart, requiring k to cover the gap between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe problem requires determining the minimum value of k such that the total damage inflicted by the poison is at least h. The solution must efficiently handle up to 1000 test cases with large values of h and a_i.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Provide clear and concise output for each test case\n- Document the solution for maintainability\nWe will use a binary search approach to efficiently determine the minimum value of k. The key observation is that the damage inflicted by the poison can be calculated by considering the intervals between attacks and the duration of the poison effect. By simulating the damage for different values of k using binary search, we can find the minimum k that results in at least h damage. This approach is efficient and scalable for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is triggered by each attack and lasts for k seconds, inflicting 1 damage per second. If a new attack occurs before the current poison effect ends, the effect is reset and starts anew.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h.\n    Implementation: Use a condition to check if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum': We need to find the smallest possible value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Use binary search to find the minimum k:\n   - Set low = 1 and high = a_n - a_1 + 1 (maximum possible k).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Simulate the damage with k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage interval considering overlaps.\n       - Accumulate the total damage.\n     - If total_damage >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n4. Output the value of low as the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values: \n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to inflict the required damage.\n\n    Test case with attacks at consecutive seconds:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Each attack renews the poison effect, so k = 1 is sufficient to inflict 3 damage.\n\n    Test case with large h:\n    2 10^18\n    1 10^9\n    Expected output: A large k value\n    Explanation: Since h is extremely large, k must also be large enough to accumulate sufficient damage over time.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles different scenarios by adjusting k based on the accumulated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that the total damage inflicted by the poison effect is at least h. The challenge lies in efficiently calculating this for potentially large values of h and a_i, ensuring the solution is both correct and performant.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k.\n- Optimize the solution for large input sizes.\n- Ensure the game mechanics are clearly explained to the user.\n- Provide detailed examples and edge cases in documentation.\n- Enhance user interface for better engagement.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will help us find the smallest k that allows the total damage to meet or exceed h. This approach is optimal for handling large input sizes and ensures performance efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp inflicts damage on the dragon. Each attack initiates or renews a poison effect that lasts for k seconds, dealing 1 damage per second.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration of the poison effect that is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the input to get the number of test cases, and for each test case, retrieve n (number of attacks), h (required damage), and the list of attack times.\n2. Implement a binary search for k, starting with a reasonable range (e.g., 1 to a large number).\n3. For each candidate k in the binary search, calculate the total damage inflicted:\n   - Initialize total damage to 0.\n   - Iterate over the attack times and calculate the damage for each attack considering the poison effect duration k.\n   - If an attack occurs before the previous poison effect ends, adjust the damage calculation accordingly.\n4. Check if the total damage is at least h. If it is, adjust the binary search range to find a smaller k; otherwise, increase k.\n5. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with attacks spaced far apart:\n    1 1000000000000000000\n    1\n    Expected output: 1000000000000000000\n    Explanation: With only one attack, k must be equal to h to inflict enough damage.\n\n    Test case with attacks very close together:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Each attack renews the poison effect immediately, so k=1 is sufficient.\n\n    Test case with maximum possible h:\n    2 1000000000000000000\n    1 1000000000\n    Expected output: 999999999\n    Explanation: The attacks are spaced far apart, requiring a large k to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe game requires a balance between strategic depth and computational efficiency. The poison effect mechanics should be clear and allow players to plan their attacks effectively. The challenge lies in calculating the minimum k value efficiently for large input sizes.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k\n- Design intuitive UI for displaying attack and health status\n- Ensure real-time performance for large-scale computations\n- Provide engaging storyline and context for the game\n- Optimize game for mobile and desktop platforms\nWe will implement a binary search algorithm to efficiently determine the minimum value of k that causes at least h damage to the dragon. The algorithm will calculate the total damage for a given k and adjust k based on whether the damage meets or exceeds h. This approach ensures computational efficiency even for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp inflicts damage on the dragon. It lasts for k seconds and can be renewed by subsequent attacks.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration of the poison effect that is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k (e.g., low = 1, high = maximum possible k).\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Compute total damage for current mid value of k.\n        c. If total damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (increase k).\n    3. Return low as the minimum viable k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a_1 = 1\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to inflict any damage.\n\n    Case 2: n = 100, h = 10^18, a_1 = 1, a_2 = 2, ..., a_100 = 100\n    Expected output: A large value close to h/n\n    Explanation: With maximum h and attacks spaced by 1 second, k must be large enough to accumulate sufficient damage.\n\n    Case 3: n = 2, h = 10, a_1 = 1, a_2 = 10\n    Expected output: 5\n    Explanation: The poison effect must last long enough to cover the gap between attacks and accumulate at least h damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirements focus on determining the minimum value of k for each test case, ensuring the poison effect inflicts at least h damage. The solution must efficiently handle large input sizes and constraints.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles large values of h and a_i efficiently\n- Optimize the solution for performance\n- Validate the output format against multiple test cases\n- Consider edge cases and test thoroughly\nWe will use a binary search approach to efficiently determine the minimum value of k. The key challenge is to handle large values of h and a_i efficiently, ensuring the solution scales well with the constraints. We will iterate over the attacks and calculate the damage using a binary search to find the smallest k that meets the damage requirement.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp inflicts damage on the dragon. It lasts for k seconds and can be renewed by subsequent attacks.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration of the poison effect that is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Initialize variables for binary search: low = 1, high = maximum possible k (e.g., h).\n    2. Perform binary search:\n        - Calculate mid = (low + high) // 2.\n        - Simulate the damage calculation with k = mid.\n        - If the total damage is at least h, adjust high = mid.\n        - Otherwise, adjust low = mid + 1.\n    3. Continue until low equals high, which will be the minimum k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value close to h/n\n    Explanation: With maximum constraints, k needs to be large enough to accumulate sufficient damage over many attacks.\n\n    Case 3: n = 2, h = 10^9, a = [1, 10^9]\n    Expected output: A value close to h\n    Explanation: With two attacks far apart, k must be large enough to cover the gap and accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting k based on the accumulated damage calculation.\n", "requirement analysis:\nThe problem requires determining the minimum duration k for which the poison effect must last to inflict at least h damage on the dragon. The solution must efficiently handle large input sizes and provide accurate results for each test case.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm for performance with up to 1000 test cases.\n- Provide clear and concise output for each test case.\n- Document the solution approach and edge case handling.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will help us find the smallest k that allows Monocarp to inflict at least h damage to the dragon. We will iterate over the attack times and calculate the total damage for each k using a helper function. This approach ensures that we handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack with the dagger inflicts 1 damage per second for k seconds. If the dragon is already poisoned, the effect is renewed, meaning the poison duration starts afresh from the current attack time.\n\n    'minimum viable value of k'\n    Explanation: This refers to finding the smallest possible duration (k seconds) for which the poison effect must last to ensure that the total damage inflicted on the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. In code, this can be implemented using a binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Initialize binary search boundaries: low = 1, high = maximum possible k (a large number).\n2. While low < high:\n   - Calculate mid = (low + high) // 2.\n   - Use a helper function to calculate total damage for k = mid.\n   - If total damage >= h, set high = mid (try smaller k).\n   - Else, set low = mid + 1 (need larger k).\n3. Return low as the minimum viable k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Case 2: n = 2, h = 10^18, a = [1, 10^9]\n    Expected output: 10^18\n    Explanation: The attacks are far apart, requiring a very large k to accumulate enough damage.\n\n    Case 3: n = 100, h = 100, a = [1, 2, ..., 100]\n    Expected output: 1\n    Explanation: Each attack is consecutive, so k = 1 is enough to accumulate 100 damage over 100 attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that the total damage inflicted by the poison effect is at least h. The challenge lies in efficiently calculating the damage over potentially large time spans and ensuring the solution is optimal for all test cases.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide clear documentation and examples for users.\n- Design a user-friendly interface for input and output.\nWe will implement a function to calculate the minimum value of k using a binary search approach to efficiently determine the smallest k that results in at least h damage. This approach is optimal for handling large input sizes and ensures performance remains efficient even at maximum input limits.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack inflicts 1 damage per second for k seconds. If a new attack occurs before the previous poison effect ends, the effect is reset and starts anew.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration of the poison effect that ensures the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb] \n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Implement a binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k, calculate the total damage:\n     - Initialize total damage to 0.\n     - Iterate over attack times and calculate damage for each attack considering overlaps.\n     - If total damage >= h, adjust the search bounds to find a smaller k.\n5. Output the minimum k for each test case.\n\n# [edge case] \n    1. Test case with n = 1 and h = 1, attack time = [1] = 1\n       Explanation: With only one attack and h = 1, k must be at least 1 to inflict the required damage.\n       \n    2. Test case with n = 2 and h = 2, attack times = [1, 2] = 1\n       Explanation: With two consecutive attacks, k = 1 is sufficient as each attack inflicts 1 damage immediately.\n\n    3. Test case with n = 3 and h = 10^18, attack times = [1, 10^9, 2*10^9] = 10^18\n       Explanation: With very large h, k must be large enough to cover the entire duration between attacks to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these cases by adjusting k based on the calculated damage for each test case.\n", "requirement analysis:\nThe main requirement is to determine the minimum duration of the poison effect (k) that will inflict at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large input sizes, ensuring that the algorithm is both time and space efficient.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear documentation and examples.\n- Enhance user interface for better understanding of results.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will help us find the smallest k that allows Monocarp to inflict at least h damage to the dragon. We will iterate over the attack times and calculate the total damage for each potential k using a helper function. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp inflicts damage on the dragon. It lasts for k seconds starting from the second of the attack, and it can be renewed if another attack occurs during its duration.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration of the poison effect that is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Implement a binary search to find the minimum k.\n    2. For each potential k, calculate the total damage using a helper function.\n    3. The helper function should iterate over attack times and calculate damage based on the poison effect duration.\n    4. Check if the calculated damage is at least h.\n    5. Adjust the binary search bounds based on whether the current k is sufficient.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k can be 1.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: Large k value\n    Explanation: The dragon requires a huge amount of damage, so k must be large enough to accumulate sufficient damage over multiple attacks.\n\n    Case 3: n = 2, h = 2, a = [1, 1000000000]\n    Expected output: 1\n    Explanation: The attacks are far apart, but only 2 damage is needed, so k can be minimal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that the total damage inflicted by the poison is at least h. The challenge lies in efficiently calculating this for potentially large values of h and a_i, while ensuring the solution is scalable across multiple test cases.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for edge cases\n- Provide clear and concise output\n- Document the solution for maintainability\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The key challenge is to handle large values of h and a_i efficiently, ensuring the solution scales well across multiple test cases. We will use Python's built-in capabilities for handling large integers and optimize the algorithm to minimize the number of calculations required.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a mechanism where each attack inflicts 1 damage per second for k seconds. If a new attack occurs before the previous poison effect ends, the effect is reset and starts anew.\n\n    'minimum viable value of k'\n    Explanation: This refers to the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. In code, this can be implemented using a condition that checks if the accumulated damage is >= h.\n\n# [degree adverb] \n    'minimum': We need to find the smallest possible value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Implement a binary search for k:\n   - Set initial bounds for k (e.g., low = 1, high = max possible value).\n   - While low < high:\n     - Calculate mid as the average of low and high.\n     - Simulate the damage calculation with k = mid.\n     - If the total damage is at least h, adjust high to mid.\n     - Otherwise, adjust low to mid + 1.\n4. Output the value of low as the minimum k for each test case.\n\n# [edge case] \n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack must independently inflict at least 1 damage.\n\n    Test case 3: n = 3, h = 10, a = [1, 2, 3] => k = 4\n    Explanation: The attacks are close together, so a smaller k might not suffice. Here, k = 4 ensures enough overlap to reach at least 10 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on whether the accumulated damage meets or exceeds h.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 876, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "rephrase_one", "parent_index": 310}
