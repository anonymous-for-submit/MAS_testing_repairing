{"name": "1579_B. Shifting Sort", "description": "The new generation external memory contains an array of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "tags": ["implementation", "sortings"], "difficulty": 8, "id": 1579, "sample_io": [{"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}], "test_list": [{"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 4 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 2 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 6 1 4 3\n", "output": ["0\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 2 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n2 3 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 6 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 4 1 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 6 0 5\n5\n2 10 2 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 1\n4\n1 4 0 3\n5\n0 5 1 4 0\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 2 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 0 5\n5\n2 3 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n4 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 4 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 3 1\n4\n2 13 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n2 13 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 0 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 0 -1 1 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 4\n5\n2 8 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 2 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n-1 2 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 4 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 1 8 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 2 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 0\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n4 3 0\n4\n0 6 1 3\n5\n2 3 1 4 3\n", "output": ["1\n1 2 1\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 0 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n0\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 0 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 0\n3\n2 4 0\n4\n0 15 1 0\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 4 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n0 5 1 4 11\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 1 0 5\n5\n2 3 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n2 3 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 8 -1 3\n5\n0 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n1 9 1 3\n5\n1 5 2 4 0\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n4 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n2 4 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n1 28 -1 4 5\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 2 -1 3\n5\n2 0 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 4 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 4 0 3\n5\n0 10 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n4 1\n3\n1 5 0\n4\n0 6 1 3\n5\n2 5 1 7 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 8 1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 4 1\n4\n2 4 0 5\n5\n2 10 2 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 2 1 3\n5\n4 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n4 5 1 6 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 6 5\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 7 0 5\n5\n2 10 2 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n4 2\n3\n0 2 0\n4\n-1 2 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 7 0 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n0 4 0\n4\n0 9 0 3\n5\n1 6 2 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 1 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["0\n0\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 0\n4\n0 0 1 3\n5\n2 5 0 4 3\n", "output": ["0\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 8 1 3\n5\n4 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n0 1\n3\n1 4 0\n4\n0 2 1 3\n5\n4 5 1 0 3\n", "output": ["0\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n1 5 1 6 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n0 4 -1\n4\n-1 6 1 3\n5\n0 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 1 -1 3\n5\n0 5 0 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 2 2 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n0\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 0\n4\n0 0 1 3\n5\n2 5 0 6 3\n", "output": ["0\n1\n1 3 2\n0\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 1\n3\n1 2 2\n4\n0 8 1 3\n5\n4 5 1 8 3\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n2 1\n3\n-2 2 0\n4\n3 8 1 6\n5\n2 5 1 6 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 3\n5\n2 0 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 5 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 5 4\n2 4 2\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n2 4 -1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 4 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 2 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 6\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 6 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 2 -1\n4\n2 4 1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n0 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 2 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 1 0\n4\n0 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 9 2 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 0 3\n5\n1 8 2 4 1\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n4 18 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n2 4 2\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 2\n4\n2 18 -1 3\n5\n0 -1 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n2\n1 2 1\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 2 8 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 0 3\n5\n2 5 1 4 6\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n0 4 -1 4\n5\n2 5 1 8 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 4 1\n4\n0 2 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n2 3 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 -1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 -1\n3\n2 1 3\n4\n1 18 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n1\n1 2 1\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 2 0 3\n5\n0 10 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 0 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 2 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 10 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 3 0\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 0\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n4 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 4 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 6\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 6 1 4 3\n", "output": ["1\n1 2 1\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 0\n4\n1 4 -1 2\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 1\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n0 2 1\n4\n0 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 -1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 4\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n1 7 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 5 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 4 0\n4\n0 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 8 1 6\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 -1\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 4 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 11 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 0\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 4 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 4\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 11\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n2 9 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 9 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 7 1 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n-1 2 0\n4\n-1 6 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -2\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 -1\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 6\n5\n2 9 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 9 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n-1 2 0\n4\n-1 12 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n1 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 -2\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 -1\n4\n0 15 1 3\n5\n1 5 1 4 2\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 9 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 14 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 0 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 6 -1\n4\n0 15 1 3\n5\n1 5 1 4 2\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}], "task_id": "codecontest/14", "prompt": "The updated external storage device includes a sequence of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions:\n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment.\n  2. After selecting these indices, you then replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2.\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "repair_prompt": ["The updated external storage device includes a sequence of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions:\n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment.\n  2. After selecting these indices, you then replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2.\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "The updated external storage device includes a sequence of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions:\n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment.\n  2. After selecting these indices, you then replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. A cyclic shift involves the rotation of an array segment to its left. This can be understood better with an example: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2.\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "The updated external storage device includes a sequence of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n]. This type of memory does not support changing the value of an arbitrary element, but allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment and after selecting these indices, you then replace the segment a[l \u2026 r] with its cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of the original elements of the segment, and in the end you get a = [1, \\color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing an integer n and a list of integers representing the array.\n\n    Returns:\n        A list of tuples, each containing an integer k and a list of tuples representing the cyclic shift operations.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        # Check if the array is already sorted\n        if a == sorted(a):\n            results.append((0, []))\n            continue\n\n        actions = []\n        sorted_a = sorted(a)\n\n        # Perform cyclic shifts to sort the array\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the correct position of the current element\n                correct_pos = sorted_a.index(a[i], i)\n                # Perform a cyclic shift\n                l = i + 1\n                r = correct_pos + 1\n                d = r - l\n                a[l-1:r] = a[l-1+d:r] + a[l-1:l-1+d]\n                actions.append((l, r, d))\n\n        # Ensure the number of operations does not exceed n\n        k = min(len(actions), n)\n        results.append((k, actions[:k]))\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Call the function\n    results = sort_with_cyclic_shifts(t, test_cases)\n\n    # Output interface\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(' '.join(map(str, action)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport typing\n\ndef sort_with_cyclic_shifts(\n    t: int, \n    test_cases: typing.List[typing.Tuple[int, typing.List[int]]]\n) -> typing.List[typing.Tuple[int, typing.List[typing.Tuple[int, int, int]]]]:\n    \"\"\"Sort arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples, each containing an integer n and a list of integers representing the array.\n\n    Returns:\n        A list of tuples, each containing an integer k and a list of tuples representing the operations.\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        operations = []\n        sorted_array = sorted(array)\n\n        if array == sorted_array:\n            results.append((0, operations))\n            continue\n\n        # Perform cyclic shifts to sort the array\n        for i in range(n):\n            if array[i:] != sorted_array[i:]:\n                # Find the segment that needs to be shifted\n                l = i + 1\n                r = n\n                d = 1\n\n                # Perform the cyclic shift\n                segment = array[l-1:r]\n                shifted_segment = segment[d:] + segment[:d]\n                array[l-1:r] = shifted_segment\n\n                operations.append((l, r, d))\n\n                # Check if the array is sorted\n                if array == sorted_array:\n                    break\n\n        results.append((len(operations), operations))\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append((n, array))\n\n    results = sort_with_cyclic_shifts(t, test_cases)\n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    results = []\n    \n    for n, array in test_cases:\n        actions = []\n        \n        # Check if the array is already sorted\n        if array == sorted(array):\n            results.append((0, actions))\n            continue\n        \n        # We will use a simple strategy to sort the array\n        # This strategy is not optimal but will ensure the array is sorted within n shifts\n        for i in range(n - 1):\n            # Find the minimum element in the unsorted part of the array\n            min_index = i\n            for j in range(i + 1, n):\n                if array[j] < array[min_index]:\n                    min_index = j\n            \n            # If the minimum element is not at the current position, perform a cyclic shift\n            if min_index != i:\n                # Perform a cyclic shift from i to min_index\n                # The offset d is the number of elements to shift, which is min_index - i\n                d = min_index - i\n                segment = array[i:min_index + 1]\n                shifted_segment = segment[d:] + segment[:d]\n                array[i:min_index + 1] = shifted_segment\n                actions.append((i + 1, min_index + 1, d))\n        \n        # Append the result for this test case\n        results.append((len(actions), actions))\n    \n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        array = list(map(int, data[index + 1:index + 1 + n]))\n        test_cases.append((n, array))\n        index += n + 1\n    \n    # Call the function\n    results = sort_with_cyclic_shifts(t, test_cases)\n    \n    # Output interface\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(action[0], action[1], action[2])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport typing\n\ndef sort_with_cyclic_shifts(\n    t: int, \n    test_cases: typing.List[typing.Tuple[int, typing.List[int]]]\n) -> typing.List[typing.Tuple[int, typing.List[typing.Tuple[int, int, int]]]]:\n    \"\"\"Sort arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of operations and a list of operations.\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        sorted_array = sorted(array)\n        if array == sorted_array:\n            results.append((0, []))\n            continue\n\n        actions = []\n        current_array = array[:]\n        \n        # Simple strategy: perform cyclic shifts to sort the array\n        for i in range(n):\n            if current_array[i] != sorted_array[i]:\n                # Find the position of the correct element in the current array\n                correct_pos = current_array.index(sorted_array[i], i)\n                # Perform a cyclic shift\n                if correct_pos > i:\n                    # Calculate the offset for the cyclic shift\n                    offset = correct_pos - i\n                    segment = current_array[i:correct_pos + 1]\n                    shifted_segment = segment[offset:] + segment[:offset]\n                    current_array[i:correct_pos + 1] = shifted_segment\n                    actions.append((i + 1, correct_pos + 1, offset))\n        \n        results.append((len(actions), actions))\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append((n, array))\n\n    # Call the function and get the result\n    results = sort_with_cyclic_shifts(t, test_cases)\n\n    # Output interface\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(f\"{action[0]} {action[1]} {action[2]}\")\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport typing\n\ndef sort_with_cyclic_shifts(\n    t: int, \n    test_cases: typing.List[typing.Tuple[int, typing.List[int]]]\n) -> typing.List[typing.Tuple[int, typing.List[typing.Tuple[int, int, int]]]]:\n    \"\"\"Sort arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing an integer n and a list of integers.\n\n    Returns:\n        A list of tuples, each containing an integer k and a list of tuples representing the operations.\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        actions = []\n        \n        # Check if the array is already sorted\n        if array == sorted(array):\n            results.append((0, actions))\n            continue\n        \n        # Perform cyclic shifts to sort the array\n        for i in range(n - 1):\n            min_index = i\n            for j in range(i + 1, n):\n                if array[j] < array[min_index]:\n                    min_index = j\n            \n            if min_index != i:\n                # Perform a cyclic shift\n                d = min_index - i\n                l = i + 1\n                r = min_index + 1\n                array[i:r] = array[i+d:r] + array[i:i+d]\n                actions.append((l, r, d))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append((n, array))\n\n# Output interface\nresults = sort_with_cyclic_shifts(t, test_cases)\nfor result in results:\n    k, actions = result\n    print(k)\n    for action in actions:\n        print(f\"{action[0]} {action[1]} {action[2]}\")\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts within n operations.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing an integer n and a list of integers representing the array.\n\n    Returns:\n        A list of tuples, each containing the number of operations k and a list of operations (l, r, d).\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        operations = []\n        sorted_a = sorted(a)\n\n        if a == sorted_a:\n            results.append((0, operations))\n            continue\n\n        # Perform cyclic shifts to sort the array\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the correct position of the current element\n                correct_pos = sorted_a.index(a[i])\n                if correct_pos > i:\n                    # Perform a cyclic shift\n                    l = i + 1\n                    r = correct_pos + 1\n                    d = r - l\n                    a[l-1:r] = a[l-1+d:r] + a[l-1:l-1+d]\n                    operations.append((l, r, d))\n\n        results.append((len(operations), operations))\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    results = sort_with_cyclic_shifts(t, test_cases)\n\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(' '.join(map(str, action)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing an integer n and a list of integers representing the array.\n\n    Returns:\n        A list of tuples, each containing an integer k and a list of tuples representing the cyclic shift operations.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        operations = []\n        \n        # Check if the array is already sorted\n        if a == sorted(a):\n            results.append((0, operations))\n            continue\n\n        # Perform cyclic shifts to sort the array\n        for i in range(n - 1):\n            min_index = i\n            for j in range(i + 1, n):\n                if a[j] < a[min_index]:\n                    min_index = j\n            \n            if min_index != i:\n                # Perform a cyclic shift\n                l = i + 1\n                r = min_index + 1\n                d = r - l\n                a[l-1:r] = a[l-1+d:r] + a[l-1:l-1+d]\n                operations.append((l, r, d))\n        \n        results.append((len(operations), operations))\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Call the function\n    results = sort_with_cyclic_shifts(t, test_cases)\n\n    # Output interface\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(f\"{action[0]} {action[1]} {action[2]}\")\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing an integer n and a list of integers representing the array.\n\n    Returns:\n        A list of tuples, each containing an integer k and a list of tuples representing the cyclic shift operations.\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        actions = []\n        sorted_array = sorted(array)\n\n        if array == sorted_array:\n            results.append((0, actions))\n            continue\n\n        # We will perform a simple strategy to sort the array using cyclic shifts\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the correct position of the current element\n                correct_pos = array.index(sorted_array[i], i)\n                # Perform a cyclic shift to move the element to its correct position\n                if correct_pos > i:\n                    # Calculate the offset for the cyclic shift\n                    d = correct_pos - i\n                    # Perform the cyclic shift\n                    segment = array[i:correct_pos + 1]\n                    shifted_segment = segment[d:] + segment[:d]\n                    array[i:correct_pos + 1] = shifted_segment\n                    # Record the action\n                    actions.append((i + 1, correct_pos + 1, d))\n\n        results.append((len(actions), actions))\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append((n, array))\n\n    # Output interface\n    results = sort_with_cyclic_shifts(t, test_cases)\n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    results = []\n    \n    for n, a in test_cases:\n        operations = []\n        \n        # Check if the array is already sorted\n        if a == sorted(a):\n            results.append((0, operations))\n            continue\n        \n        # Perform cyclic shifts to sort the array\n        for i in range(n):\n            # Find the minimum element in the unsorted part of the array\n            min_index = i\n            for j in range(i + 1, n):\n                if a[j] < a[min_index]:\n                    min_index = j\n            \n            # If the minimum element is not at the current position, perform a cyclic shift\n            if min_index != i:\n                # Calculate the offset for the cyclic shift\n                d = min_index - i\n                # Perform the cyclic shift\n                a[i:min_index+1] = a[i+1:min_index+1] + a[i:i+1]\n                # Record the operation\n                operations.append((i + 1, min_index + 1, d))\n        \n        # Append the result for the current test case\n        results.append((len(operations), operations))\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n    \n    # Output interface\n    results = sort_with_cyclic_shifts(t, test_cases)\n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport typing\n\ndef sort_with_cyclic_shifts(\n    t: int, \n    test_cases: typing.List[typing.Tuple[int, typing.List[int]]]\n) -> typing.List[typing.Tuple[int, typing.List[typing.Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts and returns the number of shifts and their details.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of shifts and a list of shift operations.\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        if array == sorted(array):\n            results.append((0, []))\n            continue\n\n        actions = []\n        sorted_array = sorted(array)\n\n        # Perform cyclic shifts to sort the array\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the correct position of the current element\n                correct_pos = sorted_array.index(array[i])\n                if correct_pos > i:\n                    # Perform a cyclic shift\n                    l = i + 1\n                    r = correct_pos + 1\n                    d = r - l\n                    segment = array[l-1:r]\n                    shifted_segment = segment[d:] + segment[:d]\n                    array[l-1:r] = shifted_segment\n                    actions.append((l, r, d))\n\n        results.append((len(actions), actions))\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append((n, array))\n\n    results = sort_with_cyclic_shifts(t, test_cases)\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to sort an array using cyclic shifts within a given number of operations. The solution should handle multiple test cases and provide output in a specified format. The challenge is to ensure the solution is efficient and meets the constraints of the problem.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Handle multiple test cases efficiently\n- Ensure output format is correct\n- Optimize for performance\n- Provide detailed documentation\nWe will implement a function that sorts an array using cyclic shifts. The approach will involve iterating over the array and performing cyclic shifts to move elements into their correct positions. We will use Python's list slicing capabilities to perform the cyclic shifts efficiently. The solution will handle multiple test cases as described in the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset. This means that elements at the start of the segment move to the end, and the rest shift left.\n\n    'sort the array'\n    Explanation: The goal is to rearrange the elements of the array in non-decreasing order using cyclic shifts.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means we can perform up to n shifts.\n\n# [degree adverb]\n    'arbitrary'\n    Explanation: The indices l and r, as well as the offset d, can be chosen freely within their respective constraints, allowing flexibility in how segments are selected and shifted.\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Check if the array is already sorted. If it is, output k = 0 and an empty sequence of shifts.\n3. If not sorted, iterate over the array to identify segments that can be cyclically shifted to move elements into their correct positions.\n4. Use list slicing to perform cyclic shifts on identified segments.\n5. Keep track of each shift operation by storing l, r, and d.\n6. Ensure that the number of operations does not exceed n.\n7. Output the number of operations k and the details of each operation.\n\n# [edge case]\n    Test case 1: [1, 1] = 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Test case 2: [3, 3, 3] = 0\n    Explanation: All elements are identical, so the array is already sorted.\n\n    Test case 3: [5, 4, 3, 2, 1] = 5\n    Explanation: The array is in reverse order, requiring multiple shifts to sort.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and performing up to n shifts will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to sort an array using cyclic shifts within a given constraint of n shifts. The solution should handle multiple test cases efficiently and provide a valid sequence of operations for each test case. The focus is on ensuring the solution is simple yet effective, without the need to minimize the number of shifts.\nrequirement pool:\n- Implement cyclic shift sorting for arrays\n- Handle multiple test cases efficiently\n- Ensure the solution is easy to understand\n- Provide a valid sequence of operations for each test case\n- Optimize for performance where possible\nWe will implement a function to sort arrays using cyclic shifts. The approach will involve identifying segments within the array that can be cyclically shifted to achieve a sorted order. We will use Python's list slicing and manipulation capabilities to perform the cyclic shifts. The solution will handle multiple test cases efficiently by iterating over each test case and applying the cyclic shift operations. The implementation will be simple and straightforward, focusing on meeting the requirement of sorting within n shifts without optimizing for the minimum number of shifts.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset, effectively moving elements from the start of the segment to the end while maintaining their order.\n\n    'sort using cyclic shifts'\n    Explanation: The task is to sort the array by performing cyclic shifts on segments of the array, with the constraint that no more than n shifts are allowed.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts performed should not exceed the length of the array, n. This means that for each test case, the number of operations (k) must be less than or equal to n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Check if the array is already sorted. If it is, output k = 0 and move to the next test case.\n3. If not sorted, identify segments that can be cyclically shifted to move elements closer to their sorted positions.\n4. Perform cyclic shifts on identified segments and keep track of each operation (l, r, d).\n5. Ensure that the total number of operations does not exceed n.\n6. Output the number of operations k and the details of each operation for each test case.\n\n# [edge case]\n    Test case with already sorted array:\n    Input: [1, 2, 3, 4] = 0\n    Explanation: The array is already sorted, so no operations are needed.\n\n    Test case with minimum size array:\n    Input: [2, 1] = 1\n    Explanation: Only one operation is needed to sort the array by shifting the segment [2, 1] to [1, 2].\n\n    Test case with all identical elements:\n    Input: [3, 3, 3] = 0\n    Explanation: The array is already sorted since all elements are identical.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and performing necessary shifts will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to sort an array using cyclic shifts within a given number of operations. The solution must handle multiple test cases and provide output in a specific format. The challenge lies in efficiently determining the segments and offsets for cyclic shifts to achieve a sorted array.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Handle multiple test cases efficiently\n- Ensure output format is correct\n- Optimize for performance with larger arrays\n- Provide detailed comments and documentation\nWe will implement a function that sorts the array using cyclic shifts. The approach will involve identifying segments of the array that can be cyclically shifted to move elements into their correct positions. We will use a simple algorithm that iteratively selects segments and applies cyclic shifts until the array is sorted. The Python standard library will be sufficient for this task, as we only need basic list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset, effectively rearranging the elements within that segment.\n\n    'segment'\n    Explanation: A segment is a contiguous subarray defined by two indices, l and r, within the array.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means we can use up to n shifts to achieve sorting.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the integer n and the array a.\n    2. Check if the array is already sorted. If it is, output k = 0.\n    3. If not sorted, identify segments that can be cyclically shifted to move elements into their correct positions.\n    4. Apply cyclic shifts iteratively until the array is sorted, ensuring the number of shifts does not exceed n.\n    5. Output the number of shifts k and the details of each shift (l, r, d).\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Input: [3, 2, 1] = 1\n    Explanation: A single shift of the entire array can sort it.\n\n    Input: [5, 4, 3, 2, 1] = 4\n    Explanation: Multiple shifts are needed to sort this reverse-ordered array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and applying shifts iteratively will handle these cases naturally.\n", "requirement analysis:\nThe requirement is to sort an array using cyclic shifts, ensuring that the number of shifts does not exceed the length of the array. The solution should handle multiple test cases efficiently and provide the correct output format.\nrequirement pool:\n- Implement cyclic shift sorting for arrays\n- Ensure solution handles up to 1000 test cases\n- Optimize for performance with larger arrays\n- Provide clear and correct output format\n- Minimize the number of shifts where possible\nWe will implement a function that sorts arrays using cyclic shifts. The approach will involve identifying segments that can be shifted to bring the array closer to a sorted state. We will use Python's list slicing and manipulation capabilities to perform cyclic shifts efficiently. Given the constraints, we will ensure the solution handles up to 1000 test cases and provides the correct output format. The implementation will focus on simplicity and efficiency, leveraging Python's built-in capabilities without additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset. This operation is used to rearrange elements within the array without changing the overall size or structure of the array.\n\n    'sort the array'\n    Explanation: The goal is to rearrange the elements of the array in non-decreasing order using cyclic shifts.\n\n# [phrase showing quantity relationship]\n    'no more than n cyclic shifts'\n    Explanation: The task requires sorting the array using at most n cyclic shifts, where n is the length of the array. This means that the number of operations performed should not exceed the number of elements in the array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Check if the array is already sorted. If it is, output k = 0 and no actions.\n3. If not sorted, identify segments that can be shifted to bring the array closer to a sorted state.\n4. Use a loop to perform cyclic shifts on identified segments, keeping track of each operation.\n5. Ensure that the number of operations does not exceed n.\n6. Output the number of operations k and the details of each operation in the format \"l r d\".\n\n# [edge case]\n    Test case with already sorted array:\n    Input: [1, 2, 3, 4, 5]\n    Output: 0\n    Explanation: The array is already sorted, so no operations are needed.\n\n    Test case with all identical elements:\n    Input: [3, 3, 3, 3]\n    Output: 0\n    Explanation: All elements are identical, so the array is trivially sorted.\n\n    Test case with minimum size:\n    Input: [2, 1]\n    Output: 1\n    Explanation: A single shift is needed to sort the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and performing shifts as needed will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to sort an array using cyclic shifts within a given number of operations. The solution should handle multiple test cases and provide output in a specified format. The challenge is to ensure the solution is efficient and meets the constraints of the problem.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Handle multiple test cases efficiently\n- Ensure output format is correct\n- Optimize for performance within given constraints\n- Provide clear documentation and comments\nWe will implement a function to sort arrays using cyclic shifts. The approach will involve identifying segments of the array that can be cyclically shifted to achieve a sorted order. We will use Python's built-in list operations to perform the cyclic shifts efficiently. The solution will handle multiple test cases and ensure the output format is correct.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset. This means that elements are moved from the start of the segment to the end, and the rest are shifted left.\n\n    'sort using cyclic shifts'\n    Explanation: The task is to sort the array by performing a series of cyclic shifts on segments of the array. The number of shifts should not exceed the length of the array.\n\n# [phrase showing quantity relationship]\n    'no more than n cyclic shifts': The number of cyclic shifts performed should be less than or equal to the length of the array.\n    Implementation: Ensure that the count of shifts does not exceed n.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Check if the array is already sorted. If it is, output k = 0.\n3. If not sorted, identify segments that can be cyclically shifted to move elements closer to their sorted positions.\n4. Perform cyclic shifts on identified segments and keep track of each operation.\n5. Ensure that the number of operations does not exceed n.\n6. Output the number of operations and details of each operation.\n\n# [edge case]\n    Edge Case 1: Input: [1, 1, 1, 1] = 0\n    Explanation: The array is already sorted, so no operations are needed.\n\n    Edge Case 2: Input: [5, 4, 3, 2, 1] = 5\n    Explanation: The array is in reverse order, requiring multiple shifts to sort.\n\n    Edge Case 3: Input: [1, 3, 2] = 1\n    Explanation: A single shift can sort this small array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and performing necessary shifts will handle these cases naturally.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases efficiently and provide output in a specified format. The focus is on achieving the task within the constraints rather than minimizing the number of shifts.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles up to 1000 test cases\n- Optimize for performance within given constraints\n- Provide clear and correct output format\n- Consider edge cases and repeated elements\nWe will implement a function that sorts the array using cyclic shifts. The approach will involve iterating over the array and performing cyclic shifts to move elements into their correct positions. We will use a simple algorithm that ensures the array is sorted within n operations, leveraging Python's list slicing capabilities for cyclic shifts.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset. This means that elements are moved from the start of the segment to the end, and the rest are shifted left.\n\n    'sort the array'\n    Explanation: The goal is to rearrange the elements of the array in non-decreasing order using cyclic shifts.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Check if the array is already sorted. If it is, output k = 0.\n3. If not sorted, perform cyclic shifts:\n   - Identify segments that can be shifted to move elements closer to their correct positions.\n   - Use list slicing to perform cyclic shifts on identified segments.\n   - Keep track of each operation (l, r, d) and ensure the number of operations does not exceed n.\n4. Output the number of operations k and the details of each operation.\n\n# [edge case] \n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already sorted, so no operations are needed.\n\n    Test case 2: [5, 4, 3, 2, 1] = 5\n    Explanation: The array is in reverse order, requiring multiple shifts to sort. Each element needs to be moved to its correct position.\n\n    Test case 3: [1, 3, 2] = 1\n    Explanation: A single shift of segment [3, 2] by offset 1 will sort the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and performing necessary shifts will handle these cases effectively.\n", "requirement analysis:\nThe requirement is to sort an array using cyclic shifts within a given number of operations. The solution should handle multiple test cases and provide output in a specified format. The challenge is to ensure the solution is efficient and meets the constraints of the problem.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Handle multiple test cases efficiently\n- Ensure output format is correct\n- Optimize for performance\n- Provide detailed documentation\nWe will implement a function that sorts an array using cyclic shifts. The approach will involve iterating over the array and performing cyclic shifts to move elements into their correct positions. We will use Python's list slicing capabilities to perform the cyclic shifts efficiently. The solution will handle multiple test cases as specified and ensure the output format is correct.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset. This operation allows rearranging elements within a specified range without changing the overall length of the array.\n\n    'sort the array'\n    Explanation: The goal is to rearrange the elements of the array in non-decreasing order using cyclic shifts.\n\n# [phrase showing quantity relationship]\n    'no more than n cyclic shifts'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means that we can perform up to n shifts to achieve the sorted order.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Check if the array is already sorted. If it is, output k = 0 and move to the next test case.\n3. If not sorted, iterate over the array to identify segments that can be cyclically shifted to move elements into their correct positions.\n4. For each segment identified, perform a cyclic shift by selecting appropriate indices l and r and an offset d.\n5. Record each shift operation and keep track of the number of operations performed.\n6. Ensure that the number of operations does not exceed n.\n7. Output the number of operations k and the details of each operation for each test case.\n\n# [edge case]\n    Test Case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already sorted, so no cyclic shifts are needed.\n\n    Test Case 2: [5, 4, 3, 2, 1] = 5\n    Explanation: The array is in reverse order, requiring multiple shifts to sort. One possible solution is to perform a series of shifts to gradually move each element into its correct position.\n\n    Test Case 3: [2, 3, 1] = 2\n    Explanation: A possible solution is to first shift the segment [2, 3] to get [3, 2, 1], then shift [3, 2, 1] to get [1, 2, 3].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over the array and performing cyclic shifts as needed will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases efficiently and provide the number of shifts used. The output format must be strictly followed.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles up to 1000 test cases\n- Optimize for minimal shifts\n- Provide detailed output format\n- Include explanation of cyclic shifts in documentation\nWe will implement a function that sorts an array using cyclic shifts. The function will iterate over the array and perform cyclic shifts to move elements into their correct positions. We will use Python's list slicing to perform the cyclic shifts efficiently. The solution will handle multiple test cases as specified in the input format.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of an array to the left by a specified offset. This operation allows rearranging elements within a specified range without changing the overall size of the array.\n\n    'sort the array'\n    Explanation: The goal is to rearrange the elements of the array in non-decreasing order using cyclic shifts.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means you can use up to n shifts to achieve the sorted order.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Check if the array is already sorted. If it is, output k = 0 and no actions.\n3. If not sorted, perform cyclic shifts:\n   - Identify segments that can be shifted to move elements closer to their correct positions.\n   - Use list slicing to perform left cyclic shifts on identified segments.\n   - Keep track of each shift operation by recording l, r, and d.\n4. Ensure that the number of shifts does not exceed n.\n5. Output the number of shifts k and the details of each shift.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Test case 2: [5, 4, 3, 2, 1] = 5\n    Explanation: The array is in reverse order, requiring multiple shifts to sort. Each element needs to be moved to its correct position.\n\n    Test case 3: [1, 3, 2] = 1\n    Explanation: A single shift of segment [3, 2] by offset 1 will sort the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and performing necessary shifts will handle these cases effectively.\n", "requirement analysis:\nThe requirement is to sort an array using cyclic shifts within a given number of operations. The solution should handle multiple test cases, and the output must adhere to a specific format. The challenge lies in efficiently determining the segments and offsets for the shifts to achieve a sorted array.\nrequirement pool:\n- Implement the cyclic shift operation for array segments.\n- Ensure the solution works for up to 1000 test cases.\n- Optimize the algorithm to perform within n shifts.\n- Handle edge cases such as already sorted arrays.\n- Provide detailed output for each operation performed.\nWe will implement a function that sorts an array using cyclic shifts. The function will iterate over the array, identifying segments that can be shifted to move elements into their correct positions. We will use Python's list slicing to perform the cyclic shifts. The solution will handle multiple test cases and output the number of shifts and the operations performed for each test case. We will ensure the solution is efficient and adheres to the constraints of performing no more than n shifts.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating a segment of the array to the left by a specified offset. This operation allows rearranging elements within a segment without changing the overall length of the array.\n\n    'sort the array'\n    Explanation: The goal is to rearrange the elements of the array in non-decreasing order using cyclic shifts.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts used to sort the array should not exceed the length of the array, n. This means we can perform up to n shifts to achieve the sorted order.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integer n and the array a.\n2. Check if the array is already sorted. If it is, output k = 0 and no operations.\n3. If not sorted, iterate over the array to identify segments that can be shifted to move elements into their correct positions.\n4. Use list slicing to perform cyclic shifts on identified segments.\n5. Keep track of each operation (l, r, d) and ensure the number of operations does not exceed n.\n6. Output the number of operations and the details of each operation for each test case.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: The array is already sorted, so no operations are needed.\n\n    Test case 2: [5, 4, 3, 2, 1] = 5\n    Explanation: The array is in reverse order, requiring multiple shifts to sort. Each element needs to be moved to its correct position.\n\n    Test case 3: [1, 3, 2] = 1\n    Explanation: A single shift of the segment [3, 2] by offset 1 will sort the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the array is already sorted and performing up to n shifts will handle these cases effectively.\n", "requirement analysis:\nThe requirement is to sort an array using cyclic shifts within a given number of operations. The solution should handle multiple test cases and provide a clear output of the operations performed. The constraints allow for flexibility in the number of shifts, as long as it does not exceed n.\nrequirement pool:\n- Implement the cyclic shift algorithm to sort the array.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm to perform within n shifts.\n- Provide detailed output for each test case.\n- Handle edge cases such as already sorted arrays.\nWe will implement a function to perform cyclic shifts on segments of an array to sort it. The approach will utilize Python's list slicing and manipulation capabilities to achieve the desired cyclic shifts. Given the constraints, we will ensure the solution handles up to 1000 test cases efficiently and provides detailed output for each test case. The algorithm will not necessarily be optimized for the minimum number of shifts but will ensure the number of shifts does not exceed n.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cyclic shift'\n    Explanation: A cyclic shift involves rotating elements within a specified segment of an array to the left by a given offset. This operation allows rearranging elements without changing their relative order outside the segment.\n\n    'sort using cyclic shifts'\n    Explanation: The requirement is to sort the array using cyclic shifts, which means rearranging the elements in ascending order by performing cyclic shifts on segments of the array.\n\n# [phrase showing quantity relationship]\n    'no more than n'\n    Explanation: The number of cyclic shifts performed should not exceed the length of the array, n. This ensures that the sorting process is efficient and adheres to the constraints.\n\n# [degree adverb]\n    'arbitrary'\n    Explanation: The indices l and r for selecting segments and the offset d for shifting are arbitrary, meaning they can be chosen freely within the given constraints to achieve the desired sorting.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case, read the length of the array, n, and the array elements.\n3. Check if the array is already sorted. If so, output k = 0.\n4. If not sorted, perform cyclic shifts:\n   - Identify segments that can be shifted to move elements closer to their sorted positions.\n   - Use list slicing to perform cyclic shifts on identified segments.\n   - Keep track of each shift operation with its parameters (l, r, d).\n5. Ensure the number of shifts does not exceed n.\n6. Output the number of shifts and their details for each test case.\n\n# [edge case]\n    Test case with already sorted array:\n    Input: [1, 2, 3, 4]\n    Output: 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Test case with maximum shifts:\n    Input: [4, 3, 2, 1]\n    Output: 4\n    Explanation: Each element needs to be shifted to its correct position, requiring multiple shifts.\n\n    Test case with repeated elements:\n    Input: [2, 2, 1, 1]\n    Output: 2\n    Explanation: The repeated elements need careful handling to ensure correct sorting without unnecessary shifts.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can handle arrays that are already sorted or require maximum shifts by checking if the array is sorted initially and performing necessary shifts within constraints.\n"], "scores": [], "pass_results": [true, true, false, false, false, true, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 866, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "mutate_method": "rephrase_one", "parent_index": 55}
