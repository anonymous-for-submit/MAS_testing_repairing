{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are provided an array a with a length of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are provided an array a with a length of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are provided an array a with a length of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right. The left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). Elements in the left section remain in their original order, maintaining their initial sequence. Meanwhile, the right section also retains the order of its elements as they were before the operation. The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "You are provided an array a with a length of n. Let's define the eversion operation; let x = a_n, then array a is divided into two sections: left and right, where the left section contains the elements of a that are not more than x (\u2264 x), and the right section contains the elements of a that are strictly greater than x (> x). The order of elements in each section remains the same as before the operation, i.e. the partition is stable, and then the array is replaced with the concatenation of the left and the right parts. For example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. We start with the array a and perform eversions on this array and we can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        eversion_count = 0\n        current_array = case\n        \n        while True:\n            last_element = current_array[-1]\n            left_section = [x for x in current_array if x <= last_element]\n            right_section = [x for x in current_array if x > last_element]\n            new_array = left_section + right_section\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\n# Program entry point\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        a = case\n        eversion_count = 0\n        \n        # Perform eversions until the array stops changing\n        while True:\n            x = a[-1]  # Last element of the array\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        max_so_far = float('-inf')\n        eversion_count = 0\n        \n        # Iterate from the end to the beginning of the array\n        for i in range(n - 1, -1, -1):\n            if case[i] > max_so_far:\n                max_so_far = case[i]\n                eversion_count += 1\n        \n        # The number of eversions needed is one less than the number of new maximums found\n        results.append(eversion_count - 1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of test cases, each test case is a list of integers.\n\n    Returns:\n        A list of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            last_element = current_array[-1]\n            left_section = [x for x in current_array if x <= last_element]\n            right_section = [x for x in current_array if x > last_element]\n            new_array = left_section + right_section\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Get results for all test cases\n    results = min_eversions(t, test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            last_element = current_array[-1]\n            left_section = [x for x in current_array if x <= last_element]\n            right_section = [x for x in current_array if x > last_element]\n            new_array = left_section + right_section\n            \n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions needed for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        if n == 0:\n            results.append(0)\n            continue\n        \n        # Initialize the number of eversions\n        eversions = 0\n        # Start with the last element as the pivot\n        x = case[-1]\n        \n        # We will iterate from the end to the start\n        # to determine the number of eversions needed\n        right_section = []\n        \n        for i in range(n - 1, -1, -1):\n            if case[i] > x:\n                right_section.append(case[i])\n            else:\n                # If we encounter an element <= x, it means we need an eversion\n                if right_section:\n                    eversions += 1\n                    # Reset the right section as we have performed an eversion\n                    right_section = []\n                # Update x to the current element\n                x = case[i]\n        \n        results.append(eversions)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        a = case\n        eversion_count = 0\n        \n        # Perform eversion operations until the array stops changing\n        while True:\n            x = a[-1]  # Last element of the array\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    to stabilize the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions\n                   required for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        max_seen = float('-inf')\n        eversion_count = 0\n        \n        # Iterate from the end of the array to the beginning\n        for i in range(n - 1, -1, -1):\n            if case[i] > max_seen:\n                max_seen = case[i]\n                eversion_count += 1\n        \n        # Subtract 1 because the last increment is unnecessary\n        results.append(eversion_count - 1)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    test_cases = []\n    \n    # Read each test case\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        eversion_count = 0\n        while True:\n            x = a[-1]\n            left = [element for element in a if element <= x]\n            right = [element for element in a if element > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case\n    such that the array stops changing.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        k = 0\n        while True:\n            x = a[-1]\n            left = [num for num in a if num <= x]\n            right = [num for num in a if num > x]\n            new_a = left + right\n            \n            if new_a == a:\n                break\n            \n            a = new_a\n            k += 1\n        \n        results.append(k)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of operations required for the array to stabilize. The solution must handle multiple test cases efficiently, with constraints on the size of the array and the number of test cases.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm to handle arrays with up to 200,000 elements.\n- Provide clear and concise output for each test case.\n- Document the code for better understanding and maintenance.\nWe will implement a function that performs the eversion operation on the array until it stabilizes. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. We will use a loop to perform eversions until the array no longer changes, and count the number of eversions required. The approach will be efficient and handle large inputs by leveraging Python's list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced with the concatenation of these sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than the last element of the array.\n\n# [degree adverb]\n    'minimum': We need to find the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. Initialize a counter for the number of eversions.\n    2. Perform the eversion operation:\n        - Identify the last element of the array, x.\n        - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n        - Concatenate the left and right sections to form a new array.\n    3. Check if the new array is different from the previous one.\n    4. If it is different, increment the counter and repeat the process.\n    5. If it is not different, return the counter as the number of eversions.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array.\n    \n    Input: [1, 2, 3, 4, 5] = 1\n    Explanation: After one eversion, the array becomes stable as all elements are less than or equal to the last element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles cases where no eversion changes occur.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of operations required. The solution must handle multiple test cases efficiently, with constraints on the size of the input array and the number of test cases.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm to handle arrays with up to 200,000 elements.\n- Provide clear documentation and comments within the code.\n- Include test cases to validate the solution against edge cases.\nWe will implement a function that performs the eversion operation on the array until it no longer changes. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. We will use a loop to perform eversions until the array remains unchanged, counting the number of eversions required. The solution will handle multiple test cases efficiently by processing each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced with the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than (\u2264)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than (>)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the array.\n2. Initialize a counter for the number of eversions.\n3. Perform the eversion operation:\n   - Identify the last element, x.\n   - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n   - Concatenate the left and right sections to form a new array.\n4. Check if the new array is different from the previous one.\n5. If it is different, increment the counter and repeat the process.\n6. If it is not different, stop and record the counter as the result for that test case.\n7. Output the results for all test cases.\n\n# [edge case]\n    Test case 1: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case 2: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and greater than any possible partition point, so no eversion changes the array.\n\n    Test case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion changes the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic inherently handles arrays that do not change after any eversion.\n", "requirement analysis:\nThe requirements focus on performing a series of operations on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the number of operations needed for stabilization. The solution must handle multiple test cases and large input sizes while ensuring the output format is adhered to.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for performance\n- Provide clear output for each test case\n- Handle edge cases effectively\nWe will implement a function that performs the eversion operation on the array until it stabilizes. The key is to efficiently partition the array into two sections based on the last element and count the number of eversions needed for the array to stop changing. We will iterate over the array from the end to the beginning, keeping track of the maximum element encountered so far. The number of eversions required is equal to the number of times we encounter a new maximum element while iterating from the end.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced with the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than the last element of the array.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. Iterate over the array from the end to the beginning.\n    3. Keep track of the maximum element encountered so far.\n    4. Each time a new maximum is encountered, increment the eversion counter.\n    5. Stop when no new maximum is found during an iteration, indicating stabilization.\n    6. Return the eversion counter.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n    \n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion is needed as the array is already stable.\n    \n    Test case: [1, 2, 3, 4, 5] = 1\n    Explanation: Only one eversion is needed as all elements are less than or equal to the last element except for itself.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking for new maximums during iteration.\n", "requirement analysis:\nThe requirements focus on efficiently partitioning an array based on a defined operation until the array stabilizes. The solution must handle multiple test cases and large datasets, ensuring performance optimization and accurate results.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles multiple test cases\n- Optimize the algorithm for performance\n- Handle edge cases gracefully\n- Provide clear documentation and comments\nWe will implement a function that performs the eversion operation on the array until it stabilizes. The function will iterate over the array, partitioning it into left and right sections based on the last element, and then concatenate these sections. We will use a loop to perform eversions until the array no longer changes, and count the number of eversions required. The solution will handle multiple test cases efficiently by processing each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, while the right section contains elements strictly greater than x. The array is then replaced by the concatenation of these sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for the number of eversions.\n    3. Perform the eversion operation:\n        - Identify the last element, x.\n        - Partition the array into left and right sections based on x.\n        - Concatenate the left and right sections to form a new array.\n    4. Check if the new array is different from the previous one.\n    5. If it is different, increment the counter and repeat the process.\n    6. If it is not different, stop and record the counter value as the result for that test case.\n    7. Output the results for all test cases.\n\n# [edge case]\n    Test case with all elements equal: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion changes the array, so k = 0.\n\n    Test case with strictly increasing order: [1, 2, 3, 4, 5] = 0\n    Explanation: The last element is always greater than all previous ones, so no eversion changes the array, k = 0.\n\n    Test case with strictly decreasing order: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion moves one element to the left section until all are moved, requiring n-1 eversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the number of eversions needed. The solution must handle up to 200,000 elements across multiple test cases, ensuring performance within the given constraints.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation for the code.\n- Include edge case handling and validation.\nWe will implement a function to perform the eversion operation on the array. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. This process will be repeated until the array no longer changes. We will use a simple loop to count the number of eversions required for stabilization. The solution will be optimized for performance by minimizing unnecessary operations and ensuring the algorithm runs efficiently for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, while the right section contains elements strictly greater than x. The array is then replaced by the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than the last element of the array.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. Perform the eversion operation:\n        - Identify the last element of the array, x.\n        - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n        - Concatenate the left and right sections to form a new array.\n    3. Check if the new array is different from the previous one.\n    4. If it is different, increment the counter and repeat the process.\n    5. If it is not different, return the counter as the number of eversions.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n    \n    Test case: [5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion changes the array.\n    \n    Test case: [1, 2, 3, 4, 5] = 1\n    Explanation: After one eversion, the array becomes [1, 2, 3, 4, 5], which does not change further.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the array changes after each eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of eversions on an array until it stabilizes. The key challenge is to efficiently partition the array and determine the number of eversions needed for stabilization. The solution must handle multiple test cases and large input sizes, ensuring performance and clarity in output.\nrequirement pool:\n- Implement the eversion operation efficiently.\n- Ensure the solution handles up to 100 test cases with a total of 200,000 elements.\n- Optimize the code for readability and maintainability.\n- Provide clear and concise output for each test case.\n- Include comments and documentation for better understanding.\nWe will implement a function that performs the eversion operation on the array until it stabilizes. The key is to efficiently partition the array into two sections based on the last element and count the number of eversions needed. We will use a simple loop to perform the eversions and check for stability by comparing the array before and after each eversion. The solution will handle multiple test cases and large input sizes by iterating over each test case and processing the array accordingly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, while the right section contains elements strictly greater than x. The array is then replaced by the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than the last element of the array.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n    1. For each test case, read the array and its length.\n    2. Initialize a counter for eversions.\n    3. Perform the eversion operation:\n        - Identify the last element, x.\n        - Partition the array into left and right sections based on x.\n        - Concatenate the left and right sections to form a new array.\n    4. Check if the new array is identical to the previous one. If so, stop; otherwise, increment the counter and repeat.\n    5. Output the counter as the number of eversions needed for stabilization.\n\n# [edge case]\n    Test case with all elements equal: [1, 1, 1, 1] = 0\n    Explanation: Since all elements are equal, no eversion changes the array, so it stabilizes immediately.\n\n    Test case with descending order: [5, 4, 3, 2, 1] = 4\n    Explanation: Each eversion moves one element to the left section until all elements are in their correct position.\n\n    Test case with ascending order: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already stable as no element needs to be moved.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking for stabilization after each eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of such operations required. The solution must handle multiple test cases efficiently, with constraints on the size of the input array and the number of test cases.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the solution to handle the maximum input size within time limits.\n- Include comments and documentation for code readability.\n- Test the solution against edge cases and large inputs.\nWe will implement a function to perform the eversion operation on an array. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. This process will be repeated until the array no longer changes. We will use a simple loop to count the number of eversions required for stabilization. The solution will handle multiple test cases efficiently by processing each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced with the concatenation of these two sections.\n\n# [phrase showing quantity relationship]\n    'not more than (\u2264)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than (>)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the array and its length.\n2. Initialize a counter for the number of eversions.\n3. Perform the eversion operation:\n   - Identify the last element, x.\n   - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n   - Concatenate the left and right sections to form a new array.\n4. Check if the new array is different from the previous one. If it is, increment the counter and repeat; otherwise, stop.\n5. Output the counter as the result for each test case.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion changes the array.\n\n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and greater than any possible partition point, so no eversion changes the array.\n\n    Test case: [1, 2, 3, 4, 5] = 0\n    Explanation: The array is already sorted in non-decreasing order, so no eversion changes the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic inherently handles arrays that do not change after any eversions by checking if the array remains unchanged after an eversion operation.\n", "requirement analysis:\nThe problem requires determining the minimum number of eversions needed for an array to stabilize. The key is to understand the partitioning process and how it affects the array. The solution must efficiently handle up to 200,000 elements across multiple test cases.\nrequirement pool:\n- Implement the eversion operation correctly.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide detailed comments and documentation for the code.\n- Optimize the solution for edge cases.\n- Include unit tests for the solution.\nWe will implement a function that performs the eversion operation on the array and counts the number of eversions required for the array to stabilize. The key observation is that the array stabilizes when the maximum element is at the end of the array. We will iterate from the end of the array to the beginning, counting how many elements are greater than the current maximum seen so far. This count will give us the number of eversions needed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. Elements less than or equal to x form the left section, and elements greater than x form the right section. The array is then replaced by the concatenation of these sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': Elements in the left section are less than or equal to x.\n    'strictly greater than x (> x)': Elements in the right section are greater than x.\n\n# [degree adverb]\n    'minimum': We need to find the smallest number of eversions required for the array to stabilize.\n\n# [code logic]\n    1. Initialize a counter for eversions.\n    2. Iterate from the end of the array to the beginning.\n    3. Track the maximum element seen so far.\n    4. Count elements that are greater than the current maximum.\n    5. The count gives the number of eversions needed for stabilization.\n\n# [edge case]\n    Test case: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n    \n    Test case: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal and already in a stable state, requiring no eversions.\n    \n    Test case: [10, 9, 8, 7, 6] = 4\n    Explanation: Each element is greater than the last element, requiring multiple eversions until stabilization.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by counting necessary eversions based on the maximum element tracking.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of such operations required. The solution must efficiently handle multiple test cases and large input sizes, ensuring that the sum of all elements across test cases does not exceed 200,000.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm to handle the maximum input size within time limits.\n- Provide clear and concise output for each test case.\n- Document the code for better understanding and maintenance.\nWe will implement a function that performs the eversion operation on the array as described. The function will iterate over the array, partitioning it into two sections based on the last element, and then concatenate these sections. This process will be repeated until the array no longer changes. We will use a simple loop to count the number of eversions required for the array to stabilize. The solution will be efficient enough to handle the maximum constraints by leveraging Python's list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements not greater than x, and the right section contains elements strictly greater than x. The array is then replaced with the concatenation of these sections.\n\n# [phrase showing quantity relationship]\n    'not more than x (\u2264 x)': This indicates that elements in the left section should be less than or equal to the last element of the array.\n    'strictly greater than x (> x)': This indicates that elements in the right section should be greater than the last element of the array.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n    1. Initialize a counter for the number of eversions.\n    2. While the array changes:\n        - Set x as the last element of the array.\n        - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n        - Concatenate left and right sections to form a new array.\n        - Increment the eversion counter.\n    3. Return the eversion counter when the array stops changing.\n\n# [edge case]\n    Input: [1, 1, 1, 1] = 0\n    Explanation: All elements are equal, so no eversion is needed as the array is already stable.\n    \n    Input: [5, 5, 5, 5, 5] = 0\n    Explanation: All elements are equal to the last element, so no eversion is needed as the array is already stable.\n    \n    Input: [1, 2, 3, 4, 5] = 1\n    Explanation: The first eversion will partition into [1, 2, 3, 4, 5], [] and no further eversions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array changes after an eversion.\n", "requirement analysis:\nThe task requires implementing an algorithm that performs a series of stable partition operations on an array until it no longer changes. The challenge is to determine the minimum number of such operations required. The solution must efficiently handle up to 200,000 elements across multiple test cases.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the algorithm to reduce time complexity.\n- Provide clear and concise output for each test case.\n- Document the code for better understanding and maintenance.\nWe will implement a function that performs the eversion operation on the array until it no longer changes. The function will efficiently handle multiple test cases by iterating through the array and partitioning it based on the last element. We will use a simple loop to perform the partition and check if the array has stabilized. The approach will ensure that the solution is efficient and handles large inputs within constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'eversion operation'\n    Explanation: The eversion operation involves partitioning the array into two sections based on the last element, x. The left section contains elements less than or equal to x, and the right section contains elements greater than x. The array is then replaced by the concatenation of these two sections.\n\n    'stops changing'\n    Explanation: The array stops changing when performing an eversion operation results in the same array as before, indicating that further eversions will not alter the array.\n\n# [phrase showing quantity relationship]\n    'not more than (\u2264)': This indicates that elements in the left section should be less than or equal to x.\n    'strictly greater than (>)': This indicates that elements in the right section should be greater than x.\n\n# [degree adverb]\n    'minimum number': This refers to finding the smallest number of eversions required for the array to stop changing.\n\n# [code logic]\n1. For each test case, read the number of elements n and the array a.\n2. Initialize a counter k to track the number of eversions.\n3. Perform the eversion operation:\n   - Identify x as the last element of the array.\n   - Partition the array into two sections: left (elements \u2264 x) and right (elements > x).\n   - Concatenate the left and right sections to form the new array.\n4. Check if the new array is identical to the previous array. If it is, break the loop.\n5. Increment k for each eversion performed.\n6. Output k for each test case.\n\n# [edge case]\n    1. Input: 1 1 1 1 = 0\n       Explanation: All elements are identical, so no eversion is needed as the array is already stable.\n    2. Input: 2 2 2 2 2 = 0\n       Explanation: Similar to the first edge case, all elements are identical, so no eversion is needed.\n    3. Input: 5 4 3 2 1 = 1\n       Explanation: The first eversion will sort the array, and it will not change further.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by checking if the array has stabilized after each eversion.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 577, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "rephrase_one", "parent_index": 327}
