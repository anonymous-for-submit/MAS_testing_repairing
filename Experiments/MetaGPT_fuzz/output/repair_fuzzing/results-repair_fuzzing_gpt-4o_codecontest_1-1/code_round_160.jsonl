{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special as it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special as it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, let's consider the case where n = 4. In this situation, the number 17 is special as it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special as it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Help Theofanis find the k-th special number sorted in increasing order and output it modulo 10^9+7 since this number may be too large.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % n != 0:\n                special_number = (special_number + power) % MOD\n            k //= n\n            power = (power * n) % MOD\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        # Generate the k-th special number using binary representation\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    # Call the function and get results\n    results = find_kth_special_number(t, test_cases)\n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport heapq\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        # Priority queue to store special numbers in increasing order\n        priority_queue = []\n        # Set to track visited numbers to avoid duplicates\n        visited = set()\n        \n        # Start with the smallest special number, which is n^0 = 1\n        heapq.heappush(priority_queue, 1)\n        visited.add(1)\n        \n        # Generate special numbers until we reach the k-th one\n        current_special_number = 0\n        for _ in range(k):\n            current_special_number = heapq.heappop(priority_queue)\n            \n            # Generate new special numbers by adding powers of n\n            power = 1\n            while True:\n                new_special_number = current_special_number + power\n                if new_special_number not in visited:\n                    heapq.heappush(priority_queue, new_special_number)\n                    visited.add(new_special_number)\n                # Break if the new power exceeds the current special number\n                if power > current_special_number:\n                    break\n                power *= n\n        \n        # Append the k-th special number modulo 10^9+7 to the results\n        results.append(current_special_number % MODULO)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        binary_representation = bin(k - 1)[2:]  # Convert k-1 to binary string\n        for i, bit in enumerate(reversed(binary_representation)):\n            if bit == '1':\n                special_number = (special_number + pow(n, i, MOD)) % MOD\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed as a sum\n    of different non-negative powers of n. This function calculates the k-th special\n    number in increasing order for each test case and returns it modulo 10^9+7.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        result = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                result = (result + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(result)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Use a list to store special numbers\n        special_numbers = []\n        \n        # Generate special numbers using binary representation\n        for i in range(k):\n            num = 0\n            power = 0\n            temp = i\n            while temp > 0:\n                if temp % 2 == 1:\n                    num += pow(n, power)\n                temp //= 2\n                power += 1\n            special_numbers.append(num)\n        \n        # Sort the list and find the k-th special number\n        special_numbers.sort()\n        \n        # Append the k-th special number modulo MOD to results\n        results.append(special_numbers[k-1] % MOD)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of n. The k-th special number\n    is the k-th number in the sequence of special numbers when sorted in\n    increasing order.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = calculate_special_number(n, k)\n        results.append(special_number)\n    return results\n\ndef calculate_special_number(n: int, k: int) -> int:\n    \"\"\"Calculates the k-th special number for given n.\n\n    Args:\n        n: The base number for powers.\n        k: The position in the sequence of special numbers.\n\n    Returns:\n        The k-th special number modulo 10^9+7.\n    \"\"\"\n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MODULO\n        power = (power * n) % MODULO\n        k //= 2\n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        test_cases.append((n, k))\n        index += 2\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to compute the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The solution must handle up to 10,000 test cases efficiently and provide results modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and scalability\nWe will use a binary representation approach to efficiently compute the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and scalable for large values of n and k. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n    - Convert k to its base-n representation.\n    - Each digit in the base-n representation corresponds to a power of n that contributes to the special number.\n    - Compute the sum of these powers to get the k-th special number.\n    - Use modular arithmetic to ensure the result is within the range specified by modulo 10^9+7.\n\n# [edge case]\n    For n = 2, k = 1: The smallest special number is 1 (2^0), so the output is 1.\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    For n = 10^9, k = 1: The smallest special number is 1 (10^9^0), so the output is 1.\n    Explanation: Even for very large n, the first special number remains 1.\n\n    For n = 2, k = 10^9: The output should be computed modulo 10^9+7.\n    Explanation: This tests the ability to handle large k values and ensure the result is correctly computed modulo 10^9+7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to base-n and computing the sum of powers inherently handles these cases, including modular arithmetic for large values.\n", "requirement analysis:\nThe problem requires finding the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10^4 test cases and large values of n and k efficiently. The result should be output modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Implement an efficient algorithm to compute the k-th special number.\n- Ensure the solution can handle the maximum constraints of n and k.\n- Optimize the solution for performance to handle up to 10^4 test cases.\n- Implement modulo operation to manage large output values.\n- Provide clear and formatted output as per the requirements.\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and perform modulo operations to ensure the results fit within the required constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over powers of n and checking combinations that sum to the desired number.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating or accessing these numbers, they should be ordered by their value.\n\n# [code logic]\n    - Convert k to its base-n representation.\n    - Each digit in this representation corresponds to a power of n that contributes to the sum forming the special number.\n    - Calculate the sum using these powers.\n    - Apply modulo 10^9+7 to ensure the result fits within constraints.\n    - Repeat for each test case.\n\n# [edge case]\n    For n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number for n = 2 is simply 2^0 = 1.\n\n    For n = 10^9, k = 1\n    Expected output: 1\n    Explanation: Even with a large n, the first special number is always 1 (n^0).\n\n    For n = 2, k = 10^9\n    Expected output: A large number modulo 10^9+7\n    Explanation: The k-th special number for large k will be a large sum of powers of n, but the result should be given modulo 10^9+7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for converting k to base-n and applying modulo operations inherently handles these cases.\n", "requirement analysis:\nThe requirement involves computing the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The solution must handle up to 10,000 test cases efficiently, with n and k values as large as 10^9. The output must be modulo 10^9+7 to ensure it fits within standard integer limits.\nrequirement pool:\n- Implement efficient algorithm to compute special numbers.\n- Ensure solution handles large inputs within constraints.\n- Optimize for performance and scalability.\n- Validate output correctness with modulo operation.\n- Provide clear documentation and examples.\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and scales well with large values of n and k. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure the results fit within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n.\n\n    'modulo 10^9+7'\n    Explanation: The result should be given modulo 10^9+7 to ensure the number is within a manageable range, especially since the k-th special number can be very large.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This indicates that each special number is formed by adding distinct powers of n, such as n^0, n^1, n^2, etc.\n\n# [degree adverb]\n    'increasing order': The sequence of special numbers should be sorted in ascending order.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Convert k to its base-n representation.\n    3. Calculate the k-th special number by summing the distinct powers of n indicated by the base-n representation.\n    4. Return the result modulo 10^9+7.\n\n# [edge case]\n    Test case with smallest values: (n=2, k=1) = 1\n    Explanation: The first special number for n=2 is simply 2^0 = 1.\n\n    Test case with large n and small k: (n=10^9, k=1) = 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Test case with large k: (n=2, k=10^9) = <expected output>\n    Explanation: This tests the efficiency and correctness of the algorithm for large k values. The expected output would be calculated based on the base-n representation of k.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by converting k to its base-n representation and calculating the sum of powers accordingly.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for speed and accuracy\nWe will use a mathematical approach to generate special numbers by considering the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will use Python's built-in capabilities to handle large integers and efficiently compute powers. The solution will iterate over possible combinations of powers of n to find the k-th special number, ensuring results are modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to finding the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over combinations of powers of n and summing them.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating or selecting the k-th special number, the sequence must be ordered.\n\n# [code logic]\n    - Parse the input to get the number of test cases and the values of n and k for each test case.\n    - For each test case, generate special numbers by considering combinations of powers of n.\n    - Use binary representation to efficiently generate sums of distinct powers.\n    - Sort the generated special numbers and select the k-th one.\n    - Return the result modulo 10^9+7.\n\n# [edge case]\n    Case 1: n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number when n = 2 is 2^0 = 1.\n\n    Case 2: n = 2, k = 2\n    Expected output: 2\n    Explanation: The second special number when n = 2 is 2^1 = 2.\n\n    Case 3: n = 3, k = 1\n    Expected output: 1\n    Explanation: The first special number when n = 3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of generating and sorting special numbers will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The solution must handle up to 10,000 test cases efficiently, with n and k values as large as 10^9. The output should be the k-th special number modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and scalability\nWe will use a mathematical approach to generate special numbers efficiently. The key is to understand that each special number can be represented as a sum of distinct powers of n. We can use a binary representation to determine which powers of n to include in the sum. For example, the binary number '101' corresponds to the sum of n^0 and n^2. We will generate these numbers in increasing order and use a priority queue to efficiently find the k-th special number. The modulo operation will be applied to ensure the result fits within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given number n.\n\n    'sequence'\n    Explanation: The sequence refers to the ordered list of special numbers generated from the powers of n.\n\n# [phrase showing quantity relationship]\n    'k-th': Refers to the position in the sequence of special numbers. We need to find the k-th special number in increasing order.\n\n# [degree adverb]\n    'increasing order': Indicates that the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Use a binary representation to determine which powers of n to include in the sum for generating special numbers.\n    3. Generate special numbers using distinct powers of n and store them in a priority queue to maintain increasing order.\n    4. Extract the k-th special number from the priority queue.\n    5. Apply modulo 10^9+7 to the result before outputting it.\n\n# [edge case]\n    Case 1: n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number when n = 2 is 2^0 = 1.\n\n    Case 2: n = 2, k = 2\n    Expected output: 2\n    Explanation: The second special number when n = 2 is 2^1 = 2.\n\n    Case 3: n = 10^9, k = 1\n    Expected output: 1\n    Explanation: The first special number when n is very large is still 1, as it corresponds to n^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using binary representation and priority queue will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are output modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for both time and space complexity\nWe will use a mathematical approach to generate the k-th special number by considering the binary representation of k-1. Each bit in this representation corresponds to a power of n, and if the bit is set, that power is included in the sum. This approach efficiently computes the k-th special number by leveraging the properties of binary numbers and powers of n, ensuring the solution is both time and space efficient. We will use Python's built-in capabilities to handle large integers and modular arithmetic to ensure results are within the required constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest.\n\n# [code logic]\n    1. For each test case, read the integers n and k.\n    2. Convert k-1 to its binary representation.\n    3. Initialize a variable to store the special number.\n    4. Iterate over each bit in the binary representation:\n        - If the bit is set (i.e., 1), add n raised to the power of the bit's position to the special number.\n    5. Compute the result modulo 10^9+7.\n    6. Output the result for each test case.\n\n# [edge case]\n    Case 1: n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Case 2: n = 10^9, k = 1\n    Expected output: 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Case 3: n = 2, k = 10^9\n    Expected output: A large number modulo 10^9+7\n    Explanation: This tests the upper limit of k, ensuring the code handles large values efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these cases by using binary representation and modular arithmetic.\n", "requirement analysis:\nThe task requires finding the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently. The result should be output modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient algorithm to compute special numbers.\n- Handle large input sizes for n and k.\n- Output results modulo 10^9+7.\n- Support multiple test cases in a single run.\n- Optimize for memory usage.\nWe will use a binary representation approach to generate special numbers. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. We will generate numbers in increasing order by iterating over binary numbers and interpreting them as base-n numbers. This approach is efficient for generating the k-th special number directly without generating all previous numbers. We will use Python's built-in capabilities for handling large integers and apply modulo 10^9+7 to manage large outputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This indicates that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater).\n\n# [degree adverb]\n    'increasing order': This means the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n    - Use a binary representation approach to generate special numbers.\n    - Interpret binary numbers as base-n numbers to form special numbers.\n    - Generate numbers in increasing order by iterating over binary numbers.\n    - For each test case, calculate the k-th special number and apply modulo 10^9+7 to manage large outputs.\n\n# [edge case]\n    Edge cases are primarily related to the constraints on n and k:\n    - When n is very large (close to 10^9), ensure that calculations do not exceed time limits.\n    - When k is very large (close to 10^9), ensure that the sequence generation is efficient.\n    \n    Example edge cases:\n    - Input: 1 2 1\n      Output: 1\n      Explanation: The smallest special number for n=2 is 1 (2^0).\n      \n    - Input: 1 10^9 1\n      Output: 1\n      Explanation: The smallest special number for a very large n is still 1 (n^0).\n      \n    - Input: 1 2 10^9\n      Output: A large number modulo 10^9+7\n      Explanation: The sequence generation should efficiently handle large k values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using binary representation and modulo operation should efficiently handle large values of n and k.\n", "requirement analysis:\nThe requirement involves computing the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are provided modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and scalability\nWe will use a mathematical approach to generate special numbers by considering the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will use Python's built-in capabilities to handle large integers and efficiently compute powers. The solution will iterate over possible combinations of powers of n to find the k-th special number.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th smallest special number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Use a loop to generate special numbers by considering the binary representation of numbers.\n3. For each number, convert its binary representation into a sum of distinct powers of n.\n4. Keep track of the special numbers generated and sort them in increasing order.\n5. Find the k-th special number in the sorted list.\n6. Output the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: (A large number modulo 10^9+7)\n    Explanation: This tests the upper limit of k and ensures that the solution can handle large values efficiently.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently due to large values of n and k.\n    \n```python\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n, k):\n    # Use a list to store special numbers\n    special_numbers = []\n    \n    # Generate special numbers using binary representation\n    for i in range(k):\n        num = 0\n        power = 0\n        temp = i\n        while temp > 0:\n            if temp % 2 == 1:\n                num += pow(n, power)\n            temp //= 2\n            power += 1\n        special_numbers.append(num)\n    \n    # Sort the list and find the k-th special number\n    special_numbers.sort()\n    \n    # Return the k-th special number modulo MOD\n    return special_numbers[k-1] % MOD\n\n# Example usage:\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(find_kth_special_number(n, k))\n```\n\nThis code efficiently generates and finds the k-th special number by leveraging binary representation to determine which powers of n to include in each special number.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n efficiently, considering the constraints of large input sizes. The solution must handle up to 10,000 test cases and large values of n and k, ensuring results are computed modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Scalability for large n and k values\n- Optimization for multiple test cases\n- Accurate results modulo 10^9+7\n- User-friendly input and output format\nWe will use a binary representation approach to efficiently compute the k-th special number. The idea is to treat the number k as a binary number and interpret each bit as a power of n. This approach leverages the fact that each special number can be represented as a sum of distinct powers of n, similar to how binary numbers represent sums of powers of 2. This method is efficient and scalable for large values of n and k, and we will use Python's built-in capabilities to handle large integers and modular arithmetic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Convert k to its binary representation.\n3. Interpret each bit in the binary representation as a power of n.\n4. Calculate the sum of these powers to find the k-th special number.\n5. Return the result modulo 10^9+7.\n\n# [edge case]\n    Test case: (n=2, k=1) = 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Test case: (n=2, k=2) = 2\n    Explanation: The second special number for n=2 is 2 (2^1).\n\n    Test case: (n=10^9, k=1) = 1\n    Explanation: Even for large n, the first special number is always 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to binary and interpreting it as powers of n inherently handles these cases.\n", "requirement analysis:\nThe task requires finding the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are computed modulo 10^9+7.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Support multiple test cases\n- Optimize for speed and memory usage\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over powers of n and checking combinations.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating or accessing the sequence, it should be ordered.\n\n# [code logic]\n    - Convert k to its base-n representation.\n    - Each digit in the base-n representation corresponds to a power of n that contributes to the sum forming the special number.\n    - Calculate the sum using these powers.\n    - Return the result modulo 10^9+7.\n\n# [edge case]\n    For edge cases, consider:\n    - Large values of n and k, such as n = 10^9 and k = 10^9.\n    - Small values of n and k, such as n = 2 and k = 1.\n    - Cases where n is a power of 2, which might simplify calculations.\n\n    Example edge cases:\n    - Input: 1 2\n      Output: 2\n      Explanation: For n = 1, the sequence is [1, 2, ...]. The second special number is 2.\n    - Input: 2 1\n      Output: 1\n      Explanation: For n = 2, the sequence starts with [1, ...]. The first special number is 1.\n    - Input: 10^9 10^9\n      Output: (calculated value modulo 10^9+7)\n      Explanation: This tests the upper limits of n and k.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for converting k to its base-n representation and calculating the sum inherently handles large values due to Python's capabilities with large integers and modular arithmetic.\n"], "scores": [], "pass_results": [true, true, true, false, false, false, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 160, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "condense_two2one", "parent_index": 66}
