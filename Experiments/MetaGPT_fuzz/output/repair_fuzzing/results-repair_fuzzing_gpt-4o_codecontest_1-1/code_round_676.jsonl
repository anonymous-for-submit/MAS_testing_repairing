{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, and each has a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nYour task is to implement an algorithm that performs the sorting according to the asc-desc-ending order.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, and each has a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nYour task is to implement an algorithm that performs the sorting according to the asc-desc-ending order.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n. Each book title has a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nYour task is to implement an algorithm that performs the sorting according to the asc-desc-ending order.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, and each has a length of m, and Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nYour task is to implement an algorithm that performs the sorting according to the asc-desc-ending order.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nimport functools\n\ndef asc_desc_sort(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order.\n\n    Args:\n        n: The number of book titles.\n        m: The length of each book title.\n        titles: A list of book titles.\n\n    Returns:\n        A list of indices representing the sorted order of the book titles.\n    \"\"\"\n    \n    def custom_comparator(a: str, b: str) -> int:\n        \"\"\"Compares two strings based on asc-desc-ending order.\n\n        Args:\n            a: The first string to compare.\n            b: The second string to compare.\n\n        Returns:\n            Negative if a < b, zero if a == b, positive if a > b.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if (i + 1) % 2 == 1:  # Odd index (1-based)\n                    return -1 if a[i] < b[i] else 1\n                else:  # Even index (1-based)\n                    return -1 if a[i] > b[i] else 1\n        return 0\n\n    # Sort titles using the custom comparator\n    sorted_titles = sorted(range(n), key=functools.cmp_to_key(lambda i, j: custom_comparator(titles[i], titles[j])))\n    \n    # Return the sorted indices (1-based)\n    return [i + 1 for i in sorted_titles]\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nresult = asc_desc_sort(n, m, titles)\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        odd_chars = title[::2]  # Characters at odd indices (0-based)\n        even_chars = title[1::2]  # Characters at even indices (0-based)\n        return (odd_chars, ''.join(reversed(even_chars)))\n\n    # Create a list of tuples (index, book_title) to preserve original indices\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the indexed books using the custom sort key\n    sorted_books = sorted(indexed_books, key=lambda x: custom_sort_key(x[1]))\n\n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in sorted_books]\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even-indexed characters: descending order\n                key.append(-ord(char))\n            else:\n                # Odd-indexed characters: ascending order\n                key.append(ord(char))\n        return key\n\n    # Sort books using the custom key and return the sorted indices\n    sorted_books = sorted(enumerate(books, start=1), key=lambda x: custom_sort_key(x[1]))\n    sorted_indices = [index for index, _ in sorted_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of books sorted in asc-desc-ending order.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: sort descending, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: sort ascending, use positive ASCII value\n                key.append(ord(char))\n        return key\n\n    # Generate a list of tuples (index, book) to preserve original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the indexed books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order based on character positions.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Generates a custom sort key for a given book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        return tuple(\n            (char if i % 2 == 0 else -ord(char))\n            for i, char in enumerate(title)\n        )\n\n    # Create a list of tuples (index, title) to keep track of original indices\n    indexed_titles = list(enumerate(book_titles, start=1))\n\n    # Sort the indexed titles using the custom sort key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the sorted book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Odd index (0-based), sort ascending\n                key.append(char)\n            else:\n                # Even index (0-based), sort descending\n                key.append(-ord(char))\n        return key\n\n    # Create a list of tuples (index, book_title) to preserve original indices\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the books using the custom sort key\n    sorted_books = sorted(indexed_books, key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in sorted_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the sorted book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        odd_chars = tuple(title[i] for i in range(0, m, 2))\n        even_chars = tuple(title[i] for i in range(1, m, 2))\n        return (odd_chars, tuple(-ord(c) for c in even_chars))\n\n    # Create a list of tuples (index, book title) to preserve original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the indexed books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order.\n\n    Args:\n        n: Number of books.\n        m: Length of each book title.\n        books: List of book titles.\n\n    Returns:\n        List of indices representing the sorted order of book titles.\n    \"\"\"\n    \n    def custom_key(book: str) -> tuple:\n        \"\"\"Generates a sorting key for a book title based on asc-desc-ending order.\n\n        Args:\n            book: Book title.\n\n        Returns:\n            A tuple representing the sorting order for the book title.\n        \"\"\"\n        return tuple(\n            (ord(book[i]) if i % 2 == 1 else -ord(book[i])) for i in range(m)\n        )\n\n    # Pair each book with its original index\n    indexed_books = [(books[i], i + 1) for i in range(n)]\n    \n    # Sort using the custom key\n    indexed_books.sort(key=lambda x: custom_key(x[0]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for _, index in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        # Create a tuple with odd-indexed characters sorted ascending\n        # and even-indexed characters sorted descending\n        odd_chars = tuple(title[i] for i in range(0, m, 2))\n        even_chars = tuple(-ord(title[i]) for i in range(1, m, 2))\n        return odd_chars + even_chars\n\n    # Sort the books using the custom key\n    sorted_books = sorted(range(n), key=lambda i: custom_sort_key(books[i]))\n\n    # Return the sorted indices (1-based)\n    return [index + 1 for index in sorted_books]\n\n# Input and output interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    result = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef asc_desc_ending_sort(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the sorted book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        return tuple(\n            (ord(char) if i % 2 == 0 else -ord(char)) for i, char in enumerate(title)\n        )\n\n    # Create a list of tuples (index, title) to maintain original indices\n    indexed_titles = list(enumerate(book_titles, start=1))\n\n    # Sort the indexed titles using the custom sort key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = asc_desc_ending_sort(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n"], "plans": ["requirement analysis:\nThe requirement is to implement a sorting algorithm that sorts book titles based on a custom lexicographical order. The sorting should consider odd-indexed characters in ascending order and even-indexed characters in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for performance\n- Test the algorithm with various edge cases\n- Document the code for maintainability\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities. The key challenge is to define a custom comparator that handles the asc-desc-ending order efficiently. We will use the functools library to create a comparator function that can be passed to the sorted() function.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Define a custom comparator function that compares two strings based on the asc-desc-ending order:\n       - For each character position, check if it is odd or even.\n       - If odd, compare characters in ascending order.\n       - If even, compare characters in descending order.\n    4. Use Python's sorted() function with the custom comparator to sort the list of book titles.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: The sorting is based on asc-desc-ending order, considering each character position.\n\n    Input: 2 2\n           AA\n           AB\n    Output: 1 2\n    Explanation: The first book title is already lexicographically smaller than the second in asc-desc-ending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a custom comparator will handle all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to implement a sorting algorithm that orders book titles based on a custom lexicographical order. The order is determined by comparing characters at odd positions in ascending order and even positions in descending order. The input size constraint ensures that the solution must be efficient, likely requiring a time complexity of O(n log n) for sorting.\nrequirement pool:\n- Implement the main sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm to handle the maximum input size efficiently.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting function that sorts the book titles based on the specified asc-desc-ending order. The sorting will be done using Python's built-in sorted function with a custom key that considers the odd and even indexed characters as described. This approach ensures an efficient O(n log n) sorting time complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This term refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted normally and even-indexed characters are sorted in reverse.\n        - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At the first position (odd), 'B' comes after 'A', so 'BA' is sorted before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At the first position (odd), 'A' comes before 'B' and 'C', so 'ABC' is first. At the second position (even), 'A' comes after 'B', so 'BAC' is second.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering both odd and even positions as specified.\n", "requirement analysis:\nThe requirement involves sorting book titles based on a unique order that combines ascending and descending lexicographical sorting depending on the character position. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Optimize the algorithm for large input sizes\n- Ensure the output format matches the requirements\n- Test the algorithm with various edge cases\n- Document the code for maintainability\nWe will implement a custom sorting function that sorts the book titles based on the asc-desc-ending order. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending order'\n    Explanation: This is a custom sorting order where characters at odd positions are sorted in ascending order, and characters at even positions are sorted in descending order.\n\n    'odd-indexed' and 'even-indexed'\n    Explanation: Odd-indexed refers to positions 1, 3, 5, etc., while even-indexed refers to positions 2, 4, 6, etc., in the string.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No explicit degree adverb\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the title, if its index is odd, use the character as is for comparison (ascending order).\n   - If its index is even, use the negative of the character's ASCII value for comparison (descending order).\n4. Use Python's `sorted()` function with the custom key to sort the list of titles.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At position 1 (odd), 'A' < 'B', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BCA\n           CAB\n    Output: 1 3 2\n    Explanation: At position 1 (odd), 'A' < 'C', so 'ABC' comes first. At position 2 (even), 'C' > 'A', so 'CAB' comes before 'BCA'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing characters based on their positions and the specified order.\n", "requirement analysis:\nThe task requires implementing a sorting algorithm that combines both ascending and descending lexicographical order based on character positions. The challenge lies in efficiently handling the sorting for potentially large input sizes, given the constraint of n \u22c5 m \u2264 10^6. The solution must ensure that the sorting respects the specified order for odd and even indexed characters.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm to handle large input sizes efficiently.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear and concise output as per the format.\n- Document the code for maintainability and readability.\nWe will implement a custom sorting function that respects the asc-desc-ending order. The function will compare strings based on the specified rules for odd and even indexed characters. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle large input sizes by leveraging Python's efficient sorting algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each pair of strings, compare characters at each index.\n        - If the index is odd, sort based on ascending order.\n        - If the index is even, sort based on descending order.\n    4. Use Python's sorted function with the custom key to sort the list of titles.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At index 0 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           AC\n           AD\n    Output: 3 2 1\n    Explanation: At index 1 (even), 'D' comes before 'C' and 'C' comes before 'B'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing each character according to its index position rules.\n", "requirement analysis:\nThe requirement is to implement a sorting algorithm that sorts book titles based on a custom lexicographical order. The order alternates between ascending and descending based on the position of the character in the string. This requires careful handling of string comparison logic to ensure the correct order is achieved.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Optimize the algorithm for large inputs\n- Ensure the solution handles edge cases like minimum and maximum input sizes\n- Provide clear documentation and comments within the code\n- Develop test cases to validate the sorting logic\nWe will implement a custom sorting algorithm that alternates between ascending and descending order based on the position of characters in the book titles. The algorithm will utilize Python's built-in sorting capabilities with a custom key function to achieve the desired order. Given the constraints, we will ensure the solution is efficient for large inputs by leveraging tuple comparisons.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read each book title into a list.\n    3. Define a custom sorting key function:\n        - For each character in the title, determine if its index is odd or even.\n        - If odd, use the character as is for ascending comparison.\n        - If even, use the negative of the character's ASCII value for descending comparison.\n    4. Sort the list of titles using this custom key function.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: The first position differs, and since it's odd, 'B' comes before 'A' lexicographically.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: The first position is odd, so 'A' comes before 'B' and 'C'. The second position is even, so 'C' comes before 'A' and 'B'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering character positions and their respective sorting orders.\n", "requirement analysis:\nThe task is to implement a sorting algorithm that orders book titles based on a custom lexicographical order. The order is determined by comparing characters at odd positions in ascending order and characters at even positions in descending order. The input size constraint ensures that the solution must be efficient, likely requiring a time complexity of O(n log n) for sorting.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise output as specified in the requirements.\n- Optimize the algorithm for performance.\n- Include comments and documentation for code clarity.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will utilize Python's built-in sorting capabilities with a custom key function to achieve the desired order. Given the constraints, the solution will be efficient with a time complexity of O(n log n).\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to a custom sorting order where odd-indexed characters in the strings are sorted in ascending order, and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of the characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of books (n) and the length of each book title (m).\n2. Read the n book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the string, determine its position (odd or even).\n   - If the position is odd, use the character as is for sorting (ascending).\n   - If the position is even, use the negative of the character's ASCII value for sorting (descending).\n4. Use Python's built-in `sorted()` function with the custom key to sort the list of book titles.\n5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is already sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: For the first character (odd), 'A' comes before 'B', but for the second character (even), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: The first character is odd, so 'A' comes before 'B' and 'C'. The second character is even, so 'C' comes before 'A' and 'B'. The third character is odd, so 'A' comes before 'B' and 'C'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering both odd and even positions as specified.\n", "requirement analysis:\nThe task is to implement a sorting algorithm that orders book titles based on a custom lexicographical order. The order is determined by comparing characters at odd positions in ascending order and characters at even positions in descending order. The input consists of n book titles, each of length m, and the output should be the indices of these titles sorted according to the specified order.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm to handle the maximum constraint efficiently.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle up to 10^6 characters.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n        - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key function.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At position 1 (odd), 'A' comes before 'B', and at position 2 (even), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 3 2 1\n    Explanation: At position 1 (odd), 'C' comes before 'B' and 'A', at position 2 (even), 'A' comes after 'B' and 'C', and at position 3 (odd), 'B' comes before 'C' and 'A'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by comparing characters based on their positions.\n", "requirement analysis:\nThe task requires implementing a sorting algorithm that orders strings based on a custom lexicographical order. The order is determined by comparing characters at odd indices in ascending order and even indices in descending order. The input size constraint ensures that the solution must be efficient, likely requiring a sorting algorithm with a time complexity of O(n log n).\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm to handle the maximum input size efficiently.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting algorithm using Python's built-in sort function with a custom comparator. The comparator will handle the asc-desc-ending order by checking each character's position in the string and comparing them according to the specified rules. This approach leverages Python's efficient sorting capabilities while allowing us to define the custom order logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting in alphabetical order from A to Z.\n    'lexicographically descending': means sorting in reverse alphabetical order from Z to A.\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each book title (m).\n    2. Store each book title in a list along with its original index.\n    3. Define a custom comparator function that:\n       - Compares characters at odd indices in ascending order.\n       - Compares characters at even indices in descending order.\n    4. Use Python's built-in sort function with the custom comparator to sort the list of book titles.\n    5. Extract and print the original indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 3\n           ABC\n           ACB\n    Output: 2 1\n    Explanation: At index 2 (even), 'C' in ACB comes before 'B' in ABC, so ACB is first.\n\n    Input: 3 2\n           AB\n           BA\n           AC\n    Output: 3 1 2\n    Explanation: At index 1 (odd), 'A' in AC comes before 'B' in AB and BA, so AC is first. Then, at index 2 (even), 'B' in AB comes before 'A' in BA.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom comparator logic inherently handles all cases by comparing each character position according to the specified rules.\n", "requirement analysis:\nThe requirement is to implement a sorting algorithm that sorts book titles based on a custom lexicographical order. The order is determined by comparing odd-indexed characters ascendingly and even-indexed characters descendingly. The solution must handle up to 10^6 characters efficiently and output the indices of the sorted titles.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Ensure the solution handles large input sizes efficiently\n- Output the indices of the sorted titles correctly\n- Optimize for performance and memory usage\n- Provide clear documentation and comments in the code\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will handle up to 10^6 characters by leveraging Python's efficient sorting algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n    4. Use Python's sorted function with the custom key to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At the first position, 'B' (from BA) is later than 'A' (from AB), so BA comes first.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 3 2 1\n    Explanation: At the first position, 'C' (from CAB) is later than 'B' (from BAC) and 'A' (from ABC), so CAB comes first. Then BAC comes before ABC because at the second position, 'A' is earlier than 'B'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting using a custom key function will handle all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to implement a sorting algorithm that combines both ascending and descending lexicographical order based on character positions. Odd-indexed characters should be sorted in ascending order, while even-indexed characters should be sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Optimize for performance to handle large inputs\n- Ensure the output format matches the requirements\n- Test the algorithm with various edge cases\n- Document the code for maintainability\nWe will implement a custom sorting function that handles the asc-desc-ending order by comparing characters at odd and even indices according to the specified rules. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. The solution will be optimized to handle large inputs by leveraging tuple comparisons and efficient string operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Define a custom sorting key function:\n        - For each book title, create a tuple where each character is transformed based on its index:\n            - If the index is odd, use the character as is (for ascending order).\n            - If the index is even, use the negative ASCII value of the character (for descending order).\n    4. Sort the list of book titles using this custom key function.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: Sorting by asc-desc-ending order results in ABC first, followed by CAB, then BAC.\n\n    Input: 2 2\n           AA\n           AB\n    Output: 2 1\n    Explanation: At the first position where they differ (second character), AB comes before AA because B is later than A in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases by using a custom sorting key that accounts for both odd and even positions.\n"], "scores": [], "pass_results": [false, true, false, true, false, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 676, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "add_1_sentence_at_end", "parent_index": 303}
