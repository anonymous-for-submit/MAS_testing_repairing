{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon, guaranteeing triumph while using resources sparingly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon, guaranteeing triumph while using resources sparingly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon. He is dedicated to ensuring triumph while using resources sparingly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon, guaranteeing triumph while using resources sparingly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_minimum_poison_impact(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp deals at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attacks (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = calculate_minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_impact(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of tuples containing n, h, and attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = minimum_poison_impact(t, test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_impact(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison impact 'k' for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing (n, h, attack_times).\n\n    Returns:\n        List[int]: List of minimum 'k' values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate cumulative damage for current 'mid' value\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on cumulative damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_impact(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to ensure at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, a[i + 1] - a[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_impact(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp will cause at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if can_cause_damage(n, h, attack_times, mid):\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n\n    return results\n\ndef can_cause_damage(n: int, h: int, attack_times: List[int], k: int) -> bool:\n    \"\"\"Check if a given k can cause at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage.\n        attack_times (List[int]): List of attack times.\n        k (int): Current value of k being tested.\n\n    Returns:\n        bool: True if k can cause at least h damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attack_times[i + 1] - attack_times[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output interface\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp will cause at least h damage to the dragon.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): A list of tuples, each containing:\n            - n (int): The number of Monocarp's attacks.\n            - h (int): The amount of damage that needs to be dealt.\n            - a (List[int]): A list of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: A list of integers representing the minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage with current k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, a[i + 1] - a[i])\n            total_damage += mid  # Add damage for the last attack\n\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output interface\n    results = calculate_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef minimum_poison_impact(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    def calculate_damage(k: int, attacks: List[int]) -> int:\n        \"\"\"Calculate the total damage dealt with a given k.\n\n        Args:\n            k (int): The poison impact value.\n            attacks (List[int]): List of attack times.\n\n        Returns:\n            int: Total damage dealt.\n        \"\"\"\n        total_damage = 0\n        n = len(attacks)\n        for i in range(n - 1):\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n        total_damage += k  # Add damage for the last attack\n        return total_damage\n\n    results = []\n    for n, h, attacks in test_cases:\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(mid, attacks) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_impact(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp's attacks deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing n, h, and a list of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is at least h\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input and output interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to ensure Monocarp deals at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attacks (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search to find the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = calculate_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_impact(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp will cause at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing n, h, and a list of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, attacks[i + 1] - attacks[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Check if the total damage is at least h\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat a dragon using efficient resource management. The solution must handle multiple test cases and large input values, ensuring quick and accurate results.\nrequirement pool:\n- Calculate minimum poison impact for each test case.\n- Ensure solution handles large input values efficiently.\n- Provide clear understanding of damage calculation process.\n- Optimize resource usage for guaranteed triumph.\n- Allow input of multiple test cases for strategy planning.\nWe will use a binary search algorithm to efficiently find the minimum value of k that ensures Monocarp deals at least h damage to the dragon. This approach is suitable given the constraints and large input values, as it reduces the complexity of the problem significantly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures Monocarp deals at least h damage to the dragon efficiently.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the minimum k) to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means that the total damage dealt must be greater than or equal to h.\n    Implementation: Ensure the sum of damage over time is >= h.\n\n# [degree adverb]\n    'minimum': means finding the smallest possible value of k that satisfies the condition.\n    Implementation: Use binary search to find the smallest k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n and h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., 1 to max possible value).\n        - Calculate damage for a given k and check if it meets or exceeds h.\n        - Adjust bounds based on whether the current k is sufficient or not.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values: \n    Input: 1 1\n           1\n    Expected output: 1\n    Explanation: With only one attack needed and one damage required, k=1 is sufficient.\n\n    Test case with maximum h:\n    Input: 1 1000000000000000000\n           1\n    Expected output: 1000000000000000000\n    Explanation: With only one attack time, k must be equal to h to meet the requirement.\n\n    Test case with attacks at maximum intervals:\n    Input: 2 10\n           1 1000000000\n    Expected output: 5\n    Explanation: The attacks are far apart, requiring a larger k to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat the dragon efficiently. The solution must handle multiple test cases and ensure that the attacks are timed optimally to achieve the desired damage with minimal resources.\nrequirement pool:\n- Calculate minimum poison impact for each test case.\n- Ensure attacks are timed optimally.\n- Handle large input values efficiently.\n- Provide accurate results for all test cases.\n- Optimize resource usage while achieving victory.\nWe will use a binary search algorithm to efficiently determine the minimum value of the parameter k. The binary search will help us find the smallest k such that the total damage dealt is at least h. This approach is efficient and suitable for handling the large input constraints provided in the problem.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures the total damage dealt to the dragon is at least h.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources, which in this context means finding the smallest k.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented using a condition like `total_damage >= h`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This indicates that we need to find the smallest possible value of k that satisfies the condition. In code, this is typically achieved using a binary search to efficiently find the minimum value.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read integers n and h.\n   - Read the list of attack times.\n3. Implement a binary search to find the minimum k:\n   - Initialize low and high bounds for k.\n   - While low is less than or equal to high:\n     - Calculate mid as the average of low and high.\n     - Calculate total damage for k = mid.\n     - If total damage is at least h, update high to mid - 1.\n     - Otherwise, update low to mid + 1.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case 1: (n=1, h=1, a=[1]) = 1\n    Explanation: With only one attack needed and h=1, the minimum k is 1.\n\n    Test case 2: (n=2, h=10^18, a=[1, 10^9]) = 10^18\n    Explanation: With a very large h and only two attacks far apart, k must be very large to accumulate enough damage.\n\n    Test case 3: (n=100, h=100, a=[1, 2, ..., 100]) = 1\n    Explanation: With attacks every second and h=100, k=1 is sufficient as each attack contributes exactly 1 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the bounds based on the total damage calculation.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat the dragon efficiently. The solution must handle multiple test cases and ensure that the damage dealt meets or exceeds the required amount using the least resources.\nrequirement pool:\n- Calculate minimum poison impact for each test case.\n- Ensure damage meets or exceeds the required amount.\n- Optimize resource usage during attacks.\n- Handle up to 1000 test cases efficiently.\n- Provide clear output format for results.\nWe will use a binary search approach to efficiently determine the minimum poison impact 'k' needed to deal at least 'h' damage to the dragon. The binary search will help us find the smallest 'k' that satisfies the condition by checking the cumulative damage over the attack intervals. This approach is efficient and suitable for handling up to 1000 test cases with large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of 'k' that will ensure Monocarp deals at least 'h' damage to the dragon.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the smallest 'k') to achieve the goal.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to 'h'. In code, this can be implemented by checking if the cumulative damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of 'k' that satisfies the condition of dealing at least 'h' damage. This can be implemented using a binary search to efficiently find the minimum value.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read the values of n and h, and the list of attack times.\n    3. Implement a binary search to find the minimum 'k':\n        - Set initial bounds for 'k'.\n        - Calculate the cumulative damage for a given 'k'.\n        - Adjust the bounds based on whether the damage is sufficient.\n    4. Output the minimum 'k' for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack needed and one damage required, k=1 is sufficient.\n\n    Test case with maximum h:\n    1 10^18\n    1\n    Expected output: 10^18\n    Explanation: With only one attack time, k must be equal to h to deal the required damage.\n\n    Test case with attacks spaced far apart:\n    2 10\n    1 1000000000\n    Expected output: 10\n    Explanation: The attacks are spaced far apart, so k must be equal to h to ensure enough damage is dealt.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting the bounds based on cumulative damage calculations.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat the dragon efficiently. The solution must handle multiple test cases and ensure that the attacks are timed optimally to achieve the desired damage.\nrequirement pool:\n- Calculate minimum poison impact (k) for each test case.\n- Ensure attacks are timed optimally.\n- Handle up to 1000 test cases efficiently.\n- Output the correct minimum value of k for each test case.\n- Optimize resource usage in calculations.\nWe will use a binary search algorithm to efficiently determine the minimum value of k for each test case. The binary search will help us find the optimal k by checking if the total damage dealt with a given k is at least h. This approach ensures that we handle up to 1000 test cases efficiently and optimize resource usage.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that will ensure the total damage dealt is at least h.\n\n    'efficiently conquer the dragon'\n    Explanation: This implies using the least amount of resources (in this case, the minimum k) to achieve the desired outcome (at least h damage).\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the array of attack times.\n   - Use binary search to find the minimum k:\n     - Set low = 1 and high = h (or a large enough value).\n     - While low < high:\n       - Calculate mid = (low + high) // 2.\n       - Calculate total damage with current mid as k.\n       - If total damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n   - Output the value of low as the minimum k for that test case.\n\n# [edge case]\n    Test Case 1: n = 1, h = 1, a = [1] => Expected Output: 1\n    Explanation: With only one attack needed and h = 1, the minimum k is 1.\n\n    Test Case 2: n = 2, h = 1000000000, a = [1, 1000000000] => Expected Output: 500000000\n    Explanation: The attacks are spaced far apart, so k must be large enough to cover the gap.\n\n    Test Case 3: n = 100, h = 100, a = [1, 2, ..., 100] => Expected Output: 1\n    Explanation: With attacks every second and h = 100, k can be as small as 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the spacing of attacks and required damage.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat the dragon efficiently. The solution must handle multiple test cases and ensure that the damage dealt meets or exceeds the required amount using the least resources possible.\nrequirement pool:\n- Calculate minimum poison impact for each test case.\n- Ensure damage meets or exceeds required amount.\n- Optimize resource usage.\n- Handle up to 1000 test cases efficiently.\n- Provide detailed damage analysis.\nWe will use a binary search algorithm to efficiently find the minimum value of the parameter k that ensures Monocarp will cause at least h damage to the dragon. This approach is suitable given the constraints and will handle up to 1000 test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of the parameter k that ensures Monocarp will cause at least h damage to the dragon.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the smallest k) to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage caused by Monocarp's attacks must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of causing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Use binary search to find the minimum k:\n     - Set low = 1 and high = h (or a large enough value).\n     - While low < high:\n       - Calculate mid = (low + high) // 2.\n       - Calculate the total damage with k = mid.\n       - If total damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n   - Output the value of low as the minimum k.\n\n# [edge case]\n    Test case 1: (1, 1, [1]) = 1\n    Explanation: With only one attack needed and one damage required, k=1 is sufficient.\n\n    Test case 2: (2, 10^18, [1, 10^9]) = 10^18\n    Explanation: With a very large h and only two attacks, k must be very large to accumulate enough damage.\n\n    Test case 3: (100, 1000, [1, 2, ..., 100]) = 10\n    Explanation: With many attacks and a moderate h, a smaller k can be sufficient.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k until the condition is met.\n", "requirement analysis:\nThe requirement is to determine the minimum value of parameter k such that Monocarp's attacks cause at least h damage to the dragon. The solution should efficiently handle up to 1000 test cases, with each test case involving up to 100 attacks and a damage requirement as high as 10^18. The attacks are performed at increasing time intervals, and the solution must calculate the optimal k for each scenario.\nrequirement pool:\n- Calculate minimum k for each test case to achieve at least h damage.\n- Handle up to 1000 test cases efficiently.\n- Ensure the solution is optimized for large values of h.\n- Provide clear and concise output for each test case.\n- Consider edge cases where n is minimal or maximal.\nWe will use a binary search algorithm to efficiently determine the minimum value of k for each test case. This approach is suitable given the constraints, as it allows us to handle large values of h and multiple test cases efficiently. The binary search will be applied over the possible values of k, checking if the total damage meets or exceeds h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of the parameter k that ensures Monocarp deals at least h damage to the dragon.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the smallest k) to achieve the goal.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage caused by Monocarp's attacks must be greater than or equal to h. In code, this can be implemented by checking if the calculated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of causing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n and h, and then the list of attack times.\n    3. Use binary search to find the minimum k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - Calculate the total damage for a given k.\n        - Adjust bounds based on whether the damage is sufficient.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with n = 1 and h = 1, a_1 = 1\n    Expected output: 1\n    Explanation: With only one attack needed and h = 1, k must be at least 1 to deal the required damage.\n\n    Test case with n = 100 and h = 10^18, a_i = i for i in range(1, 101)\n    Expected output: A large number close to 10^18/100\n    Explanation: The attacks are spaced evenly, requiring a large k to accumulate enough damage.\n\n    Test case with n = 2 and h = 10^9, a_1 = 1, a_2 = 10^9\n    Expected output: 10^9\n    Explanation: The second attack is far apart, requiring k to be at least as large as the gap to deal sufficient damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on calculated damage.\n", "requirement analysis:\nThe requirements focus on calculating the minimum parameter k to ensure Monocarp's attacks deal at least h damage to the dragon. The solution must handle multiple test cases efficiently and output the correct minimum k for each case.\nrequirement pool:\n- Calculate minimum k for each test case\n- Handle up to 1000 test cases efficiently\n- Ensure output format is correct\n- Optimize algorithm for large values of h\n- Validate input constraints\nWe will use a binary search algorithm to efficiently determine the minimum value of k. The binary search will be applied on the range of possible k values, and for each k, we will simulate the damage dealt to the dragon to check if it meets or exceeds the required damage h. This approach is efficient and suitable for handling the large constraints given in the problem.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that will ensure the total damage dealt to the dragon is at least h.\n\n    'efficiently conquer the dragon'\n    Explanation: This implies using the least amount of resources (in this case, the smallest k) to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Use binary search to find the minimum k:\n     - Set low = 1 and high = h (or a large enough value).\n     - While low < high:\n       - Calculate mid = (low + high) // 2.\n       - Simulate the damage dealt with k = mid.\n       - If the damage is at least h, set high = mid.\n       - Otherwise, set low = mid + 1.\n   - Output the value of low as the minimum k.\n\n# [edge case]\n    Test case 1: (1, 1, [1]) = 1\n    Explanation: With only one attack needed and one second, k=1 is sufficient to deal at least 1 damage.\n\n    Test case 2: (2, 10^18, [1, 10^9]) = 10^18\n    Explanation: The damage required is extremely high, so k must be at least 10^18 to ensure enough damage is dealt.\n\n    Test case 3: (3, 5, [1, 2, 3]) = 2\n    Explanation: With attacks at seconds 1, 2, and 3, k=2 is sufficient to deal at least 5 damage over these intervals.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the range of k values based on the damage calculation.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat a dragon using efficient resource management. The solution should handle multiple test cases and provide quick results for each case.\nrequirement pool:\n- Calculate minimum poison impact for each test case\n- Handle up to 1000 test cases efficiently\n- Ensure quick processing and output\n- Optimize resource usage in calculations\n- Provide user-friendly input and output format\nWe will use a binary search approach to efficiently determine the minimum value of the parameter k. The binary search will help us find the smallest k such that the total damage dealt is at least h. This approach is efficient and suitable for handling up to 1000 test cases as required.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures Monocarp's attacks deal at least h damage to the dragon.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the smallest k) to achieve the goal.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt by Monocarp's attacks must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n and h, and then read the attack times.\n    3. Use binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - While low is less than or equal to high:\n            - Calculate mid as the average of low and high.\n            - Simulate the damage dealt with k = mid.\n            - If the damage is at least h, update high to mid - 1.\n            - Otherwise, update low to mid + 1.\n    4. Output the minimum k found for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack needed and one damage required, k = 1 is sufficient.\n\n    Test case with maximum h:\n    1 10^18\n    1\n    Expected output: 10^18\n    Explanation: With only one attack time, k must be equal to h to deal the required damage.\n\n    Test case with increasing attack times:\n    3 6\n    1 2 3\n    Expected output: 2\n    Explanation: With k = 2, damage is dealt in seconds [1, 2, 3, 4, 5], which is sufficient.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by efficiently finding the minimum k that satisfies the condition for each test case.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat a dragon using efficient resource management. The solution should handle multiple test cases and provide the minimum parameter k for each scenario.\nrequirement pool:\n- Calculate minimum poison impact for each test case.\n- Ensure solution handles up to 1000 test cases efficiently.\n- Optimize algorithm for large values of h up to 10^{18}.\n- Provide clear output format for each test case.\n- Consider edge cases where n is minimal or maximal.\nWe will use a binary search algorithm to efficiently determine the minimum value of k that ensures Monocarp deals at least h damage to the dragon. This approach is suitable given the constraints, as it allows us to handle large values of h and multiple test cases efficiently. We will iterate over each test case, calculate the damage for different values of k, and use binary search to find the minimum k that satisfies the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures Monocarp deals at least h damage to the dragon efficiently.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the minimum k) to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the calculated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n and h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., low = 1, high = h).\n        - Calculate the total damage for a given k.\n        - Adjust bounds based on whether the damage is sufficient.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with n = 1 and h = 1, a_1 = 1\n    Expected output: 1\n    Explanation: With only one attack needed and minimum damage required, k = 1 is sufficient.\n\n    Test case with n = 100 and h = 10^18, a_i = i for i in range(1, 101)\n    Expected output: A large value close to h/n\n    Explanation: The large h requires a significant k to ensure enough damage over many attacks.\n\n    Test case with n = 2 and h = 10, a_1 = 1, a_2 = 1000000000\n    Expected output: 5\n    Explanation: The large gap between attacks means k must be large enough to cover the gap and deal sufficient damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying values of n and h efficiently.\n", "requirement analysis:\nThe main requirement is to calculate the minimum value of parameter k such that Monocarp will cause at least h damage to the dragon. The solution must handle up to 1000 test cases efficiently, with each test case involving up to 100 attacks and damage requirements as high as 10^18. The input and output format must be strictly followed to ensure compatibility with automated testing.\nrequirement pool:\n- Calculate minimum k for each test case to ensure at least h damage.\n- Handle up to 1000 test cases efficiently.\n- Ensure the solution can handle large numbers up to 10^18.\n- Provide clear and concise output for each test case.\n- Include example scenarios to aid user understanding.\nWe will implement a function to determine the minimum value of parameter k such that Monocarp will cause at least h damage to the dragon. The approach involves using binary search to efficiently find the minimum k, as the problem constraints allow for large numbers and multiple test cases. We will utilize Python's built-in capabilities to handle large integers and ensure the solution is optimized for performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that will ensure Monocarp deals at least h damage to the dragon.\n\n    'efficiently conquer the dragon'\n    Explanation: This implies using the least amount of resources (in this case, the smallest k) to achieve the goal of dealing at least h damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage dealt must be greater than or equal to h. In code, this can be implemented as a condition where the sum of damages is checked to be >= h.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Use binary search to find the minimum k:\n     - Initialize low and high bounds for k.\n     - While low is less than high:\n       - Calculate mid as the average of low and high.\n       - Calculate total damage for k = mid.\n       - If total damage is at least h, set high = mid.\n       - Otherwise, set low = mid + 1.\n   - Output the found minimum k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, attack times = [1]\n    Expected output: 1\n    Explanation: With only one attack needed and h = 1, k must be at least 1 to deal the required damage.\n\n    Case 2: n = 100, h = 10^18, attack times = [1, 2, ..., 100]\n    Expected output: A large number close to h/n\n    Explanation: The large value of h requires a correspondingly large k to ensure enough damage is dealt.\n\n    Case 3: n = 2, h = 10^9, attack times = [1, 10^9]\n    Expected output: 10^9\n    Explanation: The large gap between attacks means k must be at least as large as the gap to ensure enough damage is dealt.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 351, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "rephrase_one", "parent_index": 234}
