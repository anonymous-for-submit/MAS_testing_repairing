{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. There are n - 1 tunnels connecting them. It is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. There are n - 1 tunnels connecting them. It is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. There are n - 1 tunnels connecting them. It is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel. The tunnel should be between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n, and there are n - 1 tunnels connecting them. It is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy, where |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Build the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Update the value at index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum from left to right.\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left <= right:\n            if left % 2 == 1:\n                result += self.tree[left]\n                left += 1\n            if right % 2 == 0:\n                result += self.tree[right]\n                right -= 1\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], current: int, parent: int, path: List[int]):\n    \"\"\"Depth First Search to find path from root to node.\"\"\"\n    path.append(current)\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            dfs(tree, neighbor, current, path)\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    tree = [[] for _ in range(n)]\n    for s, t in tunnels:\n        tree[s - 1].append(t - 1)\n        tree[t - 1].append(s - 1)\n    \n    path_u = []\n    path_v = []\n    dfs(tree, u - 1, -1, path_u)\n    dfs(tree, v - 1, -1, path_v)\n    \n    # Find the common ancestor\n    i = 0\n    while i < min(len(path_u), len(path_v)) and path_u[i] == path_v[i]:\n        i += 1\n    \n    # Calculate energy\n    energy = 0\n    for j in range(i, len(path_u)):\n        energy += max(abs(illusion_rates[path_u[j]] + illusion_rates[path_u[j - 1]]),\n                      abs(illusion_rates[path_u[j]] - illusion_rates[path_u[j - 1]]))\n    for j in range(i, len(path_v)):\n        energy += max(abs(illusion_rates[path_v[j]] + illusion_rates[path_v[j - 1]]),\n                      abs(illusion_rates[path_v[j]] - illusion_rates[path_v[j - 1]]))\n    \n    return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(200000)\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    if u == v:\n        return 0\n\n    # Build adjacency list for the tree\n    adj_list = defaultdict(list)\n    for s, t in tunnels:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n\n    # BFS to find the path from u to v\n    def bfs(start: int, end: int) -> List[int]:\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in adj_list[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Reconstruct path from u to v\n        path = []\n        step = end\n        while step is not None:\n            path.append(step)\n            step = parent[step]\n        path.reverse()\n        return path\n\n    path = bfs(u, v)\n    \n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        a_x, a_y = illusion_rates[x - 1], illusion_rates[y - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    # Read input\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\n\nclass SegmentTree:\n    \"\"\"Segment Tree for efficiently handling updates and queries on illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at the given index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], adjacency_list: Dict[int, List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    path = find_path(u, v, adjacency_list)\n    \n    energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    \n    return energy\n\ndef find_path(u: int, v: int, adjacency_list: Dict[int, List[int]]) -> List[int]:\n    \"\"\"Finds a path from room u to room v using DFS.\"\"\"\n    stack = [(u, [u])]\n    visited = set()\n    \n    while stack:\n        current, path = stack.pop()\n        if current == v:\n            return path\n        visited.add(current)\n        for neighbor in adjacency_list[current]:\n            if neighbor not in visited:\n                stack.append((neighbor, path + [neighbor]))\n    \n    return []  # Should not reach here if the tree is correctly formed\n\ndef build_adjacency_list(tunnels: List[Tuple[int, int]], n: int) -> Dict[int, List[int]]:\n    \"\"\"Builds an adjacency list from the tunnel connections.\"\"\"\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    return adjacency_list\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    adjacency_list = build_adjacency_list(tunnels, n)\n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels, adjacency_list)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    \"\"\"Class to represent the tree structure and handle LCA queries.\"\"\"\n    \n    def __init__(self, n: int, tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.tree = [[] for _ in range(n)]\n        self.parent = [-1] * n\n        self.depth = [0] * n\n        self.build_tree(tunnels)\n        self.preprocess_lca()\n    \n    def build_tree(self, tunnels: List[Tuple[int, int]]):\n        \"\"\"Builds the tree from the given tunnels.\"\"\"\n        for s, t in tunnels:\n            self.tree[s - 1].append(t - 1)\n            self.tree[t - 1].append(s - 1)\n    \n    def preprocess_lca(self):\n        \"\"\"Preprocesses the tree for LCA queries using DFS.\"\"\"\n        self.dfs(0, -1, 0)\n    \n    def dfs(self, node: int, par: int, dep: int):\n        \"\"\"Performs DFS to set parent and depth for each node.\"\"\"\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.tree[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n    \n    def lca(self, u: int, v: int) -> int:\n        \"\"\"Finds the lowest common ancestor of nodes u and v.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Updates the illusion rate of the u-th room.\"\"\"\n    illusion_rates[u - 1] = c\n\ndef minimum_energy(illusion_rates: List[int], tree: Tree, u: int, v: int) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    u -= 1\n    v -= 1\n    lca_node = tree.lca(u, v)\n    \n    def calculate_energy(x: int, y: int) -> int:\n        \"\"\"Calculates the energy between two rooms.\"\"\"\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    # Calculate energy from u to LCA\n    energy = 0\n    current = u\n    while current != lca_node:\n        energy += calculate_energy(current, tree.parent[current])\n        current = tree.parent[current]\n    \n    # Calculate energy from v to LCA\n    current = v\n    while current != lca_node:\n        energy += calculate_energy(current, tree.parent[current])\n        current = tree.parent[current]\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    tree = Tree(n, tunnels)\n    \n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(illusion_rates, u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = minimum_energy(illusion_rates, tree, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nclass Maze:\n    def __init__(self, n, illusion_rates, tunnels):\n        \"\"\"Initialize the maze with rooms, illusion rates, and tunnels.\n\n        Args:\n            n (int): Number of rooms.\n            illusion_rates (List[int]): Initial illusion rates for each room.\n            tunnels (List[Tuple[int, int]]): Tunnel connections between rooms.\n        \"\"\"\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adjacency_list = [[] for _ in range(n + 1)]\n        for s, t in tunnels:\n            self.adjacency_list[s].append(t)\n            self.adjacency_list[t].append(s)\n        self.segment_tree = SegmentTree(illusion_rates)\n\n    def update_illusion_rate(self, room, new_rate):\n        \"\"\"Update the illusion rate of a specific room.\n\n        Args:\n            room (int): Room number to update.\n            new_rate (int): New illusion rate for the room.\n        \"\"\"\n        self.segment_tree.update(room, new_rate)\n\n    def calculate_min_energy(self, u, v):\n        \"\"\"Calculate the minimum energy required to move from room u to room v.\n\n        Args:\n            u (int): Starting room.\n            v (int): Destination room.\n\n        Returns:\n            int: Minimum energy required.\n        \"\"\"\n        path = self.find_path(u, v)\n        energy = 0\n        for i in range(len(path) - 1):\n            a_x = self.segment_tree.query(path[i])\n            a_y = self.segment_tree.query(path[i + 1])\n            energy += max(abs(a_x + a_y), abs(a_x - a_y))\n        return energy\n\n    def find_path(self, start, end):\n        \"\"\"Find the path from start room to end room using DFS.\n\n        Args:\n            start (int): Starting room.\n            end (int): Destination room.\n\n        Returns:\n            List[int]: Path from start to end.\n        \"\"\"\n        visited = [False] * (self.n + 1)\n        path = []\n\n        def dfs(current):\n            if current == end:\n                return True\n            visited[current] = True\n            path.append(current)\n            for neighbor in self.adjacency_list[current]:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n            path.pop()\n            return False\n\n        dfs(start)\n        return path\n\n\nclass SegmentTree:\n    def __init__(self, data):\n        \"\"\"Initialize the segment tree with data.\n\n        Args:\n            data (List[int]): Initial data for the segment tree.\n        \"\"\"\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data):\n        \"\"\"Build the segment tree.\n\n        Args:\n            data (List[int]): Data to build the tree.\n        \"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, index, value):\n        \"\"\"Update the value at a specific index.\n\n        Args:\n            index (int): Index to update.\n            value (int): New value.\n        \"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n\n    def query(self, index):\n        \"\"\"Query the value at a specific index.\n\n        Args:\n            index (int): Index to query.\n\n        Returns:\n            int: Value at the index.\n        \"\"\"\n        return self.tree[index + self.n]\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    illusion_rates = list(map(int, data[2:n+2]))\n    tunnels = [tuple(map(int, data[i:i+2])) for i in range(n+2, n+2+(n-1)*2, 2)]\n    queries = data[n+2+(n-1)*2:]\n    \n    maze = Maze(n, illusion_rates, tunnels)\n    \n    index = 0\n    while index < len(queries):\n        query_type = int(queries[index])\n        if query_type == 1:\n            room = int(queries[index + 1])\n            new_rate = int(queries[index + 2])\n            maze.update_illusion_rate(room, new_rate)\n            index += 3\n        elif query_type == 2:\n            u = int(queries[index + 1])\n            v = int(queries[index + 2])\n            result = maze.calculate_min_energy(u, v)\n            print(result)\n            index += 3\n\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict, deque\n\nclass SegmentTree:\n    \"\"\"Segment Tree for efficient updates and queries.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        \"\"\"Build the segment tree from the initial data.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, index: int, value: int):\n        \"\"\"Update the value at a specific index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n\n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    path = find_path(u, v, tunnels)\n    energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    return energy\n\ndef find_path(u: int, v: int, tunnels: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the path between two nodes in a tree using BFS.\"\"\"\n    graph = defaultdict(list)\n    for s, t in tunnels:\n        graph[s].append(t)\n        graph[t].append(s)\n\n    parent = {u: None}\n    queue = deque([u])\n    while queue:\n        node = queue.popleft()\n        if node == v:\n            break\n        for neighbor in graph[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                queue.append(neighbor)\n\n    path = []\n    while v is not None:\n        path.append(v)\n        v = parent[v]\n    path.reverse()\n    return path\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    segment_tree = SegmentTree(illusion_rates)\n\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_minimum_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tunnels = tunnels\n        self.adjacency_list = self._build_adjacency_list()\n        self.segment_tree = SegmentTree(illusion_rates)\n    \n    def _build_adjacency_list(self) -> List[List[int]]:\n        adjacency_list = [[] for _ in range(self.n + 1)]\n        for u, v in self.tunnels:\n            adjacency_list[u].append(v)\n            adjacency_list[v].append(u)\n        return adjacency_list\n    \n    def update_illusion_rate(self, room: int, new_rate: int) -> None:\n        self.segment_tree.update(room, new_rate)\n    \n    def calculate_min_energy(self, u: int, v: int) -> int:\n        path = self._find_path(u, v)\n        energy = 0\n        for i in range(len(path) - 1):\n            a_x = self.segment_tree.query(path[i])\n            a_y = self.segment_tree.query(path[i + 1])\n            energy += max(abs(a_x + a_y), abs(a_x - a_y))\n        return energy\n    \n    def _find_path(self, start: int, end: int) -> List[int]:\n        visited = [False] * (self.n + 1)\n        path = []\n        self._dfs(start, end, visited, path)\n        return path\n    \n    def _dfs(self, current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n        visited[current] = True\n        path.append(current)\n        if current == target:\n            return True\n        for neighbor in self.adjacency_list[current]:\n            if not visited[neighbor]:\n                if self._dfs(neighbor, target, visited, path):\n                    return True\n        path.pop()\n        return False\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]) -> None:\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int) -> None:\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n    \n    def query(self, index: int) -> int:\n        return self.tree[index + self.n]\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    maze = Maze(n, illusion_rates, tunnels)\n    \n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            maze.update_illusion_rate(u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = maze.calculate_min_energy(u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tunnels = tunnels\n        self.adjacency_list = self._build_adjacency_list()\n        self.segment_tree = SegmentTree(self.illusion_rates)\n    \n    def _build_adjacency_list(self) -> List[List[int]]:\n        adjacency_list = [[] for _ in range(self.n + 1)]\n        for s, t in self.tunnels:\n            adjacency_list[s].append(t)\n            adjacency_list[t].append(s)\n        return adjacency_list\n    \n    def update_illusion_rate(self, room: int, new_rate: int) -> None:\n        self.illusion_rates[room - 1] = new_rate\n        self.segment_tree.update(room - 1, new_rate)\n    \n    def query_min_energy(self, u: int, v: int) -> int:\n        path = self._find_path(u, v)\n        energy = 0\n        for i in range(len(path) - 1):\n            a_x = self.illusion_rates[path[i] - 1]\n            a_y = self.illusion_rates[path[i + 1] - 1]\n            energy += max(abs(a_x + a_y), abs(a_x - a_y))\n        return energy\n    \n    def _find_path(self, start: int, end: int) -> List[int]:\n        visited = [False] * (self.n + 1)\n        path = []\n        self._dfs(start, end, visited, path)\n        return path\n    \n    def _dfs(self, current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n        visited[current] = True\n        path.append(current)\n        if current == target:\n            return True\n        for neighbor in self.adjacency_list[current]:\n            if not visited[neighbor]:\n                if self._dfs(neighbor, target, visited, path):\n                    return True\n        path.pop()\n        return False\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]) -> None:\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int) -> None:\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    maze = Maze(n, illusion_rates, tunnels)\n    \n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            maze.update_illusion_rate(room, new_rate)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = maze.query_min_energy(u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.preprocess()\n\n    def preprocess(self):\n        \"\"\"Preprocess the tree using DFS to set up parent and depth arrays.\"\"\"\n        def dfs(node: int, par: int, dep: int):\n            self.parent[node] = par\n            self.depth[node] = dep\n            for neighbor in self.adj_list[node]:\n                if neighbor != par:\n                    dfs(neighbor, node, dep + 1)\n\n        # Start DFS from node 1 (assuming 1 is always part of the tree)\n        dfs(1, -1, 0)\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        \"\"\"Update the illusion rate of a specific room.\"\"\"\n        self.illusion_rates[room - 1] = new_rate\n\n    def calculate_min_energy(self, u: int, v: int) -> int:\n        \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n        # Find the path from u to v using the parent array\n        path_u = self.get_path_to_root(u)\n        path_v = self.get_path_to_root(v)\n\n        # Find the lowest common ancestor (LCA)\n        lca = self.find_lca(path_u, path_v)\n\n        # Calculate energy from u to lca and lca to v\n        energy = self.calculate_energy_on_path(path_u, lca) + self.calculate_energy_on_path(path_v, lca)\n        return energy\n\n    def get_path_to_root(self, node: int) -> List[int]:\n        \"\"\"Get the path from a node to the root.\"\"\"\n        path = []\n        while node != -1:\n            path.append(node)\n            node = self.parent[node]\n        return path\n\n    def find_lca(self, path_u: List[int], path_v: List[int]) -> int:\n        \"\"\"Find the lowest common ancestor of two paths.\"\"\"\n        path_u_set = set(path_u)\n        for node in path_v:\n            if node in path_u_set:\n                return node\n        return -1  # Should never happen if the tree is valid\n\n    def calculate_energy_on_path(self, path: List[int], lca: int) -> int:\n        \"\"\"Calculate the energy required on a path from a node to the LCA.\"\"\"\n        energy = 0\n        for i in range(len(path) - 1):\n            if path[i] == lca:\n                break\n            a_x = self.illusion_rates[path[i] - 1]\n            a_y = self.illusion_rates[path[i + 1] - 1]\n            energy += max(abs(a_x + a_y), abs(a_x - a_y))\n        return energy\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n\n    maze = Maze(n, illusion_rates, tunnels)\n\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1])\n            new_rate = int(data[index + 2])\n            maze.update_illusion_rate(room, new_rate)\n            index += 3\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            result = maze.calculate_min_energy(u, v)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    def __init__(self, n: int):\n        self.n = n\n        self.tree = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [[-1] * 20 for _ in range(n + 1)]\n        self.illusion_rates = [0] * (n + 1)\n        self.segment_tree = [0] * (4 * n)\n\n    def add_edge(self, u: int, v: int):\n        self.tree[u].append(v)\n        self.tree[v].append(u)\n\n    def dfs(self, node: int, par: int, dep: int):\n        self.parent[node][0] = par\n        self.depth[node] = dep\n        for i in range(1, 20):\n            if self.parent[node][i - 1] != -1:\n                self.parent[node][i] = self.parent[self.parent[node][i - 1]][i - 1]\n        for neighbor in self.tree[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        diff = self.depth[u] - self.depth[v]\n        for i in range(20):\n            if (diff >> i) & 1:\n                u = self.parent[u][i]\n        if u == v:\n            return u\n        for i in range(19, -1, -1):\n            if self.parent[u][i] != self.parent[v][i]:\n                u = self.parent[u][i]\n                v = self.parent[v][i]\n        return self.parent[u][0]\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.illusion_rates[room] = new_rate\n        self._update_segment_tree(1, 1, self.n, room, new_rate)\n\n    def _update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int):\n        if start == end:\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self._update_segment_tree(2 * node, start, mid, idx, value)\n            else:\n                self._update_segment_tree(2 * node + 1, mid + 1, end, idx, value)\n            self.segment_tree[node] = max(self.segment_tree[2 * node], self.segment_tree[2 * node + 1])\n\n    def calculate_minimum_energy(self, u: int, v: int) -> int:\n        ancestor = self.lca(u, v)\n        return self._calculate_energy_path(u, ancestor) + self._calculate_energy_path(v, ancestor)\n\n    def _calculate_energy_path(self, u: int, ancestor: int) -> int:\n        energy = 0\n        while u != ancestor:\n            par = self.parent[u][0]\n            energy += max(abs(self.illusion_rates[u] + self.illusion_rates[par]),\n                          abs(self.illusion_rates[u] - self.illusion_rates[par]))\n            u = par\n        return energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    tree = Tree(n)\n    \n    for i in range(1, n + 1):\n        tree.illusion_rates[i] = int(data[index])\n        index += 1\n    \n    for _ in range(n - 1):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        tree.add_edge(u, v)\n    \n    tree.dfs(1, -1, 0)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        if query_type == 1:\n            u = int(data[index])\n            index += 1\n            c = int(data[index])\n            index += 1\n            tree.update_illusion_rate(u, c)\n        elif query_type == 2:\n            u = int(data[index])\n            index += 1\n            v = int(data[index])\n            index += 1\n            result = tree.calculate_minimum_energy(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating the minimum energy needed for treasure retrieval. The solution must be able to process up to 100,000 queries and handle large values for illusion rates, ensuring quick and accurate responses.\nrequirement pool:\n- Efficient query handling for changing illusion rates\n- Accurate calculation of minimum energy for treasure retrieval\n- Support for large numbers of queries\n- Optimization for quick response times\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate paths, while Segment Tree will allow us to update and query the illusion rates efficiently. This approach ensures that both types of queries are handled in logarithmic time complexity, which is suitable given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, it represents the maze structure where rooms are nodes and tunnels are edges.\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb] \n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves finding the path with the least energy cost.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Implement DFS to traverse the tree and calculate paths.\n3. Use a Segment Tree to handle updates and queries efficiently:\n   - For type 1 queries, update the illusion rate of a specific room.\n   - For type 2 queries, calculate the minimum energy required to travel from room u to room v.\n4. Output the result for each type 2 query.\n\n# [edge case] \n    Edge Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: 10\n    Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Edge Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: 0\n    Explanation: Since all illusion rates are zero, any path will have zero energy cost.\n\n    Edge Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output: 2000000000\n    Explanation: After changing the illusion rate of room 1, the path from room 1 to room 3 will have an energy cost of max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS and Segment Tree will naturally handle these scenarios due to its generality in processing tree structures and updating/querying values efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must ensure quick updates and accurate energy calculations while maintaining a clear output format.\nrequirement pool:\n- Efficient query handling for illusion rate changes\n- Accurate calculation of minimum energy paths\n- Scalable solution for large input sizes\n- User-friendly output format\n- Support for additional query types in future\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate paths, while Segment Tree will allow us to update and query the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that for each movement between two rooms, the energy required is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'minimum sum of energy': This means that for type 2 queries, we need to find the path from room u to room v that results in the least total energy expenditure. This can be implemented using algorithms that find the shortest path in terms of energy cost, such as Dijkstra's algorithm adapted for this specific energy calculation.\n\n# [code logic]\n1. Parse the input to construct the tree and store initial illusion rates.\n2. Use DFS to preprocess the tree for efficient path queries.\n3. Implement a Segment Tree or similar data structure to handle updates to illusion rates efficiently.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, calculate the minimum energy path from room u to room v using preprocessed data and current illusion rates.\n\n# [edge case] \n    1. Query with u = v (e.g., 2 1 1) = 0\n       Explanation: If the start and end rooms are the same, no movement is needed, so the energy required is 0.\n    2. All rooms have zero illusion rate initially (e.g., 2 1 2 with all a_i = 0) = 0\n       Explanation: If all illusion rates are zero, any path will require zero energy since max(|0 + 0|, |0 - 0|) = 0.\n    3. Maximum possible illusion rate change (e.g., 1 1 10^9 followed by 2 1 2)\n       Explanation: This tests the ability to handle large numbers and ensure calculations do not overflow.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - For u = v queries, directly return 0 without further calculations.\n        - Ensure that all calculations involving illusion rates are done using data types that can handle large numbers (e.g., Python's int type).\n        - Implement checks to handle cases where all illusion rates are zero efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently handling dynamic updates to the maze's illusion rates and calculating the minimum energy required for traversal. The solution must be optimized for large input sizes and frequent queries, ensuring quick response times and accuracy.\nrequirement pool:\n- Implement efficient data structures to handle dynamic updates and queries.\n- Optimize pathfinding algorithms to minimize energy calculations.\n- Ensure the system can handle edge cases and invalid inputs gracefully.\n- Provide clear and concise output for each query.\n- Develop a user-friendly interface for input and output operations.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficiently handling updates and queries. The Segment Tree will allow us to update the illusion rates and calculate the minimum energy required for traversal between rooms efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated as max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` for absolute value.\n\n# [degree adverb] \n    'minimum': In the context of the queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented using algorithms that find the shortest path or minimum cost path in a tree, such as DFS or BFS.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Implement a DFS to calculate initial paths and energies between rooms.\n4. Use a Segment Tree to handle updates to illusion rates efficiently.\n5. For each query:\n   - If it's a type 1 query, update the illusion rate using the Segment Tree.\n   - If it's a type 2 query, calculate the minimum energy required using precomputed paths and updated illusion rates.\n\n# [edge case] \n    Edge Case 1: Minimum number of rooms (n=2) with maximum illusion rates.\n    Input: \n    ```\n    2 1\n    1000000000 -1000000000\n    1 2\n    2 1 2\n    ```\n    Expected Output: 2000000000\n    Explanation: The energy required is max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000.\n\n    Edge Case 2: All rooms have zero illusion rate.\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: 0\n    Explanation: Since all illusion rates are zero, the energy required for any path is zero.\n\n    Edge Case 3: A single update changes all paths significantly.\n    Input:\n    ```\n    4 3\n    1 1 1 1\n    1 2\n    2 3\n    3 4\n    2 1 4\n    1 2 -1000000000\n    2 1 4\n    ```\n    Expected Output: \n    Before update: 3 (since all energies are max(|1+1|, |1-1|) = 2)\n    After update: Large value due to max(|1 + (-1000000000)|, |1 - (-1000000000)|)\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently using a Segment Tree or similar data structure to ensure that updates and queries are processed in logarithmic time relative to the number of rooms. This will handle large inputs within time constraints.\n", "requirement analysis:\nThe main challenge is to efficiently handle up to 100,000 rooms and queries, ensuring that updates to illusion rates and energy calculations are performed quickly. The tree structure of the maze allows for efficient traversal and pathfinding algorithms, which should be leveraged to optimize query responses.\nrequirement pool:\n- Efficiently handle up to 100,000 queries and room updates.\n- Accurately calculate the minimum energy required for room transitions.\n- Provide a user-friendly interface for input and output.\n- Ensure the system is robust against invalid inputs.\n- Optimize for performance on both desktop and mobile platforms.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. The DFS will help in traversing the tree structure of the maze, while the Segment Tree will allow us to update and query the illusion rates efficiently. This approach leverages the tree structure for efficient pathfinding and the segment tree for quick updates and queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected acyclic graph. This structure allows traversal between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'queries'\n    Explanation: There are two types of queries: one to update the illusion rate of a room and another to calculate the minimum energy required to move from one room to another.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy calculation for moving between two rooms. It requires finding the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms. In code, this can be implemented using Python's `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to move from one room to another. This involves calculating the path with the least energy cost.\n\n# [code logic]\n    1. Parse the input to extract the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on the tunnel connections.\n    3. Implement DFS to traverse the tree and calculate paths.\n    4. Use a Segment Tree to efficiently handle updates to illusion rates and queries for minimum energy.\n    5. For type 1 queries, update the illusion rate in the Segment Tree.\n    6. For type 2 queries, use DFS combined with Segment Tree to calculate the minimum energy required for the path.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 20\n    Explanation: The path from room 1 to room 3 goes through room 2, with energy calculations max(|10 + (-10)|, |10 - (-10)|) = 20.\n\n    Input: 4 2\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 3 -10\n           2 1 4\n    Expected Output: 15, 20\n    Explanation: Initially, moving from room 1 to room 4 requires max(|-5 + (-5)|, |-5 - (-5)|) = 15 energy for each segment. After updating room 3's illusion rate, the energy changes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 2:\n            return max(abs(a[0] + a[1]), abs(a[0] - a[1]))\n        # Additional logic for handling updates and queries efficiently using Segment Tree and DFS.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating the minimum energy required for treasure retrieval. The solution must be scalable to handle up to 100,000 rooms and queries, ensuring quick and accurate responses.\nrequirement pool:\n- Efficient query handling for changing illusion rates\n- Accurate calculation of minimum energy required for treasure retrieval\n- Scalability to handle large numbers of rooms and queries\n- User-friendly interface for input and output\n- Visual representation of the maze and paths\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. The DFS will help in traversing the tree structure of the maze, while the Segment Tree will allow us to update and query the illusion rates efficiently. This approach ensures that we can handle up to 100,000 rooms and queries within a reasonable time complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected graph with no cycles.\n    'illusion rate': Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n    'queries': There are two types of queries: updating the illusion rate of a room and calculating the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates the energy calculation between two rooms, where the energy is the maximum of the absolute sum or difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented using algorithms that find the shortest path or minimum cost in a graph, such as Dijkstra's algorithm.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to traverse the tree and calculate paths.\n    4. Use a Segment Tree to efficiently update and query illusion rates.\n    5. For type 1 queries, update the illusion rate in the Segment Tree.\n    6. For type 2 queries, calculate the minimum energy required using DFS and Segment Tree.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires 0 energy.\n\n    Input: 3 2\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n           1 3 -10\n           2 1 3\n    Output: 20\n            30\n    Explanation: Initially, moving from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) = max(0, 20) = 20 energy. After updating room 3's illusion rate to -10, moving from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) = max(0, 30) = 30 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will handle these cases efficiently.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates to the illusion rates and calculate the minimum energy required for traversal in a tree structure. The solution must be optimized for large input sizes and frequent queries.\nrequirement pool:\n- Efficiently handle updates to illusion rates.\n- Calculate minimum energy required for traversal.\n- Optimize for large input sizes.\n- Ensure quick response to queries.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the updates and queries. The DFS will help in traversing the tree structure to calculate the path and the Segment Tree will allow us to update the illusion rates and query the minimum energy efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum and the absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum sum of energy': This indicates that for type 2 queries, we need to find the smallest possible total energy required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the smallest one.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Implement a DFS to traverse the tree and calculate paths.\n4. Use a Segment Tree to handle updates to illusion rates and efficiently query the minimum energy for type 2 queries.\n5. For each query:\n   - If it's type 1, update the illusion rate in the Segment Tree.\n   - If it's type 2, calculate the minimum energy required using the current illusion rates and output the result.\n\n# [edge case]\n    Edge Case 1: Minimum number of rooms\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Edge Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: All rooms have an illusion rate of zero, so any path will have zero energy.\n\n    Edge Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After changing room 1's illusion rate to -1000000000, moving from room 1 to room 3 requires max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000 energy.\n\n# [extra code for edge case]\nWe do not need extra code to handle these edge cases. The original logic using DFS and Segment Tree should be sufficient to handle all cases efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently handling a large number of queries related to changing illusion rates and calculating energy costs between rooms. The solution must be optimized for performance given the constraints on room and query numbers. The algorithm should ensure accurate updates and calculations while providing immediate results.\nrequirement pool:\n- Implement efficient query handling for changing illusion rates.\n- Develop an algorithm to calculate minimum energy between rooms.\n- Ensure scalability to handle up to 100,000 queries efficiently.\n- Provide clear output for each type 2 query.\n- Optimize data structures for fast access and updates.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path between rooms efficiently. We will utilize Segment Trees to handle updates to the illusion rates and efficiently calculate the minimum energy required for type 2 queries. This approach ensures that both update and query operations are handled in logarithmic time, which is suitable given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected graph with no cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'queries'\n    Explanation: There are two types of queries: one to update the illusion rate of a room and another to calculate the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the energy calculation formula when moving between two rooms. It requires finding the maximum of the absolute values of the sum and difference of the illusion rates of two rooms.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to move from one room to another.\n\n# [code logic]\n    1. Parse the input to retrieve the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on the tunnel connections.\n    3. Preprocess the tree using Depth First Search (DFS) to establish paths and calculate initial energies.\n    4. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    5. For type 1 queries, update the illusion rate in the Segment Tree.\n    6. For type 2 queries, use DFS and Segment Tree to calculate the minimum energy required for the path between specified rooms.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Expected Output: 2000000000\n    Explanation: The initial path from room 1 to room 3 requires maximum energy due to high illusion rates.\n\n    Input: 4 3\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 4 -10\n           2 1 4\n    Expected Output: 30, then after update, it becomes 35\n    Explanation: Initially, each step requires max(|-5 + (-5)|, |-5 - (-5)|) = 10 energy. After updating room 4's illusion rate, the energy changes accordingly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will efficiently handle all cases including edge cases.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to illusion rate updates and energy calculations in a tree-structured maze. The solution must ensure quick updates and accurate energy calculations while providing clear outputs for each query.\nrequirement pool:\n- Efficient query handling for illusion rate updates\n- Accurate energy calculation between rooms\n- Scalability to handle up to 100,000 queries\n- User-friendly output format\n- Optimization for large datasets\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path energies efficiently. We will utilize a Segment Tree to handle updates to the illusion rates and efficiently query the minimum energy required between rooms. This approach ensures that both update and query operations are handled in logarithmic time, which is suitable for the constraints given.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected acyclic graph.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the max function and abs function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from room u to room v. This can be implemented by calculating the path with the least energy using algorithms like DFS or Dijkstra's algorithm.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Preprocess the tree using DFS to calculate initial path energies.\n    4. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    5. For type 1 queries, update the illusion rate of the specified room.\n    6. For type 2 queries, calculate the minimum energy required using preprocessed data and Segment Tree.\n\n# [edge case]\n    Edge Case 1: Minimum number of rooms (n=2) with maximum illusion rates.\n    Input: \n    ```\n    2 1\n    1000000000 -1000000000\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    Explanation: The energy required is max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = max(0, 2000000000) = 2000000000.\n\n    Edge Case 2: All rooms have zero illusion rate.\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: \n    Explanation: The energy required is max(|0 + 0|, |0 - 0|) = max(0, 0) = 0 for each tunnel.\n\n    Edge Case 3: Single query with no change in illusion rates.\n    Input:\n    ```\n    4 1\n    5 -5 10 -10\n    1 2\n    2 3\n    3 4\n    2 1 4\n    ```\n    Expected Output: \n    Explanation: Calculate energy for path from room 1 to room 4 without any updates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will efficiently handle these scenarios.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must ensure quick updates and accurate energy calculations while maintaining a clear output format.\nrequirement pool:\n- Efficient query handling for illusion rate changes\n- Accurate calculation of minimum energy paths\n- Clear output format for query results\n- Responsive updates to illusion rates\n- User-friendly interface for input and output\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy path using a combination of path compression and segment trees for efficient query handling. The segment tree will help in efficiently updating the illusion rates and calculating the minimum energy required for type 2 queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It can be changed by type 1 queries.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected acyclic graph.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In type 2 queries, we need to find the minimum sum of energy required to travel from room u to room v. This involves finding the path with the least energy cost.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists.\n    3. Preprocess the tree using DFS to set up data structures for efficient query handling.\n    4. Implement a segment tree or similar structure to handle updates to illusion rates and efficiently calculate minimum energy paths.\n    5. For type 1 queries, update the illusion rate of the specified room.\n    6. For type 2 queries, calculate the minimum energy required to travel from room u to room v using preprocessed data.\n\n# [edge case]\n    Case 1: Minimum number of rooms\n    Input: \n    ```\n    2 1\n    0 0\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    0\n    ```\n    Explanation: With only two rooms and zero illusion rates, the energy required is zero.\n\n    Case 2: Maximum illusion rate change\n    Input:\n    ```\n    3 2\n    10^9 -10^9 0\n    1 2\n    2 3\n    1 1 -10^9\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    20^9\n    ```\n    Explanation: The change in illusion rate results in maximum energy calculation.\n\n    Case 3: All rooms have zero illusion rate initially\n    Input:\n    ```\n    4 2\n    0 0 0 0\n    1 2\n    2 3\n    3 4\n    2 1 4\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all rooms have zero illusion rate, no energy is required regardless of path.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should be able to handle these scenarios by correctly implementing the DFS preprocessing and segment tree updates.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to illusion rate updates and energy calculations in a maze structured as a tree. The solution must ensure quick updates and accurate energy calculations while providing clear output for each query.\nrequirement pool:\n- Efficient query handling for illusion rate updates\n- Accurate energy calculation between rooms\n- Clear output for each query\n- Scalable solution for large number of rooms and queries\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to find the shortest path between any two nodes. We will also use a Segment Tree to handle the updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. This structure is crucial for efficiently finding paths and handling queries.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy calculation when moving between rooms. It can be updated and affects the energy required to traverse tunnels.\n\n    'energy'\n    Explanation: Energy is calculated using the formula max(|a_x + a_y|, |a_x - a_y|) when moving between rooms x and y. This represents the cost of traversing a tunnel.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This involves calculating the path with the least energy cost using techniques like DFS and LCA.\n\n# [code logic]\n1. Preprocess the tree using DFS to calculate necessary paths and store information for LCA.\n2. Implement LCA to efficiently find paths between any two nodes.\n3. Use a Segment Tree to handle updates to illusion rates efficiently.\n4. For type 2 queries, calculate the minimum energy required using preprocessed data and LCA.\n5. For type 1 queries, update the illusion rate using the Segment Tree.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 1\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n    Output: 20\n    Explanation: The path from room 1 to room 3 is via room 2, with energies max(|10 + (-10)|, |10 - (-10)|) = 20 and max(|-10 + 10|, |-10 - 10|) = 20, totaling 20.\n\n    Input: 4 1\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Output: 15\n    Explanation: The path from room 1 to room 4 involves energies max(|-5 + (-5)|, |-5 - (-5)|) = 10 and max(|-5 + (-5)|, |-5 - (-5)|) = 10, totaling 15.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will handle these cases efficiently.\n"], "scores": [], "pass_results": [true, true, true, true, true, false, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 666, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "expand_one2two", "parent_index": 416}
