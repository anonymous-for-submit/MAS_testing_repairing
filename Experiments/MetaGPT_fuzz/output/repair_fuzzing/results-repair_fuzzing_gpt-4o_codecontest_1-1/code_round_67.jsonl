{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. It is necessary that the number of rows is at least 5. Additionally, it is required that the number of columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. It is necessary that the number of rows is at least 5. Additionally, it is required that the number of columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. It is necessary that the number of rows is at least 5. Additionally, it is required that the number of columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that the there must be a rows and b columns. It is important to note that it is not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m. There are n rows and m columns of blocks, and each block of the rectangle is an obsidian block or empty; CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. It is necessary that the number of rows is at least 5, and it is required that the number of columns is at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_operations_to_portal(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed for current sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid representing the blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Ensure border blocks (except corners) are obsidian blocks\n    for row in range(start_row + 1, end_row):\n        if grid[row][start_col] != '1':\n            operations += 1\n        if grid[row][end_col] != '1':\n            operations += 1\n\n    for col in range(start_col + 1, end_col):\n        if grid[start_row][col] != '1':\n            operations += 1\n        if grid[end_row][col] != '1':\n            operations += 1\n\n    # Ensure inner blocks are empty blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row][col] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to form a portal in each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions of the grid and the grid itself.\n\n    Returns:\n        list: Minimum number of operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([[int(char) for char in row] for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for start_row in range(n - a + 1):\n                    for start_col in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[start_row:start_row + a, start_col:start_col + b]\n                        operations = calculate_operations(sub_rect, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be transformed.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Check the outer edges (except corners)\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n\n    # Check the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to transform a rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and grid of a test case.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n\n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed for current sub-rectangle\n                        operations = calculate_operations(grid_array, start_row, start_col, a, b)\n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and count operations for the border conditions\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            operations += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            operations += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            operations += 1\n\n    # Check and count operations for the internal empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport sys\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the grid as a list of strings\n    :return: List of integers, each representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        matrix = np.array([list(row) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                operations = 0\n\n                # Check and count operations for borders and inner blocks\n                for i in range(start_row, start_row + 5):\n                    for j in range(start_col, start_col + 4):\n                        if (i == start_row or i == start_row + 4) and (j > start_col and j < start_col + 3):\n                            if matrix[i][j] != '1':\n                                operations += 1\n                        elif (j == start_col or j == start_col + 3) and (i > start_row and i < start_row + 4):\n                            if matrix[i][j] != '1':\n                                operations += 1\n                        elif (i > start_row and i < start_row + 4) and (j > start_col and j < start_col + 3):\n                            if matrix[i][j] != '0':\n                                operations += 1\n\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n\n        grid = []\n        for _ in range(n):\n            grid.append(data[index])\n            index += 1\n\n        test_cases.append((n, m, grid))\n\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix)\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n, m, matrix = case\n        matrix = np.array([list(map(int, list(row))) for row in matrix])\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_matrix = matrix[i:i+a, j:j+b]\n                        operations = calculate_operations(sub_matrix, a, b)\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(sub_matrix: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a given sub-matrix into a portal.\n\n    :param sub_matrix: The sub-matrix to be transformed\n    :param a: Number of rows in the sub-matrix\n    :param b: Number of columns in the sub-matrix\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n    \n    # Check and transform the borders\n    for x in range(1, a - 1):\n        if sub_matrix[x, 0] != 1:\n            operations += 1\n        if sub_matrix[x, b - 1] != 1:\n            operations += 1\n    \n    for y in range(1, b - 1):\n        if sub_matrix[0, y] != 1:\n            operations += 1\n        if sub_matrix[a - 1, y] != 1:\n            operations += 1\n    \n    # Check and transform the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_matrix[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        list[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, a, b)\n                        min_operations = min(min_operations, changes)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the outer edges (except corners)\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m and the grid\n# Collect all test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Finds the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the dimensions of the rectangle and the grid.\n\n    Returns:\n        A list of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[start_row:start_row + a, start_col:start_col + b]\n                        operations = calculate_operations(sub_rect, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculates the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect: The sub-rectangle as a numpy array.\n        a: The number of rows in the sub-rectangle.\n        b: The number of columns in the sub-rectangle.\n\n    Returns:\n        The number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the edges and interior of the sub-rectangle\n    for x in range(a):\n        for y in range(b):\n            if (x == 0 or x == a - 1) and (1 <= y < b - 1):\n                # Top and bottom edges (except corners)\n                if sub_rect[x, y] != 1:\n                    operations += 1\n            elif (y == 0 or y == b - 1) and (1 <= x < a - 1):\n                # Left and right edges (except corners)\n                if sub_rect[x, y] != 1:\n                    operations += 1\n            elif 1 <= x < a - 1 and 1 <= y < b - 1:\n                # Interior blocks\n                if sub_rect[x, y] != 0:\n                    operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = find_min_operations(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum operations for the corresponding test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, a, b)\n                        min_operations = min(min_operations, changes)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    :param grid: The grid as a numpy array\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes needed\n    \"\"\"\n    changes = 0\n\n    # Check the borders (except corners)\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the interior\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a x b\n        for i in range(n - 4):\n            for j in range(m - 3):\n                sub_grid = grid_array[i:i+5, j:j+4]\n                operations = calculate_operations(sub_grid)\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_grid: np.ndarray) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-grid into a portal.\n\n    Args:\n        sub_grid (np.ndarray): The sub-grid to be transformed.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n    a, b = sub_grid.shape\n\n    # Check and transform the borders\n    for x in range(1, a-1):\n        if sub_grid[x, 0] != 1:\n            operations += 1\n        if sub_grid[x, b-1] != 1:\n            operations += 1\n\n    for y in range(1, b-1):\n        if sub_grid[0, y] != 1:\n            operations += 1\n        if sub_grid[a-1, y] != 1:\n            operations += 1\n\n    # Check and transform the inner blocks\n    for x in range(1, a-1):\n        for y in range(1, b-1):\n            if sub_grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = find_min_operations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to transform a rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing dimensions and grid for each test case.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid of blocks.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check outer edges (except corners)\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            operations += 1\n        if grid[row, end_col] != 1:\n            operations += 1\n\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            operations += 1\n        if grid[end_row, col] != 1:\n            operations += 1\n\n    # Check inner blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements specify the need to transform a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are clear, and the solution must efficiently handle multiple test cases while ensuring the output format is adhered to.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations.\n- Ensure output format matches the specified requirements.\n- Optimize for large input sizes.\n- Handle edge cases effectively.\n- Provide clear documentation for the solution.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n by m grid. For each sub-rectangle, we will calculate the number of operations required to transform it into a portal. The function will keep track of the minimum number of operations needed across all sub-rectangles. This approach ensures that we efficiently handle the constraints and provide the correct output for each test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions, n by m, where n is the number of rows and m is the number of columns.\n    'obsidian block': A block represented by '1' in the grid.\n    'empty block': A block represented by '0' in the grid.\n    'portal': A sub-rectangle within the grid that meets specific conditions regarding its dimensions and block types.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    'minimum number of operations': The least number of changes needed to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    'minimum': Refers to the smallest number of operations required to achieve the transformation into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each grid.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the border blocks (except corners) are obsidian blocks.\n        - Ensure the inner blocks are empty blocks.\n    4. Track the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    8\n    Explanation: The entire grid is obsidian blocks, requiring changes to make inner blocks empty.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    8\n    Explanation: The entire grid is empty blocks, requiring changes to make border blocks obsidian.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The grid already forms a portal, requiring no changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given grid into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. Efficient handling of multiple test cases is necessary due to the potential size of inputs.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation.\n- Ensure the solution handles maximum input sizes within constraints.\n- Provide clear output format for each test case.\n- Optimize the algorithm for speed and accuracy.\n- Include edge case handling for smallest and largest possible grids.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle of a given grid into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the grid of blocks, where n is the number of rows and m is the number of columns.\n\n    'obsidian block or empty'\n    Explanation: Each block in the grid can either be an obsidian block (represented by 1) or an empty block (represented by 0).\n\n    'portal'\n    Explanation: A sub-rectangle of size a by b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles that meet these minimum dimensions.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating the number of changes for each possible sub-rectangle and keeping track of the smallest value.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each grid.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal conditions:\n   - Ensure the outer edges (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Keep track of the minimum number of changes for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the portal configuration.\n    Explanation: The expected output is 0 because no changes are needed.\n\n    Case 2: A grid where all blocks are obsidian.\n    Explanation: The expected output is the number of changes needed to convert the inner blocks to empty and ensure the edges meet the portal conditions.\n\n    Case 3: A grid where all blocks are empty.\n    Explanation: The expected output is the number of changes needed to convert the edges to obsidian while keeping the inner blocks empty.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. Efficient handling of multiple test cases and large inputs is essential.\nrequirement pool:\n- Implement the main algorithm to transform the rectangle into a portal.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output format.\n- Test the solution against multiple test cases for robustness.\nWe will implement a function to determine the minimum number of operations required to transform a given rectangle into a portal. The approach will involve iterating over possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to satisfy the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of dimensions a \u00d7 b where a \u2265 5 and b \u2265 4, with specific conditions on the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'at least': means the dimensions of the portal must be greater than or equal to 5 rows and 4 columns.\n    Implementation: Use conditional checks to ensure dimensions meet the minimum requirements (a >= 5 and b >= 4).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the border conditions are met (obsidian blocks on specified borders).\n        - Count the number of changes needed for internal blocks to be empty.\n    4. Track the minimum number of operations across all sub-rectangles for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    8\n    Explanation: The entire rectangle is filled with obsidian blocks. The minimum operations required to create a portal involve changing internal blocks to empty while maintaining border conditions.\n\n    Case 2: \n    Input: \n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: \n    16\n    Explanation: The entire rectangle is empty. The minimum operations required involve changing border blocks to obsidian while maintaining internal blocks as empty.\n\n    Case 3: \n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: \n    12\n    Explanation: The alternating pattern requires significant changes to meet portal conditions, focusing on border and internal block transformations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for fully obsidian or fully empty rectangles to optimize transformation operations.\n        - Use efficient matrix manipulation techniques to minimize operation count in edge scenarios.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle within a larger rectangle into a portal with specific obsidian and empty block arrangements. The solution must efficiently compute the minimum number of operations needed for this transformation across multiple test cases, adhering to constraints on dimensions and block types.\nrequirement pool:\n- Efficiently compute minimum operations for portal transformation\n- Handle multiple test cases with varying dimensions\n- Optimize algorithm for large input sizes\n- Ensure output format is clear and concise\n- Provide detailed explanation of transformation steps\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to changing an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'at least': a \u2265 5, b \u2265 4 means the minimum size of the portal is 5 rows and 4 columns.\n    'sum of n over all test cases does not exceed 400': This ensures that the total number of rows across all test cases is limited to 400.\n    'sum of m over all test cases does not exceed 400': This ensures that the total number of columns across all test cases is limited to 400.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and dimensions for each test case.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal conditions:\n   - Ensure the borders are obsidian blocks as required.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations needed for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    Explanation: The entire rectangle is already a portal, so no operations are needed. Expected output is 0.\n\n    Test case with alternating blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: \n    Explanation: The alternating pattern requires significant changes to meet portal conditions. Expected output is calculated based on specific changes needed.\n\n    Test case with all empty blocks:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    Explanation: All blocks need to be changed to meet portal conditions. Expected output is calculated based on specific changes needed.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the entire rectangle is already a portal or requires significant changes.\n```python\ndef calculate_operations(n, m, matrix):\n    min_operations = float('inf')\n    \n    for start_row in range(n - 4):\n        for start_col in range(m - 3):\n            operations = 0\n            \n            # Check and count operations for borders and inner blocks\n            for i in range(start_row, start_row + 5):\n                for j in range(start_col, start_col + 4):\n                    if (i == start_row or i == start_row + 4) and (j > start_col and j < start_col + 3):\n                        if matrix[i][j] != '1':\n                            operations += 1\n                    elif (j == start_col or j == start_col + 3) and (i > start_row and i < start_row + 4):\n                        if matrix[i][j] != '1':\n                            operations += 1\n                    elif (i > start_row and i < start_row + 4) and (j > start_col and j < start_col + 3):\n                        if matrix[i][j] != '0':\n                            operations += 1\n            \n            min_operations = min(min_operations, operations)\n    \n    return min_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        matrix = []\n        for _ in range(n):\n            matrix.append(data[index])\n            index += 1\n        \n        result = calculate_operations(n, m, matrix)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n", "requirement analysis:\nThe problem requires transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types must be adhered to, ensuring efficient computation for potentially large inputs.\nrequirement pool:\n- Implement the main algorithm to transform the rectangle into a portal.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles edge cases efficiently.\n- Provide clear and concise output format.\n- Test the solution against multiple test cases.\nWe will implement a function that iterates over all possible sub-rectangles of size a x b within the given n x m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal according to the given conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle within the given rectangle that meets specific conditions regarding its dimensions and the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions that meet these minimum requirements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of size a x b within the given n x m rectangle.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n    3. The operations involve changing blocks to meet the portal conditions: \n       - Ensure the borders (except corners) are obsidian blocks.\n       - Ensure the inner blocks are empty.\n    4. Keep track of the minimum number of operations needed across all sub-rectangles.\n    5. Return the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle with dimensions exactly 5x4 with all blocks already meeting portal conditions.\n    Expected output: 0\n    Explanation: No operations are needed as it already meets the portal conditions.\n\n    Case 2: A rectangle with dimensions larger than 5x4 but with no possible sub-rectangle meeting portal conditions without changes.\n    Expected output: Number of operations needed to transform any sub-rectangle into a portal.\n\n    Case 3: A rectangle with dimensions exactly 5x4 but all blocks are opposite to portal conditions (all inner blocks are obsidian, borders are empty).\n    Expected output: Maximum number of operations needed to transform it into a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. Efficient handling of multiple test cases is essential due to the potential size of inputs.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation.\n- Ensure output format is clear and concise.\n- Optimize code for handling large inputs efficiently.\n- Include edge case handling for smallest and largest possible rectangles.\n- Provide detailed documentation for understanding the solution approach.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach will involve iterating over possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to satisfy the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the grid of blocks, where n is the number of rows and m is the number of columns.\n\n    'obsidian block or empty'\n    Explanation: Each block in the rectangle can either be an obsidian block (represented by 1) or an empty block (represented by 0).\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles that meet these minimum dimensions.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating the number of changes for each candidate sub-rectangle and keeping track of the smallest value.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n   - Ensure the outer edges (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of changes required for any valid sub-rectangle.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Case 2: A grid with all blocks as obsidian\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: All inner blocks need to be changed to empty, requiring a total of 12 changes.\n\n    Case 3: A grid with all blocks as empty\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All outer edge blocks (except corners) need to be changed to obsidian, requiring a total of 12 changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the required changes will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. Efficient handling of multiple test cases is necessary due to the potential size of inputs.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations.\n- Ensure output format is clear and concise.\n- Optimize for handling large input sizes.\n- Consider edge cases in block configurations.\n- Provide detailed documentation for understanding the solution.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n by m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal according to the given conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with rows and columns, where each block can be either an obsidian block or an empty block.\n    'portal': A specific sub-rectangle with defined conditions for obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'at least': Indicates a minimum requirement for the dimensions of the portal (a \u2265 5, b \u2265 4).\n    Implementation: Use conditional checks to ensure dimensions meet these minimums.\n    'sum of n over all test cases does not exceed 400': Ensures the total number of rows across all test cases is within a limit.\n    Implementation: Use loops to iterate over test cases while keeping track of the total sum.\n\n# [degree adverb]\n    'minimum': Refers to the least number of operations required to transform a sub-rectangle into a portal.\n    Implementation: Use a variable to track the minimum operations needed and update it as smaller values are found.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and dimensions for each test case.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting necessary operations.\n4. Track the minimum number of operations needed for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Test case with a rectangle already satisfying portal conditions:\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected output: 0\n    Explanation: The rectangle already meets the portal conditions, so no operations are needed.\n\n    Test case with maximum dimensions:\n    Input:\n    1\n    400 400\n    (A rectangle filled with alternating obsidian and empty blocks)\n    Expected output: Depends on specific arrangement, but should be calculated correctly by the logic.\n\n    Test case with minimum dimensions:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected output: Calculated based on transforming all necessary blocks to meet portal conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should correctly calculate the minimum operations needed for any given rectangle configuration.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the solution. The challenge lies in efficiently finding sub-rectangles that can be transformed into portals while adhering to the rules.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations.\n- Optimize the solution for large input sizes.\n- Ensure the solution adheres to portal formation rules.\n- Provide clear input/output instructions.\n- Test the solution against various edge cases.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and checking the number of changes needed to satisfy the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the grid of blocks, where each block can either be an obsidian block or an empty block. The dimensions n and m specify the number of rows and columns, respectively.\n\n    'portal'\n    Explanation: A sub-rectangle of size a by b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating the number of changes for each candidate sub-rectangle and keeping track of the smallest value.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the interior is empty blocks.\n4. Track the minimum number of changes across all sub-rectangles.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No changes are needed as it already satisfies the portal conditions.\n\n    Case 2: A grid with all blocks as obsidian.\n    Example:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The interior needs to be converted to empty blocks, requiring changes.\n\n    Case 3: A grid with all blocks as empty.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: The borders need to be converted to obsidian blocks, requiring changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum number of changes will naturally handle these cases.\n", "requirement analysis:\nThe problem requires transforming a given grid into a portal with minimal operations. The constraints on the grid size and the portal dimensions are critical. Efficient algorithms are needed to handle the maximum input sizes within the given limits.\nrequirement pool:\n- Develop an algorithm to identify potential portal locations.\n- Calculate the minimum number of operations required.\n- Optimize the solution for large grid sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide detailed output for understanding the transformation process.\nWe will use a brute-force approach to check all possible sub-rectangles of size a x b within the given n x m grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will be optimized by early termination if a valid portal is found with zero operations. We will use numpy for efficient grid manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with n rows and m columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle with specific conditions on its blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    Implementation: Ensure the dimensions of the sub-rectangle are checked against these minimum values.\n    '1 < x < a': For rows, x must be greater than 1 and less than a.\n    Implementation: Iterate over rows from 2 to a-1.\n    '1 < x < b': For columns, x must be greater than 1 and less than b.\n    Implementation: Iterate over columns from 2 to b-1.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a x b within the n x m grid.\n    3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: Minimum size grid that is already a portal\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid is already a portal, so no operations are needed.\n\n    Case 2: Grid with no obsidian blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All blocks need to be changed to form a portal.\n\n    Case 3: Grid with alternating blocks\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on the specific arrangement; requires calculation.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == a and m == b:\n            # Check if the current grid is already a portal\n            if is_portal(grid):\n                return 0\n\n        # Function to check if a sub-rectangle is already a portal\n        def is_portal(sub_grid):\n            # Implement checks for portal conditions here\n\n        # Other code for handling transformations and counting operations\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. Efficient handling of multiple test cases is essential due to the potential size of input data.\nrequirement pool:\n- Implement the main algorithm to transform rectangles into portals.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output format.\n- Test the solution with various input sizes and scenarios.\nWe will implement a function to determine the minimum number of operations required to transform a given rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to satisfy the portal conditions. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can either be an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific conditions regarding its dimensions and the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle (portal) must have at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles of these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the least number of operations required to transform a sub-rectangle into a portal. This involves calculating the number of changes for each possible sub-rectangle and selecting the smallest value.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n   - Ensure the outer edges (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Case 2: A grid with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The inner blocks need to be changed to empty, requiring a total of 12 changes.\n\n    Case 3: A grid with all blocks as empty.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: The outer edges need to be changed to obsidian, requiring a total of 12 changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum number of changes will naturally handle these cases.\n"], "scores": [], "pass_results": [true, true, true, true, false, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 67, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 59}
