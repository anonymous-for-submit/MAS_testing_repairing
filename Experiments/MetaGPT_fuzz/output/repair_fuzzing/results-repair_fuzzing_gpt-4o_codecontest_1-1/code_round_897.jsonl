{"name": "1613_A. Long Comparison", "description": "Monocarp wrote down two numbers on a whiteboard. Both numbers follow a specific format: a positive integer x with p zeros appended to its end.\n\nNow Monocarp asks you to compare these two numbers. Can you help him?\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers x_1 and p_1 (1 \u2264 x_1 \u2264 10^6; 0 \u2264 p_1 \u2264 10^6) \u2014 the description of the first number.\n\nThe second line of each testcase contains two integers x_2 and p_2 (1 \u2264 x_2 \u2264 10^6; 0 \u2264 p_2 \u2264 10^6) \u2014 the description of the second number.\n\nOutput\n\nFor each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.\n\nExample\n\nInput\n\n\n5\n2 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n\n\nOutput\n\n\n&gt;\n=\n&lt;\n=\n&lt;\n\nNote\n\nThe comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.", "tags": ["implementation", "math"], "difficulty": 7, "id": 1613, "sample_io": [{"input": "5\n2 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n", "output": [">\n=\n<\n=\n<\n"]}], "test_list": [{"input": "1\n2000 0\n2 3\n", "output": ["=\n"]}, {"input": "1\n1 6\n1000000 0\n", "output": ["=\n"]}, {"input": "3\n1 3\n100 1\n2 3\n200 1\n6 3\n600 1\n", "output": ["=\n=\n=\n"]}, {"input": "1\n1201 0\n12 2\n", "output": [">\n"]}, {"input": "1\n50 2\n500 1\n", "output": ["=\n"]}, {"input": "1\n21 4\n210010 0\n", "output": ["<\n"]}, {"input": "1\n12 2\n1205 0\n", "output": ["<\n"]}, {"input": "1\n12 2\n1204 0\n", "output": ["<\n"]}, {"input": "1\n100000 1\n1000000 0\n", "output": ["=\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n999999 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "1\n1000000 10\n1000000 10\n", "output": ["=\n"]}, {"input": "1\n1 5\n101 3\n", "output": ["<\n"]}, {"input": "1\n105 0\n1 2\n", "output": [">\n"]}, {"input": "1\n402 2\n4 4\n", "output": [">\n"]}, {"input": "1\n1011 2\n1023 2\n", "output": ["<\n"]}, {"input": "2\n4 0\n7 0\n5 0\n6 0\n", "output": ["<\n<\n"]}, {"input": "1\n12 2\n1201 0\n", "output": ["<\n"]}, {"input": "1\n12001 59\n12 62\n", "output": [">\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n", "output": ["=\n=\n=\n=\n=\n=\n=\n"]}, {"input": "1\n1 6\n10101 2\n", "output": ["<\n"]}, {"input": "1\n999999 0\n999999 0\n", "output": ["=\n"]}, {"input": "1\n999999 0\n1000000 0\n", "output": ["<\n"]}, {"input": "5\n2 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n", "output": [">\n=\n<\n=\n<\n"]}, {"input": "1\n4 4\n402 2\n", "output": ["<\n"]}, {"input": "1\n12 5\n1204 3\n", "output": ["<\n"]}, {"input": "1\n100000 1\n100 4\n", "output": ["=\n"]}, {"input": "1\n1562 0\n2 3\n", "output": ["<\n"]}, {"input": "3\n1 3\n100 1\n4 3\n200 1\n6 3\n600 1\n", "output": ["=\n>\n=\n"]}, {"input": "1\n21 4\n72620 0\n", "output": [">\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n999999 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "2\n4 0\n7 0\n5 0\n1 0\n", "output": ["<\n>\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n362 1\n6 3\n600 1\n1 10\n1000000 4\n", "output": ["=\n=\n=\n=\n>\n=\n=\n"]}, {"input": "5\n2 1\n19 1\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n", "output": ["<\n=\n<\n=\n<\n"]}, {"input": "3\n1 3\n100 1\n4 3\n200 1\n5 3\n600 1\n", "output": ["=\n>\n<\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 1\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "2\n4 0\n7 0\n5 -1\n1 0\n", "output": ["<\n<\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n362 1\n6 3\n316 1\n1 10\n1000000 4\n", "output": ["=\n=\n=\n=\n>\n>\n=\n"]}, {"input": "5\n2 1\n33 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 0\n", "output": ["<\n=\n<\n=\n>\n"]}, {"input": "3\n1 3\n100 1\n4 3\n200 1\n5 3\n465 1\n", "output": ["=\n>\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 6\n1000 7\n1000000 4\n10000 1\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n=\n<\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "5\n2 1\n33 -1\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 0\n", "output": [">\n=\n<\n=\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 6\n1000 7\n1000000 4\n10000 1\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 7\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n=\n<\n=\n<\n=\n=\n=\n<\n=\n=\n=\n=\n<\n>\n"]}, {"input": "5\n2 1\n33 -1\n10 2\n100 1\n1999 0\n2 0\n1 0\n1 0\n99 0\n1 0\n", "output": [">\n=\n>\n=\n>\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n6 3\n300 1\n4 3\n400 1\n4 3\n352 1\n6 3\n316 1\n1 10\n1000000 4\n", "output": ["=\n=\n>\n=\n>\n>\n=\n"]}, {"input": "3\n1 3\n100 1\n8 0\n200 1\n5 0\n465 1\n", "output": ["=\n<\n<\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n6 3\n300 1\n5 3\n400 1\n4 3\n352 1\n6 3\n316 1\n1 10\n1000000 4\n", "output": ["=\n=\n>\n>\n>\n>\n=\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1100 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 6\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1101 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n>\n<\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 6\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1101 7\n1010000 4\n10000 7\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n>\n<\n=\n=\n>\n>\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "3\n1 3\n100 1\n2 3\n200 1\n11 3\n600 1\n", "output": ["=\n=\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1010000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n999999 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n>\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n59 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "2\n4 0\n2 0\n5 0\n6 0\n", "output": [">\n<\n"]}, {"input": "5\n3 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n", "output": [">\n=\n<\n=\n<\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 7\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n999999 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 0\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n>\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 2\n362 1\n6 3\n600 1\n1 10\n1000000 4\n", "output": ["=\n=\n=\n=\n<\n=\n=\n"]}, {"input": "5\n2 1\n19 1\n3 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n", "output": ["<\n<\n<\n=\n<\n"]}, {"input": "5\n2 1\n33 0\n10 2\n100 0\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 0\n", "output": ["<\n>\n<\n=\n>\n"]}, {"input": "3\n1 3\n110 1\n4 3\n200 1\n5 3\n600 1\n", "output": ["<\n>\n<\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000010 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 1\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 10\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n<\n=\n=\n=\n<\n>\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n362 1\n6 3\n316 1\n1 10\n1000000 4\n", "output": ["=\n=\n=\n>\n>\n>\n=\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10001 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000010 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 6\n1000000 4\n100 8\n1000000 6\n1000 7\n1000000 4\n10000 1\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n<\n<\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n4 3\n362 1\n6 3\n316 1\n1 2\n1000000 4\n", "output": ["=\n=\n=\n=\n>\n>\n<\n"]}, {"input": "5\n2 1\n33 -1\n10 2\n100 0\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 0\n", "output": [">\n>\n<\n=\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n3 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n<\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1001000 4\n100 8\n1000000 6\n1000 7\n1000000 4\n10000 1\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 7\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n<\n<\n=\n<\n=\n=\n=\n<\n=\n=\n=\n=\n<\n>\n"]}, {"input": "7\n1 3\n100 1\n2 5\n200 1\n3 3\n300 1\n4 3\n400 1\n4 3\n352 1\n6 3\n316 1\n1 10\n1000000 4\n", "output": ["=\n>\n=\n=\n>\n>\n=\n"]}, {"input": "5\n2 1\n33 -1\n10 2\n100 1\n1999 0\n2 0\n1 0\n1 1\n99 0\n1 0\n", "output": [">\n=\n>\n<\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 2\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n<\n<\n>\n"]}, {"input": "5\n2 1\n33 -1\n10 2\n100 1\n1999 0\n2 0\n1 1\n1 0\n29 0\n1 0\n", "output": [">\n=\n>\n>\n>\n"]}, {"input": "3\n2 3\n100 1\n8 0\n200 1\n5 0\n465 1\n", "output": [">\n<\n<\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000001 1\n1000011 1\n999999 1\n999998 1\n839388 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n>\n>\n"]}, {"input": "5\n2 1\n33 -1\n4 2\n100 1\n1999 0\n2 0\n1 0\n1 0\n29 0\n2 0\n", "output": [">\n<\n>\n=\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 5\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1100 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n>\n=\n<\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 6\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1101 7\n1010000 4\n10000 2\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n>\n<\n=\n=\n>\n<\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1010000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n999999 0\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n>\n=\n=\n=\n<\n>\n>\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n59 1\n3 3\n300 1\n4 3\n400 1\n5 3\n200 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n>\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "2\n4 0\n2 0\n5 0\n6 -1\n", "output": [">\n>\n"]}, {"input": "5\n3 1\n19 0\n10 2\n101 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n", "output": [">\n<\n<\n=\n<\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 7\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 8\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n999999 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n>\n=\n=\n=\n=\n=\n=\n>\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 0\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1010 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n>\n=\n>\n=\n=\n=\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 14\n1000010 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 9\n1000000 4\n100 0\n1000000 4\n1000 7\n1000000 4\n10000 1\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 10\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n=\n<\n=\n<\n=\n=\n=\n=\n<\n=\n=\n=\n<\n>\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n362 1\n6 3\n316 1\n1 10\n1000000 8\n", "output": ["=\n=\n=\n>\n>\n>\n<\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10001 6\n1000000 4\n1000 7\n1000000 3\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000010 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n<\n=\n<\n=\n=\n<\n>\n<\n>\n"]}, {"input": "21\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 0\n5 3\n500 1\n6 3\n600 1\n1 10\n1000000 4\n10 6\n1000000 4\n100 8\n1000000 6\n1000 7\n1000000 4\n10000 1\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 2\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n", "output": ["=\n=\n=\n>\n=\n=\n=\n<\n<\n=\n<\n=\n=\n=\n=\n=\n<\n=\n=\n<\n>\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n462 1\n4 3\n362 1\n6 3\n316 1\n1 2\n1000000 4\n", "output": ["=\n=\n=\n<\n>\n>\n<\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n3 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n110 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n<\n=\n<\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "7\n1 3\n100 1\n2 5\n200 1\n3 3\n300 1\n4 2\n400 1\n4 3\n352 1\n6 3\n316 1\n1 10\n1000000 4\n", "output": ["=\n>\n=\n<\n>\n>\n=\n"]}, {"input": "5\n2 1\n33 -1\n10 2\n100 2\n1999 0\n2 0\n1 0\n1 1\n99 0\n1 0\n", "output": [">\n<\n>\n<\n>\n"]}, {"input": "3\n2 3\n100 1\n8 3\n200 1\n5 -1\n465 1\n", "output": [">\n>\n<\n"]}, {"input": "23\n1 3\n100 0\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 2\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": [">\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n<\n<\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n121 1\n5 3\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000001 1\n1000011 1\n999999 1\n999998 1\n839388 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n>\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n>\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 1\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1100 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n<\n=\n<\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 6\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1101 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1010011 1\n999999 1\n999998 1\n1793536 1\n45690 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n>\n<\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n<\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 6\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 2\n1101 7\n1010000 4\n10000 2\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n>\n<\n=\n>\n>\n<\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "1\n1201 -1\n12 2\n", "output": ["<\n"]}, {"input": "1\n50 1\n500 1\n", "output": ["<\n"]}, {"input": "1\n12 2\n1205 1\n", "output": ["<\n"]}, {"input": "1\n5 2\n1204 0\n", "output": ["<\n"]}, {"input": "1\n100000 1\n1000000 -1\n", "output": [">\n"]}, {"input": "1\n1100000 10\n1000000 10\n", "output": [">\n"]}, {"input": "1\n2 5\n101 3\n", "output": [">\n"]}, {"input": "1\n105 -1\n1 2\n", "output": ["<\n"]}, {"input": "1\n402 0\n4 4\n", "output": ["<\n"]}, {"input": "1\n1011 2\n1023 3\n", "output": ["<\n"]}, {"input": "1\n12 2\n802 0\n", "output": [">\n"]}, {"input": "1\n12001 59\n12 2\n", "output": [">\n"]}, {"input": "1\n1 6\n11101 2\n", "output": ["<\n"]}, {"input": "1\n1603908 0\n999999 0\n", "output": [">\n"]}, {"input": "1\n999999 0\n1001000 0\n", "output": ["<\n"]}, {"input": "1\n4 3\n402 2\n", "output": ["<\n"]}, {"input": "1\n21 5\n1204 3\n", "output": [">\n"]}, {"input": "1\n100100 1\n100 4\n", "output": [">\n"]}, {"input": "5\n2 1\n33 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n", "output": ["<\n=\n<\n=\n<\n"]}, {"input": "1\n1562 -1\n2 3\n", "output": ["<\n"]}, {"input": "1\n1201 -1\n20 2\n", "output": ["<\n"]}, {"input": "1\n83 2\n500 1\n", "output": [">\n"]}, {"input": "1\n21 4\n114481 0\n", "output": [">\n"]}, {"input": "1\n2 2\n1205 1\n", "output": ["<\n"]}, {"input": "1\n5 4\n1204 0\n", "output": [">\n"]}, {"input": "1\n100100 1\n1000000 -1\n", "output": [">\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000000 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "1\n1100000 19\n1000000 10\n", "output": [">\n"]}, {"input": "1\n2 5\n111 3\n", "output": [">\n"]}, {"input": "1\n105 -1\n2 2\n", "output": ["<\n"]}, {"input": "1\n402 0\n1 4\n", "output": ["<\n"]}, {"input": "1\n1111 2\n1023 3\n", "output": ["<\n"]}, {"input": "1\n12 2\n802 1\n", "output": ["<\n"]}, {"input": "1\n12001 59\n12 3\n", "output": [">\n"]}, {"input": "1\n1 6\n11100 2\n", "output": ["<\n"]}, {"input": "1\n1603908 0\n1801851 0\n", "output": ["<\n"]}, {"input": "1\n999999 0\n1001010 0\n", "output": ["<\n"]}, {"input": "1\n5 4\n402 2\n", "output": [">\n"]}, {"input": "1\n25 5\n1204 3\n", "output": [">\n"]}, {"input": "1\n100100 1\n110 4\n", "output": ["<\n"]}, {"input": "1\n1927 -1\n20 2\n", "output": ["<\n"]}, {"input": "1\n83 2\n952 1\n", "output": ["<\n"]}, {"input": "1\n21 4\n114481 -1\n", "output": [">\n"]}, {"input": "1\n2 2\n743 1\n", "output": ["<\n"]}, {"input": "1\n5 5\n1204 0\n", "output": [">\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000010 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "1\n2 5\n111 5\n", "output": ["<\n"]}, {"input": "1\n402 0\n1 1\n", "output": [">\n"]}, {"input": "1\n1111 2\n1023 0\n", "output": [">\n"]}, {"input": "1\n12 2\n831 1\n", "output": ["<\n"]}, {"input": "1\n12001 59\n12 0\n", "output": [">\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n4 3\n362 1\n6 3\n316 1\n1 10\n1000000 4\n", "output": ["=\n=\n=\n=\n>\n>\n=\n"]}, {"input": "1\n1 1\n11100 2\n", "output": ["<\n"]}, {"input": "1\n1603908 -1\n1801851 0\n", "output": ["<\n"]}, {"input": "1\n362052 0\n1001010 0\n", "output": ["<\n"]}, {"input": "1\n25 4\n1204 3\n", "output": ["<\n"]}, {"input": "1\n100100 1\n010 4\n", "output": [">\n"]}, {"input": "3\n1 3\n100 1\n8 3\n200 1\n5 3\n465 1\n", "output": ["=\n>\n>\n"]}, {"input": "1\n1927 -1\n16 2\n", "output": ["<\n"]}, {"input": "1\n132 2\n952 1\n", "output": [">\n"]}, {"input": "1\n21 4\n177954 -1\n", "output": [">\n"]}, {"input": "1\n2 4\n743 1\n", "output": [">\n"]}, {"input": "1\n5 5\n1216 0\n", "output": [">\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 7\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "1\n2 5\n011 5\n", "output": ["<\n"]}, {"input": "1\n468 0\n1 1\n", "output": [">\n"]}, {"input": "1\n1111 3\n1023 0\n", "output": [">\n"]}, {"input": "1\n7 2\n831 1\n", "output": ["<\n"]}, {"input": "1\n12001 59\n18 0\n", "output": [">\n"]}, {"input": "7\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n4 3\n352 1\n6 3\n316 1\n1 10\n1000000 4\n", "output": ["=\n=\n=\n=\n>\n>\n=\n"]}, {"input": "1\n1 1\n11100 0\n", "output": ["<\n"]}, {"input": "1\n2992743 -1\n1801851 0\n", "output": ["<\n"]}, {"input": "1\n362052 0\n1001011 0\n", "output": ["<\n"]}, {"input": "1\n25 4\n1990 3\n", "output": ["<\n"]}, {"input": "3\n1 3\n100 1\n8 3\n200 1\n5 0\n465 1\n", "output": ["=\n>\n<\n"]}, {"input": "1\n1927 -2\n16 2\n", "output": ["<\n"]}, {"input": "1\n132 2\n1561 1\n", "output": ["<\n"]}, {"input": "1\n2 4\n768 1\n", "output": [">\n"]}, {"input": "1\n5 9\n1216 0\n", "output": [">\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "1\n2 5\n010 5\n", "output": ["<\n"]}, {"input": "1\n15 0\n1 1\n", "output": [">\n"]}, {"input": "1\n1111 3\n533 0\n", "output": [">\n"]}, {"input": "1\n7 2\n1076 1\n", "output": ["<\n"]}, {"input": "1\n12001 59\n11 0\n", "output": [">\n"]}, {"input": "1\n1 1\n11100 1\n", "output": ["<\n"]}, {"input": "1\n2992743 0\n1801851 0\n", "output": [">\n"]}, {"input": "1\n122308 0\n1001011 0\n", "output": ["<\n"]}, {"input": "1\n25 5\n1990 3\n", "output": [">\n"]}, {"input": "5\n2 1\n33 -1\n10 2\n100 1\n1999 0\n2 0\n1 0\n1 0\n29 0\n1 0\n", "output": [">\n=\n>\n=\n>\n"]}, {"input": "1\n1927 -3\n16 2\n", "output": ["<\n"]}, {"input": "1\n132 2\n2693 1\n", "output": ["<\n"]}, {"input": "1\n2 4\n768 0\n", "output": [">\n"]}, {"input": "1\n5 14\n1216 0\n", "output": [">\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1000 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000001 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "1\n2 2\n011 5\n", "output": ["<\n"]}, {"input": "1\n7 0\n1 1\n", "output": ["<\n"]}, {"input": "1\n1111 3\n950 0\n", "output": [">\n"]}, {"input": "1\n7 2\n1076 2\n", "output": ["<\n"]}, {"input": "1\n12001 59\n11 1\n", "output": [">\n"]}, {"input": "1\n1 0\n11100 1\n", "output": ["<\n"]}, {"input": "1\n2992743 1\n1801851 0\n", "output": [">\n"]}, {"input": "1\n25 4\n1990 0\n", "output": [">\n"]}, {"input": "5\n2 1\n33 -1\n10 2\n100 1\n1999 0\n2 0\n1 0\n1 0\n29 0\n2 0\n", "output": [">\n=\n>\n=\n>\n"]}, {"input": "3\n1 3\n100 1\n8 0\n200 0\n5 0\n465 1\n", "output": ["=\n<\n<\n"]}, {"input": "1\n132 2\n73 1\n", "output": [">\n"]}, {"input": "1\n5 19\n1216 0\n", "output": [">\n"]}, {"input": "1\n2 1\n011 5\n", "output": ["<\n"]}, {"input": "1\n7 0\n1 2\n", "output": ["<\n"]}, {"input": "1\n1111 3\n1246 0\n", "output": [">\n"]}, {"input": "1\n12001 59\n11 2\n", "output": [">\n"]}, {"input": "1\n1 0\n11100 0\n", "output": ["<\n"]}, {"input": "1\n2992743 1\n28222 0\n", "output": [">\n"]}, {"input": "1\n34 4\n1990 0\n", "output": [">\n"]}, {"input": "3\n1 3\n100 1\n8 0\n200 0\n5 0\n465 2\n", "output": ["=\n<\n<\n"]}, {"input": "1\n132 1\n73 1\n", "output": [">\n"]}, {"input": "1\n5 19\n1216 1\n", "output": [">\n"]}, {"input": "23\n1 3\n100 1\n2 3\n200 1\n3 3\n300 1\n4 3\n400 1\n5 3\n500 1\n6 3\n600 1\n1 9\n1000000 4\n10 9\n1000000 4\n100 8\n1000000 4\n1101 7\n1000000 4\n10000 6\n1000000 4\n100000 5\n1000000 4\n1000000 4\n1000000 4\n1000000 4\n100000 5\n1000000 4\n10000 6\n1000000 4\n1000 7\n1000000 4\n100 8\n1000000 4\n10 9\n1000000 4\n1 10\n999999 1\n1000000 1\n1000011 1\n999999 1\n999998 1\n1793536 1\n999999 1\n999998 1\n", "output": ["=\n=\n=\n=\n=\n=\n<\n=\n=\n>\n=\n=\n=\n=\n=\n=\n=\n=\n=\n<\n>\n<\n>\n"]}, {"input": "1\n7 0\n2 2\n", "output": ["<\n"]}, {"input": "1\n1111 3\n2222 0\n", "output": [">\n"]}, {"input": "1\n12001 59\n21 2\n", "output": [">\n"]}, {"input": "1\n1 0\n11000 1\n", "output": ["<\n"]}, {"input": "1\n2992743 1\n28222 1\n", "output": [">\n"]}, {"input": "1\n7 4\n1990 0\n", "output": [">\n"]}, {"input": "1\n229 1\n73 1\n", "output": [">\n"]}, {"input": "1\n2 19\n1216 1\n", "output": [">\n"]}], "task_id": "codecontest/113", "prompt": "Monocarp wrote down two numbers on a whiteboard. Each of the numbers has a distinct form: a positive integer x followed by p zeros appended at its end.\n\nNow Monocarp asks you to compare these two numbers. Can you help him?\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers x_1 and p_1 (1 \u2264 x_1 \u2264 10^6; 0 \u2264 p_1 \u2264 10^6) \u2014 the description of the first number.\n\nThe second line of each testcase contains two integers x_2 and p_2 (1 \u2264 x_2 \u2264 10^6; 0 \u2264 p_2 \u2264 10^6) \u2014 the description of the second number.\n\nOutput\n\nFor each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.\n\nExample\n\nInput\n\n\n5\n2 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n\n\nOutput\n\n\n&gt;\n=\n&lt;\n=\n&lt;\n\nNote\n\nThe comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.", "repair_prompt": ["Monocarp wrote down two numbers on a whiteboard. Each of the numbers has a distinct form: a positive integer x followed by p zeros appended at its end.\n\nNow Monocarp asks you to compare these two numbers. Can you help him?\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers x_1 and p_1 (1 \u2264 x_1 \u2264 10^6; 0 \u2264 p_1 \u2264 10^6) \u2014 the description of the first number.\n\nThe second line of each testcase contains two integers x_2 and p_2 (1 \u2264 x_2 \u2264 10^6; 0 \u2264 p_2 \u2264 10^6) \u2014 the description of the second number.\n\nOutput\n\nFor each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n2 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n\n\nOutput\n\n\n&gt;\n=\n&lt;\n=\n&lt;\n\nNote\n\nThe comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.", "Monocarp wrote down two numbers on a whiteboard. Each of the numbers has a distinct form: a positive integer x followed by p zeros which are appended at its end. There can be several zeros appended but all these zeros come after the integer x.\n\nNow Monocarp asks you to compare these two numbers. Can you help him?\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers x_1 and p_1 (1 \u2264 x_1 \u2264 10^6; 0 \u2264 p_1 \u2264 10^6) \u2014 the description of the first number.\n\nThe second line of each testcase contains two integers x_2 and p_2 (1 \u2264 x_2 \u2264 10^6; 0 \u2264 p_2 \u2264 10^6) \u2014 the description of the second number.\n\nOutput\n\nFor each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n2 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n\n\nOutput\n\n\n&gt;\n=\n&lt;\n=\n&lt;\n\nNote\n\nThe comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.", "Monocarp wrote down two numbers on a whiteboard, each having a distinct form: a positive integer x followed by p zeros appended at its end. Now Monocarp asks you to compare these two numbers. Can you help him?\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers x_1 and p_1 (1 \u2264 x_1 \u2264 10^6; 0 \u2264 p_1 \u2264 10^6) \u2014 the description of the first number.\n\nThe second line of each testcase contains two integers x_2 and p_2 (1 \u2264 x_2 \u2264 10^6; 0 \u2264 p_2 \u2264 10^6) \u2014 the description of the second number.\n\nOutput\n\nFor each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n2 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n\n\nOutput\n\n\n&gt;\n=\n&lt;\n=\n&lt;\n\nNote\n\nThe comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef compare_numbers(test_cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    \"\"\"Compares two numbers formed by appending zeros to a base integer.\n\n    Args:\n        test_cases: A list of tuples, each containing four integers (x1, p1, x2, p2).\n                    x1 and p1 describe the first number, x2 and p2 describe the second number.\n\n    Returns:\n        A list of strings where each string is one of '>', '<', or '=' indicating the comparison result.\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate the effective lengths of the numbers\n        effective_length_1 = len(str(x1)) + p1\n        effective_length_2 = len(str(x2)) + p2\n\n        # Compare effective lengths\n        if effective_length_1 > effective_length_2:\n            results.append('>')\n        elif effective_length_1 < effective_length_2:\n            results.append('<')\n        else:\n            # If effective lengths are equal, compare the base numbers\n            # Adjust the numbers to the same length by appending zeros\n            if x1 * (10 ** (p2 - p1)) > x2:\n                results.append('>')\n            elif x1 * (10 ** (p2 - p1)) < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = []\n    for _ in range(n):\n        x1, p1 = map(int, input().split())\n        x2, p2 = map(int, input().split())\n        test_cases.append((x1, p1, x2, p2))\n\n    # Output interface\n    results = compare_numbers(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef compare_numbers(test_cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    \"\"\"Compares two numbers represented by integers followed by zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing four integers (x1, p1, x2, p2).\n                    x1 and x2 are the base numbers, p1 and p2 are the number of zeros appended.\n\n    Returns:\n        A list of strings where each string is '>', '<', or '=' indicating the comparison result.\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate the effective length of each number\n        len1 = len(str(x1)) + p1\n        len2 = len(str(x2)) + p2\n\n        # Compare based on effective length\n        if len1 > len2:\n            results.append('>')\n        elif len1 < len2:\n            results.append('<')\n        else:\n            # If lengths are equal, compare the numbers directly\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) + tuple(map(int, input().split())) for _ in range(n)]\n    \n    results = compare_numbers(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef compare_numbers(t: int, test_cases: list[tuple[int, int, int, int]]) -> list[str]:\n    \"\"\"Compares two numbers represented by a base integer and a number of zeros appended.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing four integers (x1, p1, x2, p2).\n\n    Returns:\n        A list of strings representing the comparison result for each test case.\n        '<' if the first number is smaller, '>' if the first number is larger, '=' if they are equal.\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate effective lengths\n        len1 = len(str(x1)) + p1\n        len2 = len(str(x2)) + p2\n\n        # Compare effective lengths\n        if len1 > len2:\n            results.append('>')\n        elif len1 < len2:\n            results.append('<')\n        else:\n            # Effective lengths are equal, compare base integers\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = []\n    for _ in range(n):\n        x1, p1 = map(int, input().split())\n        x2, p2 = map(int, input().split())\n        test_cases.append((x1, p1, x2, p2))\n\n    # Output interface\n    results = compare_numbers(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef compare_numbers(test_cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    \"\"\"Compares two numbers represented by a base integer and a number of trailing zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing four integers (x1, p1, x2, p2).\n                    x1 and p1 describe the first number, x2 and p2 describe the second number.\n\n    Returns:\n        A list of strings where each string is one of '>', '<', or '=' indicating the comparison result.\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate the effective length of each number\n        len1 = len(str(x1)) + p1\n        len2 = len(str(x2)) + p2\n\n        # Compare the effective lengths\n        if len1 > len2:\n            results.append('>')\n        elif len1 < len2:\n            results.append('<')\n        else:\n            # If lengths are equal, compare the base integers\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = []\n    for _ in range(n):\n        x1, p1 = map(int, input().split())\n        x2, p2 = map(int, input().split())\n        test_cases.append((x1, p1, x2, p2))\n\n    # Output interface\n    results = compare_numbers(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef compare_numbers(test_cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    \"\"\"Compares two numbers represented by a base integer and appended zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing four integers (x1, p1, x2, p2).\n                    x1 and p1 describe the first number, x2 and p2 describe the second number.\n\n    Returns:\n        A list of strings where each string is '<', '>', or '=' based on the comparison of the two numbers.\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate effective lengths\n        len1 = len(str(x1)) + p1\n        len2 = len(str(x2)) + p2\n        \n        # Compare effective lengths\n        if len1 > len2:\n            results.append('>')\n        elif len1 < len2:\n            results.append('<')\n        else:\n            # If lengths are equal, compare the base integers\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = []\n    for _ in range(n):\n        x1, p1 = map(int, input().split())\n        x2, p2 = map(int, input().split())\n        test_cases.append((x1, p1, x2, p2))\n    \n    results = compare_numbers(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef compare_numbers(t: int, test_cases: list[tuple[int, int, int, int]]) -> list[str]:\n    \"\"\"Compares two numbers based on their base integer and the number of trailing zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, int, int]]): List of tuples containing the test cases.\n            Each tuple consists of four integers: x1, p1, x2, p2.\n\n    Returns:\n        list[str]: List of comparison results for each test case.\n    \"\"\"\n    results = []\n    \n    for x1, p1, x2, p2 in test_cases:\n        # Calculate effective lengths\n        effective_length_1 = len(str(x1)) + p1\n        effective_length_2 = len(str(x2)) + p2\n        \n        # Compare effective lengths\n        if effective_length_1 > effective_length_2:\n            results.append('>')\n        elif effective_length_1 < effective_length_2:\n            results.append('<')\n        else:\n            # If effective lengths are equal, compare base values\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        x1, p1 = map(int, input().split())\n        x2, p2 = map(int, input().split())\n        test_cases.append((x1, p1, x2, p2))\n    \n    results = compare_numbers(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef compare_numbers(test_cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    \"\"\"Compares two numbers represented by a base integer and appended zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing four integers (x1, p1, x2, p2).\n                    x1 and p1 describe the first number, x2 and p2 describe the second number.\n\n    Returns:\n        A list of strings, each representing the result of the comparison ('<', '>', or '=').\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate the effective length of each number\n        len1 = len(str(x1)) + p1\n        len2 = len(str(x2)) + p2\n        \n        # Compare the effective lengths\n        if len1 > len2:\n            results.append('>')\n        elif len1 < len2:\n            results.append('<')\n        else:\n            # If lengths are equal, compare the base integers\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) + tuple(map(int, input().split())) for _ in range(n)]\n    \n    results = compare_numbers(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef compare_numbers(test_cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    \"\"\"Compares two numbers represented by a base integer and a number of trailing zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing four integers (x_1, p_1, x_2, p_2).\n                    x_1 and p_1 describe the first number as x_1 followed by p_1 zeros.\n                    x_2 and p_2 describe the second number as x_2 followed by p_2 zeros.\n\n    Returns:\n        A list of strings where each string is one of '<', '>', or '=' indicating the\n        comparison result of the two numbers for each test case.\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate the effective length of each number\n        len1 = len(str(x1)) + p1\n        len2 = len(str(x2)) + p2\n\n        # Compare the effective lengths\n        if len1 > len2:\n            results.append('>')\n        elif len1 < len2:\n            results.append('<')\n        else:\n            # If lengths are equal, compare the base integers directly\n            # Adjust the numbers to the same length by appending zeros\n            if x1 * (10 ** p1) > x2 * (10 ** p2):\n                results.append('>')\n            elif x1 * (10 ** p1) < x2 * (10 ** p2):\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) + tuple(map(int, input().split())) for _ in range(n)]\n\n    # Call the function\n    results = compare_numbers(test_cases)\n\n    # Output interface\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef compare_numbers(test_cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    \"\"\"Compares two numbers represented by a base integer and a number of zeros appended.\n\n    Args:\n        test_cases: A list of tuples, each containing four integers (x1, p1, x2, p2).\n                    x1 and p1 describe the first number as x1 followed by p1 zeros.\n                    x2 and p2 describe the second number as x2 followed by p2 zeros.\n\n    Returns:\n        A list of strings where each string is one of '>', '<', or '=' indicating\n        the comparison result of the two numbers for each test case.\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate the effective length of each number\n        len1 = len(str(x1)) + p1\n        len2 = len(str(x2)) + p2\n\n        # Compare the effective lengths\n        if len1 > len2:\n            results.append('>')\n        elif len1 < len2:\n            results.append('<')\n        else:\n            # If lengths are equal, compare the base integers\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = []\n    for _ in range(n):\n        x1, p1 = map(int, input().split())\n        x2, p2 = map(int, input().split())\n        test_cases.append((x1, p1, x2, p2))\n    \n    results = compare_numbers(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef compare_numbers(test_cases: List[Tuple[int, int, int, int]]) -> List[str]:\n    \"\"\"Compares two numbers represented by a base integer and a number of trailing zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing four integers (x_1, p_1, x_2, p_2).\n                    x_1 and p_1 describe the first number, x_2 and p_2 describe the second number.\n\n    Returns:\n        A list of strings where each string is one of '>', '<', or '=' indicating the comparison result.\n    \"\"\"\n    results = []\n    for x1, p1, x2, p2 in test_cases:\n        # Calculate the effective length of each number\n        len1 = len(str(x1)) + p1\n        len2 = len(str(x2)) + p2\n\n        if len1 > len2:\n            results.append('>')\n        elif len1 < len2:\n            results.append('<')\n        else:\n            # If effective lengths are equal, compare the numbers directly\n            # Normalize the numbers by adding zeros to the shorter one\n            if p1 > p2:\n                x2 *= 10 ** (p1 - p2)\n            elif p2 > p1:\n                x1 *= 10 ** (p2 - p1)\n\n            if x1 > x2:\n                results.append('>')\n            elif x1 < x2:\n                results.append('<')\n            else:\n                results.append('=')\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) + tuple(map(int, input().split())) for _ in range(n)]\n\n    # Output interface\n    results = compare_numbers(test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires comparing two numbers represented by a base integer and a number of zeros appended. The challenge is to handle potentially very large numbers efficiently without directly constructing them, as this could lead to performance issues. The solution should focus on comparing the effective lengths and values of these numbers.\nrequirement pool:\n- Efficiently compare numbers with appended zeros without constructing them\n- Handle up to 10,000 test cases efficiently\n- Provide clear and concise output for each comparison\n- Ensure the solution is robust against edge cases\n- Optimize for performance with large input sizes\nWe will compare the numbers by considering their effective lengths and values without constructing the full numbers. The key is to compare the lengths first (x_1 + p_1 vs x_2 + p_2) and then compare the base numbers if the lengths are equal. This approach avoids inefficiencies with very large numbers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'positive integer': means that both x_1 and x_2 are greater than 0.\n    'zeros appended': means that the number is formed by appending p_1 or p_2 zeros to x_1 or x_2 respectively.\n\n# [phrase showing quantity relationship]\n    'smaller than': means the first number is less than the second number.\n    'greater than': means the first number is more than the second number.\n    'equal': means both numbers are the same.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, calculate the effective length of both numbers by adding the number of zeros to the length of the integer.\n    2. Compare the effective lengths:\n       - If the effective length of the first number is greater, print '>'.\n       - If the effective length of the second number is greater, print '<'.\n       - If they are equal, compare the base numbers (x_1 and x_2):\n         - If x_1 > x_2, print '>'.\n         - If x_1 < x_2, print '<'.\n         - If x_1 == x_2, print '='.\n\n# [edge case]\n    Case 1: (x_1=1, p_1=1000000), (x_2=10, p_2=999999) = '='\n    Explanation: Both numbers have the same effective length and value when zeros are appended.\n\n    Case 2: (x_1=1000000, p_1=0), (x_2=999999, p_2=0) = '>'\n    Explanation: The first number is greater than the second number without any zeros appended.\n\n    Case 3: (x_1=1, p_1=0), (x_2=1, p_2=1000000) = '<'\n    Explanation: The second number is much larger due to the appended zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing effective lengths and base numbers will suffice.\n", "requirement analysis:\nThe requirements focus on comparing two numbers represented by integers followed by zeros. The challenge lies in efficiently handling large numbers and ensuring accurate comparisons across multiple test cases. The solution must be optimized for performance given the high input limits.\nrequirement pool:\n- Implement efficient number comparison logic.\n- Ensure accurate results for all possible test cases.\n- Optimize performance for handling large numbers.\n- Provide clear output format as specified.\n- Consider edge cases and potential input errors.\nWe will implement a function that compares two numbers represented by integers followed by zeros. The challenge is efficiently handling large numbers and ensuring accurate comparisons across multiple test cases. We will use basic arithmetic operations to compare the numbers without converting them to actual large integers, which optimizes performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'positive integer': means that the numbers x_1 and x_2 are greater than zero.\n    'zeros appended': means that the numbers are formed by appending p_1 and p_2 zeros to x_1 and x_2 respectively.\n\n# [phrase showing quantity relationship]\n    'followed by': indicates the number of zeros appended to the integer.\n    'greater than', 'smaller than', 'equal': these are used to compare the two numbers formed.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. For each test case, calculate the effective length of each number by adding the number of digits in x_1 and x_2 to p_1 and p_2 respectively.\n    2. Compare the effective lengths:\n       - If the effective length of the first number is greater, print '>'.\n       - If the effective length of the second number is greater, print '<'.\n       - If they are equal, compare the numbers directly:\n         - If x_1 > x_2, print '>'.\n         - If x_1 < x_2, print '<'.\n         - If x_1 == x_2, print '='.\n\n# [edge case] \n    (x_1=1, p_1=0), (x_2=10, p_2=0) = '<'\n    Explanation: The first number is 1 and the second number is 10, so 1 < 10.\n    \n    (x_1=1000000, p_1=0), (x_2=1, p_2=6) = '='\n    Explanation: Both numbers are effectively 1000000, so they are equal.\n    \n    (x_1=999999, p_1=5), (x_2=1000000, p_2=4) = '>'\n    Explanation: The first number is effectively larger due to more zeros appended.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing effective lengths and then values will handle all cases correctly.\n", "requirement analysis:\nThe task requires comparing two numbers represented by a base integer and a number of zeros appended. The challenge lies in efficiently handling large numbers due to the constraints. The solution must be optimized for both time and space complexity to handle up to 10,000 test cases with large values of x and p.\nrequirement pool:\n- Develop an efficient comparison algorithm for large numbers with appended zeros.\n- Ensure the solution is optimized for handling up to 10,000 test cases.\n- Implement edge case handling for numbers with maximum constraints.\n- Provide clear and concise output for each comparison.\n- Optimize the code for readability and maintainability.\nWe will implement a function that compares two numbers represented by a base integer and a number of zeros appended. The approach will focus on comparing the effective length of the numbers first, and if they are equal, compare the base integers directly. This avoids constructing large numbers explicitly, ensuring efficiency even with large values of x and p.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'positive integer': Each number x is a positive integer, meaning it is greater than zero.\n    'zeros appended': The number is formed by appending p zeros to the integer x, effectively multiplying x by 10^p.\n\n# [phrase showing quantity relationship]\n    'followed by p zeros': This means the number is x * 10^p. The quantity relationship here is that the number of zeros appended determines the magnitude of the number.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, calculate the effective length of the numbers by adding the length of x and p.\n2. Compare the effective lengths:\n   - If the first number's effective length is greater, it is larger.\n   - If the second number's effective length is greater, it is larger.\n3. If the effective lengths are equal, compare the base integers directly:\n   - If x_1 > x_2, the first number is larger.\n   - If x_1 < x_2, the second number is larger.\n   - If x_1 == x_2, the numbers are equal.\n\n# [edge case]\n    (1, 1000000) vs (1, 999999) = >\n    Explanation: The first number has one more zero appended than the second, making it larger.\n    \n    (1000000, 0) vs (1, 6) = =\n    Explanation: Both numbers are effectively 1000000.\n    \n    (123456, 3) vs (1234567, 2) = <\n    Explanation: The first number is 123456000 and the second is 123456700, so the second is larger.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of comparing effective lengths and then base integers covers all scenarios.\n", "requirement analysis:\nThe task requires comparing two numbers represented by a base integer and a number of trailing zeros. The challenge is to efficiently handle up to 10,000 test cases and numbers that can be extremely large due to the zeros. The solution must be optimized for both time and space complexity to ensure quick processing and accurate results.\nrequirement pool:\n- Implement efficient comparison logic for large numbers\n- Optimize for handling up to 10,000 test cases\n- Ensure clear and concise output format\n- Handle edge cases such as equal numbers with different zero counts\n- Provide user-friendly error messages for invalid inputs\nWe will implement a function that compares two numbers represented by a base integer and a number of trailing zeros. The approach will involve calculating the effective length of each number and comparing them directly. If the lengths are equal, we will compare the base integers. This ensures efficient handling of large numbers and up to 10,000 test cases. We will use Python's native integer handling capabilities, which can manage large numbers efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'positive integer': Each number is a positive integer, meaning it is greater than zero.\n    'trailing zeros': The zeros are appended to the end of the integer, affecting its magnitude.\n\n# [phrase showing quantity relationship]\n    'greater than': Used to compare if one number is larger than another.\n    'smaller than': Used to compare if one number is less than another.\n    'equal': Used to determine if two numbers are the same.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integers x_1, p_1, x_2, and p_2.\n2. Calculate the effective length of each number by adding the length of x_1 and p_1 for the first number, and x_2 and p_2 for the second number.\n3. Compare the effective lengths:\n   - If the first number's length is greater, print '>'.\n   - If the second number's length is greater, print '<'.\n   - If lengths are equal, compare x_1 and x_2 directly:\n     - If x_1 > x_2, print '>'.\n     - If x_1 < x_2, print '<'.\n     - If x_1 == x_2, print '='.\n\n# [edge case] \n    (1, 0) vs (1, 0) = '='\n    Explanation: Both numbers are 1 with no trailing zeros, so they are equal.\n    \n    (10^6, 0) vs (1, 6) = '='\n    Explanation: The first number is 10^6 and the second number is 1 followed by 6 zeros, both are equal to 1000000.\n    \n    (1, 10^6) vs (10^6, 0) = '>'\n    Explanation: The first number is 1 followed by a million zeros, which is much larger than 10^6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing effective lengths and then base integers will handle these cases correctly.\n", "requirement analysis:\nThe task requires comparing two numbers represented by a base integer and appended zeros. The challenge lies in efficiently handling large numbers and ensuring accurate comparisons across multiple test cases.\nrequirement pool:\n- Implement efficient number comparison logic\n- Optimize for large input sizes\n- Ensure clear output format\n- Handle edge cases such as maximum input values\n- Provide user-friendly input method\nWe will implement a function that compares two numbers represented by a base integer and a number of appended zeros. The challenge is to handle large numbers efficiently without directly constructing them, which can be achieved by comparing the lengths and values of the numbers in a strategic manner. We will use basic arithmetic and string manipulation to achieve this.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'positive integer': means that the base integer x is always greater than 0.\n    'appended zeros': refers to the number of zeros added to the end of the integer x, represented by p.\n\n# [phrase showing quantity relationship]\n    'followed by': indicates the sequence in which zeros are appended after the integer x.\n    'greater than', 'smaller than', 'equal': these are used to compare the two numbers formed by x and p.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, calculate the effective length of each number by adding the number of zeros (p) to the length of the integer (x).\n    2. Compare the effective lengths of the two numbers:\n       - If one number has a longer effective length, it is larger.\n       - If both have the same effective length, compare the integer values directly.\n    3. Return '<', '>', or '=' based on the comparison.\n\n# [edge case]\n    Compare(1, 0, 1, 0) = '='\n    Explanation: Both numbers are effectively '1', so they are equal.\n    \n    Compare(1000000, 0, 999999, 1) = '='\n    Explanation: The first number is '1000000' and the second is '9999990', both have the same effective length and value.\n    \n    Compare(1, 1000000, 2, 999999) = '<'\n    Explanation: The first number is effectively '1' followed by 1000000 zeros, and the second is '2' followed by 999999 zeros. The second number is larger due to its base integer.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing effective lengths and values will suffice.\n", "requirement analysis:\nThe requirement is to compare two numbers represented by a base integer and a number of trailing zeros. The challenge lies in handling large numbers efficiently without converting them to actual integers due to potential size constraints. The solution should focus on comparing the effective lengths of the numbers and their base values.\nrequirement pool:\n- Implement efficient number comparison logic without converting to full integer form.\n- Ensure the solution handles up to 10,000 test cases efficiently.\n- Provide clear and concise output for each test case.\n- Optimize for large input sizes and trailing zeros.\n- Include error handling for invalid inputs.\nWe will implement a function that compares two numbers based on their base integer and the number of trailing zeros. Instead of converting the numbers to full integer form, we will compare their effective lengths and base values directly. This approach ensures efficiency and accuracy even with large numbers and many test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'positive integer': Each number is a positive integer followed by zeros.\n    'trailing zeros': The zeros appended to the integer x, which affect the magnitude of the number.\n\n# [phrase showing quantity relationship]\n    'followed by': Indicates the sequence where zeros are appended after the integer x.\n    'greater than', 'smaller than', 'equal': These are used to compare the two numbers based on their magnitude.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, calculate the effective length of each number by adding the number of digits in x and the number of trailing zeros p.\n    2. Compare the effective lengths of the two numbers:\n       - If one number has a longer effective length, it is greater.\n       - If both have the same effective length, compare their base values (x_1 and x_2).\n    3. Print '<', '>', or '=' based on the comparison result.\n\n# [edge case]\n    Compare(1, 1000000) with (1000000, 0) = '='\n    Explanation: Both numbers have an effective length of 7 digits, and their base values are equal when considering trailing zeros.\n    \n    Compare(1000000, 0) with (999999, 1) = '>'\n    Explanation: The first number has an effective length of 7 digits, while the second has an effective length of 8 digits, making the second number greater.\n    \n    Compare(1, 0) with (1, 0) = '='\n    Explanation: Both numbers are identical with no trailing zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing effective lengths and base values will suffice.\n", "requirement analysis:\nThe task requires comparing two numbers represented by a base integer and a number of appended zeros. The challenge lies in efficiently handling large numbers and ensuring accurate comparisons across multiple test cases. The solution must be optimized for performance given the constraints on input size.\nrequirement pool:\n- Implement efficient number comparison logic\n- Optimize for large input sizes\n- Ensure clear output format\n- Handle edge cases gracefully\n- Provide user-friendly input method\nWe will implement a function to compare two numbers represented by a base integer and a number of appended zeros. The challenge is to handle large numbers efficiently without directly constructing them, which can be done by comparing the lengths and values of the numbers. We will use Python's built-in capabilities for handling integers and comparisons.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct form': means that the numbers are represented in a unique way by appending zeros to a base integer.\n    'compare': means to determine the relationship between two numbers (greater, less, or equal).\n\n# [phrase showing quantity relationship]\n    'appended': means adding zeros to the end of a number, which increases its magnitude.\n    'greater than', 'smaller than', 'equal': these are the comparison operations to determine the relationship between two numbers.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the integers x_1, p_1, x_2, and p_2.\n    2. Calculate the effective length of each number by adding the number of zeros (p_1 and p_2) to the length of x_1 and x_2 respectively.\n    3. Compare the effective lengths:\n       - If the length of the first number is greater than the second, print '>'.\n       - If the length of the first number is less than the second, print '<'.\n       - If lengths are equal, compare the base integers x_1 and x_2:\n         - If x_1 > x_2, print '>'.\n         - If x_1 < x_2, print '<'.\n         - If x_1 == x_2, print '='.\n\n# [edge case]\n    Compare(1, 0, 10, 0) = '<'\n    Explanation: The first number is 1 and the second number is 10. Since 1 < 10, the output is '<'.\n    \n    Compare(1000000, 0, 999999, 1) = '='\n    Explanation: The first number is 1000000 and the second number is 9999990. Both numbers have the same magnitude when zeros are appended.\n    \n    Compare(12345, 5, 12345, 5) = '='\n    Explanation: Both numbers are identical in value and form when zeros are appended.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing lengths and values will suffice.\n", "requirement analysis:\nThe requirement is to compare two numbers represented by a base integer and a number of trailing zeros. The challenge lies in efficiently handling large numbers due to the potential size of the trailing zeros. The solution must be optimized for performance and provide clear output for each test case.\nrequirement pool:\n- Implement efficient number comparison logic.\n- Optimize for large input sizes.\n- Ensure clear and concise output format.\n- Handle edge cases such as equal numbers.\n- Provide user-friendly input handling.\nWe will implement a function that compares two numbers represented by a base integer and a number of trailing zeros. The challenge is to handle potentially large numbers efficiently. We will use Python's built-in integer type, which can handle arbitrarily large numbers, to perform the comparison. The function will compare the effective lengths of the numbers first, and if they are equal, it will compare the base integers directly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct form': Each number is represented by a base integer followed by a certain number of zeros.\n    'compare': Determine the relationship between two numbers (greater than, less than, or equal).\n\n# [phrase showing quantity relationship]\n    'followed by p zeros': This means the number is x * 10^p. In code, this can be represented by multiplying the base integer by 10 raised to the power of the number of zeros.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integers x_1, p_1, x_2, and p_2.\n2. Calculate the effective length of each number by adding the length of the base integer to the number of zeros.\n3. Compare the effective lengths:\n   - If one is greater, determine the larger number based on length.\n   - If they are equal, compare the base integers directly.\n4. Output the comparison result for each test case.\n\n# [edge case]\n    (1, 1000000) and (1, 999999) = >\n    Explanation: The first number has one more zero than the second, making it larger.\n    \n    (1000000, 0) and (1, 6) = =\n    Explanation: Both numbers are effectively 1000000.\n    \n    (123456, 0) and (123456, 0) = =\n    Explanation: Both numbers are identical.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing effective lengths and then base integers will handle these cases correctly.\n", "requirement analysis:\nThe task requires comparing two numbers represented by a base integer and a number of zeros appended. The challenge lies in efficiently handling large numbers and ensuring accurate comparisons across multiple test cases.\nrequirement pool:\n- Implement efficient number comparison logic\n- Ensure accurate results for all possible input ranges\n- Optimize performance for high input limits\n- Design intuitive input/output handling\n- Provide clear error messages for invalid inputs\nWe will implement a function to compare two numbers represented by a base integer and a number of zeros appended. The challenge is efficiently handling large numbers and ensuring accurate comparisons across multiple test cases. We will use basic arithmetic operations to compare the numbers without converting them to actual large integers, which can be inefficient. The approach involves comparing the lengths of the numbers first and then the base integers if necessary.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct form': Each number is represented by a base integer followed by a certain number of zeros.\n    'compare': Determine the relationship between two numbers (greater than, less than, or equal).\n\n# [phrase showing quantity relationship]\n    'followed by p zeros': This means the number is x * 10^p. In code, this can be represented by appending p zeros to x or considering the length of the number as x + p.\n    'greater than', 'less than', 'equal': These are comparison operations that can be implemented using comparison operators in Python (>, <, ==).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integers x_1, p_1, x_2, and p_2.\n2. Calculate the effective length of each number as len1 = len(str(x_1)) + p_1 and len2 = len(str(x_2)) + p_2.\n3. Compare len1 and len2:\n   - If len1 > len2, print '>'.\n   - If len1 < len2, print '<'.\n   - If len1 == len2, compare x_1 and x_2:\n     - If x_1 > x_2, print '>'.\n     - If x_1 < x_2, print '<'.\n     - If x_1 == x_2, print '='.\n\n# [edge case]\n    1 0, 1 0 = '='\n    Explanation: Both numbers are 1, so they are equal.\n    \n    1000000 0, 999999 1 = '>'\n    Explanation: The first number is 1000000 and the second is 9999990. The first number is greater.\n    \n    1 1000000, 10 999999 = '='\n    Explanation: Both numbers are effectively the same length and value when considering the zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing lengths and then values will handle these cases correctly.\n", "requirement analysis:\nThe requirement is to compare two numbers represented by a base integer and a number of trailing zeros. The challenge lies in efficiently handling large numbers due to the potential size of the trailing zeros. The solution must be optimized for performance given the constraints of up to 10,000 test cases and large input values.\nrequirement pool:\n- Implement efficient number comparison logic.\n- Ensure the solution handles up to 10,000 test cases.\n- Optimize for large input sizes with trailing zeros.\n- Provide clear and concise output for each test case.\n- Consider edge cases such as equal numbers with different trailing zeros.\nWe will implement a function to compare two numbers represented by a base integer and a number of trailing zeros. The challenge is to efficiently handle large numbers due to the potential size of the trailing zeros. We will use basic arithmetic operations to compare the numbers without actually constructing them, ensuring performance efficiency even for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'positive integer': Each number is a positive integer, meaning it is greater than zero.\n    'trailing zeros': The number of zeros appended to the integer, which affects the magnitude of the number.\n\n# [phrase showing quantity relationship]\n    'smaller than': Indicates a comparison where one number is less than another.\n    'greater than': Indicates a comparison where one number is more than another.\n    'equal': Indicates a comparison where two numbers are the same.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integers x_1, p_1, x_2, and p_2.\n2. Calculate the effective length of each number by adding the length of x_1 and p_1 for the first number, and x_2 and p_2 for the second number.\n3. Compare the effective lengths:\n   - If the effective length of the first number is greater, print '>'.\n   - If the effective length of the second number is greater, print '<'.\n   - If they are equal, compare x_1 * 10^p_1 with x_2 * 10^p_2:\n     - If x_1 * 10^p_1 is greater, print '>'.\n     - If x_2 * 10^p_2 is greater, print '<'.\n     - If they are equal, print '='.\n\n# [edge case] \n    (1, 0) and (1, 0) = '='\n    Explanation: Both numbers are 1 with no trailing zeros, so they are equal.\n    \n    (1000000, 0) and (1, 6) = '='\n    Explanation: The first number is 1000000 and the second number is also 1000000 (1 followed by 6 zeros), so they are equal.\n    \n    (1, 1000000) and (2, 999999) = '<'\n    Explanation: The first number is 1 followed by 1000000 zeros, which is smaller than 2 followed by 999999 zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of comparing effective lengths and then comparing the numbers directly if necessary will handle all edge cases.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 897, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers x_1 and p_1 (1 \u2264 x_1 \u2264 10^6; 0 \u2264 p_1 \u2264 10^6) \u2014 the description of the first number.\n\nThe second line of each testcase contains two integers x_2 and p_2 (1 \u2264 x_2 \u2264 10^6; 0 \u2264 p_2 \u2264 10^6) \u2014 the description of the second number.\n\nOutput\n\nFor each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.\n\nExample\n\nInput\n\n\n5\n2 1\n19 0\n10 2\n100 1\n1999 0\n2 3\n1 0\n1 0\n99 0\n1 2\n\n\nOutput\n\n\n&gt;\n=\n&lt;\n=\n&lt;\n\nNote\n\nThe comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.", "mutate_method": "rephrase_one", "parent_index": 498}
