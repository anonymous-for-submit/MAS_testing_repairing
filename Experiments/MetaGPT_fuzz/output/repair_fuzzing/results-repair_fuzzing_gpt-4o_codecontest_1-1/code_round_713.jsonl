{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem concerning a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, consider n = 4. The number 17 is special. It can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him determine the k-th special number if they are sorted in ascending order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem concerning a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, consider n = 4. The number 17 is special. It can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him determine the k-th special number if they are sorted in ascending order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem concerning a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, consider n = 4. The number 17 is special. It can be written as 4^0 + 4^2 = 1 + 16 = 17. However, 9 is not a special number in this sequence.\n\nTheofanis asks you to help him determine the k-th special number if they are sorted in ascending order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem concerning a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, consider n = 4, where 17 is special as it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him determine the k-th special number if they are sorted in ascending order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of n. The k-th special number\n    refers to the k-th number in the sequence of special numbers when sorted\n    in ascending order.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to read input and output the results.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        test_cases.append((n, k))\n        index += 2\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Call the function and get results\n    results = find_kth_special_number(t, test_cases)\n    \n    # Output each result\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Compute the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    num_test_cases = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(num_test_cases)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Compute the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = compute_special_number(n, k)\n        results.append(special_number)\n    return results\n\ndef compute_special_number(n: int, k: int) -> int:\n    \"\"\"Compute the k-th special number for given n using binary representation of k.\n\n    Args:\n        n: The base number for powers.\n        k: The position in the sequence of special numbers.\n\n    Returns:\n        The k-th special number modulo 10^9+7.\n    \"\"\"\n    special_number = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            special_number = (special_number + power) % MODULO\n        power = (power * n) % MODULO\n        k //= 2\n    return special_number\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    num_test_cases = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(num_test_cases)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Compute the k-th special number for each test case using base-n representation.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains n and k.\n\n    Returns:\n        List[int]: List of k-th special numbers modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of n. The k-th special number\n    is the k-th number in the sequence of special numbers when sorted in\n    ascending order.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires computing the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are modulo 10^9+7.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Support up to 10,000 test cases\n- Optimize for both time and space complexity\nWe will use a mathematical approach to compute the k-th special number efficiently. The key observation is that the k-th special number can be represented as a sum of distinct powers of n, where the binary representation of k determines which powers are included. This allows us to compute the result in logarithmic time relative to k by iterating over the bits of k and calculating the corresponding powers of n. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure the solution is efficient and correct.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater).\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest.\n\n# [code logic]\n    - Parse the input to get the number of test cases, t.\n    - For each test case, read the values of n and k.\n    - Convert k to its binary representation.\n    - For each bit in the binary representation of k, calculate the corresponding power of n and sum them up to get the k-th special number.\n    - Apply modulo 10^9+7 to the result to handle large numbers.\n    - Output the result for each test case.\n\n# [edge case]\n    Input: 1 1\n    Output: 1\n    Explanation: For n = 1, the sequence is [1, 2, 3, ...]. The first special number is 1.\n\n    Input: 2 1\n    Output: 1\n    Explanation: For n = 2, the sequence is [1, 2, 3, ...]. The first special number is 1.\n\n    Input: 10^9 1\n    Output: 1\n    Explanation: For n = 10^9, the sequence starts with [1, ...]. The first special number is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases by iterating over the bits of k and calculating powers of n accordingly.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n and k values across multiple test cases. The special number is defined as a sum of different non-negative powers of n. The solution must handle large values efficiently and return results modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance\nWe will use a mathematical approach to determine the k-th special number. The key observation is that each special number can be represented as a sum of distinct powers of n. This is similar to representing a number in a base-n numeral system, where each digit is either 0 or 1. The k-th special number can be found by converting k to its binary representation and interpreting it as a base-n number. This approach is efficient and handles large values of n and k well. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are within the specified modulo constraint.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer. In code, this can be implemented by iterating over powers of n and checking combinations.\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. In code, this means ensuring that when generating or selecting numbers, they are considered in increasing order.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Convert k to its binary representation.\n3. Interpret this binary representation as a base-n number to find the k-th special number.\n4. Use modular arithmetic to ensure the result is within the modulo constraint (10^9+7).\n5. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1 = 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 2: n = 10^9, k = 1 = 1\n    Explanation: Even for large n, the first special number is still 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Explanation: This tests the upper limit of k. The expected output would be a large number modulo 10^9+7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to its binary representation and interpreting it as a base-n number inherently handles these cases.\n", "requirement analysis:\nThe requirement is to determine the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, providing results modulo 10^9+7.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Optimize for speed and memory usage\n- Ensure accuracy of results modulo 10^9+7\n- Provide clear and concise output format\nWe will use a mathematical approach to compute the k-th special number efficiently. The key observation is that the k-th special number in base n can be represented as the k-th number in base n using digits 0 and 1 only. This is because each special number is a sum of distinct powers of n, which corresponds to binary representation in base n. We will convert k to its binary representation and interpret it as a number in base n. This approach ensures efficient computation even for large values of n and k.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given base n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or positive). In code, this can be implemented by iterating over powers of n and checking combinations.\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating or accessing the k-th special number, the sequence must be ordered.\n\n# [code logic]\n    1. Convert the integer k to its binary representation.\n    2. Interpret this binary representation as a number in base n, where each binary digit corresponds to a power of n.\n    3. Compute the sum of these powers to get the k-th special number.\n    4. Return the result modulo 10^9+7 to handle large numbers.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for any base n is always 1 (n^0).\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: The second special number for base n=2 is 2 (2^1).\n\n    Input: 10^9 1\n    Expected Output: 1\n    Explanation: Even for large n, the first special number is always 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by correctly interpreting the binary representation and computing the sum of powers.\n", "requirement analysis:\nThe task requires computing the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently. The result should be returned modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient algorithm to compute k-th special number.\n- Handle large input sizes for n and k.\n- Implement modulo operation to manage large outputs.\n- Optimize for multiple test cases.\n- Provide clear and concise output format.\nWe will use a mathematical approach to generate special numbers by considering the binary representation of k. Each bit in the binary representation corresponds to a power of n, which allows us to efficiently compute the k-th special number. We will use Python's built-in capabilities to handle large integers and apply modulo operation to ensure results are within the specified range.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over powers of n and checking combinations.\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This affects how we generate and store the sequence.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Generate special numbers using the binary representation of integers up to k. Each bit in the binary representation corresponds to a power of n.\n    3. Calculate the sum for each combination of powers to form special numbers.\n    4. Sort the special numbers in ascending order.\n    5. Retrieve the k-th special number from the sorted list.\n    6. Apply modulo operation with 10^9+7 to ensure the result is within the specified range.\n    7. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Edge Case 3: n = 3, k = 10^9\n    Expected Output: (result modulo 10^9+7)\n    Explanation: The k-th special number for large k will be large, requiring modulo operation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by considering binary representation and applying modulo operation.\n", "requirement analysis:\nThe problem requires determining the k-th special number for given n and k values. A special number is defined as a sum of distinct non-negative powers of n. The solution must efficiently handle large inputs and provide results modulo 10^9+7. The challenge lies in efficiently computing the k-th special number without generating all previous numbers.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and memory usage\nWe will use a mathematical approach to compute the k-th special number directly using binary representation. Each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of k. This allows us to efficiently compute the k-th special number without generating all previous numbers. We will use Python's built-in capabilities for handling large integers and apply modulo 10^9+7 to ensure the results fit within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over powers of n and checking combinations that sum to the desired number.\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This affects how we determine the k-th special number, ensuring we select the correct position in the sorted sequence.\n\n# [code logic]\n    - Convert k to its binary representation.\n    - Interpret each bit in the binary representation as a power of n.\n    - Sum the distinct powers of n where the corresponding bit in k's binary representation is 1.\n    - Apply modulo 10^9+7 to the result to ensure it fits within constraints.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: The second special number for n=2 is 2 (n^1).\n\n    Input: 3 1\n    Expected Output: 1\n    Explanation: The first special number for n=3 is also 1 (n^0).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by correctly interpreting the binary representation of k and summing the appropriate powers of n.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n and k values across multiple test cases. The solution must efficiently handle large values of n and k, ensuring results are accurate and within the constraints of modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large input values for n and k\n- Ensure output is modulo 10^9+7\n- Format output correctly for multiple test cases\n- Optimize for performance and scalability\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly compute the k-th special number. This approach is efficient and scales well with large values of n and k. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over powers of n and checking combinations that sum to the desired number.\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This affects how we determine the k-th special number, ensuring we select the correct position in the sorted sequence.\n\n# [code logic]\n    - Convert k to its base-n representation.\n    - Compute the k-th special number by summing distinct powers of n based on the base-n representation.\n    - Use modular arithmetic to ensure the result is within the constraints (modulo 10^9+7).\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Input: 10^9 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Input: 2 10^9\n    Expected Output: (large number modulo 10^9+7)\n    Explanation: For large k, the k-th special number will be large, and we need to ensure it is computed modulo 10^9+7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for converting k to base-n and computing the sum of powers inherently handles these cases. However, ensure that modular arithmetic is applied consistently to prevent overflow and meet constraints.\n", "requirement analysis:\nThe requirement is to determine the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are output modulo 10^9+7.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and memory usage\nWe will use a mathematical approach to determine the k-th special number by leveraging the properties of powers of n. The k-th special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of k. This approach is efficient and can handle large values of n and k. We will use Python's built-in capabilities for handling large integers and apply modulo 10^9+7 to ensure the results fit within the required constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'k-th': This indicates the position of the special number in the sorted sequence. It means we need to find the k-th smallest special number.\n\n# [degree adverb] \n    'increasing order': This means that the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Convert k to its binary representation.\n    3. Interpret each bit in the binary representation as a power of n, where the bit is set (1).\n    4. Sum these powers to get the k-th special number.\n    5. Apply modulo 10^9+7 to the result to ensure it fits within the required constraints.\n    6. Output the result for each test case.\n\n# [edge case] \n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: A large number modulo 10^9+7\n    Explanation: This tests the upper limit of k and ensures that the code handles large values correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of converting k to binary and summing powers of n inherently handles these cases.\n", "requirement analysis:\nThe task requires computing the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are output modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for speed and memory usage\nWe will use a mathematical approach to generate the k-th special number by considering the binary representation of k. Each bit in the binary representation corresponds to a power of n, which allows us to efficiently compute the sum of distinct powers of n. This approach ensures that we handle large values of n and k efficiently. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are output modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, if n = 4, then 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over the binary representation of k and using each bit to determine whether to include a corresponding power of n in the sum.\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This affects how we determine the k-th special number, as we need to ensure the sequence is ordered correctly.\n\n# [code logic]\n    - Convert k to its binary representation.\n    - Initialize a variable to store the special number.\n    - Iterate over each bit in the binary representation of k.\n    - For each bit that is set (i.e., equals 1), add the corresponding power of n to the special number.\n    - Return the special number modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number when n = 2 is simply 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: Even with a very large n, the first special number is always 1 because it corresponds to n^0.\n\n    Edge Case 3: n = 3, k = 8\n    Expected Output: 27\n    Explanation: The eighth special number for n = 3 is calculated as 3^3 = 27.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of converting k to binary and using powers of n inherently handles these cases correctly.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases efficiently, with n and k values as large as 10^9. The output must be modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient algorithm to compute special numbers\n- Handle large values of n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and scalability\nWe will use a mathematical approach to determine the k-th special number. A special number can be represented as a sum of distinct powers of n. To find the k-th special number, we can convert k to its binary representation and interpret it as a base-n number. This approach leverages the fact that each bit in the binary representation of k corresponds to a power of n, allowing us to efficiently compute the k-th special number. We will use Python's built-in capabilities for handling large integers and apply modulo 10^9+7 to manage large outputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given number n.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over powers of n and checking combinations.\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating or selecting the k-th special number, the sequence must be ordered.\n\n# [code logic]\n1. Convert k to its binary representation.\n2. Interpret the binary representation as a base-n number, where each bit corresponds to a power of n.\n3. Calculate the sum of these powers to determine the k-th special number.\n4. Apply modulo 10^9+7 to the result to handle large numbers.\n5. Repeat for each test case.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: For n=2, the second special number is 2 (2^1).\n\n    Input: 10^9 1\n    Expected Output: 1\n    Explanation: Even for very large n, the first special number remains 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by correctly interpreting the binary representation and applying modulo operation.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are output modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Ensure correct input/output format\n- Optimize for speed and accuracy\nWe will use a mathematical approach to determine the k-th special number by leveraging the properties of powers of n. The k-th special number can be represented in base-n as a binary number where each bit represents whether a particular power of n is included in the sum. This approach allows us to efficiently compute the k-th special number by converting k to its binary form and interpreting it as a sum of powers of n. We will use Python's built-in capabilities to handle large integers and modular arithmetic to ensure results are within the required constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in ascending order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or positive).\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest.\n\n# [code logic]\n    - Convert k to its binary representation.\n    - Interpret the binary representation as a sum of powers of n, where each bit indicates whether a particular power of n is included.\n    - Compute the sum using powers of n based on the binary representation.\n    - Apply modulo 10^9+7 to the result to ensure it fits within the required constraints.\n    - Repeat the above steps for each test case.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: The second special number for n=2 is 2^1 = 2.\n\n    Input: 3 1\n    Expected Output: 1\n    Explanation: The first special number for n=3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of converting k to binary and interpreting it as a sum of powers of n inherently handles these cases.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 713, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "rephrase_one", "parent_index": 262}
