{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nWrite code to implement the sorting method described.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nWrite code to implement the sorting method described.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending. He prefers this order because it reflects the natural progression in alphabetical arrangement. While Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nWrite code to implement the sorting method described.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books, where each book title is represented by a string s_i numbered from 1 to n, each with length m, and Andi really wants to sort the book lexicographically ascending while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly, whereas the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds: * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. Write code to implement the sorting method described.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value\n                key.append(ord(char))\n        return key\n\n    # Create a list of tuples (index, book) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order.\n\n    Args:\n        n: Number of books.\n        m: Length of each book title.\n        books: List of book titles.\n\n    Returns:\n        List of indices representing the sorted order of book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given book title.\n\n        Args:\n            title: The book title to generate the sort key for.\n\n        Returns:\n            A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: sort descendingly, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: sort ascendingly, use ASCII value\n                key.append(ord(char))\n        return key\n\n    # Generate a list of tuples (index, book_title) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on the specified asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd indices (1-based) are sorted in ascending order\n            if i % 2 == 0:\n                key.append((0, char))\n            # Even indices (1-based) are sorted in descending order\n            else:\n                key.append((1, -ord(char)))\n        return key\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in the custom order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Generates a sorting key for a book title based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the sorting key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: sort in descending order\n                key.append(-ord(char))\n            else:\n                # Odd index: sort in ascending order\n                key.append(ord(char))\n        return tuple(key)\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(book: str) -> List:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            book (str): The book title.\n\n        Returns:\n            List: A list of tuples representing the custom sort key.\n        \"\"\"\n        return [(book[i], i % 2 == 0) for i in range(m)]\n\n    # Pair each book with its original index\n    indexed_books = [(book, index + 1) for index, book in enumerate(books)]\n\n    # Sort books using the custom key\n    sorted_books = sorted(indexed_books, key=lambda x: custom_sort_key(x[0]))\n\n    # Extract the original indices of the sorted books\n    sorted_indices = [index for _, index in sorted_books]\n\n    return sorted_indices\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n\n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef asc_desc_ending_sort(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        return [(title[i], -ord(title[i])) if i % 2 == 0 else (title[i], ord(title[i])) for i in range(m)]\n\n    # Create a list of tuples (index, title) to keep track of original indices\n    indexed_titles = list(enumerate(book_titles, start=1))\n\n    # Sort the indexed titles using the custom sort key\n    sorted_titles = sorted(indexed_titles, key=lambda x: custom_sort_key(x[1]))\n\n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in sorted_titles]\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = asc_desc_ending_sort(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef asc_desc_ending_sort(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n: The number of book titles.\n        m: The length of each book title.\n        book_titles: A list of book titles.\n\n    Returns:\n        A list of indices representing the sorted order of book titles.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Creates a custom sort key for a given title.\n\n        Args:\n            title: The book title to create a sort key for.\n\n        Returns:\n            A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd-indexed characters (0-based index) are sorted ascending\n            if i % 2 == 0:\n                key.append((char, True))  # True for ascending\n            # Even-indexed characters (0-based index) are sorted descending\n            else:\n                key.append((char, False))  # False for descending\n        return key\n\n    # Sort the book titles using the custom sort key\n    sorted_titles = sorted(range(n), key=lambda i: custom_sort_key(book_titles[i]))\n\n    # Convert 0-based indices to 1-based indices\n    sorted_indices = [index + 1 for index in sorted_titles]\n\n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    book_titles = [input().strip() for _ in range(n)]\n\n    # Output interface\n    sorted_indices = asc_desc_ending_sort(n, m, book_titles)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on the asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(book: str) -> List:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            book (str): The book title.\n\n        Returns:\n            List: A list of tuples representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(book):\n            # Odd index (1-based) -> Ascending order\n            if (i + 1) % 2 == 1:\n                key.append((0, char))\n            # Even index (1-based) -> Descending order\n            else:\n                key.append((1, -ord(char)))\n        return key\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd-indexed positions (0-based) are sorted ascending\n            if i % 2 == 0:\n                key.append((0, char))\n            # Even-indexed positions (0-based) are sorted descending\n            else:\n                key.append((1, -ord(char)))\n        return key\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        # Create a tuple where odd-indexed characters are sorted ascending\n        # and even-indexed characters are sorted descending\n        return tuple(\n            (ord(title[i]) if i % 2 == 0 else -ord(title[i]))\n            for i in range(m)\n        )\n\n    # Sort the books using the custom key and return the sorted indices\n    sorted_books = sorted(range(n), key=lambda i: custom_sort_key(books[i]))\n    return [index + 1 for index in sorted_books]\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n"], "plans": ["requirement analysis:\nThe requirement is to implement a sorting algorithm that combines both ascending and descending lexicographical order based on character positions. Odd-indexed characters should be sorted in ascending order, while even-indexed characters should be sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Optimize for readability and maintainability\n- Include comprehensive test cases\n- Document the code for future reference\nWe will implement a custom sorting function that sorts the book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting in alphabetical order from A to Z.\n    'lexicographically descending': means sorting in reverse alphabetical order from Z to A.\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the title, if its index is odd, use the character as is for comparison (ascending order).\n   - If its index is even, use the negative of the character's ASCII value for comparison (descending order).\n4. Sort the list of titles using this custom key function.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    1 1\n    A\n    = 1\n    Explanation: With only one book, it remains in its position regardless of sorting rules.\n\n    2 2\n    AB\n    BA\n    = 2 1\n    Explanation: For the first character (odd index), 'A' < 'B', so 'BA' comes before 'AB'.\n\n    3 3\n    ABC\n    BAC\n    CAB\n    = 1 3 2\n    Explanation: At the first differing position (index 0, odd), 'A' < 'B' < 'C', so 'ABC' comes first, followed by 'CAB', then 'BAC'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to implement a custom sorting algorithm for a list of book titles. The sorting should be based on a unique rule where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of a number of book titles, each with a fixed length, and the output should be the indices of these titles sorted according to the specified rule.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Include comprehensive test cases to validate the sorting logic.\n- Document the code to explain the sorting logic and approach.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities, leveraging the key parameter to define our custom sorting logic. The key will be a function that compares characters based on their positions (odd or even) and sorts them accordingly. This approach ensures efficiency and simplicity, handling the maximum input size effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting strings based on dictionary order from A to Z.\n    'lexicographically descending': means sorting strings based on dictionary order from Z to A.\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the string, determine its index (odd or even).\n   - If the index is odd, use the character as is for comparison (ascending order).\n   - If the index is even, use the negative of the character's ASCII value for comparison (descending order).\n4. Sort the list of book titles using this custom key.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: For the first character (odd), 'B' > 'A', so BA comes before AB.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: At position 1 (odd), 'A' < 'B' < 'C', so ABC comes first. At position 2 (even), 'C' > 'A', so CAB comes before BAC.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by correctly applying the asc-desc-ending order rules.\n", "requirement analysis:\nThe requirement is to implement a custom sorting algorithm for a list of book titles. The sorting is based on a unique rule where odd-indexed characters are sorted in ascending order and even-indexed characters in descending order. The challenge is to efficiently handle the sorting given the constraints on the number of books and the length of each title.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Include comprehensive test cases to validate the sorting logic.\n- Document the code to explain the sorting logic and approach.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n# [phrase showing quantity relationship]\n    'odd-indexed': Refers to positions 1, 3, 5, etc., in the string.\n    'even-indexed': Refers to positions 2, 4, 6, etc., in the string.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Parse the input to get the number of books (n) and the length of each title (m).\n    - Read each book title into a list.\n    - Implement a custom sorting function:\n        - For each pair of titles, compare characters at odd indices in ascending order.\n        - Compare characters at even indices in descending order.\n    - Use Python's sorted function with the custom key to sort the list of titles.\n    - Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 1 (odd), 'A' < 'B', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 3 2 1\n    Explanation: At index 1 (odd), 'C' < 'B' < 'A', so 'CAB' comes first, followed by 'BAC', then 'ABC'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting based on custom key function will handle all cases correctly.\n", "requirement analysis:\nThe requirement is to implement a custom sorting algorithm for a list of book titles. The sorting is based on a unique rule where odd-indexed characters are sorted in ascending order and even-indexed characters in descending order. The challenge is to efficiently handle up to 10^6 characters in total, ensuring the solution is optimized for performance.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles large input sizes efficiently.\n- Provide clear and concise output as per the format.\n- Optimize the code for readability and maintainability.\n- Include comments and documentation for the code.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution is optimized for performance by leveraging tuple comparisons in Python.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to a custom sorting order where characters at odd indices are sorted in ascending order, and characters at even indices are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of the characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the title, if its index is odd, use the character as is for comparison (ascending order).\n   - If its index is even, use the negative of the character's ASCII value for comparison (descending order).\n4. Sort the list of titles using this custom key.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    1 1\n    A\n    = 1\n    Explanation: With only one book, it remains in its position regardless of sorting criteria.\n\n    2 2\n    AB\n    BA\n    = 2 1\n    Explanation: For the first character (odd index), 'A' comes before 'B', so 'BA' comes before 'AB'.\n\n    3 3\n    ABC\n    BAC\n    CAB\n    = 1 2 3\n    Explanation: The first differing position is odd, so we sort based on ascending order of the first character.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic with a custom sorting key will handle all cases, including edge cases, correctly.\n", "requirement analysis:\nThe requirement is to implement a sorting algorithm that combines both ascending and descending lexicographical orders based on character positions. Odd-indexed characters should be sorted in ascending order, while even-indexed characters should be sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Optimize for performance and memory usage\n- Provide clear documentation and comments in the code\n- Include test cases to validate the sorting algorithm\nWe will implement a custom sorting function that sorts the book titles based on the specified asc-desc-ending order. The function will iterate over each character position of the strings, comparing them according to the rules: odd-indexed characters are sorted in ascending order, and even-indexed characters are sorted in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending order'\n    Explanation: This is a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This refers to the dictionary order of strings, where strings are compared based on the alphabetical order of their characters.\n\n# [phrase showing quantity relationship]\n    'odd-indexed': Refers to positions 1, 3, 5, etc., in the string.\n    'even-indexed': Refers to positions 2, 4, 6, etc., in the string.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of books (n) and the length of each book title (m).\n2. Store each book title in a list along with its original index.\n3. Define a custom sorting function:\n   - For each character position in the book titles:\n     - If the position is odd, compare characters in ascending order.\n     - If the position is even, compare characters in descending order.\n4. Use Python's `sorted()` function with the custom sorting function as the key.\n5. Extract and print the original indices of the sorted book titles.\n\n# [edge case]\n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At position 1 (odd), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At position 1 (odd), 'A' comes before 'B' and 'C', so 'ABC' comes first. At position 2 (even), 'B' comes after 'A', so 'BAC' comes before 'CAB'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing each character position according to the specified rules.\n", "requirement analysis:\nThe requirement is to implement a sorting algorithm that combines both ascending and descending lexicographical orders based on character positions. Odd-indexed characters should be sorted in ascending order, while even-indexed characters should be sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Optimize for performance and memory usage\n- Provide clear documentation and comments in the code\n- Consider edge cases and test thoroughly\nWe will implement a custom sorting function that sorts strings based on the asc-desc-ending order. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the n book titles.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n    4. Use Python's sorted function with the custom key to sort the book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At the first position, 'B' comes after 'A' in descending order, so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 3 2 1\n    Explanation: At the first position, 'C' comes after 'B' and 'A', so 'CAB' comes first. Then 'BAC' comes before 'ABC' because at the second position, 'A' comes before 'B'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering both odd and even positions as specified.\n", "requirement analysis:\nThe requirement is to implement a sorting algorithm that combines both ascending and descending lexicographical order based on character positions. Odd-indexed characters should be sorted in ascending order, while even-indexed characters should be sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Optimize for performance and memory usage\n- Provide clear documentation and comments in the code\n- Include unit tests to verify the sorting logic\nWe will implement a custom sorting function that sorts strings based on the asc-desc-ending order. This will involve comparing characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n    4. Use Python's sorted function with the custom key to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: The first position differs, and since it's odd, 'B' comes before 'A' lexicographically.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 3 2 1\n    Explanation: The first position differs for all, and since it's odd, 'C' comes before 'B', which comes before 'A'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to implement a custom sorting algorithm for a list of book titles. The sorting should be based on a unique rule where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of a number of book titles, each with a fixed length, and the output should be the indices of these titles sorted according to the specified rule.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise documentation for the implemented solution.\n- Include test cases to validate the sorting algorithm.\n- Optimize the code for readability and maintainability.\nWe will implement a custom sorting function that compares book titles based on the specified asc-desc-ending order. The function will iterate over each character of the book titles, comparing them according to their index (odd or even) and applying the appropriate lexicographical order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a custom sorting function that takes two strings and compares them based on the asc-desc-ending order.\n    2. For each pair of strings, iterate through their characters.\n    3. Compare characters at odd indices in ascending order and characters at even indices in descending order.\n    4. Use Python's built-in sorting function with the custom comparator to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At index 1 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           AC\n           AD\n    Output: 3 2 1\n    Explanation: At index 2 (even), 'D' comes before 'C', and 'C' comes before 'B'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by comparing each character according to its index position.\n", "requirement analysis:\nThe requirement is to implement a sorting algorithm that combines both ascending and descending lexicographical order based on character positions. Odd-indexed characters should be sorted in ascending order, while even-indexed characters should be sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Optimize for performance and memory usage\n- Provide clear documentation and comments in the code\n- Include test cases to validate the sorting algorithm\nWe will implement a custom sorting function that sorts the book titles based on the specified asc-desc-ending order. This will involve iterating over the characters of the book titles and applying the sorting rules based on their positions. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution is optimized for performance and can handle up to 10^6 characters.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each pair of titles, compare characters at each position.\n        - If the position is odd, sort based on ascending order.\n        - If the position is even, sort based on descending order.\n    4. Use Python's sorted function with the custom key to sort the titles.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At position 1 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           AC\n           AD\n    Output: 3 2 1\n    Explanation: At position 2 (even), 'D' comes before 'C' and 'B', so AD comes first, followed by AC and AB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting with a custom key function will handle all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to implement a custom sorting algorithm for a list of book titles. The sorting is based on a unique rule where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The challenge is to efficiently handle the sorting given the constraints on the size of the input.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the algorithm for speed and memory usage.\n- Provide clear documentation and comments in the code.\n- Include test cases to validate the sorting logic.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n    4. Use Python's sorted function with the custom key to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is already sorted.\n    \n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 1 (odd), 'A' < 'B', so 'BA' comes before 'AB'.\n    \n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At index 1 (odd), 'A' < 'B' < 'C', so they are sorted in ascending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting with a custom key function will handle these cases correctly.\n"], "scores": [], "pass_results": [false, false, true, false, false, true, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 574, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "add_1_sentence_at_end", "parent_index": 146}
