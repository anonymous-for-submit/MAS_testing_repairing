{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM found a rectangle A of size n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM found a rectangle A of size n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM found a rectangle A of size n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5, b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The first and last blocks in each row from the second to the last must be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1 < x < a, 1 < y < b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM found a rectangle A of size n \u00d7 m with n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty, and CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions: a \u2265 5,b \u2265 4, for all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks; for all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks, and for all 1<x<a,1<y<b, block M_{x,y} is an empty block; M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that the there must be a rows and b columns, not b rows and a columns, and corners can be any type.\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for this sub-rectangle\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param grid: The grid as a numpy array\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param end_row: Ending row of the sub-rectangle\n    :param end_col: Ending column of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check the borders (except corners)\n    for i in range(start_row + 1, end_row):\n        if grid[i, start_col] != 1:\n            operations += 1\n        if grid[i, end_col] != 1:\n            operations += 1\n\n    for j in range(start_col + 1, end_col):\n        if grid[start_row, j] != 1:\n            operations += 1\n        if grid[end_row, j] != 1:\n            operations += 1\n\n    # Check the interior\n    for i in range(start_row + 1, end_row):\n        for j in range(start_col + 1, end_col):\n            if grid[i, j] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum operations to form a portal for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings.\n\n    Returns:\n        List of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient manipulation\n        matrix = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = calculate_changes(matrix, start_row, start_col, a, b)\n                        min_operations = min(min_operations, changes)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix: The numpy array representing the grid.\n        start_row: The starting row of the sub-rectangle.\n        start_col: The starting column of the sub-rectangle.\n        a: The number of rows in the sub-rectangle.\n        b: The number of columns in the sub-rectangle.\n\n    Returns:\n        The number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check edges and inner blocks\n    for i in range(a):\n        for j in range(b):\n            current_value = matrix[start_row + i, start_col + j]\n            if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                # Edge conditions\n                if (i == 0 or i == a - 1) and (j == 0 or j == b - 1):\n                    # Corners can be any type, no change needed\n                    continue\n                elif current_value == 0:\n                    # Edge should be obsidian (1), change needed\n                    changes += 1\n            else:\n                # Inner blocks should be empty (0)\n                if current_value == 1:\n                    changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Process and output results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix) where matrix is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix into a numpy array for efficient manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid[i:i+a, j:j+b]\n                        operations = calculate_operations(sub_rect, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check and transform borders (except corners)\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n\n    # Check and transform inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(n: int, m: int, grid: list[list[int]]) -> int:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (list[list[int]]): The grid represented as a list of lists containing 0s and 1s.\n\n    Returns:\n        int: Minimum number of operations required to create a portal.\n    \"\"\"\n    min_operations = float('inf')\n\n    # Iterate over all possible sub-rectangles of size at least 5x4\n    for start_row in range(n - 4):\n        for start_col in range(m - 3):\n            for end_row in range(start_row + 4, n):\n                for end_col in range(start_col + 3, m):\n                    operations = 0\n\n                    # Calculate operations needed for the current sub-rectangle\n                    for i in range(start_row, end_row + 1):\n                        for j in range(start_col, end_col + 1):\n                            if (i == start_row or i == end_row) and (j > start_col and j < end_col):\n                                # Border rows, except corners\n                                if grid[i][j] != 1:\n                                    operations += 1\n                            elif (j == start_col or j == end_col) and (i > start_row and i < end_row):\n                                # Border columns, except corners\n                                if grid[i][j] != 1:\n                                    operations += 1\n                            elif (i > start_row and i < end_row) and (j > start_col and j < end_col):\n                                # Inner blocks\n                                if grid[i][j] != 0:\n                                    operations += 1\n\n                    # Update minimum operations\n                    min_operations = min(min_operations, operations)\n\n    return min_operations\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    results = []\n\n    for _ in range(t):\n        # Read dimensions of the grid\n        n, m = map(int, input().split())\n        # Read the grid\n        grid = [list(map(int, input().strip())) for _ in range(n)]\n        # Calculate the result for the current test case\n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n\n    # Output results\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to form a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum operations for the corresponding test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        matrix = np.array([[int(char) for char in row] for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_matrix = matrix[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_matrix, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_matrix: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-matrix into a portal.\n\n    :param sub_matrix: The sub-matrix to be transformed\n    :param a: Number of rows in the sub-matrix\n    :param b: Number of columns in the sub-matrix\n    :return: The number of operations required\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for x in range(1, a - 1):\n        if sub_matrix[x, 0] != 1:\n            operations += 1\n        if sub_matrix[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_matrix[0, y] != 1:\n            operations += 1\n        if sub_matrix[a - 1, y] != 1:\n            operations += 1\n\n    # Check the inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_matrix[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_operations(n: int, m: int, grid: List[str]) -> int:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        n (int): Number of rows in the rectangle.\n        m (int): Number of columns in the rectangle.\n        grid (List[str]): The grid representing the rectangle with '0' as empty and '1' as obsidian.\n\n    Returns:\n        int: Minimum number of operations needed to create a portal.\n    \"\"\"\n    min_operations = float('inf')\n\n    # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n    for start_row in range(n - 4):\n        for start_col in range(m - 3):\n            operations = 0\n\n            # Check and count operations for each condition\n            for i in range(start_row + 1, start_row + 5 - 1):\n                if grid[i][start_col] != '1':\n                    operations += 1\n                if grid[i][start_col + 4 - 1] != '1':\n                    operations += 1\n\n            for j in range(start_col + 1, start_col + 4 - 1):\n                if grid[start_row][j] != '1':\n                    operations += 1\n                if grid[start_row + 5 - 1][j] != '1':\n                    operations += 1\n\n            for i in range(start_row + 1, start_row + 5 - 1):\n                for j in range(start_col + 1, start_col + 4 - 1):\n                    if grid[i][j] != '0':\n                        operations += 1\n\n            min_operations = min(min_operations, operations)\n\n    return min_operations\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum operations needed for each test case to create a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing the grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations needed for each test case.\n    \"\"\"\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        result = calculate_operations(n, m, test_case)\n        results.append(result)\n    return results\n\n# Example usage:\n# t = number of test cases\n# For each test case, call min_operations_to_portal with t, test_cases as inputs.\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        rectangle = [input().strip() for _ in range(n)]\n        test_cases.append(rectangle)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n    \n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix)\n    :return: List of minimum operations for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, matrix in test_cases:\n        # Convert the matrix into a numpy array for efficient operations\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        \n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n    \n    :param grid: The grid representing the rectangle\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param end_row: Ending row of the sub-rectangle\n    :param end_col: Ending column of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n    \n    # Check border conditions\n    for row in range(start_row, end_row + 1):\n        if row == start_row or row == end_row:\n            # Top and bottom borders\n            for col in range(start_col + 1, end_col):\n                if grid[row, col] != 1:\n                    operations += 1\n        else:\n            # Left and right borders\n            if grid[row, start_col] != 1:\n                operations += 1\n            if grid[row, end_col] != 1:\n                operations += 1\n    \n    # Check interior conditions\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a rectangle into a portal.\n    \n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the grid as a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient manipulation\n        matrix = np.array([list(map(int, row)) for row in grid])\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4 + 1):\n            for start_col in range(m - 3 + 1):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for this sub-rectangle\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        # Update the minimum operations if this is a better solution\n                        min_operations = min(min_operations, operations)\n        \n        # Append the result for this test case\n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n    \n    :param matrix: The grid as a numpy array\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n    \n    # Check the border conditions for obsidian blocks\n    for x in range(start_row + 1, end_row):\n        if matrix[x, start_col] != 1:\n            operations += 1\n        if matrix[x, end_col] != 1:\n            operations += 1\n    \n    for y in range(start_col + 1, end_col):\n        if matrix[start_row, y] != 1:\n            operations += 1\n        if matrix[end_row, y] != 1:\n            operations += 1\n    \n    # Check the internal conditions for empty blocks\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if matrix[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(n: int, m: int, grid: list[str]) -> int:\n    \"\"\"Calculate the minimum number of operations needed to form a portal in the grid.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (list[str]): The grid represented as a list of strings, where '0' is an empty block and '1' is an obsidian block.\n\n    Returns:\n        int: The minimum number of operations required to form a portal.\n    \"\"\"\n    min_operations = float('inf')\n\n    # Convert grid to numpy array for efficient slicing\n    grid_array = np.array([list(row) for row in grid], dtype=int)\n\n    # Iterate over all possible sub-rectangles of size at least 5x4\n    for i in range(n - 4 + 1):\n        for j in range(m - 3 + 1):\n            for a in range(5, n - i + 1):\n                for b in range(4, m - j + 1):\n                    operations = calculate_operations(grid_array, i, j, a, b)\n                    min_operations = min(min_operations, operations)\n\n    return min_operations\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: The number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and count operations for borders\n    for x in range(a):\n        for y in range(b):\n            if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                # Border conditions\n                if (x == 0 or x == a - 1) and (1 <= y < b - 1):\n                    # Top and bottom borders\n                    if grid[start_row + x, start_col + y] == 0:\n                        operations += 1\n                elif (y == 0 or y == b - 1) and (1 <= x < a - 1):\n                    # Left and right borders\n                    if grid[start_row + x, start_col + y] == 0:\n                        operations += 1\n            else:\n                # Inner block conditions\n                if grid[start_row + x, start_col + y] == 1:\n                    operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        result = min_operations_to_portal(n, m, grid)\n        results.append(result)\n\n    # Output interface\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to convert current sub-rectangle into a portal\n                        operations = calculate_operations(case, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Ensure borders are obsidian blocks\n    for row in range(start_row, end_row + 1):\n        if row == start_row or row == end_row:\n            for col in range(start_col, end_col + 1):\n                if grid[row][col] == '0':\n                    operations += 1\n        else:\n            if grid[row][start_col] == '0':\n                operations += 1\n            if grid[row][end_col] == '0':\n                operations += 1\n\n    # Ensure interior (excluding corners) is empty blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row][col] == '1':\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must efficiently handle the maximum input sizes. The key challenge is to identify the optimal sub-rectangle and calculate the necessary transformations.\nrequirement pool:\n- Develop an algorithm to identify potential sub-rectangles.\n- Calculate the minimum operations needed for transformation.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution adheres to the input-output format.\n- Provide detailed comments and documentation for the code.\nWe will use a dynamic programming approach to efficiently find the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to satisfy the portal conditions. We will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m'\n    Explanation: This refers to the initial grid of blocks, where each block can be either an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific conditions, including having obsidian blocks on its borders and empty blocks inside, except for the corners.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the least number of operations needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of changes required for each potential portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the interior is empty blocks.\n4. Keep track of the minimum number of changes required for any sub-rectangle in each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with minimum size portal:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    = 0\n    Explanation: The grid already forms a portal, so no changes are needed.\n\n    Test case with all blocks as obsidian:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    = 12\n    Explanation: All interior blocks need to be changed to empty, requiring 12 operations.\n\n    Test case with all blocks as empty:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    = 12\n    Explanation: All border blocks (except corners) need to be changed to obsidian, requiring 12 operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the required changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on size and block types are crucial for determining the solution. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations.\n- Optimize the solution for large input sizes.\n- Ensure accurate transformation of blocks.\n- Provide detailed explanation of the transformation process.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine the minimum number of operations required to transform a given rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to convert each into a portal. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A specific sub-rectangle with defined conditions for obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    Explanation: This sets the minimum size for the portal, ensuring it is large enough to meet the conditions.\n    Implementation: Use loops to iterate over sub-rectangles of size at least 5x4.\n\n# [degree adverb]\n    'minimum': Refers to the least number of operations required to transform a sub-rectangle into a portal.\n    Explanation: The goal is to find the smallest number of changes needed.\n    Implementation: Track the number of changes for each sub-rectangle and return the smallest count.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet portal conditions:\n        - Ensure edges are obsidian blocks except corners.\n        - Ensure inner blocks are empty.\n    4. Track the minimum number of changes across all sub-rectangles.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal conditions:\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected output: 0\n    Explanation: The rectangle already meets portal conditions, so no changes are needed.\n\n    Test case with maximum dimensions:\n    Input:\n    1\n    400 400\n    (all blocks are obsidian)\n    Expected output: Large number (depends on specific arrangement)\n    Explanation: Transforming a large rectangle with all obsidian blocks will require many changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on the size of the portal and the types of blocks are clearly defined, ensuring that the solution must efficiently handle matrices up to 400x400 in size. The output format is strict, requiring precise computation and presentation of results.\nrequirement pool:\n- Implement efficient matrix transformation algorithm.\n- Ensure output format adheres to specifications.\n- Optimize for minimal operations.\n- Handle edge cases and large inputs effectively.\n- Provide detailed explanation of transformation steps.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle of a given matrix into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to convert each into a portal. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This indicates that the dimensions of the portal must be at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions satisfying these conditions.\n\n# [degree adverb]\n    'minimum': This refers to finding the least number of operations required to transform a sub-rectangle into a portal.\n    Implementation: Iterate through possible sub-rectangles and calculate the number of changes needed, keeping track of the smallest number.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Keep track of the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already satisfies portal conditions.\n    Explanation: If a rectangle already meets the portal conditions, no operations are needed, so the expected output is 0.\n\n    Case 2: A rectangle with maximum dimensions (400x400) and all blocks are obsidian.\n    Explanation: The maximum number of changes would be needed to convert a sub-rectangle into a portal, as all inner blocks need to be empty.\n\n    Case 3: A rectangle with minimum dimensions (5x4) and all blocks are empty.\n    Explanation: The minimum number of changes would be needed to convert a sub-rectangle into a portal, as only border blocks need to be obsidian.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given grid into a portal with minimal operations. The constraints on the grid size and the portal conditions are crucial for ensuring the solution is both efficient and correct. The solution must handle multiple test cases and provide accurate results for each.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations needed.\n- Optimize the algorithm for large grid sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide detailed output for understanding the transformation process.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle of a given grid into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific conditions regarding the placement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to changing an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This indicates that the dimensions of the portal must be at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions satisfying these conditions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the grid dimensions for each test case.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the first and last blocks in each row from the second to the last are obsidian blocks.\n        - Ensure the first and last blocks in each column from the second to the last are obsidian blocks.\n        - Ensure all inner blocks are empty.\n    4. Track the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal\n    Explanation: If a grid already satisfies all portal conditions, no operations are needed, so the expected output is 0.\n\n    Case 2: A grid with all blocks as obsidian\n    Explanation: The maximum number of operations will be needed to convert inner blocks to empty while maintaining obsidian borders.\n\n    Case 3: A grid with all blocks as empty\n    Explanation: The maximum number of operations will be needed to convert border blocks to obsidian while maintaining empty inner blocks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle of a given grid into a portal. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must account for the specific conditions that define a portal, ensuring that the edges are obsidian blocks and the interior is empty. The challenge lies in efficiently checking all possible sub-rectangles and calculating the required transformations.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal formation.\n- Ensure the solution handles the maximum constraints of n and m effectively.\n- Optimize the algorithm for speed and accuracy.\n- Provide clear and concise output for each test case.\n- Implement additional features for user interaction and input validation.\nWe will use a dynamic programming approach to efficiently determine the minimum number of operations required to form a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to transform each into a portal. We will leverage numpy for efficient matrix operations and slicing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m': This refers to the main grid or matrix where the operations will be performed.\n    'obsidian block or empty': These are the two possible states for each block in the matrix, represented by 1 and 0 respectively.\n    'portal': A sub-rectangle that meets specific conditions outlined in the requirement.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means that the dimensions of the portal must be at least 5 rows and 4 columns.\n    '1 < x < a', '1 < x < b': These conditions specify the range of indices for which certain blocks must be obsidian or empty.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to satisfy the portal conditions:\n   - Ensure that for all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian.\n   - Ensure that for all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian.\n   - Ensure that for all 1 < x < a, 1 < y < b, block M_{x,y} is empty.\n4. Track the minimum number of changes required across all sub-rectangles.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the desired portal configuration.\n    Explanation: The expected output is 0 since no changes are needed.\n    \n    Case 2: A grid where all blocks are obsidian.\n    Explanation: The expected output is the number of changes needed to convert the inner blocks to empty while keeping the border conditions.\n\n    Case 3: A grid where all blocks are empty.\n    Explanation: The expected output is the number of changes needed to convert the border blocks to obsidian while keeping the inner blocks empty.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid is already in a portal configuration or completely opposite. This can be done by checking if a sub-rectangle already satisfies the portal conditions before calculating changes. If it does, return 0 immediately for that sub-rectangle.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient due to the potential size of the input. The solution should handle multiple test cases and provide the correct number of operations for each.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for a portal.\n- Optimize the algorithm for large inputs to ensure scalability.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide detailed comments and documentation for the code.\n- Include test cases to verify the solution's correctness.\nWe will use a brute-force approach to check all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will be optimized by early termination if a portal is found with zero operations. Libraries like NumPy can be used for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m'\n    Explanation: This refers to the initial grid of blocks, where each block can either be an obsidian block or an empty block. The dimensions n and m define the number of rows and columns, respectively.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means checking sub-rectangles where the number of rows is at least 5 and the number of columns is at least 4.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the lowest operation count found.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the first and last blocks in each row from the second to the last are obsidian.\n   - Ensure the first and last blocks in each column from the second to the last are obsidian.\n   - Ensure all inner blocks are empty.\n4. Track the minimum number of operations needed for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Edge Case 1: A rectangle that is already a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already satisfies all portal conditions, so no operations are needed.\n\n    Edge Case 2: A rectangle with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All necessary obsidian blocks need to be added, resulting in a high operation count.\n\n    Edge Case 3: A rectangle with maximum dimensions.\n    Input:\n    1\n    400 400\n    (all blocks are initially empty)\n    Expected Output: (depends on specific arrangement)\n    Explanation: This tests the efficiency and correctness of handling large inputs.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases efficiently, especially for large inputs.\n    \n```python\ndef calculate_operations(n, m, grid):\n    min_operations = float('inf')\n    \n    for start_row in range(n - 4):\n        for start_col in range(m - 3):\n            operations = 0\n            \n            # Check and count operations for each condition\n            for i in range(start_row + 1, start_row + n - 1):\n                if grid[i][start_col] != '1':\n                    operations += 1\n                if grid[i][start_col + m - 1] != '1':\n                    operations += 1\n            \n            for j in range(start_col + 1, start_col + m - 1):\n                if grid[start_row][j] != '1':\n                    operations += 1\n                if grid[start_row + n - 1][j] != '1':\n                    operations += 1\n            \n            for i in range(start_row + 1, start_row + n - 1):\n                for j in range(start_col + 1, start_col + m - 1):\n                    if grid[i][j] != '0':\n                        operations += 1\n            \n            min_operations = min(min_operations, operations)\n    \n    return min_operations\n\n# Example usage:\n# t = number of test cases\n# For each test case, call calculate_operations with n, m, and grid as inputs.\n```\n", "requirement analysis:\nThe task requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints on the size and type of blocks within the portal are critical. Efficient algorithms are needed to handle the maximum input sizes within the given limits.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide clear input and output formatting instructions.\n- Develop a user-friendly interface for inputting test cases.\nWe will use a dynamic programming approach to efficiently determine the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes required to meet the portal conditions. We will leverage numpy for efficient matrix operations and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m'\n    Explanation: This refers to the initial grid of blocks, where each block can either be an obsidian block (represented by '1') or an empty block (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific conditions, including having a border of obsidian blocks and an interior of empty blocks, with specific size constraints.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the least number of operations required to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of changes needed for each potential sub-rectangle.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to transform it into a portal:\n   - Ensure the border conditions are met (obsidian blocks on the edges).\n   - Ensure the interior conditions are met (empty blocks inside).\n4. Keep track of the minimum number of changes required for any sub-rectangle in each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 8\n    Explanation: The entire rectangle is filled with obsidian blocks, requiring changes to create an empty interior.\n\n    Case 2:\n    Input:\n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: 16\n    Explanation: The entire rectangle is empty, requiring changes to create an obsidian border.\n\n    Case 3:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: 12\n    Explanation: Alternating pattern requires significant changes to meet portal conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum number of changes will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on the size and type of blocks are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and large input sizes while ensuring accuracy in portal formation.\nrequirement pool:\n- Implement the main algorithm to transform rectangles into portals.\n- Optimize the solution for handling large input sizes efficiently.\n- Ensure the solution accurately identifies and transforms blocks.\n- Provide clear input and output formatting instructions.\n- Develop a user-friendly interface for inputting test cases.\nWe will implement a function to determine the minimum number of operations needed to transform a given rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes required to make each sub-rectangle a portal. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size at least 5x4 with specific conditions on the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': These conditions specify the minimum dimensions for a sub-rectangle to be considered a portal. In code, this means we need to iterate over all possible sub-rectangles of these dimensions or larger.\n    '1 < x < a, 1 < y < b': This specifies the range for the internal blocks of the portal, which must be empty. In code, this means checking and potentially changing these blocks to meet the portal criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to make it a portal.\n    4. Keep track of the minimum number of changes required across all sub-rectangles for each test case.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already satisfies the portal conditions.\n    Explanation: If a rectangle already meets the portal criteria, no changes are needed, so the output should be 0.\n    \n    Case 2: A rectangle with no obsidian blocks.\n    Explanation: The entire portal needs to be formed from empty blocks, requiring maximum changes.\n    \n    Case 3: A rectangle with dimensions exactly 5x4.\n    Explanation: This is the smallest possible portal size, and we need to ensure it meets all conditions with minimal changes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires transforming a given rectangle into a portal with minimum operations. The constraints ensure that the solution must handle up to 400 rows and columns efficiently. The portal formation rules are strict, requiring specific block placements, which must be adhered to for accurate results.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations\n- Ensure portal formation rules are strictly followed\n- Optimize for handling maximum constraints\n- Provide clear transformation steps\n- Enhance user interface for better input handling\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will keep track of the minimum number of operations required across all sub-rectangles. We will use numpy for efficient matrix operations and slicing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A of size n \u00d7 m'\n    Explanation: This refers to the main grid or matrix that contains blocks, where n is the number of rows and m is the number of columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific conditions, including having obsidian blocks on its borders and empty blocks inside, except for the corners.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles with these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the lowest operation count found.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each grid.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n4. Keep track of the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Explanation: If the grid already satisfies the portal conditions, no operations are needed. The expected output is 0.\n\n    Case 2: A grid with all blocks as obsidian.\n    Explanation: Transforming this grid into a portal will require changing all inner blocks to empty, except for the borders. The expected output will depend on the size of the grid.\n\n    Case 3: A grid with all blocks as empty.\n    Explanation: Transforming this grid into a portal will require changing all border blocks to obsidian. The expected output will depend on the size of the grid.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Check if a sub-rectangle is already a portal and return 0 operations if true.\n    - Calculate operations needed for grids with uniform block types (all obsidian or all empty).\n\n```python\ndef min_operations_to_portal(test_cases):\n    results = []\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n        for i in range(n - 4 + 1):\n            for j in range(m - 3 + 1):\n                for a in range(5, n - i + 1):\n                    for b in range(4, m - j + 1):\n                        operations = calculate_operations(grid, i, j, a, b)\n                        min_operations = min(min_operations, operations)\n        results.append(min_operations)\n    return results\n\ndef calculate_operations(grid, start_row, start_col, a, b):\n    operations = 0\n    # Check and count operations for borders and inner blocks\n    # Implement logic to count necessary changes\n    return operations\n```\n\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, and the solution should focus on efficiently checking possible sub-rectangles and calculating the required transformations.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations.\n- Optimize the solution for handling maximum constraints.\n- Ensure the solution is easy to understand and maintain.\n- Test the solution against various edge cases.\n- Document the solution and provide clear instructions for use.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to convert each into a portal. We will use a brute-force method due to the manageable constraints, ensuring that the solution is efficient enough for the given input limits.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A geometric shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A specific sub-rectangle configuration with obsidian blocks on the borders and empty blocks inside, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'minimum number of operations': The least number of changes needed to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    'minimum': Refers to the smallest number of operations required to achieve the desired configuration.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to convert it into a portal:\n        - Ensure the borders are obsidian blocks.\n        - Ensure the interior (excluding corners) is empty blocks.\n    4. Track the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with a rectangle already configured as a portal:\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected output: 0\n    Explanation: The rectangle is already a portal, so no operations are needed.\n\n    Test case with maximum dimensions:\n    Input:\n    1\n    400 400\n    (all blocks are obsidian)\n    Expected output: Large number (depends on specific configuration)\n    Explanation: Transforming a large rectangle with all obsidian blocks into a portal requires many operations.\n\n    Test case with minimum dimensions:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected output: 12\n    Explanation: All border blocks need to be changed to obsidian, requiring multiple operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, true, false, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 685, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "condense_two2one", "parent_index": 10}
