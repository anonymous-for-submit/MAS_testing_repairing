{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Consider cases where topics or difficulties overlap carefully to ensure valid selections. Take into account the uniqueness of each combination when calculating the total number of valid problemsets.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Consider cases where topics or difficulties overlap carefully to ensure valid selections. Take into account the uniqueness of each combination when calculating the total number of valid problemsets.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. This ensures the uniqueness of every individual problem. It is guaranteed that each problem is distinct in either its topic or difficulty, or both.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Consider cases where topics or difficulties overlap carefully to ensure valid selections. Take into account the uniqueness of each combination when calculating the total number of valid problemsets.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp is the coach of the Berland State University programming teams and he decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, and the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Consider cases where topics or difficulties overlap carefully to ensure valid selections and take into account the uniqueness of each combination when calculating the total number of valid problemsets.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n\n        for topic, difficulty in problems:\n            # Subtract combinations where the topic or difficulty is not unique\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problemsets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problemsets for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of topic and difficulty.\n\n    Returns:\n        A list of integers representing the number of valid problemsets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Populate the dictionaries with counts\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems from n: C(n, 3)\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate combinations where topics are not all different\n        same_topic_combinations = sum(count * (count - 1) * (count - 2) // 6 for count in topic_count.values())\n\n        # Calculate combinations where difficulties are not all different\n        same_difficulty_combinations = sum(count * (count - 1) * (count - 2) // 6 for count in difficulty_count.values())\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - same_topic_combinations - same_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problemsets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problemsets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problemsets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing topic and difficulty.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problemsets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Update counts for each problem\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing any 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where all three problems have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topic_count.values() if count >= 3)\n\n        # Calculate invalid combinations where all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulty_count.values() if count >= 3)\n\n        # Calculate combinations that were subtracted twice (same topic and difficulty)\n        double_counted_combinations = 0\n        for topic, difficulty in problems:\n            if topic_count[topic] >= 3 and difficulty_count[difficulty] >= 3:\n                double_counted_combinations += comb(topic_count[topic] - 1, 2) * comb(difficulty_count[difficulty] - 1, 2)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + double_counted_combinations\n\n        # Append result for the current test case\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problemsets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom collections import Counter\nfrom typing import List, Tuple\n\ndef count_valid_problemsets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of results, each representing the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = Counter()\n        difficulty_count = Counter()\n        problem_count = Counter((a, b) for a, b in problems)\n\n        for a, b in problems:\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not distinct\n        invalid_combinations = 0\n        for a, b in problems:\n            # Subtract combinations where the topic or difficulty is not distinct\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output results\n    results = count_valid_problemsets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems\n        total_combinations = comb(n, 3)\n\n        # Subtract invalid combinations where all topics are the same\n        invalid_topic_combinations = sum(comb(count, 3) for count in topic_count.values() if count >= 3)\n\n        # Subtract invalid combinations where all difficulties are the same\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulty_count.values() if count >= 3)\n\n        # Add back combinations that were subtracted twice (both same topic and difficulty)\n        double_counted_combinations = 0\n        for topic, difficulty in problems:\n            if topic_count[topic] > 1 and difficulty_count[difficulty] > 1:\n                double_counted_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + double_counted_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print the results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problemsets(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the number of valid ways to select three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the number of problems and a list of problems.\n\n    Returns:\n        list: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize counters for topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where topics or difficulties overlap\n        invalid_combinations = 0\n\n        # Subtract combinations where topics overlap\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += comb(count, 3)\n\n        # Subtract combinations where difficulties overlap\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += comb(count, 3)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problemsets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problemsets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problemsets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problemsets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize counters for topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics are not different\n        invalid_topic_combinations = sum(count * (count - 1) * (count - 2) // 6 for count in topic_count.values())\n\n        # Calculate invalid combinations where difficulties are not different\n        invalid_difficulty_combinations = sum(count * (count - 1) * (count - 2) // 6 for count in difficulty_count.values())\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problemsets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    def combination(n: int, k: int) -> int:\n        \"\"\"Calculate the number of combinations C(n, k).\n\n        Args:\n            n (int): Total number of items.\n            k (int): Number of items to choose.\n\n        Returns:\n            int: Number of combinations.\n        \"\"\"\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        k = min(k, n - k)\n        c = 1\n        for i in range(k):\n            c = c * (n - i) // (i + 1)\n        return c\n\n    results = []\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count frequency of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Total combinations of choosing 3 problems from n\n        total_combinations = combination(n, 3)\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n\n        # Invalid combinations where all three problems have the same topic\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += combination(count, 3)\n\n        # Invalid combinations where all three problems have the same difficulty\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += combination(count, 3)\n\n        # Subtract invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print the results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not distinct\n        invalid_combinations = 0\n\n        # Count invalid combinations for each topic\n        for topic, count in topic_count.items():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Count invalid combinations for each difficulty\n        for difficulty, count in difficulty_count.items():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Count invalid combinations where both topic and difficulty are the same\n        for topic, difficulty in problems:\n            invalid_combinations -= (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problemsets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problemsets for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid problemsets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize counters for topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total number of ways to choose 3 problems (n choose 3)\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties overlap\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Subtract combinations where the current topic or difficulty is repeated\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problemsets(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the selection criteria are met without exceeding time limits.\nrequirement pool:\n- Implement an efficient algorithm to select valid problem sets.\n- Ensure the solution handles the maximum input size within time constraints.\n- Optimize the solution for both speed and accuracy.\n- Provide clear and concise output for each test case.\n- Include detailed comments and documentation for maintainability.\nWe will use a combination of combinatorial mathematics and efficient data structures to solve the problem. Specifically, we will leverage the itertools library to generate combinations and use dictionaries to count occurrences of topics and difficulties. This approach ensures that we can handle large inputs efficiently by reducing unnecessary computations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics': Refers to the category or subject of each problem, represented by the integer a_i.\n    'difficulties': Refers to the level of challenge of each problem, represented by the integer b_i.\n    'combinatorial mathematics': Involves calculating the number of ways to choose items from a set, which is crucial for determining valid problem sets.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': Means we need to select precisely three problems from the given set.\n    'different': Implies that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems, n.\n2. Store each problem's topic and difficulty in a list of tuples.\n3. Use combinatorial mathematics to calculate the total number of ways to choose 3 problems from n (nC3).\n4. Use dictionaries to count occurrences of each topic and difficulty.\n5. Calculate invalid combinations where topics or difficulties overlap using these counts.\n6. Subtract invalid combinations from the total combinations to get valid sets.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Test case with all topics or difficulties the same:\n    Input: 4\n           1 1\n           1 2\n           1 3\n           1 4\n    Output: 0\n    Explanation: No valid set of three problems can be formed as all topics are the same.\n\n    Test case with maximum n:\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations of three problems are valid as all topics and difficulties are different.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either their topics or difficulties are all different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems across all test cases. The uniqueness of each problem based on topic and difficulty must be maintained.\nrequirement pool:\n- Efficiently calculate valid combinations of problems\n- Ensure no repetition in selected problem topics and difficulties\n- Optimize for large input sizes\n- Provide clear output format\n- Handle edge cases with minimum problems\nWe will use a combinatorial approach to efficiently calculate the number of valid problemsets. The key is to count the number of ways to select three problems such that either their topics or difficulties are all different. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to determine the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either all different topics or all different difficulties, or both. This is crucial for determining valid combinations.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means we need to select precisely three problems for each valid combination.\n    'number of ways': refers to calculating the total possible combinations that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and details for each test case.\n    2. For each test case, initialize dictionaries to count occurrences of each topic and difficulty.\n    3. Iterate through the list of problems to populate these dictionaries.\n    4. Calculate the total number of ways to select three problems using combinatorial logic:\n        - Total combinations of three problems from n: C(n, 3)\n        - Subtract combinations where topics are not all different.\n        - Subtract combinations where difficulties are not all different.\n    5. Output the result for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) satisfies both conditions.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No combination of three problems can satisfy either condition.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial calculations will naturally account for these scenarios.\n", "requirement analysis:\nThe requirement involves selecting three problems from a set of n problems such that either their topics or difficulties are all different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems, ensuring no two problems have the same topic and difficulty simultaneously.\nrequirement pool:\n- Implement efficient algorithm to count valid problemsets\n- Ensure output format matches requirements\n- Optimize for large input sizes\n- Validate uniqueness of problem combinations\n- Provide detailed error handling for edge cases\nWe will use a combinatorial approach to count the number of valid problemsets. The key is to efficiently count combinations of problems that satisfy the conditions of having either all different topics or all different difficulties. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics': means that the three selected problems must have unique topics.\n    'different difficulties': means that the three selected problems must have unique difficulties.\n    'combinatorial approach': refers to using combinations to count valid selections.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means we need to select precisely three problems.\n    'number of ways': refers to counting all possible valid combinations.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems `n`.\n2. Initialize dictionaries to count occurrences of each topic and difficulty.\n3. For each problem, update the topic and difficulty counts.\n4. Calculate the total number of ways to choose any 3 problems from `n` using combinations: C(n, 3).\n5. Subtract invalid combinations:\n   - For each topic, calculate invalid combinations where all three problems have the same topic.\n   - For each difficulty, calculate invalid combinations where all three problems have the same difficulty.\n6. Add back combinations that were subtracted twice (same topic and difficulty).\n7. Sum up all valid combinations for each test case and print the result.\n\n# [edge case] \n    Test case with minimum n:\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one way to select all three problems, satisfying both conditions.\n\n    Test case with all topics and difficulties the same:\n    3\n    1 1\n    1 1\n    1 1\n    = 0\n    Explanation: No valid way to select three problems as they do not satisfy any condition.\n\n    Test case with maximum n:\n    Consider a test case with n = 200000, where topics and difficulties are distributed evenly.\n    The expected output would depend on the specific distribution but should handle large input sizes efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either their topics or difficulties are all different. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate calculation of valid combinations.\nrequirement pool:\n- Efficiently calculate valid combinations of problems\n- Ensure no repetition in topics and difficulties\n- Optimize for large input sizes\n- Provide clear output format\n- Handle multiple test cases seamlessly\nWe will use a combination of combinatorial mathematics and efficient data structures to solve the problem. Specifically, we will leverage the collections library to count occurrences of topics and difficulties, and use combinatorial logic to calculate valid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics': Refers to the category or subject matter of each problem.\n    'difficulties': Refers to the level of challenge each problem presents.\n    'distinct': Ensures that no two problems have the same topic and difficulty simultaneously.\n    'combinatorial mathematics': Involves calculating the number of ways to choose items from a set, often using combinations.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': Means we need to select precisely three problems from the list.\n    'different': Implies that the selected problems must have unique topics or difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use a dictionary or collections.Counter to count occurrences of each topic and difficulty.\n4. Calculate the total number of ways to choose 3 problems from n using combinatorial formula C(n, 3).\n5. Subtract invalid combinations where topics or difficulties are not distinct.\n6. For each problem, adjust the count based on its topic and difficulty to ensure valid selections.\n7. Sum up valid combinations for each test case and print the result.\n\n# [edge case]\n    Test case with minimum n = 3:\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select all three problems since they all have different topics and difficulties.\n\n    Test case with all same topics:\n    Input: 1\n           4\n           1 2\n           1 3\n           1 4\n           1 5\n    Output: 0\n    Explanation: No valid selection since all problems have the same topic.\n\n    Test case with all same difficulties:\n    Input: 1\n           4\n           2 1\n           3 1\n           4 1\n           5 1\n    Output: 0\n    Explanation: No valid selection since all problems have the same difficulty.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Ensure that when counting combinations, we exclude those where all selected problems share the same topic or difficulty.\n    - Adjust counts dynamically as we iterate through each problem to maintain valid selections.\n\n```python\nfrom collections import Counter\n\ndef count_valid_problemsets(t, test_cases):\n    results = []\n    \n    for n, problems in test_cases:\n        topic_count = Counter()\n        difficulty_count = Counter()\n        problem_count = Counter((a, b) for a, b in problems)\n        \n        for a, b in problems:\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n    \n    return results\n\n# Example usage:\nt = 2\ntest_cases = [\n    (4, [(2, 4), (3, 4), (2, 1), (1, 3)]),\n    (5, [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)])\n]\n\nprint(count_valid_problemsets(t, test_cases))\n```\nThis code efficiently calculates the number of valid problem sets by considering both topic and difficulty constraints and adjusting for invalid combinations dynamically.\n", "requirement analysis:\nThe task requires selecting three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 50000 test cases with a total of up to 200000 problems across all test cases. The uniqueness of each problem is guaranteed by distinct topic-difficulty pairs.\nrequirement pool:\n- Efficiently handle large input sizes and multiple test cases.\n- Ensure the selected problems meet the conditions of different topics or difficulties.\n- Optimize the algorithm to reduce time complexity.\n- Provide clear and concise output for each test case.\n- Consider edge cases where n is minimal or maximal.\nWe will use a combinatorial approach to count the number of valid problem sets. For each test case, we will first calculate the total number of ways to choose any three problems. Then, we will subtract the invalid combinations where either all topics or all difficulties are the same. This can be efficiently done using dictionaries to count occurrences of each topic and difficulty.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is distinct in either its topic or difficulty, or both, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a combination of three problems from the given set.\n\n    'topics of all three selected problems are different'\n    Explanation: The selected problems must have distinct topics.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The selected problems must have distinct difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems.\n    \n    'different': implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems `n`.\n2. Store the topics and difficulties of each problem in separate lists.\n3. Calculate the total number of ways to choose any three problems using combinatorial formula C(n, 3).\n4. Use dictionaries to count occurrences of each topic and difficulty.\n5. Subtract invalid combinations:\n   - For each topic, calculate the number of ways to choose three problems with the same topic and subtract from total.\n   - For each difficulty, calculate the number of ways to choose three problems with the same difficulty and subtract from total.\n6. Add back combinations that were subtracted twice (both same topic and difficulty).\n7. Output the result for each test case.\n\n# [edge case] \n    Test case with minimum n:\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one way to select all three problems since they all have different topics and difficulties.\n\n    Test case with all same topics:\n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    = 0\n    Explanation: No valid selection as all topics are the same.\n\n    Test case with all same difficulties:\n    4\n    1 1\n    2 1\n    3 1\n    4 1\n    = 0\n    Explanation: No valid selection as all difficulties are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of subtracting invalid combinations and adding back double-counted ones will handle these cases correctly.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either their topics or difficulties are all different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems, ensuring performance optimization and correctness.\nrequirement pool:\n- Efficiently calculate valid combinations of problems\n- Ensure no repetition in selected problem topics and difficulties\n- Optimize for large input sizes\n- Provide clear output format\n- Handle edge cases with minimal problems\nWe will use a combination of combinatorial mathematics and hash maps to efficiently count valid combinations of problems. The key is to count the number of ways to select three problems such that either their topics or difficulties are all different. We will utilize Python's collections library to manage counts and combinations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem is distinct in either its topic or difficulty, or both, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose three problems from the given set that meet the specified conditions.\n\n# [phrase showing quantity relationship]\n    'number of ways'\n    Explanation: This refers to the different combinations possible to select three problems that satisfy the conditions. In code, this can be implemented using combinatorial mathematics to calculate combinations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the list of problems for each test case.\n2. For each test case, initialize counters for topics and difficulties using hash maps.\n3. Count occurrences of each topic and difficulty.\n4. Calculate the total number of ways to select three problems using combinatorial mathematics (n choose 3).\n5. Subtract invalid combinations where topics or difficulties overlap.\n6. Return the number of valid combinations for each test case.\n\n# [edge case]\n    Test case with minimum n = 3:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Expected Output: 1\n    Explanation: Only one way to select all three problems since they are distinct in both topic and difficulty.\n\n    Test case with all topics or difficulties the same:\n    Input: 4\n           1 1\n           1 2\n           1 3\n           1 4\n    Expected Output: 0\n    Explanation: No valid selection since all topics are the same.\n\n    Test case with maximum overlap:\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Expected Output: 10\n    Explanation: All combinations are valid since each problem is distinct in both topic and difficulty.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement involves selecting three problems from a set of n problems such that they meet at least one of the specified conditions regarding topics and difficulties. The solution must efficiently handle up to 50000 test cases and ensure that the sum of n across all test cases does not exceed 200000.\nrequirement pool:\n- Implement efficient algorithm to count valid problemsets\n- Ensure solution handles maximum constraints effectively\n- Provide clear output format as specified\n- Optimize for performance with large datasets\n- Validate input data to ensure no duplicate topic-difficulty pairs\nWe will use a combination of combinatorial counting and hash maps to efficiently determine the number of valid problemsets. The key is to count combinations where either topics or difficulties are unique among the selected problems. We will leverage Python's collections library to manage counts and combinations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique': Each problem has a unique combination of topic and difficulty, meaning no two problems share the same topic and difficulty simultaneously.\n    'different': The selected problems must have either different topics or different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select exactly three problems from the given set.\n    'number of ways': We need to calculate the total number of valid combinations of three problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the list of problems for each test case.\n    2. For each test case, initialize counters for topics and difficulties using hash maps.\n    3. Count the occurrences of each topic and difficulty.\n    4. Calculate combinations where topics are different using combinatorial counting.\n    5. Calculate combinations where difficulties are different using combinatorial counting.\n    6. Sum the valid combinations for each test case and output the result.\n\n# [edge case]\n    Input: 3\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) satisfies both conditions.\n\n    Input: 4\n           4\n           1 2\n           2 3\n           3 4\n           4 1\n    Output: 4\n    Explanation: All combinations satisfy at least one condition.\n\n    Input: 5\n           5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy at least one condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations based on unique topics or difficulties will naturally handle these cases.\n", "requirement analysis:\nThe requirement involves selecting three problems from a set of n problems such that they meet at least one of the specified conditions. The solution must efficiently handle up to 50000 test cases and ensure that the sum of n across all test cases does not exceed 200000. The uniqueness of each problem based on topic and difficulty must be maintained.\nrequirement pool:\n- Implement efficient algorithm to select problems based on conditions\n- Ensure solution handles large input sizes within constraints\n- Provide clear output format as specified\n- Optimize code for readability and maintainability\n- Include comments and documentation for clarity\nWe will use a combinatorial approach to solve this problem efficiently. The key is to count the number of valid combinations of three problems that satisfy at least one of the given conditions. We will use dictionaries to keep track of the frequency of each topic and difficulty, and then calculate the number of valid combinations by subtracting invalid combinations from the total possible combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial approach'\n    Explanation: This refers to using combinatorial mathematics to count the number of ways to select items from a set, ensuring that the selections meet specific criteria.\n\n    'frequency of each topic and difficulty'\n    Explanation: This involves counting how many times each topic and difficulty level appears among the problems, which helps in determining valid combinations.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': We need to select exactly three problems from the given set.\n    'at least one of two conditions': The selected problems must satisfy at least one of the two conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems `n`.\n2. Initialize dictionaries to count the frequency of each topic and difficulty.\n3. For each problem, update the frequency counts for its topic and difficulty.\n4. Calculate the total number of ways to choose 3 problems from `n` using combinatorial formula C(n, 3).\n5. Calculate the number of invalid combinations where neither condition is satisfied:\n   - For each topic, calculate invalid combinations where all three problems have the same topic.\n   - For each difficulty, calculate invalid combinations where all three problems have the same difficulty.\n6. Subtract these invalid combinations from the total combinations to get the valid combinations.\n7. Output the result for each test case.\n\n# [edge case]\n    Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select all three problems, and it satisfies both conditions.\n\n    Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected output: 4\n    Explanation: All combinations of three problems satisfy at least one condition.\n\n    Case 3: n = 5, problems = [(1, 1), (1, 2), (1, 3), (2, 1), (3, 1)]\n    Expected output: 10\n    Explanation: All combinations satisfy at least one condition due to diverse topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid combinations by subtracting invalid ones will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that they meet at least one of the two conditions: all topics are different or all difficulties are different. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the constraints are respected and the output is accurate.\nrequirement pool:\n- Efficiently calculate combinations of problems meeting the criteria\n- Handle large input sizes without performance degradation\n- Ensure the solution is scalable for future enhancements\n- Provide clear and concise output for each test case\n- Optimize for minimal computational complexity\nWe will use combinatorial mathematics to efficiently calculate the number of valid problem sets. The key is to leverage data structures like dictionaries to count occurrences of topics and difficulties, and then use these counts to determine valid combinations. We will use the itertools library to handle combinations and ensure scalability for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial mathematics'\n    Explanation: This refers to the branch of mathematics dealing with combinations of objects. In this context, it is used to calculate the number of ways to select three problems that meet the given conditions.\n\n    'topics and difficulties'\n    Explanation: Each problem has a unique topic and difficulty, and the selection criteria are based on these attributes.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': We need to select precisely three problems from the given set.\n    'different': This implies that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the details of each problem.\n2. For each test case, initialize data structures to count occurrences of each topic and difficulty.\n3. Use combinatorial logic to calculate the number of valid combinations:\n   - Calculate combinations where all topics are different.\n   - Calculate combinations where all difficulties are different.\n4. Ensure no double-counting by considering overlaps between topic and difficulty conditions.\n5. Output the total number of valid combinations for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (problems 1, 2, 3) satisfies both conditions.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No combination of three problems can satisfy either condition.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should account for all possible combinations and ensure valid selections based on the given conditions.\n", "requirement analysis:\nThe requirement is to select three problems from a given set such that they meet at least one of the specified conditions regarding topics and difficulties. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate and valid selections.\nrequirement pool:\n- Implement efficient algorithm to select valid problemsets.\n- Ensure the solution handles edge cases and large inputs.\n- Optimize performance for high number of test cases.\n- Provide clear output format as specified.\n- Validate uniqueness of each problem combination.\nWe will use a combination of combinatorial mathematics and hash maps to efficiently count the number of valid problemsets. The approach involves calculating combinations of problems based on their topics and difficulties, ensuring that the constraints are met. We will utilize Python's collections library to manage counts and combinations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics': means that the selected problems must have unique topics.\n    'different difficulties': means that the selected problems must have unique difficulties.\n    'combinatorial mathematics': refers to using combinations to count valid sets of problems.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means we need to select precisely three problems.\n    'number of ways': refers to counting all possible valid combinations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the list of problems for each test case.\n    2. For each test case, initialize counters for topics and difficulties using hash maps.\n    3. Count the occurrences of each topic and difficulty.\n    4. Calculate the total number of ways to select any three problems using combinatorial mathematics (n choose 3).\n    5. Subtract invalid combinations where topics or difficulties overlap.\n    6. Add back combinations that satisfy either condition (unique topics or unique difficulties).\n    7. Output the result for each test case.\n\n# [edge case]\n    Input: 3\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one valid set exists where both topics and difficulties are different: (1, 2, 3).\n\n    Input: 4\n           4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No valid set exists as all combinations have overlapping topics and difficulties.\n\n    Input: 5\n           5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations are valid as both topics and difficulties are different.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will naturally handle these scenarios.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 293, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "add_1_sentence_at_end", "parent_index": 214}
