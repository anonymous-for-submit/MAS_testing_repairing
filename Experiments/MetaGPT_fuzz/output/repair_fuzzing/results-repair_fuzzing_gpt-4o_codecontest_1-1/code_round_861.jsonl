{"name": "1622_B. Berland Music", "description": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\n\n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "tags": ["data structures", "greedy", "math", "sortings"], "difficulty": 8, "id": 1622, "sample_io": [{"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}], "test_list": [{"input": "1\n7\n1 2 3 4 5 6 7\n0101010\n", "output": ["1 5 2 6 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n10101010101010101010101010101010101010101010101010\n", "output": ["26 1 27 2 28 3 29 4 30 5 31 6 32 7 33 8 34 9 35 10 36 11 37 12 38 13 39 14 40 15 41 16 42 17 43 18 44 19 45 20 46 21 47 22 48 23 49 24 50 25\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 4 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n3 1 2\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["2 1\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101010\n", "output": ["4 5 1 6 2 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 1 2\n1 6 5 8 2 7 4 3\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101000\n", "output": ["5 6 1 7 2 3 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n3 1 2\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n1 2 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 2 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 1 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 7 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["2 1\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01100100\n", "output": ["2 1\n3 2 1\n1 7 6 5 2 8 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n1 2 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 5 2 6 3 4 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 1 6 2 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 1 2 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n1 2 3\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 4 2 5 6 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 7 4 5 6\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111011\n", "output": ["2 1\n1 6 2 7 3 4 5\n3 4 2 8 5 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 2 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 5 6 7 2 3 4\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 6 7 1 2 3\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110100\n", "output": ["2 1\n3 2 1\n5 6 4 8 1 7 3 2\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n2 3 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1001000\n", "output": ["6 1 2 7 3 4 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00100001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 7 6 4 3 5 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n2 3 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 3 2 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n3 2 1\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n1 5 6 7 2 3 4\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010010\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 6 1 8 3 2 7 4\n"]}, {"input": "3\n2\n2 1\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 4 5 6 1 7 2\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 7 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 4 3 8 2 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111101\n", "output": ["2 1\n3 2 1\n1 4 3 8 6 5 2 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n2 3 4 5 6 1 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0110000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 7 2 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n2 1 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 6 4 7 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 3 1\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110110\n", "output": ["2 1\n3 2 1\n1 5 4 8 2 6 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n10010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 2 1 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 2 1\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 2 1\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 2 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 5 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1100010\n", "output": ["5 6 1 2 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110111\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 4 8 3 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n4 5 6 7 1 2 3\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 4 2 5 3 6 7\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 4 1 5 6 7 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110110\n", "output": ["2 1\n3 2 1\n4 5 3 8 1 6 7 2\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["1 2\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n3 4 5 6 7 1 2\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01100001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 7 6 5 3 2 4 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 7 2 3 4 5 6\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11011011\n", "output": ["2 1\n1 5 2 6 3 4 7\n3 4 1 8 5 2 7 6\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}], "task_id": "codecontest/155", "prompt": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are putting in considerable effort to enhance their current system. They are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them. Consider edge cases where all songs are liked or disliked.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "repair_prompt": ["Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are putting in considerable effort to enhance their current system. They are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them. Consider edge cases where all songs are liked or disliked.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "Berland Music is a music streaming service built specifically to support Berland local artist. The developers working on this service are highly skilled and innovative. They are putting in considerable effort to enhance their current system. They are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them. Consider edge cases where all songs are liked or disliked.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "Berland Music is a music streaming service built specifically to support Berland local artist, and its developers are putting in considerable effort to enhance their current system. So imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it. Now the service has to re-evaluate the song ratings in such a way that: the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold).\n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x. Print the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them. Consider edge cases where all songs are liked or disliked.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on likes and dislikes.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of songs.\n            - p: List of predicted ratings (a permutation of numbers from 1 to n).\n            - s: String of likes ('1') and dislikes ('0').\n\n    Returns:\n        A list of lists, where each list is the re-evaluated ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings\n        sorted_p = sorted(p)\n\n        # Assign the highest available ratings to liked songs\n        liked_ratings = sorted_p[-len(liked_indices):]\n        # Assign the lowest available ratings to disliked songs\n        disliked_ratings = sorted_p[:len(disliked_indices)]\n\n        # Create a new permutation q\n        q = [0] * n\n        for i, index in enumerate(liked_indices):\n            q[index] = liked_ratings[i]\n        for i, index in enumerate(disliked_indices):\n            q[index] = disliked_ratings[i]\n\n        results.append(q)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    results = []\n    \n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n        \n        # Sort liked indices by their original ratings in descending order\n        liked_indices.sort(key=lambda x: p[x], reverse=True)\n        # Sort disliked indices by their original ratings in ascending order\n        disliked_indices.sort(key=lambda x: p[x])\n        \n        # Assign ratings\n        q = [0] * n\n        current_rating = n\n        \n        # Assign highest ratings to liked songs\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n        \n        # Assign remaining ratings to disliked songs\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n        \n        results.append(q)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        p = list(map(int, input().strip().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n    \n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings permutations for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices based on feedback\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Create a new permutation q\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Original permutation of predicted ratings.\n            - s (str): String representing likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the original ratings\n        sorted_p = sorted(p)\n\n        # Assign ratings to liked and disliked songs\n        q = [0] * n\n        liked_ratings = sorted_p[-len(liked_indices):]\n        disliked_ratings = sorted_p[:len(disliked_indices)]\n\n        # Fill the permutation q based on likes and dislikes\n        for idx, rating in zip(liked_indices, liked_ratings):\n            q[idx] = rating\n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            q[idx] = rating\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): String indicating liked (1) or disliked (0) songs.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings permutations for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on their predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Create a new permutation q\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs next\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on likes and dislikes.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of songs.\n            - p: List of predicted ratings (a permutation of numbers 1 to n).\n            - s: String of likes ('1') and dislikes ('0').\n\n    Returns:\n        A list of lists, where each list is the re-evaluated ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort liked and disliked indices based on their predicted ratings\n        liked_indices.sort(key=lambda i: p[i], reverse=True)\n        disliked_indices.sort(key=lambda i: p[i])\n\n        # Create a new permutation for the ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign the lowest ratings to disliked songs\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating += 1\n\n        # Assign the highest ratings to liked songs\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef adjust_song_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjust song ratings based on user feedback to ensure liked songs have higher ratings than disliked ones.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings, a permutation of integers from 1 to n.\n            - s (str): Feedback string, where '1' indicates a liked song and '0' indicates a disliked song.\n\n    Returns:\n        List[List[int]]: List of adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings\n        sorted_p = sorted(p)\n\n        # Assign highest ratings to liked songs and lowest to disliked songs\n        liked_ratings = sorted_p[-len(liked_indices):]\n        disliked_ratings = sorted_p[:len(disliked_indices)]\n\n        # Create a new ratings list\n        q = [0] * n\n\n        # Assign ratings to liked songs\n        for idx, rating in zip(liked_indices, liked_ratings):\n            q[idx] = rating\n\n        # Assign ratings to disliked songs\n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            q[idx] = rating\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = adjust_song_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback while maintaining a permutation of ratings.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Permutation of predicted ratings.\n            - s (str): String representing likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on their predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign the highest available ratings to liked songs and the lowest to disliked songs\n        q = [0] * n\n        current_rating = 1\n\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        p = list(map(int, input().strip().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of songs.\n            - p: List of predicted ratings (a permutation of numbers from 1 to n).\n            - s: String of likes ('1') and dislikes ('0').\n\n    Returns:\n        A list of lists, where each list is the re-evaluated ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on their values in p\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign lowest ratings to disliked songs\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign highest ratings to liked songs\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        p = list(map(int, input().strip().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    result = reevaluate_ratings(t, test_cases)\n    for res in result:\n        print(' '.join(map(str, res)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback while maintaining permutation integrity.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Permutation of predicted ratings.\n            - s (str): String representing likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on their predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign lowest ratings to disliked songs\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign highest ratings to liked songs\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback\n- Ensure permutation of song ratings is maintained\n- Develop user interface for liking/disliking songs\n- Optimize algorithm for large datasets\n- Integrate local artist support features\nWe will implement a function that processes each test case independently. The function will separate the songs into liked and disliked categories based on the input string. It will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring the permutation condition is met. The solution will be optimized to handle the maximum constraints efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings q_1, q_2, ..., q_n must be a rearrangement of numbers from 1 to n, with each number appearing exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value. Here, it is used to calculate the difference between the predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that the new rating for liked songs must be higher than the new rating for disliked songs. In code, this can be implemented by ensuring that all liked songs have higher indices in the sorted list of ratings.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between the predicted and re-evaluated ratings. In code, this can be achieved by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n1. For each test case:\n   - Parse the number of songs `n`, the predicted ratings `p`, and the like/dislike string `s`.\n   - Separate the indices of liked and disliked songs based on `s`.\n   - Sort the predicted ratings `p` and assign the highest available ratings to liked songs and the lowest to disliked songs.\n   - Construct the new permutation `q` by placing these assigned ratings back in their original positions.\n   - Output the permutation `q`.\n\n# [edge case]\n    Case 1: All songs liked\n    Input: n = 3, p = [3, 1, 2], s = \"111\"\n    Expected Output: 1 2 3\n    Explanation: Since all songs are liked, they can be assigned any permutation of 1 to n.\n\n    Case 2: All songs disliked\n    Input: n = 3, p = [3, 1, 2], s = \"000\"\n    Expected Output: 1 2 3\n    Explanation: Since all songs are disliked, they can be assigned any permutation of 1 to n.\n\n    Case 3: Alternating likes and dislikes\n    Input: n = 4, p = [4, 3, 2, 1], s = \"1010\"\n    Expected Output: 3 1 4 2\n    Explanation: Liked songs (indices 1 and 3) get higher ratings than disliked songs (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes inherently handles these cases.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge is to ensure liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback\n- Ensure permutation of song ratings is maintained\n- Optimize for minimal sum of absolute differences in ratings\n- Handle edge cases where all songs are liked or disliked\n- Develop user interface for liking/disliking songs\nWe will implement a function to re-evaluate song ratings based on user feedback while maintaining a permutation of ratings. The function will sort the songs into liked and disliked categories, assign the highest ratings to liked songs, and the lowest to disliked ones. This approach ensures that the permutation condition is met and the sum of absolute differences is minimized. We will use Python's built-in sorting capabilities to efficiently handle the permutation and rating assignment.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings q_1, q_2, ..., q_n must be a rearrangement of the numbers 1 to n, with each number appearing exactly once.\n\n    'liked' and 'disliked'\n    Explanation: These terms refer to Monocarp's feedback on the songs. A 'liked' song (s_i=1) should have a higher rating than a 'disliked' song (s_i=0) in the new permutation.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that for any liked song i and disliked song j, the new rating q_i must be greater than q_j.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation q that minimizes the sum of absolute differences between the original and new ratings.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Read n, the permutation p, and the string s.\n   - Separate the indices of liked and disliked songs.\n   - Sort the liked indices in descending order and disliked indices in ascending order.\n   - Assign the highest available ratings to liked songs and the lowest to disliked songs.\n   - Construct the new permutation q based on these assignments.\n3. Output the permutation q for each test case.\n\n# [edge case]\n    Case 1: All songs liked\n    Input: 3, 3 1 2, 111\n    Expected Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation is valid. The one with minimum cost is the original permutation.\n\n    Case 2: All songs disliked\n    Input: 3, 3 1 2, 000\n    Expected Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation is valid. The one with minimum cost is the original permutation.\n\n    Case 3: Alternating likes and dislikes\n    Input: 4, 4 3 2 1, 1010\n    Expected Output: 4 1 3 2\n    Explanation: Liked songs (1 and 3) get higher ratings than disliked songs (2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting liked and disliked songs separately and assigning ratings accordingly will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs are rated higher than disliked ones while minimizing the difference from the original predicted ratings. The solution should handle multiple test cases efficiently, considering edge cases where all songs are liked or disliked.\nrequirement pool:\n- Develop the song recommendation algorithm.\n- Ensure the algorithm handles edge cases efficiently.\n- Integrate the recommendation module with the existing system.\n- Optimize the algorithm for performance with large datasets.\n- Enhance the user interface for better user interaction.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust their ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this, ensuring the solution is both simple and performant.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. Here, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs. In code, this can be implemented by ensuring that for indices i and j, if s_i=1 and s_j=0, then q_i > q_j.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation q that minimizes the sum of absolute differences between p and q. In code, this involves sorting and rearranging elements to achieve the minimum possible sum.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case:\n        - Read n, the number of songs.\n        - Read the permutation p of predicted ratings.\n        - Read the string s representing Monocarp's feedback.\n        - Separate the indices of liked and disliked songs based on s.\n        - Sort the liked and disliked indices separately.\n        - Assign ratings such that liked songs have higher ratings than disliked ones.\n        - Ensure the permutation q minimizes the sum of absolute differences with p.\n    3. Output the permutation q for each test case.\n\n# [edge case]\n    Case 1: All songs are liked (e.g., s = \"111\")\n    Expected output: The permutation q can be equal to p since all songs are liked, minimizing the sum of absolute differences to zero.\n\n    Case 2: All songs are disliked (e.g., s = \"000\")\n    Expected output: Any permutation q will satisfy the condition since there are no liked songs to compare against disliked ones.\n\n    Case 3: Alternating likes and dislikes (e.g., s = \"101010\")\n    Expected output: Ensure that liked songs have higher ratings than adjacent disliked songs, while minimizing the sum of absolute differences.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting liked and disliked songs separately and assigning ratings accordingly will handle these cases naturally.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings. The solution should handle multiple test cases efficiently, considering edge cases where all songs are liked or disliked.\nrequirement pool:\n- Develop the song recommendation algorithm to re-evaluate ratings.\n- Ensure the algorithm handles edge cases efficiently.\n- Integrate the recommendation module with the existing system.\n- Optimize the algorithm for performance with large datasets.\n- Enhance the user interface for better user interaction.\nWe will implement a function that processes multiple test cases to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings. We will use sorting and list manipulation to achieve this efficiently. The solution will handle edge cases where all songs are liked or disliked by directly assigning the permutation as the result.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to calculate the difference between the original and new ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs. In code, this can be implemented by ensuring that indices corresponding to liked songs have higher values than those corresponding to disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation with the minimum possible sum of absolute differences between original and new ratings. In code, this can be achieved by sorting and rearranging elements to minimize differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, the permutation p, and the string s.\n3. Separate indices of liked and disliked songs based on s.\n4. Sort the original ratings p.\n5. Assign the highest available ratings to liked songs and the lowest to disliked songs while maintaining permutation constraints.\n6. Calculate the permutation q such that the sum of absolute differences is minimized.\n7. Print the result for each test case.\n\n# [edge case]\n    Case 1: All songs are liked (e.g., s = \"111\")\n    Expected output: The permutation q should be equal to p since all permutations are valid and the minimum difference is achieved by keeping p unchanged.\n\n    Case 2: All songs are disliked (e.g., s = \"000\")\n    Expected output: Any permutation is valid, but choosing q = p minimizes the sum of absolute differences.\n\n    Case 3: Alternating likes and dislikes (e.g., s = \"101010\")\n    Expected output: Ensure that liked songs have higher ratings than disliked ones by assigning higher values to indices with '1' and lower values to indices with '0'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between predicted and new ratings.\nrequirement pool:\n- Implement song recommendation module with permutation logic\n- Ensure liked songs have higher ratings than disliked ones\n- Optimize for minimum sum of absolute differences\n- Handle edge cases where all songs are liked or disliked\n- Maintain efficient performance for large input sizes\nWe will implement a function that processes multiple test cases to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences between predicted and new ratings. We will use sorting and permutation logic to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings must be rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. Here, it is used to minimize the difference between predicted and new ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs. In code, this can be implemented by ensuring that indices corresponding to liked songs have higher values than those corresponding to disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between predicted and new ratings. In code, this can be implemented by sorting and rearranging elements to achieve the minimum possible sum.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, the permutation p, and the string s.\n3. Separate indices of liked and disliked songs based on s.\n4. Sort the liked and disliked indices separately.\n5. Assign the highest available ratings to liked songs and lowest to disliked songs while maintaining permutation constraints.\n6. Calculate the sum of absolute differences between p and q.\n7. Output the permutation q for each test case.\n\n# [edge case]\n    Case 1: All songs are liked (e.g., s = \"111\")\n    Expected output: The permutation q should be equal to p because no rearrangement is needed, minimizing the sum of absolute differences to zero.\n\n    Case 2: All songs are disliked (e.g., s = \"000\")\n    Expected output: Any permutation q will work as long as it forms a valid permutation, but ideally, it should be equal to p for minimum cost.\n\n    Case 3: Alternating likes and dislikes (e.g., s = \"101010\")\n    Expected output: Ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, with minimal deviation from predicted ratings.\nrequirement pool:\n- Implement song recommendation algorithm\n- Develop user interface for liking/disliking songs\n- Optimize algorithm for minimal rating deviation\n- Ensure seamless integration with existing system\n- Support for edge cases in recommendation logic\nWe will implement a function that processes each test case independently. The function will separate the songs into liked and disliked categories based on the input string. It will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring the permutation constraint is maintained. The approach will use sorting and indexing to efficiently assign ratings, minimizing the absolute difference from the original predicted ratings.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings must be rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to minimize the difference between the original and new ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs.\n    'smallest value': This refers to minimizing the sum of absolute differences between original and new ratings.\n\n# [degree adverb]\n    'smallest': This means finding the permutation that results in the least possible sum of absolute differences.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, the permutation p, and the string s.\n    3. Separate indices of liked and disliked songs based on s.\n    4. Sort the indices of liked songs by their predicted ratings in descending order.\n    5. Sort the indices of disliked songs by their predicted ratings in ascending order.\n    6. Assign the highest available ratings to liked songs and lowest to disliked songs.\n    7. Ensure the permutation constraint is maintained.\n    8. Output the new permutation for each test case.\n\n# [edge case]\n    Case 1: All songs are liked\n    Input: 3, 1 2 3, 111\n    Expected Output: 1 2 3\n    Explanation: Since all songs are liked, the original permutation can be used as it satisfies the condition.\n\n    Case 2: All songs are disliked\n    Input: 3, 3 2 1, 000\n    Expected Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation is valid as there are no liked songs to compare against.\n\n    Case 3: Alternating likes and dislikes\n    Input: 4, 4 3 2 1, 1010\n    Expected Output: 3 4 1 2\n    Explanation: Liked songs (indices 0 and 2) should have higher ratings than disliked songs (indices 1 and 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between predicted and new ratings. Edge cases include scenarios where all songs are liked or disliked.\nrequirement pool:\n- Implement algorithm to adjust song ratings based on user feedback\n- Ensure permutation of ratings is maintained\n- Optimize for minimal sum of absolute differences\n- Handle edge cases where all songs are liked or disliked\n- Develop user interface for liking/disliking songs\nWe will implement a function that processes multiple test cases to adjust song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while maintaining a permutation of ratings. The approach involves sorting the songs based on their predicted ratings and user feedback, then assigning new ratings to minimize the sum of absolute differences. We will use Python's built-in sorting capabilities to efficiently handle the permutation and rating adjustments.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this requirement, it means that the ratings must be rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. Here, it is used to calculate the sum of differences between predicted and new ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs. In code, this can be implemented by ensuring that the indices of liked songs are assigned higher values than those of disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between predicted and new ratings. In code, this can be implemented by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of songs, predicted ratings, and feedback string.\n3. Separate the indices of liked and disliked songs.\n4. Sort the predicted ratings.\n5. Assign the highest ratings to liked songs and lowest to disliked songs to ensure q_i > q_j for liked over disliked.\n6. Calculate the permutation that minimizes the sum of absolute differences.\n7. Output the permutation for each test case.\n\n# [edge case]\n    Case 1: All songs are liked\n    Input: 3 3 1 2 111\n    Expected Output: 1 2 3\n    Explanation: Since all songs are liked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Case 2: All songs are disliked\n    Input: 3 3 1 2 000\n    Expected Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Case 3: Alternating likes and dislikes\n    Input: 4 4 3 2 1 0101\n    Expected Output: 4 1 3 2\n    Explanation: Liked songs (indices 2 and 4) should have higher ratings than disliked ones (indices 1 and 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on feedback will naturally handle these scenarios.\n", "requirement analysis:\nThe system needs to re-evaluate song ratings based on user feedback while maintaining a permutation of ratings. The challenge is to ensure liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between predicted and new ratings. Edge cases include scenarios where all songs are liked or disliked.\nrequirement pool:\n- Implement song rating re-evaluation algorithm\n- Optimize for minimum sum of absolute differences\n- Ensure permutation integrity in ratings\n- Handle edge cases for all liked or disliked songs\n- Improve user interface for feedback collection\nWe will implement a function to re-evaluate song ratings based on user feedback while maintaining a permutation of ratings. The function will ensure liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between predicted and new ratings. We will use Python's built-in sorting capabilities to efficiently handle the permutation and rating adjustments.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements. In this context, it means that the ratings are a sequence of numbers from 1 to n, each appearing exactly once.\n\n    'liked' and 'disliked'\n    Explanation: These terms refer to Monocarp's feedback on the songs. A 'liked' song should have a higher rating than any 'disliked' song in the new permutation.\n\n# [phrase showing quantity relationship]\n    'greater than'\n    Explanation: This indicates that the new rating for liked songs must be numerically higher than the ratings for disliked songs. In code, this can be implemented by ensuring that all liked songs are assigned higher numbers in the permutation than disliked songs.\n\n# [degree adverb]\n    'smallest'\n    Explanation: This refers to finding the permutation that minimizes the sum of absolute differences between the predicted and new ratings. In code, this involves sorting and assigning ratings to minimize these differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Read n, the number of songs.\n   - Read the permutation p of predicted ratings.\n   - Read the string s representing likes and dislikes.\n3. Separate the indices of liked and disliked songs.\n4. Sort the liked and disliked indices based on their predicted ratings.\n5. Assign the highest available ratings to liked songs and the lowest to disliked songs.\n6. Construct the new permutation q based on these assignments.\n7. Output the permutation q for each test case.\n\n# [edge case]\n    Case 1: All songs liked\n    Input: 3, 3 1 2, 111\n    Expected Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation is valid, but using the original minimizes the sum of absolute differences.\n\n    Case 2: All songs disliked\n    Input: 3, 3 1 2, 000\n    Expected Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation is valid, but using the original minimizes the sum of absolute differences.\n\n    Case 3: Alternating likes and dislikes\n    Input: 4, 4 3 2 1, 1010\n    Expected Output: 4 1 3 2\n    Explanation: Liked songs (1st and 3rd) get higher ratings than disliked (2nd and 4th).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes inherently handles these scenarios.\n", "requirement analysis:\nThe system needs to efficiently re-evaluate song ratings based on user feedback while maintaining a permutation of ratings. The algorithm should prioritize songs liked by users and ensure they have higher ratings than disliked songs. Edge cases, such as all songs being liked or disliked, should be handled gracefully.\nrequirement pool:\n- Implement efficient permutation algorithm for rating adjustment\n- Develop user interface for feedback collection\n- Integrate local artist support features\n- Optimize backend for handling large datasets\n- Enhance recommendation engine based on user feedback\nWe will implement a function that efficiently re-evaluates song ratings based on user feedback while maintaining a permutation of ratings. The function will prioritize songs liked by users and ensure they have higher ratings than disliked songs. We will use sorting and list manipulation techniques to achieve this. The edge cases where all songs are liked or disliked will be handled by simply returning the original permutation or a sorted permutation respectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are a sequence of numbers from 1 to n, each appearing exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value. Here, it is used to calculate the difference between the predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': Songs that Monocarp liked should have a greater rating than those he disliked. This means for indices i and j, if s_i=1 and s_j=0, then q_i > q_j.\n\n# [degree adverb]\n    'smallest': We need to find the permutation q that minimizes the sum of absolute differences between p and q.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Read n, the permutation p, and the string s.\n   - Separate the indices of liked and disliked songs based on s.\n   - Sort the liked and disliked indices based on their values in p.\n   - Assign the highest available ratings to liked songs and the lowest to disliked songs to minimize the sum of absolute differences.\n   - Construct the permutation q by placing these ratings in their respective positions.\n3. Output the permutation q for each test case.\n\n# [edge case]\n    Case 1: All songs are liked (s consists entirely of '1's).\n    Example: n = 3, p = [3, 1, 2], s = \"111\"\n    Expected output: 3 1 2\n    Explanation: Since all songs are liked, the permutation with minimum cost is the original permutation.\n\n    Case 2: All songs are disliked (s consists entirely of '0's).\n    Example: n = 3, p = [3, 1, 2], s = \"000\"\n    Expected output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but sorting gives the minimum cost.\n\n    Case 3: Alternating likes and dislikes.\n    Example: n = 4, p = [4, 3, 2, 1], s = \"1010\"\n    Expected output: 4 1 3 2\n    Explanation: Assign higher ratings to liked songs (4 and 3) and lower ratings to disliked songs (1 and 2).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting liked and disliked songs separately and assigning ratings accordingly will naturally handle these cases.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining permutation integrity. The challenge lies in ensuring liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between predicted and new ratings.\nrequirement pool:\n- Implement song recommendation module with permutation integrity\n- Ensure liked songs have higher ratings than disliked ones\n- Optimize for minimum sum of absolute differences\n- Handle edge cases where all songs are liked or disliked\n- Develop intuitive user interface for feedback\nWe will implement a function to re-evaluate song ratings based on user feedback while maintaining permutation integrity. The function will ensure liked songs have higher ratings than disliked ones and optimize for the minimum sum of absolute differences. We will use Python's built-in sorting capabilities to efficiently handle the permutation and rating adjustments.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are a sequence where each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. Here, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs. In code, this can be implemented by ensuring that indices corresponding to liked songs have higher values than those corresponding to disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between predicted and re-evaluated ratings. In code, this can be implemented by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, the permutation p, and the string s.\n3. Separate indices of liked and disliked songs based on s.\n4. Sort the liked and disliked indices separately.\n5. Assign the highest available ratings to liked songs and the lowest to disliked songs.\n6. Calculate the permutation q such that the sum of absolute differences is minimized.\n7. Print the permutation q for each test case.\n\n# [edge case]\n    Case 1: All songs are liked (e.g., s = \"111\")\n    Expected output: The permutation q should be equal to p because all permutations are valid, and the minimum sum of absolute differences is achieved when q = p.\n\n    Case 2: All songs are disliked (e.g., s = \"000\")\n    Expected output: Any permutation is valid, but q = p minimizes the sum of absolute differences.\n\n    Case 3: Alternating likes and dislikes (e.g., s = \"101010\")\n    Expected output: Ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes will naturally handle these scenarios.\n"], "scores": [], "pass_results": [false, true, true, false, false, true, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 861, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "mutate_method": "expand_one2two", "parent_index": 83}
