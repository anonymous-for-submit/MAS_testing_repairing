{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is determined to find the best way to poison the dragon efficiently, ensuring victory while using resources sparingly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is determined to find the best way to poison the dragon efficiently, ensuring victory while using resources sparingly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is determined to find the best way to poison the dragon efficiently, ensuring victory while using resources sparingly. The poison must be administered in such a way that it guarantees success. It needs to guarantee that the dragon is defeated. In this problem, you are tasked with calculating the minimum number of poison doses required. Each dose has a specific potency that diminishes over time, so timing is crucial. Your goal is to develop an algorithm that identifies the optimal schedule for administering the doses.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is determined to find the best way to poison the dragon efficiently, ensuring victory while using resources sparingly.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = calculate_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_min_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp deals at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            # Calculate the total damage with k = mid\n            total_damage = 0\n            for i in range(n - 1):\n                total_damage += min(mid, a[i + 1] - a[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Check if the total damage is at least h\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output interface\n    results = calculate_min_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_k(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing n, h, and a list of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        \n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage with current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Check if the total damage is at least h\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attacks = list(map(int, input().split()))\n    test_cases.append((n, h, attacks))\n\n# Output interface\nresults = minimum_k(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_doses(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum number of poison doses required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low <= high:\n            mid = (low + high) // 2\n            if can_defeat_dragon(n, h, attacks, mid):\n                high = mid - 1\n            else:\n                low = mid + 1\n        results.append(low)\n\n    return results\n\ndef can_defeat_dragon(n: int, h: int, attacks: List[int], k: int) -> bool:\n    \"\"\"Check if the dragon can be defeated with a given k.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage.\n        attacks (List[int]): List of attack times.\n        k (int): Current potency of each dose.\n\n    Returns:\n        bool: True if the dragon can be defeated, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    total_damage += k  # Add the damage from the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print the results\n    results = minimum_poison_doses(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_doses(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum number of poison doses required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if can_defeat_dragon(n, h, attacks, mid):\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n\n    return results\n\ndef can_defeat_dragon(n: int, h: int, attacks: List[int], k: int) -> bool:\n    \"\"\"Check if the dragon can be defeated with a given k.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage to defeat the dragon.\n        attacks (List[int]): List of attack times.\n        k (int): Current value of k being tested.\n\n    Returns:\n        bool: True if the dragon can be defeated, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Call the function and print the results\n    results = minimum_poison_doses(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_doses(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum number of poison doses required to defeat the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attacks (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: List of minimum values of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_doses(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_attack_power(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum attack power k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum attack power k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n - 1):\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output results\n    results = minimum_attack_power(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to ensure at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp's attacks deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attack_times (List[int]): List of integers representing the seconds when attacks are performed.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        result = h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                result = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(result)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attack_times = list(map(int, input().split()))\n    test_cases.append((n, h, attack_times))\n\n# Output interface\nresults = minimum_k(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = calculate_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement focuses on calculating the minimum parameter k to ensure Monocarp deals at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large values for n and h, ensuring optimal resource usage and clear output.\nrequirement pool:\n- Calculate minimum k for each test case efficiently.\n- Ensure solution handles large input values effectively.\n- Provide clear and concise output format.\n- Optimize resource usage during calculation.\n- Include detailed comments for understanding the process.\nWe will use a binary search algorithm to efficiently determine the minimum value of k. This approach is suitable because it allows us to quickly narrow down the possible values of k by checking if a given k can achieve the required damage h. The binary search will be applied over the range of possible k values, leveraging the sorted nature of attack times to calculate the damage efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum value of the parameter k'\n    Explanation: This refers to finding the smallest integer k such that the total damage dealt by Monocarp's attacks is at least h.\n\n    'at least h damage'\n    Explanation: The total damage caused by the attacks must be greater than or equal to h.\n\n# [phrase showing quantity relationship]\n    'at least': This means the damage must be greater than or equal to h. In code, this can be implemented using a comparison operator like `>=`.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Use binary search to find the minimum k:\n     - Set initial low and high bounds for k.\n     - While low is less than high:\n       - Calculate mid as the average of low and high.\n       - Calculate the total damage for this mid value of k.\n       - If the total damage is at least h, adjust high to mid.\n       - Otherwise, adjust low to mid + 1.\n   - Output the value of low as it represents the minimum k.\n\n# [edge case]\n    Edge Case 1: n = 1, h = 1, a = [1] = 1\n    Explanation: With only one attack needed and h = 1, k must be at least 1 to deal the required damage.\n\n    Edge Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100] = 10^18\n    Explanation: With maximum n and h values, the algorithm must efficiently find k without exceeding time limits.\n\n    Edge Case 3: n = 2, h = 10^9, a = [1, 10^9] = 10^9\n    Explanation: The large gap between attack times tests if the algorithm correctly calculates damage over large intervals.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on whether the calculated damage meets or exceeds h.\n", "requirement analysis:\nThe requirement focuses on calculating the minimum value of k to ensure Monocarp deals at least h damage to the dragon. The solution must efficiently handle multiple test cases and large values of h, ensuring optimal resource usage and maximum damage output.\nrequirement pool:\n- Calculate minimum k for each test case efficiently.\n- Handle large values of h without performance issues.\n- Ensure output format is clear and concise.\n- Optimize resource usage in calculations.\n- Provide detailed documentation for the solution.\nWe will use a binary search algorithm to efficiently find the minimum value of k that ensures Monocarp deals at least h damage to the dragon. This approach is suitable given the constraints, as it allows us to handle large values of h and multiple test cases efficiently. We will leverage Python's built-in capabilities for handling large integers and use a simple loop to simulate the damage calculation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'binary search'\n    Explanation: Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the portion of the list that could contain the item in half until you've narrowed down the possible locations to just one.\n\n    'minimum value of k'\n    Explanation: The task is to find the smallest integer k such that the total damage dealt is at least h. This involves calculating the damage for different values of k and finding the smallest one that meets the requirement.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the calculated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition. This can be implemented using a binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Initialize binary search bounds for k (e.g., low = 1, high = h).\n4. Perform binary search:\n   - Calculate mid = (low + high) // 2.\n   - Simulate the damage dealt with k = mid.\n   - If the damage is at least h, update high = mid.\n   - Otherwise, update low = mid + 1.\n5. After binary search, low will be the minimum k that satisfies the condition.\n6. Print the result for each test case.\n\n# [edge case]\n    Test case: 1 1\n              1\n    Expected output: 1\n    Explanation: With only one attack needed and one damage required, k must be at least 1.\n\n    Test case: 2 1000000000000000000\n              1 1000000000\n    Expected output: 1000000000\n    Explanation: With a very large h and only two attacks, k must be very large to accumulate enough damage.\n\n    Test case: 3 10\n              1 2 3\n    Expected output: 4\n    Explanation: The attacks are spaced such that k must be at least 4 to ensure enough overlap to reach h.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the bounds based on whether the current k meets the damage requirement.\n", "requirement analysis:\nThe game requires a strategic approach to determine the minimum value of k for each test case, ensuring that Monocarp can efficiently defeat the dragon using the least amount of resources. The solution should handle up to 1000 test cases and large values for h, up to 10^18, while maintaining performance.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k\n- Ensure scalability for large input values\n- Provide clear output format for test cases\n- Optimize resource usage in gameplay\n- Enhance user experience with strategic feedback\nWe will use a binary search algorithm to efficiently determine the minimum value of k. The binary search will help us find the smallest k such that the total damage dealt is at least h. This approach is efficient and suitable for handling the large input constraints provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum value of the parameter k'\n    Explanation: This refers to finding the smallest possible value of k such that the total damage dealt to the dragon is at least h.\n\n    'at least h damage'\n    Explanation: This means the total damage caused by Monocarp's attacks must be equal to or greater than h.\n\n# [phrase showing quantity relationship]\n    'at least': This indicates a condition where the total damage must be greater than or equal to h. In code, this can be implemented using a comparison operator like `>=`.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read integers n and h.\n   - Read the list of attack times.\n3. Implement a binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - While the lower bound is less than or equal to the upper bound:\n     - Calculate the mid-point of k.\n     - Simulate the damage dealt with this k.\n     - If the damage is at least h, adjust the upper bound to search for a smaller k.\n     - Otherwise, adjust the lower bound to search for a larger k.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack needed and h = 1, k = 1 is sufficient.\n\n    Test case 2: n = 100, h = 1, a = [1, 2, ..., 100] => Expected output: 1\n    Explanation: Even with maximum attacks, if h = 1, k = 1 is sufficient.\n\n    Test case 3: n = 2, h = 10^18, a = [1, 10^9] => Expected output: A large number\n    Explanation: With very high h and sparse attacks, k needs to be large enough to cover the gap between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these cases by adjusting bounds based on whether the current k satisfies the condition.\n", "requirement analysis:\nThe problem requires developing an algorithm that calculates the minimum number of poison doses needed to defeat a dragon. The algorithm must consider the timing of each dose, as potency diminishes over time. The solution should handle up to 1000 test cases efficiently, with each test case involving up to 100 attacks and damage values as high as 10^18.\nrequirement pool:\n- Develop an algorithm to calculate minimum poison doses\n- Ensure the algorithm handles up to 1000 test cases efficiently\n- Optimize the algorithm for large damage values\n- Provide clear and accurate output for each test case\n- Document the algorithm for ease of understanding and maintenance\nWe will use a binary search approach to determine the minimum number of poison doses required. The key idea is to simulate the damage over time and adjust the dose potency using binary search to find the minimum value of k that ensures the total damage is at least h. This approach is efficient and scalable, handling up to 1000 test cases with large damage values.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum number of poison doses'\n    Explanation: The requirement is to find the least number of doses needed to ensure the dragon is defeated, which implies optimizing the use of resources.\n\n    'optimal schedule'\n    Explanation: This refers to the timing and sequence of administering doses to maximize their effectiveness.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest possible value of k that achieves the required damage. In code, this can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Use binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - While low is less than or equal to high:\n            - Calculate mid as the average of low and high.\n            - Simulate the damage for k = mid.\n            - If the damage is at least h, adjust high; otherwise, adjust low.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with n = 1 and h = 1, a_1 = 1\n    Expected output: 1\n    Explanation: With only one attack needed and minimum damage required, k = 1 is sufficient.\n\n    Test case with n = 100 and h = 10^18, a_i = i (1 \u2264 i \u2264 100)\n    Expected output: A large number close to h/n\n    Explanation: The large h requires a significant number of doses, testing the upper limits of input constraints.\n\n    Test case with n = 2 and h = 10^9, a_1 = 1, a_2 = 10^9\n    Expected output: A value that ensures damage is spread over the large gap between attacks.\n    Explanation: The large gap between attacks requires careful calculation of k to ensure sufficient damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying input sizes and constraints efficiently.\n", "requirement analysis:\nThe problem requires developing an algorithm that efficiently calculates the minimum number of poison doses needed to defeat a dragon. The algorithm must consider the timing of each dose due to diminishing potency and ensure that the total damage meets or exceeds the required threshold. The solution must handle up to 1000 test cases and large input sizes efficiently.\nrequirement pool:\n- Develop the main algorithm to calculate minimum doses\n- Ensure the algorithm handles up to 1000 test cases\n- Optimize the algorithm for large input sizes\n- Provide clear and accurate output for each test case\n- Document the solution for ease of understanding\nWe will use a binary search algorithm to efficiently determine the minimum number of poison doses required. The binary search will help us find the smallest value of k such that the total damage dealt is at least h. This approach is efficient and scalable, handling up to 1000 test cases and large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum number of poison doses'\n    Explanation: The task is to find the smallest number of doses (k) that will ensure the total damage is at least h.\n\n    'optimal schedule for administering the doses'\n    Explanation: The timing of the doses is crucial because the potency diminishes over time, so the schedule must be optimized to ensure maximum damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Use binary search to find the minimum k:\n   - Set low = 1 and high = h (or a large enough value).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Simulate the damage with k = mid.\n     - If the total damage is >= h, set high = mid.\n     - Otherwise, set low = mid + 1.\n4. Output the value of low for each test case as it represents the minimum k.\n\n# [edge case]\n    Test case 1: (1, 1, [1]) = 1\n    Explanation: With only one attack needed and one second available, k=1 is sufficient.\n\n    Test case 2: (2, 10, [1, 1000000000]) = 10\n    Explanation: The attacks are far apart, so each attack must deal maximum damage. k=10 ensures that at least 10 damage is dealt.\n\n    Test case 3: (100, 1000000000000000000, [1, 2, ..., 100]) = 10000000000\n    Explanation: With a very high damage requirement and many attacks, k must be large enough to accumulate sufficient damage over time.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k until the condition is met.\n", "requirement analysis:\nThe requirements focus on developing an algorithm that efficiently calculates the minimum number of poison doses needed to defeat the dragon. The algorithm must consider the timing of each dose due to diminishing potency and ensure that the total damage meets or exceeds the required amount. The solution should handle multiple test cases and large input sizes effectively.\nrequirement pool:\n- Develop the main algorithm for poison scheduling\n- Ensure scalability for large input sizes\n- Optimize for efficiency in processing\n- Provide clear output format\n- Include comprehensive test cases\nWe will use a binary search approach to determine the minimum value of k, which represents the potency of each poison dose. The binary search will help efficiently find the smallest k that ensures the total damage is at least h. This approach is chosen for its balance between efficiency and scalability, making it suitable for handling large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum number of poison doses'\n    Explanation: The requirement is to find the smallest number of doses needed to ensure the dragon is defeated, which means calculating the least amount of resources required to achieve the goal.\n\n    'optimal schedule'\n    Explanation: This refers to the timing and sequence of administering the poison doses to maximize their effectiveness and ensure the dragon is defeated.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage caused by the poison doses must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest possible value of k that ensures the dragon is defeated. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    - Initialize variables for binary search: low and high bounds for k.\n    - Perform binary search:\n        - Calculate mid-point k.\n        - Simulate the damage caused by k doses.\n        - If damage is at least h, adjust high bound; otherwise, adjust low bound.\n    - Return the minimum k found.\n\n# [edge case]\n    Input: 1 1\n           1\n    Output: 1\n    Explanation: With only one attack needed and one dose available, the minimum k is 1.\n\n    Input: 2 1\n           1 2\n    Output: 1\n    Explanation: Even with two attacks, only one dose is needed to meet the minimum damage requirement.\n\n    Input: 100 10^18\n           1 2 3 ... 100\n    Output: Large value (depends on implementation)\n    Explanation: With a very high damage requirement, the algorithm must efficiently find a large k using binary search.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying input sizes and damage requirements efficiently.\n", "requirement analysis:\nThe requirements focus on determining the minimum attack power needed to achieve a specified amount of damage to the dragon. The solution should efficiently calculate the parameter k for each test case, ensuring that the damage dealt meets or exceeds the required amount.\nrequirement pool:\n- Calculate minimum attack power k for each test case.\n- Ensure the solution handles large values of h efficiently.\n- Optimize the sequence of attacks to minimize resource usage.\n- Provide clear output format for test case results.\n- Include detailed notes on attack strategy.\nWe will use a binary search approach to efficiently determine the minimum attack power k. The key challenge is to ensure that the solution can handle large values of h efficiently, which is why binary search is suitable. We will calculate the total damage for a given k and adjust k accordingly until we find the minimum value that satisfies the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum value of the parameter k'\n    Explanation: This refers to finding the smallest possible value of k such that the total damage dealt to the dragon is at least h.\n\n    'at least h damage'\n    Explanation: This means the total damage must be greater than or equal to h.\n\n# [phrase showing quantity relationship]\n    'at least': This indicates a condition where the total damage must be greater than or equal to h. In code, this can be implemented using a comparison operator (>=).\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition. In code, this can be implemented using a binary search to efficiently find the minimum value.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n3. Use binary search to find the minimum k:\n   - Set initial low and high bounds for k.\n   - While low is less than high:\n     - Calculate mid as the average of low and high.\n     - Calculate total damage for k = mid.\n     - If total damage is at least h, adjust high to mid.\n     - Otherwise, adjust low to mid + 1.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack needed and h = 1, k must be at least 1.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large number close to h/n\n    Explanation: The large value of h requires a large k to ensure sufficient damage.\n\n    Case 3: n = 2, h = 10, a = [1, 1000000000]\n    Expected output: 5\n    Explanation: The large gap between attacks means k must be large enough to cover the gap and deal enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirements focus on determining the minimum value of parameter k to ensure Monocarp deals at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases, with each test case involving up to 100 attacks and requiring damage calculations up to 10^18.\nrequirement pool:\n- Efficiently calculate the minimum k for each test case\n- Handle large input sizes and ensure performance\n- Provide clear output format for test results\n- Ensure intuitive understanding of attack mechanics\n- Optimize code for readability and maintainability\nWe will use a binary search algorithm to efficiently determine the minimum value of k for each test case. The binary search will help in narrowing down the possible values of k by checking if a given k can achieve the required damage h. This approach is efficient and suitable for handling the large input sizes specified in the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum value of the parameter k'\n    Explanation: The requirement is to find the smallest possible value of k such that the total damage dealt is at least h.\n\n    'damage'\n    Explanation: The damage is calculated based on the attacks performed at specific seconds, and the parameter k determines the duration of each attack's effect.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. This can be implemented by ensuring the sum of damage over the attack intervals meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n and h, and then read the attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., low = 1, high = maximum possible k).\n        - Calculate the total damage for a mid value of k.\n        - Adjust bounds based on whether the damage is sufficient.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with n = 1 and h = 1, a_1 = 1\n    Expected output: 1\n    Explanation: With only one attack needed and minimum damage required, k = 1 is sufficient.\n\n    Test case with n = 100 and h = 10^18, a_1 = 1, a_2 = 2, ..., a_100 = 100\n    Expected output: A large value close to h/n\n    Explanation: The large h requires a significant k to accumulate enough damage over many attacks.\n\n    Test case with n = 2 and h = 10, a_1 = 1, a_2 = 10\n    Expected output: 5\n    Explanation: The attacks are spaced out, requiring a larger k to cover the gap and meet the damage requirement.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying input sizes and conditions efficiently.\n", "requirement analysis:\nThe requirements focus on determining the minimum parameter k to ensure Monocarp's attacks deal at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with varying attack times and damage requirements, ensuring optimal performance even for large values of h.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k\n- Ensure solution handles large input sizes effectively\n- Provide clear output format for test cases\n- Optimize code for performance\n- Enhance user experience with intuitive gameplay mechanics\nWe will implement a binary search algorithm to efficiently determine the minimum value of k such that Monocarp's attacks deal at least h damage to the dragon. The binary search will be applied on the possible values of k, leveraging the sorted nature of attack times to calculate the damage efficiently. This approach ensures optimal performance even for large values of h and multiple test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum value of the parameter k'\n    Explanation: The requirement is to find the smallest possible value of k that ensures Monocarp's attacks deal at least h damage to the dragon.\n\n    'binary search'\n    Explanation: A search algorithm that efficiently finds the target value by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible k that satisfies the condition. In code, this can be implemented using a binary search to minimize k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n and h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - While low <= high:\n            - Calculate mid as (low + high) // 2.\n            - Calculate total damage for k = mid.\n            - If total damage >= h, update result and set high = mid - 1.\n            - Otherwise, set low = mid + 1.\n    4. Print the result for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack needed and one damage required, k=1 is sufficient.\n\n    Test case with maximum h:\n    1 10^18\n    1\n    Expected output: 10^18\n    Explanation: With only one attack time, k must be equal to h to deal the required damage.\n\n    Test case with attacks spaced far apart:\n    3 10\n    1 1000 2000\n    Expected output: 5\n    Explanation: The minimum k that allows at least 10 damage is when attacks are spaced such that damage accumulates over time.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the bounds based on the calculated damage.\n", "requirement analysis:\nThe requirement focuses on calculating the minimum value of k to ensure Monocarp's attacks deal at least h damage to the dragon. The solution should efficiently handle multiple test cases and optimize the attack strategy.\nrequirement pool:\n- Calculate minimum k for each test case\n- Ensure attacks are timed optimally\n- Optimize resource usage\n- Maximize damage output\n- Provide detailed attack strategy\nWe will use a binary search algorithm to efficiently determine the minimum value of k for each test case. This approach is suitable given the constraints, as it allows us to handle large values of h and multiple test cases efficiently. The binary search will help us find the smallest k such that the total damage is at least h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'minimum value of the parameter k'\n    Explanation: This refers to finding the smallest possible value of k such that the total damage dealt to the dragon is at least h.\n\n    'at least h damage'\n    Explanation: This means the total damage must be equal to or greater than h.\n\n# [phrase showing quantity relationship]\n    'at least': This indicates a condition where the damage must be greater than or equal to h. In code, this can be implemented using a comparison operator like `>=`.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read integers n and h.\n   - Read the list of attack times.\n3. Implement a binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - While the lower bound is less than or equal to the upper bound:\n     - Calculate the mid-point of k.\n     - Simulate the damage dealt with this k.\n     - If the damage is at least h, adjust the upper bound to search for a smaller k.\n     - Otherwise, adjust the lower bound to search for a larger k.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case 1: (1, 1, [1]) = 1\n    Explanation: With only one attack needed and one damage required, k=1 is sufficient.\n\n    Test case 2: (2, 10^18, [1, 10^9]) = 10^18\n    Explanation: With extremely high damage required and only two attacks, k must be very large.\n\n    Test case 3: (100, 1, [1, 2, ..., 100]) = 1\n    Explanation: With many attacks and only one damage required, k=1 is sufficient.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting bounds based on whether the current k satisfies the damage requirement.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 977, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "rephrase_one", "parent_index": 77}
