{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n by m, consisting of n rows and m columns of blocks, where each block is either an obsidian block or an empty block and can be switched between these types with a single operation. A rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the number of rows be at least 5 and columns at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n by m, consisting of n rows and m columns of blocks, where each block is either an obsidian block or an empty block and can be switched between these types with a single operation. A rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the number of rows be at least 5 and columns at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m, consisting of n rows and m columns of blocks, where each block is either an obsidian block or an empty block and can be switched between these types with a single operation. A rectangle M of size a \u00d7 b is referred to as a portal. This is true if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the number of rows be at least 5. Additionally, the columns must be at least 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nKeep in mind that there must be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m, consisting of n rows and m columns of blocks, where each block is either an obsidian block or an empty block and can be switched between these types with a single operation. A rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria: * a \u2265 5,b \u2265 4, meaning it is necessary that the number of rows be at least 5 and columns at least 4. * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks, and for all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type. Keep in mind that there must be a rows and b columns, not b rows and a columns. CQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(t: int, matrices: list) -> list:\n    \"\"\"Find the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        matrices (list): List of matrices for each test case.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for matrix in matrices:\n        n, m = matrix.shape\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n\n                        # Check the border conditions\n                        for x in range(1, a - 1):\n                            if matrix[i + x, j] != 1:\n                                operations += 1\n                            if matrix[i + x, j + b - 1] != 1:\n                                operations += 1\n\n                        for y in range(1, b - 1):\n                            if matrix[i, j + y] != 1:\n                                operations += 1\n                            if matrix[i + a - 1, j + y] != 1:\n                                operations += 1\n\n                        # Check the inner blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if matrix[i + x, j + y] != 0:\n                                    operations += 1\n\n                        # Update the minimum operations found\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nt = int(input())\nmatrices = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().strip())) for _ in range(n)]\n    matrices.append(np.array(matrix))\n\n# Output interface\nresults = find_min_operations(t, matrices)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to create a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix)\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, matrix in test_cases:\n        # Convert the matrix into a numpy array for efficient manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        \n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of operations needed to transform the sub-rectangle into a portal\n                        operations = 0\n                        \n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[i + x, j] != 1:\n                                operations += 1\n                            if grid[i + x, j + b - 1] != 1:\n                                operations += 1\n                        for y in range(1, b - 1):\n                            if grid[i, j + y] != 1:\n                                operations += 1\n                            if grid[i + a - 1, j + y] != 1:\n                                operations += 1\n                        \n                        # Check inner conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x, j + y] != 0:\n                                    operations += 1\n                        \n                        # Update the minimum operations needed\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to create a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: A list of tuples, each containing (n, m, matrix) where matrix is a list of strings\n    :return: A list of integers, each representing the minimum operations for the corresponding test case\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient manipulation\n        matrix_np = np.array([list(row) for row in matrix], dtype=int)\n        \n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform the sub-rectangle into a portal\n                        operations = calculate_operations(matrix_np, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param matrix: The numpy array representation of the matrix\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: The number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check the edges of the portal\n    for x in range(start_row + 1, end_row):\n        if matrix[x, start_col] != 1:\n            operations += 1\n        if matrix[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if matrix[start_row, y] != 1:\n            operations += 1\n        if matrix[end_row, y] != 1:\n            operations += 1\n\n    # Check the internal blocks of the portal\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if matrix[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and matrix of blocks.\n\n    Returns:\n        list: Minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_operations = float('inf')\n\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array(matrix)\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Define the sub-rectangle dimensions\n                end_row = start_row + 5\n                end_col = start_col + 4\n\n                # Calculate the number of operations needed to transform the sub-rectangle into a portal\n                operations = 0\n\n                # Check border conditions\n                for x in range(start_row + 1, end_row - 1):\n                    if grid[x, start_col] != 1:\n                        operations += 1\n                    if grid[x, end_col - 1] != 1:\n                        operations += 1\n\n                for y in range(start_col + 1, end_col - 1):\n                    if grid[start_row, y] != 1:\n                        operations += 1\n                    if grid[end_row - 1, y] != 1:\n                        operations += 1\n\n                # Check inner blocks\n                for x in range(start_row + 1, end_row - 1):\n                    for y in range(start_col + 1, end_col - 1):\n                        if grid[x, y] != 0:\n                            operations += 1\n\n                # Update the minimum operations for this test case\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n\n    # Initialize list to store test cases\n    test_cases = []\n\n    # Read each test case\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().strip())) for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    # Call the function and print results\n    results = find_min_operations(t, test_cases)\n    for result in results:\n        print(result)\n\n# Ensure the main function is called when the script is executed\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a x b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n\n                        # Check the border conditions\n                        for x in range(a):\n                            if x == 0 or x == a - 1:\n                                # Top and bottom rows\n                                for y in range(1, b - 1):\n                                    if case[i + x][j + y] != '1':\n                                        operations += 1\n                            else:\n                                # Left and right columns\n                                if case[i + x][j] != '1':\n                                    operations += 1\n                                if case[i + x][j + b - 1] != '1':\n                                    operations += 1\n\n                        # Check the inner blocks\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if case[i + x][j + y] != '0':\n                                    operations += 1\n\n                        # Update the minimum operations found\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Determine the minimum number of operations needed to create a portal for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and matrix.\n\n    Returns:\n        list[int]: List of integers representing minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a x b\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Calculate operations needed for sub-rectangle starting at (i, j)\n                operations = calculate_operations(grid, i, j)\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    a, b = 5, 4  # Portal dimensions\n    operations = 0\n\n    # Check boundary conditions\n    for x in range(start_row + 1, start_row + a - 1):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, start_col + b - 1] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, start_col + b - 1):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[start_row + a - 1, y] != 1:\n            operations += 1\n\n    # Check interior conditions\n    for x in range(start_row + 1, start_row + a - 1):\n        for y in range(start_col + 1, start_col + b - 1):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef find_min_operations(test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Determine the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        test_cases: A list of tuples, each containing the dimensions of the rectangle and the grid.\n\n    Returns:\n        A list of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed for current sub-rectangle\n                        operations = calculate_operations(matrix, start_row, start_col, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix: The numpy array representing the grid.\n        start_row: The starting row of the sub-rectangle.\n        start_col: The starting column of the sub-rectangle.\n        a: The number of rows in the sub-rectangle.\n        b: The number of columns in the sub-rectangle.\n\n    Returns:\n        The number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Ensure border blocks are obsidian as required\n    for x in range(1, a - 1):\n        if matrix[start_row + x, start_col] == 0:\n            operations += 1\n        if matrix[start_row + x, start_col + b - 1] == 0:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if matrix[start_row, start_col + y] == 0:\n            operations += 1\n        if matrix[start_row + a - 1, start_col + y] == 0:\n            operations += 1\n\n    # Ensure inner blocks are empty\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[start_row + x, start_col + y] == 1:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = find_min_operations(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and matrix of blocks.\n\n    Returns:\n        list: List of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_operations = float('inf')\n\n        # Convert matrix to numpy array for efficient operations\n        np_matrix = np.array(matrix)\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(np_matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The matrix of blocks.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and count operations for the border blocks\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            operations += 1\n        if matrix[row, end_col] != 1:\n            operations += 1\n\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            operations += 1\n        if matrix[end_row, col] != 1:\n            operations += 1\n\n    # Check and count operations for the inner blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n\n    # Initialize list to store test cases\n    test_cases = []\n\n    # Read each test case\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().strip())) for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for start_row in range(n - a + 1):\n                    for start_col in range(m - b + 1):\n                        operations = 0\n\n                        # Check border conditions\n                        for x in range(1, a - 1):\n                            if grid[start_row + x][start_col] != '1':\n                                operations += 1\n                            if grid[start_row + x][start_col + b - 1] != '1':\n                                operations += 1\n\n                        for y in range(1, b - 1):\n                            if grid[start_row][start_col + y] != '1':\n                                operations += 1\n                            if grid[start_row + a - 1][start_col + y] != '1':\n                                operations += 1\n\n                        # Check internal conditions\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[start_row + x][start_col + y] != '0':\n                                    operations += 1\n\n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a matrix of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate operations needed for sub-rectangle starting at (start_row, start_col)\n                operations = 0\n\n                # Check border conditions\n                for i in range(start_row, start_row + 5):\n                    if i == start_row or i == start_row + 4:\n                        # Top and bottom borders\n                        for j in range(start_col + 1, start_col + 3):\n                            if case[i][j] != '1':\n                                operations += 1\n                    else:\n                        # Left and right borders\n                        if case[i][start_col] != '1':\n                            operations += 1\n                        if case[i][start_col + 3] != '1':\n                            operations += 1\n\n                # Check inner conditions\n                for i in range(start_row + 1, start_row + 4):\n                    for j in range(start_col + 1, start_col + 3):\n                        if case[i][j] != '0':\n                            operations += 1\n\n                # Update minimum operations\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m and the matrix\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append(matrix)\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on matrix dimensions and block types are clearly defined, ensuring the solution must efficiently handle edge cases and large inputs. The output format is crucial for user understanding and must be adhered to strictly.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation\n- Ensure solution handles maximum input sizes within constraints\n- Provide clear output format as specified in requirements\n- Optimize for speed and accuracy\n- Include detailed comments for code clarity\nWe will implement an efficient algorithm to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m matrix and calculate the number of operations required to meet the portal criteria. We will use numpy for efficient matrix manipulation and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix where the operations will be performed. It consists of n rows and m columns.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the placement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle (portal) must have at least 5 rows and 4 columns. This can be implemented by ensuring any sub-rectangle considered for transformation meets these minimum dimensions.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the least number of changes needed to transform a sub-rectangle into a portal. This involves counting the necessary changes and selecting the configuration with the fewest changes.\n\n# [code logic]\n1. Parse the input to extract the number of test cases, and for each test case, the dimensions n and m, followed by the matrix itself.\n2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met with obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Edge Case 1: A matrix that is already a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The matrix already satisfies the portal conditions, so no operations are needed.\n\n    Edge Case 2: A matrix with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: All inner blocks need to be changed to empty, and some border blocks need to be adjusted.\n\n    Edge Case 3: A matrix with all blocks as empty.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over possible sub-rectangles and calculating the minimum operations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on matrix dimensions and block types are clearly defined, ensuring the solution must efficiently handle the transformation process while adhering to the portal criteria.\nrequirement pool:\n- Implement efficient algorithm to determine minimum operations for portal creation.\n- Ensure solution handles maximum input constraints effectively.\n- Provide clear output format for user understanding.\n- Optimize code for fast computation.\n- Include detailed comments for code clarity.\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m matrix and calculate the number of operations required to meet the portal criteria. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix where the operations will be performed. It consists of n rows and m columns.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the placement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means we only consider sub-rectangles that meet these minimum dimensions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest number of operations required to transform a sub-rectangle into a portal. This involves calculating the number of changes needed for each possible sub-rectangle and selecting the smallest value.\n\n# [code logic]\n1. Parse the input to get the number of test cases, and for each test case, read the dimensions n and m, followed by the n lines representing the matrix.\n2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met with obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The entire grid is filled with obsidian blocks, requiring changes to meet the portal criteria.\n\n    Case 2:\n    Input:\n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: 16\n    Explanation: The entire grid is empty, requiring changes to meet the portal criteria.\n\n    Case 3:\n    Input:\n    1\n    5 4\n    1000\n    0000\n    0110\n    0000\n    0001\n    Expected Output: 12\n    Explanation: As given in the example, this configuration requires specific changes to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on matrix dimensions and block types are clearly defined, ensuring the solution must efficiently handle the transformation process while adhering to these rules.\nrequirement pool:\n- Implement efficient matrix transformation algorithm\n- Ensure solution handles maximum input sizes\n- Provide clear output format for test cases\n- Optimize for speed and accuracy\n- Include detailed comments and documentation\nWe will implement a function that iterates over all possible sub-rectangles of the given matrix that meet the minimum size requirements for a portal. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will return the minimum number of operations required for each test case. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A sub-rectangle with specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The portal must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': Refers to the range of rows within the portal, excluding the first and last row.\n    'For all 1 < x < b': Refers to the range of columns within the portal, excluding the first and last column.\n\n# [degree adverb]\n    'minimum': The least number of operations needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles that meet the minimum size requirements (a \u2265 5, b \u2265 4).\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal by checking each block against the portal criteria.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected output: 12\n    Explanation: All blocks need to be transformed into obsidian blocks according to portal criteria.\n\n    Test case with all obsidian blocks:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected output: 8\n    Explanation: Only internal blocks need to be transformed into empty blocks.\n\n    Test case with mixed blocks:\n    Input:\n    1\n    6 5\n    10101\n    01010\n    10101\n    01010\n    10101\n    01010\n    Expected output: Depends on arrangement; calculate based on portal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating operations will handle these cases naturally.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient, especially given the maximum possible input size. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal criteria.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for portal creation.\n- Optimize the algorithm to handle maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The approach will involve iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations required to meet the portal criteria. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m': This refers to the main grid or matrix that contains blocks, which can be either obsidian or empty.\n    'portal': A sub-rectangle within the main grid that meets specific criteria to be considered a portal.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    Explanation: The task is to transform a sub-rectangle within a larger grid into a portal by changing blocks between obsidian and empty types.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The sub-rectangle must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': This means for all rows except the first and last, certain conditions must be met.\n    'For all 1 < x < b': This means for all columns except the first and last, certain conditions must be met.\n    Explanation: These phrases define the size constraints and specific conditions for the blocks within the portal.\n\n# [degree adverb]\n    'minimum number of operations': The goal is to achieve the transformation with the least number of changes.\n    Explanation: The task is to find the least number of changes needed to convert a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met (obsidian blocks on specified borders).\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the correct configuration for a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No operations are needed as it already forms a portal.\n\n    Case 2: A grid where no possible sub-rectangle can be transformed into a portal without changing every block.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All blocks need to be changed to meet the portal criteria.\n\n    Case 3: A grid with minimum size where only one operation is needed.\n    Example:\n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1110\n    Expected Output: 1\n    Explanation: Only one block needs to be changed to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient, given the potential size of the input. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal criteria.\nrequirement pool:\n- Develop an efficient algorithm to identify the minimum operations for portal formation.\n- Ensure the solution handles the maximum constraints effectively.\n- Provide detailed output for each test case.\n- Optimize the code for performance and scalability.\n- Include comprehensive test cases to validate the solution.\nWe will use a brute-force approach to iterate over all possible sub-rectangles of size a x b within the given n x m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal according to the given criteria. The solution will be optimized by early termination if a portal is found with zero operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can be either an obsidian block (represented by '1') or an empty block (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle of size a x b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The portal must have at least 5 rows and 4 columns. In code, this means any sub-rectangle considered must have dimensions that satisfy these conditions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The task is to find the least number of operations required to transform a sub-rectangle into a portal. This involves calculating the number of changes needed and selecting the smallest value.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size a x b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met with obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already in portal form\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle is already a portal, so no operations are needed.\n\n    Case 2: A rectangle with all blocks as obsidian\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The inner blocks need to be converted to empty blocks, requiring multiple operations.\n\n    Case 3: A rectangle with all blocks as empty\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: The border blocks need to be converted to obsidian blocks, requiring multiple operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are clear, ensuring the solution must efficiently handle the transformation process while adhering to the specified conditions.\nrequirement pool:\n- Implement efficient algorithm to determine minimum operations\n- Ensure solution handles maximum input constraints\n- Provide clear output format for user understanding\n- Optimize for speed and accuracy\n- Include detailed comments for code clarity\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size a x b within the given n x m rectangle and calculate the number of operations required to meet the portal criteria. We will use numpy for efficient matrix manipulation and calculation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m': This refers to the main grid of blocks, where each block can be either an obsidian block or an empty block.\n    'portal': A sub-rectangle of size a \u00d7 b that meets specific criteria to be considered a portal.\n    'obsidian block': Represented by '1', a block that is part of the portal's boundary.\n    'empty block': Represented by '0', a block that is part of the portal's interior.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The portal must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': This means for all rows except the first and last in the portal.\n    'For all 1 < x < b': This means for all columns except the first and last in the portal.\n\n# [degree adverb]\n    'minimum number of operations': The goal is to find the least number of changes needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b within the n \u00d7 m rectangle.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the boundary conditions are met (obsidian blocks on specified edges).\n   - Ensure the interior conditions are met (empty blocks inside).\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    12\n    Explanation: All boundary blocks need to be changed to obsidian, requiring 12 operations.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The sub-rectangle is already a portal, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient, especially given the maximum possible input size. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal criteria, ensuring that the solution is both time and space efficient.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for portal creation.\n- Optimize the algorithm for handling maximum constraints efficiently.\n- Ensure the output format is clear and adheres to the specified requirements.\n- Test the solution against edge cases to ensure robustness.\n- Document the solution approach and provide examples for clarity.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations needed to meet the portal criteria. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or empty.\n    'portal': A sub-rectangle of size a \u00d7 b that meets specific criteria regarding block types and dimensions.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The portal must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': Refers to the range of rows within the portal where certain blocks must be obsidian.\n    'For all 1 < x < b': Refers to the range of columns within the portal where certain blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': The least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to meet the portal criteria:\n        - Ensure the border blocks are obsidian as required.\n        - Ensure the inner blocks are empty.\n    4. Track the minimum number of operations across all sub-rectangles for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meets the portal criteria with no operations needed.\n    Explanation: If a sub-rectangle already satisfies all portal conditions, the expected output is 0 operations.\n\n    Case 2: A rectangle with dimensions exactly 5x4 where all blocks are initially empty.\n    Explanation: The expected output would be the number of operations needed to convert border blocks to obsidian.\n\n    Case 3: A rectangle with dimensions larger than 5x4 but no possible sub-rectangle can be transformed into a portal.\n    Explanation: The expected output would be the minimum operations needed for any valid sub-rectangle transformation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should account for these scenarios by iterating over all possible sub-rectangles and calculating operations needed.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must efficiently handle the maximum input sizes. The key challenge is to ensure the algorithm can quickly identify potential sub-rectangles and calculate the necessary operations.\nrequirement pool:\n- Develop an algorithm to identify potential portal sub-rectangles.\n- Optimize the solution to handle maximum constraints efficiently.\n- Ensure the output format is clear and adheres to the requirements.\n- Test the solution against various edge cases to ensure robustness.\n- Document the solution approach and provide usage instructions.\nWe will use a dynamic programming approach to efficiently determine the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations needed to convert each into a portal. We will utilize numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix that contains blocks, where each block can be either an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle (portal) must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles that meet these minimum dimensions.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of operations for each valid sub-rectangle.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n4. Use dynamic programming to store and update the minimum number of operations for each sub-rectangle.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle with all blocks already forming a portal.\n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No operations are needed as the rectangle already forms a portal.\n\n    Case 2: A rectangle with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in 12 operations.\n\n    Case 3: A rectangle with dimensions exactly matching the minimum required for a portal.\n    Input:\n    1\n    5 4\n    1000\n    0000\n    0110\n    0000\n    0001\n    Expected Output: 12\n    Explanation: As shown in the example, transforming this into a portal requires changing several blocks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must iterate over possible sub-rectangles and calculate the cost of transformation, ensuring it meets the portal criteria.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal creation.\n- Ensure the solution handles edge cases and maximum constraints.\n- Optimize the algorithm for speed and memory usage.\n- Provide detailed comments and documentation for the code.\n- Implement additional features for user interaction and input validation.\nWe will implement a function to determine the minimum number of operations needed to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the cost of transformation based on the given criteria. We will use efficient iteration and calculation techniques to handle the constraints of n and m up to 400. The solution will focus on minimizing the number of operations by checking each potential portal configuration and counting the necessary changes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can be either an obsidian block (1) or an empty block (0).\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over possible sub-rectangles starting from these minimum dimensions.\n\n    '1 < x < a, 1 < y < b'\n    Explanation: This defines the range for the internal blocks of the portal that must be empty. In code, this means checking and ensuring these positions are 0.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the least number of operations needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of changes required for each potential portal configuration.\n\n# [code logic]\n1. Parse the input to get the number of test cases and dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met with obsidian blocks.\n   - Ensure the internal conditions are met with empty blocks.\n4. Track the minimum number of operations across all sub-rectangles.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the correct configuration for a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No operations are needed as it already forms a portal.\n\n    Case 2: A grid where no obsidian blocks are present.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian.\n\n    Case 3: A grid with minimum dimensions but with incorrect internal configuration.\n    Example:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 6\n    Explanation: Internal blocks need to be changed to empty.\n\n# [extra code for edge case]\nWe do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on matrix dimensions and block types are clearly defined, ensuring the solution is both efficient and accurate. The challenge lies in optimizing the transformation process to handle large matrices within the given limits.\nrequirement pool:\n- Implement efficient algorithm to determine minimum operations for portal creation\n- Ensure solution handles maximum input sizes effectively\n- Provide clear output format for user understanding\n- Optimize code for speed and accuracy\n- Include detailed comments and documentation for maintainability\nWe will use a dynamic programming approach to efficiently determine the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, keeping track of the minimum cost encountered. Libraries such as NumPy can be used for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A two-dimensional shape with rows and columns.\n    'obsidian block': A block represented by '1' in the matrix.\n    'empty block': A block represented by '0' in the matrix.\n    'portal': A sub-rectangle meeting specific criteria regarding block types.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The portal must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': Refers to all rows except the first and last.\n    'For all 1 < x < b': Refers to all columns except the first and last.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases, dimensions of each rectangle, and the block configuration.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border blocks are obsidian where required.\n   - Ensure the inner blocks are empty.\n4. Keep track of the minimum number of operations for each test case.\n5. Output the minimum operations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    8\n    Explanation: The entire rectangle is obsidian, requiring conversion of inner blocks to empty.\n\n    Test case with alternating blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output: \n    12\n    Explanation: Alternating pattern requires significant changes to meet portal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating transformation costs will naturally handle these scenarios.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 610, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "condense_two2one", "parent_index": 164}
