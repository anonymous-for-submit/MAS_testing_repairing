{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n \u00d7 m consisting of n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. Additionally, CQXYM can transform an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5, b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the rectangle must have a rows and b columns, not b rows and a columns. Also, corners can be any type.\n\nCQXYM is curious to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n \u00d7 m consisting of n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. Additionally, CQXYM can transform an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5, b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the rectangle must have a rows and b columns, not b rows and a columns. Also, corners can be any type.\n\nCQXYM is curious to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n \u00d7 m consisting of n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty. Additionally, CQXYM can transform an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5, b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The leftmost and rightmost blocks in every row except the first and last ones must be made of obsidian. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the rectangle must have a rows and b columns, not b rows and a columns. Also, corners can be any type.\n\nCQXYM is curious to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n \u00d7 m consisting of n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or empty, and CQXYM can transform an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5, b \u2265 4. \n  * For every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the rectangle must have a rows and b columns, not b rows and a columns. Also, corners can be any type.\n\nCQXYM is curious to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for case_index in range(t):\n        grid = test_cases[case_index]\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed for this sub-rectangle\n                        operations = 0\n\n                        # Check the border conditions\n                        for i in range(start_row + 1, end_row):\n                            if grid[i][start_col] != '1':\n                                operations += 1\n                            if grid[i][end_col] != '1':\n                                operations += 1\n                        for j in range(start_col + 1, end_col):\n                            if grid[start_row][j] != '1':\n                                operations += 1\n                            if grid[end_row][j] != '1':\n                                operations += 1\n\n                        # Check the inner blocks\n                        for i in range(start_row + 1, end_row):\n                            for j in range(start_col + 1, end_col):\n                                if grid[i][j] != '0':\n                                    operations += 1\n\n                        # Update the minimum operations found\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print the results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param matrix: The numpy array representing the grid\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check border conditions\n    for x in range(start_row + 1, end_row):\n        if matrix[x, start_col] != 1:\n            operations += 1\n        if matrix[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if matrix[start_row, y] != 1:\n            operations += 1\n        if matrix[end_row, y] != 1:\n            operations += 1\n\n    # Check interior conditions\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if matrix[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and matrix.\n\n    Returns:\n        list[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array([list(map(int, row)) for row in matrix])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of transformations needed for the current sub-rectangle\n                        operations = calculate_transformations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_transformations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of transformations needed to make a sub-rectangle a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of transformations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions for obsidian blocks\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] == 0:\n            operations += 1\n        if grid[x, end_col] == 0:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] == 0:\n            operations += 1\n        if grid[end_row, y] == 0:\n            operations += 1\n\n    # Check the inner conditions for empty blocks\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] == 1:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and matrix of blocks.\n\n    Returns:\n        list: Minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate the number of transformations needed for the current sub-rectangle\n                operations = calculate_transformations(matrix, start_row, start_col)\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_transformations(matrix: np.ndarray, start_row: int, start_col: int) -> int:\n    \"\"\"Calculate the number of transformations needed to make a sub-rectangle a portal.\n\n    Args:\n        matrix (np.ndarray): The matrix of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n\n    Returns:\n        int: Number of transformations needed.\n    \"\"\"\n    a, b = 5, 4  # Minimum dimensions for a portal\n    operations = 0\n\n    # Check and transform the top and bottom rows\n    for col in range(start_col + 1, start_col + b - 1):\n        if matrix[start_row, col] != 1:\n            operations += 1\n        if matrix[start_row + a - 1, col] != 1:\n            operations += 1\n\n    # Check and transform the left and right columns\n    for row in range(start_row + 1, start_row + a - 1):\n        if matrix[row, start_col] != 1:\n            operations += 1\n        if matrix[row, start_col + b - 1] != 1:\n            operations += 1\n\n    # Check and transform the inner blocks to be empty\n    for row in range(start_row + 1, start_row + a - 1):\n        for col in range(start_col + 1, start_col + b - 1):\n            if matrix[row, col] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().strip())) for _ in range(n)]\n    test_cases.append((n, m, np.array(matrix)))\n\n# Call the function and print the results\nresults = min_operations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the grid as a list of strings\n    :return: List of integers, each representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate transformations needed for current sub-rectangle\n                        operations = calculate_transformations(matrix, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_transformations(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of transformations needed to convert a sub-rectangle into a portal.\n\n    :param matrix: The grid as a numpy array\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of transformations needed\n    \"\"\"\n    operations = 0\n\n    # Check and transform the leftmost and rightmost blocks in every row except the first and last\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            operations += 1\n        if matrix[row, end_col] != 1:\n            operations += 1\n\n    # Check and transform the topmost and bottommost blocks in every column except the first and last\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            operations += 1\n        if matrix[end_row, col] != 1:\n            operations += 1\n\n    # Check and transform all inner blocks to be empty\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and transform the leftmost and rightmost blocks in every row except the first and last\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            operations += 1\n        if grid[row, end_col] != 1:\n            operations += 1\n\n    # Check and transform the topmost and bottommost blocks in every column except the first and last\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            operations += 1\n        if grid[end_row, col] != 1:\n            operations += 1\n\n    # Check and transform all inner blocks to be empty\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                operations += 1\n\n    return operations\n\ndef handle_edge_cases(n: int, m: int) -> str:\n    \"\"\"Handle edge cases where no valid sub-rectangle can be formed due to size constraints.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n\n    Returns:\n        str: Message indicating invalid input based on constraints.\n    \"\"\"\n    if n < 5 or m < 4:\n        return \"Invalid input based on constraints\"\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of grids for each test case.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible dimensions (a, b) that satisfy a \u2265 5 and b \u2265 4\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n\n                        # Calculate operations needed for the current sub-rectangle\n                        for i in range(a):\n                            for j in range(b):\n                                current_block = grid[start_row + i][start_col + j]\n                                if (i == 0 or i == a - 1) and (1 <= j < b - 1):\n                                    # Top and bottom borders (except corners)\n                                    if current_block != '1':\n                                        operations += 1\n                                elif (j == 0 or j == b - 1) and (1 <= i < a - 1):\n                                    # Left and right borders (except corners)\n                                    if current_block != '1':\n                                        operations += 1\n                                elif 1 <= i < a - 1 and 1 <= j < b - 1:\n                                    # Inner blocks\n                                    if current_block != '0':\n                                        operations += 1\n\n                        # Update the minimum operations for this test case\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_operations(test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Find the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        test_cases: A list of tuples, each containing the dimensions of the grid and the grid itself.\n\n    Returns:\n        A list of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed to transform the sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid: The numpy array representing the grid.\n        start_row: The starting row index of the sub-rectangle.\n        start_col: The starting column index of the sub-rectangle.\n        end_row: The ending row index of the sub-rectangle.\n        end_col: The ending column index of the sub-rectangle.\n\n    Returns:\n        The number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the conditions for the portal and count necessary transformations\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    results = find_min_operations(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions of the grid and the grid itself.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[i:i + a, j:j + b]\n\n                        # Calculate the number of transformations needed\n                        operations = calculate_transformations(sub_rect, a, b)\n\n                        # Track the minimum number of transformations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_transformations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of transformations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be transformed.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of transformations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the borders (except corners)\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] == 0:  # Left border\n            operations += 1\n        if sub_rect[x, b - 1] == 0:  # Right border\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] == 0:  # Top border\n            operations += 1\n        if sub_rect[a - 1, y] == 0:  # Bottom border\n            operations += 1\n\n    # Check the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] == 1:  # Inner block should be empty\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing dimensions and grid for each test case.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible positions for sub-rectangle of size a x b\n        for i in range(n - 4):  # a must be at least 5\n            for j in range(m - 3):  # b must be at least 4\n                # Calculate operations needed to transform current sub-rectangle into a portal\n                operations = calculate_operations(matrix, i, j)\n                min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The grid matrix.\n        start_row (int): Starting row index for the sub-rectangle.\n        start_col (int): Starting column index for the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    a, b = 5, 4  # Minimum dimensions for a portal\n    operations = 0\n\n    # Check borders (except corners)\n    for x in range(1, a - 1):\n        if matrix[start_row + x, start_col] != 1:\n            operations += 1\n        if matrix[start_row + x, start_col + b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if matrix[start_row, start_col + y] != 1:\n            operations += 1\n        if matrix[start_row + a - 1, start_col + y] != 1:\n            operations += 1\n\n    # Check inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[start_row + x, start_col + y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m and the n x m grid\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe task requires transforming a given grid into a specific pattern with minimal operations. The constraints on grid size and the number of test cases suggest a need for an efficient algorithm. The solution must handle edge cases where the grid dimensions are at their maximum limits.\nrequirement pool:\n- Develop an algorithm to identify and transform sub-rectangles into portals with minimal operations.\n- Ensure the solution can handle the maximum grid size efficiently.\n- Provide a visual representation of the transformed grid.\n- Allow batch processing of multiple test cases.\n- Optimize the algorithm for speed and resource usage.\nWe will use a dynamic programming approach to efficiently find the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, keeping track of the minimum cost. Libraries such as NumPy can be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can either be an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific conditions, including having certain blocks as obsidian and others as empty.\n\n    'minimum number of operations'\n    Explanation: The least number of changes needed to transform a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this can be checked using conditional statements to ensure the sub-rectangle meets these size requirements.\n\n# [degree adverb]\n    'minimum'\n    Explanation: Refers to finding the smallest number of operations needed. In code, this involves keeping track of the lowest cost found during the transformation process.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, read the grid and store it in a matrix format.\n3. Iterate over all possible sub-rectangles that meet the minimum size requirement (a \u2265 5, b \u2265 4).\n4. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met (obsidian blocks on specified edges).\n   - Ensure the inner blocks are empty.\n5. Keep track of the minimum number of operations required for each test case.\n6. Output the minimum operations for each test case.\n\n# [edge case]\n    Test Case 1:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 0\n    Explanation: The entire grid is already a portal, so no operations are needed.\n\n    Test Case 2:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be converted to obsidian, requiring 12 operations.\n\n    Test Case 3:\n    Input:\n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should account for all possible configurations by iterating over all sub-rectangles and calculating the transformation cost.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the solution. The challenge lies in efficiently finding the sub-rectangle that requires the least transformations.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations\n- Optimize the solution for large input sizes\n- Ensure accurate transformation of blocks\n- Provide clear and concise output\n- Handle multiple test cases efficiently\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of operations. The function will use a brute-force approach to evaluate each sub-rectangle, but will be optimized to skip unnecessary checks using the constraints provided. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, consisting of blocks.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle with specific conditions on its borders and interior.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range for x where the condition applies.\n    'For all 1 < x < b': Indicates a range for x where the condition applies.\n    'For all 1<x<a,1<y<b': Indicates a range for both x and y where the condition applies.\n\n# [degree adverb]\n    'minimum': The least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\n    4. Keep track of the minimum number of operations for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: Minimum size rectangle that is already a portal.\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle is already a portal, so no operations are needed.\n\n    Case 2: Rectangle with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be transformed into obsidian blocks.\n\n    Case 3: Rectangle with all obsidian blocks.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 8\n    Explanation: Interior blocks need to be transformed into empty blocks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will handle these cases by evaluating each sub-rectangle and calculating the necessary transformations.\n", "requirement analysis:\nThe requirements focus on transforming blocks within a rectangle to form a portal with minimal operations. The constraints on dimensions and block types are crucial for ensuring valid portal formation. The solution must efficiently handle multiple test cases and large input sizes while providing accurate results.\nrequirement pool:\n- Implement the main algorithm to transform blocks into portals.\n- Ensure the solution handles multiple test cases efficiently.\n- Optimize the algorithm for large dimensions.\n- Validate input constraints and provide error handling.\n- Enhance user interface for better output readability.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of transformations needed to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A two-dimensional shape with rows and columns.\n    'obsidian block': A block represented by '1'.\n    'empty block': A block represented by '0'.\n    'portal': A sub-rectangle with specific conditions involving obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range of rows within the portal.\n    'For all 1 < x < b': Indicates a range of columns within the portal.\n\n# [degree adverb]\n    'minimum': The least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of transformations needed to meet the portal conditions.\n    4. Keep track of the minimum number of transformations required for each test case.\n    5. Output the minimum number of transformations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    0\n    Explanation: The rectangle is already a portal, so no transformations are needed.\n\n    Test case with all empty blocks:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output: \n    12\n    Explanation: All blocks need to be transformed to meet the portal conditions.\n\n    Test case with mixed blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output: \n    8\n    Explanation: Transformations are needed to meet the portal conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating transformations will handle these cases effectively.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific conditions. The challenge lies in minimizing the number of operations needed to achieve this transformation. The constraints on dimensions and block types are crucial for determining the solution approach.\nrequirement pool:\n- Implement efficient block transformation algorithm.\n- Ensure solution handles maximum input constraints.\n- Optimize for minimum operations required.\n- Provide clear and concise output for each test case.\n- Develop user-friendly input and output interface.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach will involve iterating over possible sub-rectangles of size at least 5x4 and calculating the number of transformations needed to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A two-dimensional shape with rows and columns.\n    'obsidian block': A block that is represented by '1'.\n    'empty block': A block that is represented by '0'.\n    'portal': A specific sub-rectangle with defined conditions.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': This means for all rows except the first and last, certain conditions must be met.\n    'For all 1 < x < b': This means for all columns except the first and last, certain conditions must be met.\n    Implementation: Use loops to iterate over the specified range and check conditions.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required.\n    Implementation: Use a method to calculate and compare the number of operations needed for each possible sub-rectangle.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of transformations needed to meet portal conditions.\n    4. Keep track of the minimum number of transformations required for each test case.\n    5. Output the minimum number of transformations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected output: 12\n    Explanation: All blocks need to be transformed to meet portal conditions.\n\n    Test case with already a portal:\n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected output: 0\n    Explanation: The rectangle already meets portal conditions.\n\n    Test case with maximum dimensions:\n    Input:\n    1\n    400 400\n    (all blocks are empty)\n    Expected output: Large number (depends on specific implementation)\n    Explanation: Many transformations are needed due to large size.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large dimensions.\n        (code for handling large dimensions efficiently using numpy or similar libraries)\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific conditions. The challenge lies in minimizing the number of operations needed to achieve this transformation. The constraints on dimensions and block types must be carefully managed to ensure the portal is formed correctly.\nrequirement pool:\n- Implement the transformation algorithm to create portals.\n- Optimize the number of operations required.\n- Ensure the solution handles maximum input sizes efficiently.\n- Provide clear output format as specified.\n- Include detailed comments for understanding the transformation process.\nWe will implement a function to determine the minimum number of operations required to transform a given rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of transformations needed to meet the portal conditions. We will use numpy for efficient matrix manipulation and to handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the initial grid of blocks, where each block can either be an obsidian block (represented by '1') or an empty block (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the larger rectangle that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles of these minimum dimensions.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of transformations needed to convert a sub-rectangle into a portal. This involves calculating the number of changes required for each potential portal and selecting the smallest value.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of transformations needed to meet the portal conditions:\n   - Ensure the leftmost and rightmost blocks in every row except the first and last are obsidian.\n   - Ensure the topmost and bottommost blocks in every column except the first and last are obsidian.\n   - Ensure all inner blocks are empty.\n4. Track the minimum number of transformations required for each test case.\n5. Output the minimum number of transformations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The entire rectangle already satisfies the portal conditions, so no transformations are needed.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    12\n    Explanation: All blocks need to be transformed to meet the portal conditions, requiring a total of 12 transformations.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The sub-rectangle already satisfies the portal conditions, so no transformations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating transformations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific conditions. The challenge lies in minimizing the number of operations required for transformation while adhering to the constraints of the portal's structure. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement efficient block transformation algorithm.\n- Ensure output format consistency across test cases.\n- Optimize performance for large inputs.\n- Provide clear documentation for user understanding.\n- Enhance user interface for better interaction.\nWe will implement a function to determine the minimum number of operations required to transform a given rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of transformations needed to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the initial grid of blocks, where each block can either be an obsidian block (represented by '1') or an empty block (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific conditions, including size and block type arrangements.\n\n    'minimum number of operations'\n    Explanation: The least number of changes needed to transform a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over all possible sub-rectangles of these minimum dimensions.\n\n    '1 < x < a', '1 < x < b'\n    Explanation: These conditions specify the range of rows and columns that must meet certain block type requirements. In code, this involves checking and transforming blocks within these ranges.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it meets the portal conditions:\n   - Ensure the leftmost and rightmost blocks in every row except the first and last are obsidian.\n   - Ensure the topmost and bottommost blocks in every column except the first and last are obsidian.\n   - Ensure all inner blocks are empty.\n4. Calculate the number of transformations needed for each sub-rectangle to meet these conditions.\n5. Track the minimum number of transformations across all sub-rectangles for each test case.\n6. Output the minimum number of transformations for each test case.\n\n# [edge case]\n    Edge Case 1: A grid where all blocks are already in the portal configuration.\n    Example: \n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No transformations are needed as it already meets the portal conditions.\n\n    Edge Case 2: A grid with no possible sub-rectangle meeting the minimum size requirement.\n    Example:\n    Input:\n    1\n    4 3\n    111\n    101\n    101\n    111\n    Expected Output: Not applicable (since n < 5 or m < 4, this input is invalid based on constraints).\n\n    Edge Case 3: A grid with alternating blocks that require maximum transformations.\n    Example:\n    Input:\n    1\n    5 4\n    0101\n    1010\n    0101\n    1010\n    0101\n    Expected Output: Calculated based on maximum transformations needed to convert to a portal.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where no valid sub-rectangle can be formed due to size constraints.\n    \n```python\ndef handle_edge_cases(n, m):\n    if n < 5 or m < 4:\n        return \"Invalid input based on constraints\"\n```\n\nThis function can be called before processing each test case to ensure valid inputs.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern called a portal with minimal operations. The constraints are manageable within the given limits, and the solution should focus on efficiently finding and transforming the sub-rectangle.\nrequirement pool:\n- Develop an algorithm to identify the minimum operations needed to create a portal.\n- Ensure the solution handles edge cases and maximum constraints efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation for the solution.\n- Implement test cases to validate the solution.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will iterate over all possible top-left corners of the sub-rectangles and check all possible dimensions that satisfy the portal conditions. The minimum number of operations across all valid sub-rectangles will be the answer for each test case. This approach is feasible given the constraints, as the maximum grid size is 400x400.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the grid of blocks with n rows and m columns, where each block can be either an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means checking sub-rectangles where the number of rows is at least 5 and the number of columns is at least 4.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to find the smallest number of operations needed to transform a sub-rectangle into a portal. In code, this involves keeping track of the lowest count of operations required across all possible sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the grid for each test case.\n2. For each test case, iterate over all possible top-left corners of sub-rectangles.\n3. For each top-left corner, iterate over all possible dimensions (a, b) that satisfy a \u2265 5 and b \u2265 4.\n4. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n5. Track the minimum number of operations needed for each test case.\n6. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    8\n    Explanation: The entire grid is filled with obsidian blocks. Transforming it into a portal requires changing all inner blocks to empty, which requires 8 operations.\n\n    Case 2: \n    Input: \n    1\n    6 5\n    00000\n    00000\n    00000\n    00000\n    00000\n    00000\n    Expected Output: \n    12\n    Explanation: The entire grid is empty. Transforming it into a portal requires changing all border blocks (except corners) to obsidian, which requires 12 operations.\n\n    Case 3: \n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: \n    10\n    Explanation: The grid has alternating blocks. Transforming it into a portal requires changing some border blocks to obsidian and some inner blocks to empty, requiring a total of 10 operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle of a given grid into a portal. The constraints ensure that the solution must be efficient, especially given the maximum grid size of 400x400. The solution should iterate over possible sub-rectangles and calculate the cost of transforming them into a portal, ensuring that the operations are minimized.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for a portal.\n- Optimize the solution for large grid sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide clear and concise output for each test case.\n- Enhance user experience with detailed explanations of the results.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of transformations needed. We will use numpy for efficient matrix operations and slicing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can either be an obsidian block (represented by '1') or an empty block (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific conditions regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n4. Keep track of the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid with all blocks as obsidian (all '1's).\n    Explanation: The entire grid needs to be transformed to meet the portal conditions, which may require a large number of operations.\n\n    Case 2: A grid with all blocks as empty (all '0's).\n    Explanation: Similar to the first case, but in reverse; all blocks need to be transformed to meet the portal conditions.\n\n    Case 3: A grid where a valid portal already exists.\n    Explanation: The expected output should be 0 since no operations are needed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Check if a valid portal already exists in the grid before counting operations.\n    - Implement logic to efficiently count operations for transforming all obsidian or all empty grids.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must handle up to 400x400 grid sizes efficiently. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal conditions, ensuring optimal performance.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for a portal.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 within the given n x m grid and calculate the number of transformations needed to satisfy the portal conditions. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n \u00d7 m'\n    Explanation: This refers to the grid of blocks with n rows and m columns, where each block can either be an obsidian block or an empty block.\n\n    'portal'\n    Explanation: A sub-rectangle of size a \u00d7 b that satisfies specific conditions regarding the placement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The dimensions of the portal must be at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles that meet these minimum size requirements.\n\n# [degree adverb]\n    'minimum number of operations'\n    Explanation: The goal is to find the smallest number of transformations needed to convert a sub-rectangle into a portal. In code, this involves calculating the number of changes for each potential sub-rectangle and keeping track of the smallest value.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check the conditions for it to be a portal:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the inner blocks are empty.\n4. Count the number of transformations needed for each sub-rectangle to meet these conditions.\n5. Track the minimum number of transformations across all sub-rectangles for each test case.\n6. Output the minimum number of transformations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the portal configuration.\n    Example: \n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No transformations are needed as it already satisfies the portal conditions.\n\n    Case 2: A grid where all blocks are obsidian.\n    Example:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: Transformations are needed to make the inner blocks empty and adjust the borders.\n\n    Case 3: A grid where all blocks are empty.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: Transformations are needed to make the borders obsidian while keeping inner blocks empty.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating transformations will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient for large inputs, with a focus on minimizing operations. The solution should handle multiple test cases and provide results for each.\nrequirement pool:\n- Develop an algorithm to identify the minimum operations needed to form a portal.\n- Ensure the solution handles the maximum constraints efficiently.\n- Optimize the algorithm for performance improvements.\n- Provide detailed output for each test case.\n- Implement additional features for user interaction and feedback.\nWe will use a brute-force approach to check all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will iterate over all possible positions and dimensions of sub-rectangles, ensuring that the constraints for a portal are met. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with specified dimensions, consisting of rows and columns.\n    'obsidian block': A type of block in the rectangle, represented by '1'.\n    'empty block': Another type of block in the rectangle, represented by '0'.\n    'portal': A specific sub-rectangle with defined conditions that need to be met.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': The dimensions of the portal must be at least 5 rows and 4 columns.\n    'For every 1 < x < a': Indicates a range for x where certain conditions must be met.\n    'For all 1 < x < b': Indicates a range for x where certain conditions must be met.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\n    3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n    4. Ensure that the conditions for a portal are met: \n       - The borders (except corners) must be obsidian blocks.\n       - The inner blocks must be empty.\n    5. Track the minimum number of operations needed for each test case.\n    6. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    Explanation: The entire rectangle is already filled with obsidian blocks, requiring maximum operations to transform into a portal.\n\n    Test case with alternating blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output: \n    Explanation: Alternating blocks require specific transformations to meet portal conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n        - Implement checks for minimum dimensions and alternating patterns.\n        - Optimize transformation logic to minimize operations in these scenarios.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 941, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 456}
