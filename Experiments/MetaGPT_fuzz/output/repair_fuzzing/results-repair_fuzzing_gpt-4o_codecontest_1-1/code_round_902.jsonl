{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria: a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks, and for each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria: a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks, and for each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria: a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. Additionally, for each 1 < x < b, blocks M_{1,x} and M_{a,x} are also obsidian blocks. For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block at all. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria: a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks, and for each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks, while for each 1 < x < a, 1 < y < b, block M_{x,y} contains no block. M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal. Consider the problem of optimizing the configuration with the minimal changes required, and explore potential algorithms to efficiently identify the solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef minimal_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimal number of changes needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: A list of tuples, each containing:\n                       - n (int): number of rows\n                       - m (int): number of columns\n                       - grid (list of str): n strings of length m representing the grid\n    :return: A list of integers, each representing the minimal number of changes for the corresponding test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([[int(char) for char in row] for row in grid])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, a, b)\n                        # Update the minimum changes if the current one is smaller\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    :param grid: The grid as a numpy array\n    :param start_row: The starting row of the sub-rectangle\n    :param start_col: The starting column of the sub-rectangle\n    :param a: The number of rows in the sub-rectangle\n    :param b: The number of columns in the sub-rectangle\n    :return: The number of changes needed\n    \"\"\"\n    changes = 0\n\n    # Check the top and bottom borders\n    for col in range(start_col + 1, start_col + b - 1):\n        if grid[start_row, col] == 0:\n            changes += 1\n        if grid[start_row + a - 1, col] == 0:\n            changes += 1\n\n    # Check the left and right borders\n    for row in range(start_row + 1, start_row + a - 1):\n        if grid[row, start_col] == 0:\n            changes += 1\n        if grid[row, start_col + b - 1] == 0:\n            changes += 1\n\n    # Check the inner area\n    for row in range(start_row + 1, start_row + a - 1):\n        for col in range(start_col + 1, start_col + b - 1):\n            if grid[row, col] == 1:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = minimal_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef is_portal(grid, top, left, a, b):\n    \"\"\"Check if a sub-rectangle is a portal.\"\"\"\n    # Check the border conditions for obsidian blocks\n    for x in range(1, a - 1):\n        if grid[top + x][left] != '1' or grid[top + x][left + b - 1] != '1':\n            return False\n    for y in range(1, b - 1):\n        if grid[top][left + y] != '1' or grid[top + a - 1][left + y] != '1':\n            return False\n    # Check the inner conditions for vacant blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[top + x][left + y] != '0':\n                return False\n    return True\n\ndef calculate_transformation_cost(grid, top, left, a, b):\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\"\"\"\n    changes = 0\n    # Calculate changes for the border\n    for x in range(1, a - 1):\n        if grid[top + x][left] != '1':\n            changes += 1\n        if grid[top + x][left + b - 1] != '1':\n            changes += 1\n    for y in range(1, b - 1):\n        if grid[top][left + y] != '1':\n            changes += 1\n        if grid[top + a - 1][left + y] != '1':\n            changes += 1\n    # Calculate changes for the inner part\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[top + x][left + y] != '0':\n                changes += 1\n    return changes\n\ndef find_min_changes(n: int, m: int, grid: list[str]) -> int:\n    \"\"\"Find the minimum number of changes required to transform a sub-rectangle into a portal.\"\"\"\n    min_changes = float('inf')\n    \n    # Iterate over all possible sub-rectangles of size at least 5x4\n    for a in range(5, n + 1):\n        for b in range(4, m + 1):\n            for top in range(n - a + 1):\n                for left in range(m - b + 1):\n                    if is_portal(grid, top, left, a, b):\n                        min_changes = 0\n                        break\n                    changes = calculate_transformation_cost(grid, top, left, a, b)\n                    min_changes = min(min_changes, changes)\n                if min_changes == 0:\n                    break\n            if min_changes == 0:\n                break\n        if min_changes == 0:\n            break\n    \n    return min_changes\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        result = find_min_changes(n, m, grid)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef minimal_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimal number of changes required to form a portal for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and grid configuration.\n\n    Returns:\n        list: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid of blocks.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check borders (except corners)\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            changes += 1\n        if grid[row, end_col] != 1:\n            changes += 1\n\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            changes += 1\n        if grid[end_row, col] != 1:\n            changes += 1\n\n    # Check interior\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\n# Read number of test cases\nt = int(input())\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = minimal_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_changes(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimal number of changes required to form a portal for each test case.\n    \n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing minimal changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, list(row))) for row in grid])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for this sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, end_row, end_col)\n                        # Update the minimum changes if this is a better solution\n                        min_changes = min(min_changes, changes)\n        \n        # Append the result for this test case\n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n    \n    :param grid: The grid as a numpy array\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param end_row: Ending row of the sub-rectangle\n    :param end_col: Ending column of the sub-rectangle\n    :return: Number of changes needed\n    \"\"\"\n    changes = 0\n    \n    # Check the borders for obsidian blocks\n    for i in range(start_row + 1, end_row):\n        if grid[i, start_col] == 0:\n            changes += 1\n        if grid[i, end_col] == 0:\n            changes += 1\n    \n    for j in range(start_col + 1, end_col):\n        if grid[start_row, j] == 0:\n            changes += 1\n        if grid[end_row, j] == 0:\n            changes += 1\n    \n    # Check the inside for vacant blocks\n    for i in range(start_row + 1, end_row):\n        for j in range(start_col + 1, end_col):\n            if grid[i, j] == 1:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = find_min_changes(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    def calculate_changes(grid: List[str], n: int, m: int) -> int:\n        \"\"\"Calculate the minimum changes required for a single grid to form a portal.\n\n        Args:\n            grid (List[str]): The grid representing the rectangle.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n\n        Returns:\n            int: Minimum number of changes required.\n        \"\"\"\n        min_changes = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for a in range(i + 4, n):\n                    for b in range(j + 3, m):\n                        # Calculate changes needed for the current sub-rectangle\n                        changes = 0\n                        # Check the borders\n                        for x in range(i + 1, a):\n                            if grid[x][j] != '1':\n                                changes += 1\n                            if grid[x][b] != '1':\n                                changes += 1\n                        for y in range(j + 1, b):\n                            if grid[i][y] != '1':\n                                changes += 1\n                            if grid[a][y] != '1':\n                                changes += 1\n                        # Check the inner area\n                        for x in range(i + 1, a):\n                            for y in range(j + 1, b):\n                                if grid[x][y] != '0':\n                                    changes += 1\n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n\n        return min_changes\n\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        result = calculate_changes(test_case, n, m)\n        results.append(result)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_changes(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing dimensions and matrix for each test case.\n\n    Returns:\n        list: Minimum number of changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert matrix to numpy array for efficient operations\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles that meet the minimum dimension criteria\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid, start_row, start_col, end_row, end_col)\n                        # Update the minimum changes if the current sub-rectangle requires fewer changes\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check and change border blocks to obsidian\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            changes += 1\n        if grid[x, end_col] != 1:\n            changes += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            changes += 1\n        if grid[end_row, y] != 1:\n            changes += 1\n\n    # Check and change interior blocks to vacant\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = find_min_changes(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        \n        # Initialize prefix sum array\n        prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n        \n        # Fill prefix sum array\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                prefix_sum[i][j] = (int(grid[i - 1][j - 1]) +\n                                    prefix_sum[i - 1][j] +\n                                    prefix_sum[i][j - 1] -\n                                    prefix_sum[i - 1][j - 1])\n        \n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for i1 in range(1, n - 4 + 1):\n            for j1 in range(1, m - 3 + 1):\n                for i2 in range(i1 + 4, n + 1):\n                    for j2 in range(j1 + 3, m + 1):\n                        # Calculate number of obsidian blocks in the sub-rectangle\n                        total_obsidian = (prefix_sum[i2][j2] -\n                                          prefix_sum[i1 - 1][j2] -\n                                          prefix_sum[i2][j1 - 1] +\n                                          prefix_sum[i1 - 1][j1 - 1])\n                        \n                        # Calculate number of changes needed to form a portal\n                        changes = total_obsidian\n                        \n                        # Calculate the number of obsidian blocks needed on the edges\n                        edge_obsidian = ((i2 - i1 + 1) * 2 + (j2 - j1 + 1) * 2 - 4)\n                        \n                        # Calculate the number of vacant blocks needed inside\n                        inner_vacant = ((i2 - i1 - 1) * (j2 - j1 - 1))\n                        \n                        # Calculate the number of changes needed\n                        changes = (edge_obsidian + inner_vacant - total_obsidian)\n                        \n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        if n < 5 or m < 4:\n            results.append(-1)\n            continue\n\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(map(int, list(row))) for row in grid])\n\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions a >= 5 and b >= 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i + a, j:j + b]\n\n                        # Calculate changes needed to make this sub-rectangle a portal\n                        changes = calculate_changes_to_portal(sub_rect, a, b)\n\n                        # Track the minimal number of changes\n                        min_changes = min(min_changes, changes)\n\n        # If no valid portal was found, append -1\n        if min_changes == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_changes)\n\n    return results\n\ndef calculate_changes_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes needed\n    \"\"\"\n    changes = 0\n\n    # Check top and bottom borders\n    for x in range(1, b - 1):\n        if sub_rect[0, x] != 1:  # Top border\n            changes += 1\n        if sub_rect[a - 1, x] != 1:  # Bottom border\n            changes += 1\n\n    # Check left and right borders\n    for y in range(1, a - 1):\n        if sub_rect[y, 0] != 1:  # Left border\n            changes += 1\n        if sub_rect[y, b - 1] != 1:  # Right border\n            changes += 1\n\n    # Check interior\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:  # Interior should be vacant\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Function call\nresults = min_changes_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_changes_to_portal(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimal number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        List[int]: List of minimal changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = calculate_changes(i, j, a, b, grid)\n                        # Update the minimum changes if the current changes are less\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(i: int, j: int, a: int, b: int, grid: List[str]) -> int:\n    \"\"\"Calculate the number of changes needed to convert a sub-rectangle into a portal.\n\n    Args:\n        i (int): Row index of the top-left corner of the sub-rectangle.\n        j (int): Column index of the top-left corner of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n        grid (List[str]): The grid representing the rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the borders for obsidian block requirements\n    for x in range(i + 1, i + a - 1):\n        if grid[x][j] != '1':\n            changes += 1\n        if grid[x][j + b - 1] != '1':\n            changes += 1\n\n    for y in range(j + 1, j + b - 1):\n        if grid[i][y] != '1':\n            changes += 1\n        if grid[i + a - 1][y] != '1':\n            changes += 1\n\n    # Check the internal blocks to be vacant\n    for x in range(i + 1, i + a - 1):\n        for y in range(j + 1, j + b - 1):\n            if grid[x][y] != '0':\n                changes += 1\n\n    return changes\n\n# Input interface\n# Read number of test cases\nt = int(input())\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = minimal_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_min_changes(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimal number of changes required for each test case to transform a sub-rectangle into a portal.\n    \n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing (n, m, grid) where grid is a list of strings representing the rectangle.\n    \n    Returns:\n        list: List of integers representing the minimal changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                changes = calculate_changes(matrix, start_row, start_col)\n                min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed for a sub-rectangle starting at (start_row, start_col) to become a portal.\n    \n    Args:\n        matrix (np.ndarray): The matrix representing the rectangle.\n        start_row (int): Starting row index for the sub-rectangle.\n        start_col (int): Starting column index for the sub-rectangle.\n    \n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n    a = start_row + 5\n    b = start_col + 4\n\n    # Check borders and interior for required changes\n    for i in range(start_row, a):\n        for j in range(start_col, b):\n            if i == start_row or i == a - 1:\n                if j != start_col and j != b - 1 and matrix[i, j] != 1:\n                    changes += 1\n            elif j == start_col or j == b - 1:\n                if matrix[i, j] != 1:\n                    changes += 1\n            else:\n                if matrix[i, j] != 0:\n                    changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = find_min_changes(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal configuration. The solution must efficiently handle multiple test cases and large input sizes while providing clear output for each case.\nrequirement pool:\n- Implement the main algorithm to transform rectangles into portals.\n- Optimize the algorithm for minimal changes.\n- Ensure the solution handles large input sizes efficiently.\n- Provide clear and concise output for each test case.\n- Develop a user-friendly interface for input and output.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimal number of changes. The function will use a brute-force approach to check each sub-rectangle, but will be optimized by precomputing the number of obsidian blocks in each row and column to quickly calculate the number of changes needed. This approach will leverage numpy for efficient array manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific dimensions and block configurations that meet certain criteria.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The number of rows (a) in the portal must be at least 5.\n    'greater than or equal to 4': The number of columns (b) in the portal must be at least 4.\n\n# [degree adverb]\n    'fewest': The minimal number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n    4. Precompute the number of obsidian blocks in each row and column to optimize the calculation of changes.\n    5. Use numpy for efficient array manipulation to handle large dimensions.\n    6. Return the minimal number of changes for each test case.\n\n# [edge case]\n    Test case with a rectangle already configured as a portal:\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Output:\n    0\n    Explanation: The rectangle is already a portal, so no changes are needed.\n\n    Test case with a rectangle where no sub-rectangle can be transformed into a portal:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output:\n    20\n    Explanation: All blocks need to be changed to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimal changes will naturally handle these cases.\n", "requirement analysis:\nThe problem requires identifying the minimal number of changes to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, and the solution should efficiently handle multiple test cases. The key challenge is optimizing the algorithm to minimize changes while ensuring correctness.\nrequirement pool:\n- Develop an algorithm to find the minimal changes required for each test case.\n- Ensure the solution handles the maximum constraints efficiently.\n- Optimize the algorithm for speed and accuracy.\n- Provide clear and concise output for each test case.\n- Consider edge cases and ensure robustness.\nWe will use a dynamic programming approach to efficiently find the minimal number of changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to convert each into a portal. We will use memoization to store intermediate results and avoid redundant calculations. The solution will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can be either obsidian or vacant.\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria, including dimensions and block configurations.\n\n    'obsidian block'\n    Explanation: A block type represented by '1' in the grid.\n\n    'vacant block'\n    Explanation: A block type represented by '0' in the grid.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5\n    'greater than or equal to 4': b must be at least 4\n    'for every 1 < x < a': means for all x values between 1 and a-1\n    'for each 1 < x < b': means for all x values between 1 and b-1\n\n# [degree adverb]\n    'fewest': means the minimal number of changes needed\n    'minimal': refers to the smallest possible number of changes\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the dimensions n and m, and then the grid itself.\n3. Iterate over all possible sub-rectangles of size at least 5x4.\n4. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n5. Use dynamic programming to store results of subproblems to avoid redundant calculations.\n6. Return the minimum number of changes required for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Case 2: A grid with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 16\n    Explanation: All blocks need to be changed to form a portal.\n\n    Case 3: A grid with maximum dimensions.\n    Input:\n    1\n    400 400\n    (all blocks are '0')\n    Expected Output: Calculation based on the specific configuration needed to form a portal.\n    Explanation: The output depends on the specific configuration required to form a portal within such a large grid.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid is already a portal or has no obsidian blocks.\n    \n```python\ndef handle_edge_cases(grid, n, m):\n    # Check if the grid is already a portal\n    if is_portal(grid, n, m):\n        return 0\n    \n    # Check if there are no obsidian blocks\n    if all(grid[i][j] == '0' for i in range(n) for j in range(m)):\n        return calculate_full_transformation_cost(n, m)\n    \n    # Other logic for handling edge cases...\n```\n\nNote: The function `is_portal` would check if the current grid configuration already satisfies the portal conditions, and `calculate_full_transformation_cost` would compute the cost of transforming an entirely vacant grid into a portal.\n", "requirement analysis:\nThe requirements focus on transforming a sub-rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal configuration. The solution must efficiently handle multiple test cases and large input sizes, ensuring scalability and performance.\nrequirement pool:\n- Implement the main algorithm to identify minimal changes.\n- Optimize the algorithm for large input sizes.\n- Ensure accurate output for each test case.\n- Handle edge cases and ensure robustness.\n- Provide clear documentation and user instructions.\nWe will implement a function to find the minimal number of changes required to transform a sub-rectangle into a portal. The approach will involve iterating over all possible sub-rectangles of size at least 5x4 and checking the number of changes needed to convert it into a portal. We will use numpy for efficient matrix operations and to handle large inputs effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can be either obsidian or vacant.\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria, including dimensions and block configurations.\n\n    'obsidian block'\n    Explanation: A block type represented by '1' in the grid.\n\n    'vacant block'\n    Explanation: A block type represented by '0' in the grid.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': \n    Explanation: The dimension 'a' of the portal must be at least 5. In code, this can be checked using `a >= 5`.\n\n    'greater than or equal to 4': \n    Explanation: The dimension 'b' of the portal must be at least 4. In code, this can be checked using `b >= 4`.\n\n# [degree adverb] \n    'fewest number of changes':\n    Explanation: The goal is to minimize the number of changes needed to transform a sub-rectangle into a portal. This involves finding the configuration that requires the least modifications.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to convert it into a portal:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the interior is vacant.\n4. Track the minimum number of changes across all sub-rectangles for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case] \n    Edge Case 1: A grid that is already a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: No changes are needed as it already meets the portal criteria.\n\n    Edge Case 2: A grid with all blocks as obsidian.\n    Example:\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The interior needs to be cleared, requiring changes to all interior blocks.\n\n    Edge Case 3: A grid with all blocks vacant.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: The borders need to be filled with obsidian, requiring changes to all border blocks except corners.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding the minimal number of changes to transform a sub-rectangle into a portal. The constraints are manageable, but the solution must be efficient to handle the maximum input sizes. The algorithm should focus on identifying potential portal positions and calculating the required changes efficiently.\nrequirement pool:\n- Develop an efficient algorithm to find the minimal changes for a portal.\n- Ensure the solution handles edge cases and large inputs.\n- Provide clear and correct output for each test case.\n- Optimize the algorithm for performance.\n- Test the solution against various scenarios.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to form a portal. The algorithm will iterate over all possible sub-rectangles of the given dimensions and calculate the number of changes needed to convert each into a portal. We will leverage numpy for efficient matrix operations and use memoization to store intermediate results for sub-rectangles to avoid redundant calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle with specific dimensions and block configurations. It must have obsidian blocks on its borders except for the corners, which can be any type, and vacant blocks inside.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5\n    'greater than or equal to 4': b must be at least 4\n    Explanation: These phrases define the minimum dimensions required for a sub-rectangle to be considered a portal.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of dimensions at least 5x4 within the given n by m rectangle.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n    3. Use dynamic programming to store results of previously computed sub-rectangles to avoid redundant calculations.\n    4. Leverage numpy for efficient matrix operations to handle large data efficiently.\n    5. Return the minimum number of changes required for each test case.\n\n# [edge case]\n    Case 1: A rectangle with dimensions exactly 5x4 where all blocks are already configured as a portal.\n    Explanation: No changes are needed, so the expected output is 0.\n    \n    Case 2: A rectangle with dimensions larger than 5x4 but no possible sub-rectangle can be configured as a portal without changes.\n    Explanation: The output should reflect the minimum number of changes needed to form at least one portal.\n\n    Case 3: A rectangle with dimensions exactly 5x4 where all blocks are vacant.\n    Explanation: The expected output is the number of changes needed to configure the borders as obsidian blocks.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 5 or m < 4:\n            return -1\n        # Additional logic to handle cases where no portal can be formed without changes\n        # Implement checks for minimum dimension requirements and calculate changes accordingly\n        (other code)\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern with minimal changes. The constraints are manageable, but the solution must efficiently handle the maximum input sizes. The algorithm should focus on identifying potential sub-rectangles and calculating the minimal changes required to meet the portal criteria.\nrequirement pool:\n- Develop an efficient algorithm to identify sub-rectangles.\n- Calculate the minimal changes required for transformation.\n- Ensure the solution handles edge cases effectively.\n- Optimize for performance with large inputs.\n- Provide clear documentation and examples.\nWe will use a dynamic programming approach to efficiently identify sub-rectangles and calculate the minimal changes required to transform them into portals. The algorithm will iterate over possible sub-rectangles and use memoization to store intermediate results, reducing redundant calculations. Libraries such as NumPy can be utilized for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific dimensions and block arrangements that meet certain criteria.\n    Explanation: The requirement involves transforming a sub-rectangle within a larger rectangle into a portal by changing block types.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to': Used to define the minimum dimensions of the portal (a \u2265 5, b \u2265 4).\n    Explanation: The portal must have at least 5 rows and 4 columns.\n    'fewest number of changes': Refers to minimizing the number of block type switches needed to create a portal.\n    Explanation: The goal is to find the optimal configuration with the least modifications.\n\n# [degree adverb]\n    'minimal': Refers to the smallest number of changes required.\n    Explanation: The task is to achieve the transformation with the least possible alterations.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, check if it can be transformed into a portal by counting necessary changes.\n    4. Use dynamic programming to store results of previously computed sub-rectangles to avoid redundant calculations.\n    5. Return the minimum number of changes required for each test case.\n\n# [edge case]\n    Case 1: A rectangle already configured as a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Output:\n    0\n    Explanation: No changes are needed as the rectangle already meets portal criteria.\n\n    Case 2: A rectangle with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output:\n    12\n    Explanation: All border blocks need to be changed to obsidian, resulting in maximum changes.\n\n    Case 3: A rectangle with mixed blocks but no valid portal configuration.\n    Example:\n    Input:\n    1\n    6 5\n    10101\n    01010\n    10101\n    01010\n    10101\n    01010\n    Output:\n    Depends on optimal sub-rectangle selection and transformation.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where no valid portal configuration exists initially.\n        (code for handling edge cases)\n        def transform_to_portal(rectangle):\n            # Implement logic to identify and transform sub-rectangles into portals\n            # Consider edge cases where no valid configuration exists initially\n            pass\n", "requirement analysis:\nThe requirements focus on transforming a sub-rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal configuration. The solution must efficiently handle multiple test cases and provide clear outputs.\nrequirement pool:\n- Develop an algorithm to identify the minimal changes required for portal transformation.\n- Ensure the solution is scalable for large inputs.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for speed and efficiency.\n- Include detailed comments and documentation for clarity.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the number of changes needed to meet the portal criteria. We will leverage numpy for efficient matrix operations and calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific criteria for obsidian blocks on its borders and vacant blocks inside.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The number of rows (a) in the portal must be at least 5.\n    'greater than or equal to 4': The number of columns (b) in the portal must be at least 4.\n    'for every 1 < x < a': Indicates a range for x where the condition must hold true for all values within this range.\n    'for each 1 < x < b': Indicates a range for x where the condition must hold true for all values within this range.\n\n# [degree adverb]\n    'fewest': Refers to the minimal number of changes needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles that meet the minimum dimension criteria (a >= 5, b >= 4).\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n        - Ensure the borders have obsidian blocks as specified.\n        - Ensure the interior blocks are vacant.\n    4. Use dynamic programming to store and update the minimum number of changes required for each sub-rectangle.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meeting portal criteria\n    Input: \n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Case 2: A rectangle with all vacant blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in a total of 12 changes.\n\n    Case 3: A rectangle with alternating obsidian and vacant blocks\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on specific arrangement; requires calculation.\n    Explanation: The alternating pattern requires strategic changes to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where rectangles already meet portal criteria or have specific patterns.\n        if is_portal(rectangle):\n            return 0\n        # Additional logic to handle specific patterns efficiently.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are clear, and the solution must efficiently handle multiple test cases with potentially large inputs. The algorithm should prioritize minimizing changes while ensuring the portal criteria are met.\nrequirement pool:\n- Develop an algorithm to identify sub-rectangles that can be transformed into portals.\n- Optimize the algorithm to minimize the number of changes required.\n- Ensure the solution can handle the maximum input size efficiently.\n- Provide clear output for each test case.\n- Create a user-friendly interface for input and output.\nWe will use a dynamic programming approach to efficiently identify and transform sub-rectangles into portals. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes required to convert each into a portal. We will use a 2D prefix sum array to quickly calculate the number of obsidian blocks in any sub-rectangle, which will help in determining the number of changes needed. This approach ensures that we can handle the maximum input size efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the main grid or matrix of blocks, where each block can either be an obsidian block (represented by '1') or vacant (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the main grid that meets specific criteria: dimensions of at least 5x4, with specific blocks on the edges being obsidian and the inner blocks being vacant.\n\n    'fewest number of changes'\n    Explanation: The minimum number of block switches needed to transform a sub-rectangle into a portal.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': \n    Explanation: The number of rows (a) in the portal must be at least 5.\n    Implementation: Use a loop to iterate over possible sub-rectangles with a minimum of 5 rows.\n\n    'greater than or equal to 4': \n    Explanation: The number of columns (b) in the portal must be at least 4.\n    Implementation: Use a loop to iterate over possible sub-rectangles with a minimum of 4 columns.\n\n# [degree adverb] \n    'fewest': \n    Explanation: The goal is to minimize the number of changes needed.\n    Implementation: Use a dynamic programming approach to track and minimize changes.\n\n# [code logic]\n1. Parse the input to get the number of test cases and each test case's grid dimensions and block configuration.\n2. For each test case, initialize a 2D prefix sum array to quickly calculate the number of obsidian blocks in any sub-rectangle.\n3. Iterate over all possible sub-rectangles with dimensions at least 5x4.\n4. For each sub-rectangle, calculate the number of changes needed to convert it into a portal using the prefix sum array.\n5. Track the minimum number of changes across all sub-rectangles for each test case.\n6. Output the minimum number of changes for each test case.\n\n# [edge case] \n    Edge Case 1: A grid where all blocks are obsidian (e.g., 5x4 grid of all '1's).\n    Expected Output: The number of changes needed to create a portal, which involves making the inner blocks vacant.\n\n    Edge Case 2: A grid where all blocks are vacant (e.g., 5x4 grid of all '0's).\n    Expected Output: The number of changes needed to create a portal, which involves making the edge blocks obsidian.\n\n    Edge Case 3: A grid with exactly one possible portal configuration already present.\n    Expected Output: 0, as no changes are needed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for fully obsidian or fully vacant grids and adjust the change count accordingly.\n        - Ensure that the logic correctly identifies when no changes are needed if a valid portal already exists.\n", "requirement analysis:\nThe problem requires identifying sub-rectangles within a larger rectangle and transforming them into portals with minimal changes. The constraints on dimensions and block types must be carefully considered to ensure the solution is both efficient and accurate.\nrequirement pool:\n- Implement the main algorithm to identify portals\n- Optimize the algorithm for minimal changes\n- Ensure scalability for large inputs\n- Provide clear output for each test case\n- Consider edge cases and validate results\nWe will implement a function to identify the minimal number of changes required to transform a sub-rectangle into a portal. The approach will involve iterating over all possible sub-rectangles of valid dimensions and calculating the number of changes needed to meet the portal criteria. We will use efficient iteration and calculation techniques to ensure scalability for large inputs. The numpy library will be used for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific dimensions and block arrangements that meet certain criteria.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The number of rows (a) in the portal must be at least 5.\n    'greater than or equal to 4': The number of columns (b) in the portal must be at least 4.\n\n# [degree adverb]\n    'fewest': The minimal number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions a >= 5 and b >= 4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n       - Ensure the borders are obsidian blocks except for corners.\n       - Ensure the interior is vacant.\n    4. Track the minimal number of changes across all sub-rectangles for each test case.\n    5. Output the minimal number of changes for each test case.\n\n# [edge case]\n    Test case with a rectangle already meeting portal criteria:\n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Output:\n    0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Test case with no possible portal due to insufficient dimensions:\n    Input:\n    1\n    4 3\n    111\n    101\n    101\n    111\n    Output:\n    -1 (or some indication that no portal can be formed)\n    Explanation: The dimensions do not allow for a valid portal.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where no valid portal can be formed due to insufficient dimensions.\n        if n < 5 or m < 4:\n            print(-1)\n            continue\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a portal with minimal changes. The constraints on the dimensions and the specific block requirements for a portal are critical. The solution must efficiently handle the maximum input size and provide the minimal number of changes for each test case.\nrequirement pool:\n- Implement an algorithm to find the minimal changes required to form a portal.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution can handle multiple test cases efficiently.\n- Provide clear output for each test case.\n- Consider edge cases where the grid is already a portal.\nWe will implement a function to find the minimal number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of valid dimensions and calculating the number of changes needed to convert each into a portal. We will use dynamic programming to optimize the calculation of changes for each sub-rectangle, leveraging the constraints on the dimensions and block requirements. The solution will efficiently handle the maximum input size by ensuring that the algorithm complexity is manageable within the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific dimensions and block arrangements that meet certain criteria.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': The dimension 'b' of the portal must be at least 4.\n    'fewest number of changes': The goal is to minimize the number of block changes needed to form a portal.\n\n# [degree adverb]\n    'minimal': Refers to the smallest number of changes required to achieve the desired configuration.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions for each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to convert it into a portal:\n        - Ensure the borders meet the obsidian block requirements.\n        - Count the number of changes needed for internal blocks to be vacant.\n    4. Use dynamic programming to efficiently compute changes for overlapping sub-rectangles.\n    5. Track the minimum number of changes across all sub-rectangles for each test case.\n    6. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Test case with maximum dimensions:\n    Input: \n    1\n    400 400\n    (all blocks are vacant)\n    Output: \n    (calculated number of changes)\n    Explanation: All blocks need to be changed to meet the portal criteria.\n\n    Test case with mixed blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output: \n    (calculated number of changes)\n    Explanation: Changes are needed to meet the portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases efficiently, especially for large dimensions.\n        - Implement dynamic programming to store intermediate results and avoid redundant calculations.\n        - Use memoization to cache results for sub-rectangles that have been processed.\n", "requirement analysis:\nThe problem requires identifying the minimal number of changes to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must be efficient to handle the maximum input sizes. The algorithm should focus on optimizing the search for potential portals and calculating the required changes.\nrequirement pool:\n- Develop an efficient algorithm to find the minimal changes required.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance and scalability.\n- Implement additional features for user interaction if needed.\nWe will use a dynamic programming approach to efficiently identify the minimal changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles and calculate the number of changes needed to meet the portal criteria. We will leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific criteria regarding dimensions and block types.\n    Explanation: The requirement involves transforming a sub-rectangle within a larger rectangle into a portal by changing block types.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The number of rows (a) in the portal must be at least 5.\n    'greater than or equal to 4': The number of columns (b) in the portal must be at least 4.\n    Explanation: These phrases define the minimum dimensions required for a sub-rectangle to qualify as a portal.\n\n# [degree adverb]\n    'fewest': Refers to the minimal number of changes needed to transform a sub-rectangle into a portal.\n    Explanation: The goal is to optimize the number of changes, making it as small as possible.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure the borders are obsidian blocks except for corners.\n   - Ensure the interior is vacant.\n4. Use dynamic programming to store and update the minimum number of changes required for each sub-rectangle.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Test case with all vacant blocks:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output: \n    12\n    Explanation: All border blocks need to be changed to obsidian, resulting in 12 changes.\n\n    Test case with mixed blocks:\n    Input: \n    1\n    6 5\n    10101\n    01010\n    10101\n    01010\n    10101\n    01010\n    Output: \n    15\n    Explanation: Changes are needed to ensure all borders are obsidian and interior is vacant.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n```python\ndef transform_to_portal(test_cases):\n    import numpy as np\n    \n    results = []\n    \n    for n, m, matrix in test_cases:\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Calculate changes needed for current sub-rectangle\n                changes = calculate_changes(matrix, start_row, start_col)\n                min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(matrix, start_row, start_col):\n    # Implement logic to calculate changes needed for a sub-rectangle starting at (start_row, start_col)\n    # Ensure borders are obsidian and interior is vacant\n    \n    # Example logic (to be refined based on specific requirements):\n    changes = 0\n    a = start_row + 5\n    b = start_col + 4\n    \n    # Check borders and interior for required changes\n    \n    return changes\n\n# Example usage:\ntest_cases = [\n    (5, 4, [\n        \"1000\",\n        \"0000\",\n        \"0110\",\n        \"0000\",\n        \"0001\"\n    ]),\n]\nprint(transform_to_portal(test_cases))\n```\nThis code provides a framework for handling edge cases by iterating over possible sub-rectangles and calculating necessary changes.\n"], "scores": [], "pass_results": [true, false, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 902, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "condense_two2one", "parent_index": 549}
