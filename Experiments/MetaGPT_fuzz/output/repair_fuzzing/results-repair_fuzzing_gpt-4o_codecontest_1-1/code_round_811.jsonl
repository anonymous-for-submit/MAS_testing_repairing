{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant, and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks. Each square in the rectangle can be either an obsidian block or vacant. CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria:\n\n  * a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks.\n  * For each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For each 1 < x < a, 1 < y < b, block M_{x,y} contains no block. There should be no block in M_{x,y} for all valid x and y indices.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.\n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.\n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM discovered a rectangle A with dimensions n by m consisting of n rows and m columns of blocks, where each square can be either an obsidian block or vacant and CQXYM is able to switch an obsidian block to empty or vice versa in one move.\n\nA rectangle M with dimensions a by b can be termed a portal if and only if it meets these criteria: a is greater than or equal to 5, b is greater than or equal to 4, and for every 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks, and for each 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.   \n\nFor each 1 < x < a, 1 < y < b, block M_{x,y} contains no block, and M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can have any block type.  \n\nTake note that there must be a rows with b columns, not b rows and a columns, and corners are allowed to be any type.  \n\nCQXYM wishes to find out the fewest number of changes needed to transform at least one sub-rectangle into a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(matrix, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    :param matrix: The grid represented as a numpy array\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of changes needed\n    \"\"\"\n    changes = 0\n    \n    # Check top and bottom borders\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            changes += 1\n        if matrix[end_row, col] != 1:\n            changes += 1\n    \n    # Check left and right borders\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            changes += 1\n        if matrix[row, end_col] != 1:\n            changes += 1\n    \n    # Check interior blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef transform_to_portal(t: int, test_cases: list[list[str]]) -> list[int]:\n    \"\"\"Transforms rectangles into portals by calculating the minimum number of changes required.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[list[str]]): List of matrices representing each test case.\n\n    Returns:\n        list[int]: List of integers representing the minimum number of changes needed for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        m = len(case[0])\n        matrix = np.array([[int(char) for char in row] for row in case])\n\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed for this sub-rectangle\n                        changes = calculate_changes(matrix, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculates the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The matrix representing the rectangle.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: The number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the borders\n    for x in range(start_row + 1, end_row):\n        if matrix[x, start_col] != 1:\n            changes += 1\n        if matrix[x, end_col] != 1:\n            changes += 1\n\n    for y in range(start_col + 1, end_col):\n        if matrix[start_row, y] != 1:\n            changes += 1\n        if matrix[end_row, y] != 1:\n            changes += 1\n\n    # Check the inner area\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if matrix[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append(matrix)\n\n    # Call the function and print the results\n    results = transform_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_minimum_changes(test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Find the minimum number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        test_cases: A list of tuples, each containing the dimensions of the grid and the grid itself.\n\n    Returns:\n        A list of integers representing the minimum number of changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid: The grid as a numpy array.\n        start_row: The starting row of the sub-rectangle.\n        start_col: The starting column of the sub-rectangle.\n        a: The number of rows in the sub-rectangle.\n        b: The number of columns in the sub-rectangle.\n\n    Returns:\n        The number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the borders (except corners)\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the interior (excluding borders)\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    results = find_minimum_changes(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions of the rectangle and the grid.\n\n    Returns:\n        list: Minimum number of changes for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid])\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles with dimensions at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        changes = 0\n                        \n                        # Check borders\n                        for x in range(a):\n                            if grid_array[i + x, j] != '1':\n                                changes += 1\n                            if grid_array[i + x, j + b - 1] != '1':\n                                changes += 1\n                        for y in range(b):\n                            if grid_array[i, j + y] != '1':\n                                changes += 1\n                            if grid_array[i + a - 1, j + y] != '1':\n                                changes += 1\n                        \n                        # Check interior\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid_array[i + x, j + y] != '0':\n                                    changes += 1\n                        \n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and print results\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef find_minimum_changes(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: List of minimum changes for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, grid = case\n        grid = np.array([list(map(int, row)) for row in grid])\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate changes needed for this sub-rectangle\n                        changes = calculate_changes(grid, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check top and bottom borders\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            changes += 1\n        if grid[end_row, col] != 1:\n            changes += 1\n\n    # Check left and right borders\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            changes += 1\n        if grid[row, end_col] != 1:\n            changes += 1\n\n    # Check interior\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = find_minimum_changes(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing dimensions and matrix for each test case.\n\n    Returns:\n        list: Minimum number of changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix into a numpy array for efficient operations\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of dimensions at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes needed to transform the sub-rectangle into a portal\n                        changes = calculate_changes_to_portal(grid, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes_to_portal(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the vertical borders\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            changes += 1\n        if grid[x, end_col] != 1:\n            changes += 1\n\n    # Check the horizontal borders\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            changes += 1\n        if grid[end_row, y] != 1:\n            changes += 1\n\n    # Check the inner area\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform a sub-rectangle into a portal for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing (n, m, grid) where grid is a list of strings representing the grid.\n\n    Returns:\n        list: List of integers, each representing the minimum number of changes for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        min_changes = float('inf')\n        \n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        \n        # Iterate over all possible sub-rectangles with dimensions a >= 5, b >= 4\n        for a_start in range(n - 4):\n            for b_start in range(m - 3):\n                for a_end in range(a_start + 5, n + 1):\n                    for b_end in range(b_start + 4, m + 1):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid_array, a_start, b_start, a_end, b_end)\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(grid_array: np.ndarray, a_start: int, b_start: int, a_end: int, b_end: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid_array (np.ndarray): Numpy array representation of the grid.\n        a_start (int): Starting row index of the sub-rectangle.\n        b_start (int): Starting column index of the sub-rectangle.\n        a_end (int): Ending row index of the sub-rectangle.\n        b_end (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n    \n    # Check border blocks (excluding corners)\n    for x in range(a_start + 1, a_end - 1):\n        if grid_array[x][b_start] != 1:\n            changes += 1\n        if grid_array[x][b_end - 1] != 1:\n            changes += 1\n    \n    for y in range(b_start + 1, b_end - 1):\n        if grid_array[a_start][y] != 1:\n            changes += 1\n        if grid_array[a_end - 1][y] != 1:\n            changes += 1\n    \n    # Check inner blocks\n    for x in range(a_start + 1, a_end - 1):\n        for y in range(b_start + 1, b_end - 1):\n            if grid_array[x][y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    def count_changes_to_portal(grid: List[str], n: int, m: int) -> int:\n        \"\"\"Count the minimum changes required to transform a sub-rectangle into a portal.\n\n        Args:\n            grid (List[str]): Grid of blocks.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n\n        Returns:\n            int: Minimum number of changes required.\n        \"\"\"\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = 0\n                        # Check top and bottom borders\n                        for col in range(start_col, end_col + 1):\n                            if grid[start_row][col] != '1':\n                                changes += 1\n                            if grid[end_row][col] != '1':\n                                changes += 1\n                        # Check left and right borders\n                        for row in range(start_row + 1, end_row):\n                            if grid[row][start_col] != '1':\n                                changes += 1\n                            if grid[row][end_col] != '1':\n                                changes += 1\n                        # Check interior\n                        for row in range(start_row + 1, end_row):\n                            for col in range(start_col + 1, end_col):\n                                if grid[row][col] != '0':\n                                    changes += 1\n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n\n        return min_changes\n\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        result = count_changes_to_portal(test_case, n, m)\n        results.append(result)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    def is_portal(grid: List[str], a: int, b: int, start_row: int, start_col: int) -> bool:\n        \"\"\"Check if a sub-rectangle is already a portal.\n\n        Args:\n            grid (List[str]): The grid of blocks.\n            a (int): Number of rows in the sub-rectangle.\n            b (int): Number of columns in the sub-rectangle.\n            start_row (int): Starting row index of the sub-rectangle.\n            start_col (int): Starting column index of the sub-rectangle.\n\n        Returns:\n            bool: True if the sub-rectangle is a portal, False otherwise.\n        \"\"\"\n        for x in range(1, a - 1):\n            if grid[start_row + x][start_col] != '1' or grid[start_row + x][start_col + b - 1] != '1':\n                return False\n        for y in range(1, b - 1):\n            if grid[start_row][start_col + y] != '1' or grid[start_row + a - 1][start_col + y] != '1':\n                return False\n        return True\n\n    def calculate_changes(grid: List[str], a: int, b: int, start_row: int, start_col: int) -> int:\n        \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n        Args:\n            grid (List[str]): The grid of blocks.\n            a (int): Number of rows in the sub-rectangle.\n            b (int): Number of columns in the sub-rectangle.\n            start_row (int): Starting row index of the sub-rectangle.\n            start_col (int): Starting column index of the sub-rectangle.\n\n        Returns:\n            int: Number of changes required.\n        \"\"\"\n        changes = 0\n        for x in range(1, a - 1):\n            if grid[start_row + x][start_col] != '1':\n                changes += 1\n            if grid[start_row + x][start_col + b - 1] != '1':\n                changes += 1\n        for y in range(1, b - 1):\n            if grid[start_row][start_col + y] != '1':\n                changes += 1\n            if grid[start_row + a - 1][start_col + y] != '1':\n                changes += 1\n        return changes\n\n    results = []\n    for test_case in test_cases:\n        n = len(test_case)\n        m = len(test_case[0])\n        min_changes = float('inf')\n\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for start_row in range(n - a + 1):\n                    for start_col in range(m - b + 1):\n                        if is_portal(test_case, a, b, start_row, start_col):\n                            min_changes = min(min_changes, 0)\n                        else:\n                            changes = calculate_changes(test_case, a, b, start_row, start_col)\n                            min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes needed to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum changes for a test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Check if the current sub-rectangle can be transformed into a portal\n                        changes = calculate_changes(matrix, start_row, start_col, end_row, end_col)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform the sub-rectangle into a portal.\n\n    :param matrix: The grid as a numpy array\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of changes needed\n    \"\"\"\n    changes = 0\n\n    # Check the edges for obsidian blocks\n    for row in range(start_row + 1, end_row):\n        if matrix[row, start_col] != 1:\n            changes += 1\n        if matrix[row, end_col] != 1:\n            changes += 1\n\n    for col in range(start_col + 1, end_col):\n        if matrix[start_row, col] != 1:\n            changes += 1\n        if matrix[end_row, col] != 1:\n            changes += 1\n\n    # Check the inner blocks for vacant blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if matrix[row, col] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Function call\nresults = min_changes_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe task requires transforming a sub-rectangle within a larger rectangle into a specific pattern called a portal. The portal has strict requirements for its borders and interior, and the goal is to achieve this with the fewest changes possible. The solution must handle multiple test cases and large input sizes efficiently.\nrequirement pool:\n- Implement the algorithm to identify and transform sub-rectangles into portals.\n- Optimize the solution to minimize the number of changes required.\n- Ensure the solution can handle the maximum input constraints efficiently.\n- Provide clear and concise output for each test case.\n- Include detailed comments and documentation for the code.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and checking how many changes are needed to meet the portal criteria. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions, n by m, where n is the number of rows and m is the number of columns.\n    'obsidian block': A block represented by '1' in the grid.\n    'vacant': A block represented by '0' in the grid.\n    'portal': A sub-rectangle with specific criteria that must be met to be considered a portal.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension a of the portal must be at least 5.\n    'greater than or equal to 4': The dimension b of the portal must be at least 4.\n    'fewest number of changes': The minimum number of moves required to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n        - Ensure the borders are obsidian blocks as specified.\n        - Ensure the interior blocks are vacant.\n    4. Track the minimum number of changes required for each test case.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Test case with minimum dimensions:\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Test case with all vacant blocks:\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output: \n    12\n    Explanation: All border blocks need to be changed to obsidian, resulting in 12 changes.\n\n    Test case with mixed blocks:\n    Input: \n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Output: \n    8\n    Explanation: Adjustments are needed to ensure all border blocks are obsidian and interior blocks are vacant.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over sub-rectangles and calculating changes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are clearly defined, ensuring that the solution must efficiently handle the transformation process while adhering to these rules.\nrequirement pool:\n- Implement the main algorithm to transform rectangles into portals.\n- Optimize the solution for large inputs to ensure fast computation.\n- Provide detailed output for each test case.\n- Ensure the solution is scalable and can handle multiple test cases.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to transform rectangles into portals using a brute-force approach to check all possible sub-rectangles and calculate the minimum number of changes required. Given the constraints, we will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can be either an obsidian block (represented by '1') or vacant (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria regarding the arrangement of obsidian and vacant blocks.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5\n    'greater than or equal to 4': b must be at least 4\n    These phrases indicate the minimum dimensions required for a sub-rectangle to be considered a portal.\n\n# [degree adverb]\n    'fewest': This indicates that we need to find the minimum number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n4. Keep track of the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already meets the criteria for a portal, so no changes are needed.\n\n    Case 2: A rectangle with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All blocks need to be changed to meet the portal criteria.\n\n    Case 3: A rectangle with alternating blocks.\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on the specific arrangement, but should be calculated based on the minimum changes needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the minimum changes will naturally handle these cases.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern with the minimum number of changes. The constraints ensure that the solution must be efficient, especially given the maximum possible grid size. The solution should iterate over possible sub-rectangles and calculate the number of changes needed to meet the portal criteria.\nrequirement pool:\n- Implement an efficient algorithm to find the minimum changes needed.\n- Optimize the solution for handling large grid sizes.\n- Ensure the solution is robust and handles edge cases.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution.\nWe will implement a function that iterates over all possible sub-rectangles of the given grid and calculates the number of changes needed to transform each into a portal. The function will use efficient grid traversal techniques to minimize computational complexity. We will utilize numpy for efficient array manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid of blocks with specified dimensions (n by m) where each block can be either obsidian or vacant.\n    'portal': A specific sub-rectangle within the grid that meets certain criteria regarding its dimensions and block arrangement.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': The dimension 'b' of the portal must be at least 4.\n    'for every 1 < x < a': This specifies a range for x, meaning x must be greater than 1 and less than a.\n    'for each 1 < x < b': This specifies a range for x, meaning x must be greater than 1 and less than b.\n\n# [degree adverb]\n    'fewest': The goal is to minimize the number of changes needed to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to extract the number of test cases and the dimensions of each grid.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed:\n   - Ensure the borders (except corners) are obsidian blocks.\n   - Ensure the interior (excluding borders) is vacant.\n4. Track the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Case 2: A grid with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in 12 changes.\n\n    Case 3: A grid with maximum dimensions but no valid portal.\n    Input:\n    1\n    400 400\n    (all blocks are vacant)\n    Expected Output: Large number (depends on specific implementation)\n    Explanation: The entire border of a potential portal needs to be changed to obsidian, which is computationally intensive.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid is already a portal or has no obsidian blocks. This can be handled by checking if the initial state of the sub-rectangle already meets the portal conditions before counting changes.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are clear, and the solution must efficiently handle multiple test cases with potentially large inputs. The output format is strict, requiring careful attention to detail.\nrequirement pool:\n- Implement efficient algorithm to transform rectangles into portals.\n- Ensure solution handles large inputs within constraints.\n- Provide clear output format for user interpretation.\n- Optimize for minimal changes required.\n- Include detailed explanation of output results.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of the given dimensions and calculate the number of changes needed for each. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the initial grid of blocks, where each block can be either an obsidian block (represented by '1') or vacant (represented by '0').\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria, including having obsidian blocks on its borders and being empty inside, except for the corners.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': \n    Explanation: The dimension 'a' of the portal must be at least 5. In code, this can be checked using `if a >= 5`.\n\n    'greater than or equal to 4': \n    Explanation: The dimension 'b' of the portal must be at least 4. In code, this can be checked using `if b >= 4`.\n\n# [degree adverb]\n    'fewest number of changes':\n    Explanation: This indicates that the goal is to minimize the number of changes needed to transform a sub-rectangle into a portal. In code, this involves calculating and comparing the number of changes for each possible sub-rectangle.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, calculate the number of changes needed to meet the portal criteria:\n   - Ensure the borders are obsidian blocks.\n   - Ensure the interior is empty.\n4. Track the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle already meeting portal criteria\n    Explanation: If a sub-rectangle already meets the criteria, no changes are needed, so the output should be 0.\n\n    Case 2: A rectangle with all blocks as obsidian\n    Explanation: The maximum number of changes would be needed to clear the interior while maintaining the border, so calculate accordingly.\n\n    Case 3: A rectangle with all blocks vacant\n    Explanation: The maximum number of changes would be needed to fill the border with obsidian blocks while keeping the interior empty.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where a sub-rectangle already meets the portal criteria or is entirely filled with one type of block.\n    \n```python\ndef min_changes_to_portal(test_cases):\n    results = []\n    for n, m, grid in test_cases:\n        min_changes = float('inf')\n        for a in range(5, n+1):\n            for b in range(4, m+1):\n                for i in range(n-a+1):\n                    for j in range(m-b+1):\n                        changes = 0\n                        # Check borders\n                        for x in range(a):\n                            if grid[i+x][j] != '1':\n                                changes += 1\n                            if grid[i+x][j+b-1] != '1':\n                                changes += 1\n                        for y in range(b):\n                            if grid[i][j+y] != '1':\n                                changes += 1\n                            if grid[i+a-1][j+y] != '1':\n                                changes += 1\n                        # Check interior\n                        for x in range(1, a-1):\n                            for y in range(1, b-1):\n                                if grid[i+x][j+y] != '0':\n                                    changes += 1\n                        min_changes = min(min_changes, changes)\n        results.append(min_changes)\n    return results\n```\nThis code iterates over all possible sub-rectangles and calculates the number of changes needed to transform them into a portal, considering both border and interior conditions.\n", "requirement analysis:\nThe task requires transforming a sub-rectangle of a given grid into a portal with specific conditions. The main challenge is to minimize the number of changes needed to achieve this transformation. The solution must efficiently handle the constraints of up to 400x400 grids and multiple test cases.\nrequirement pool:\n- Implement the main algorithm to find the minimum changes needed for a portal.\n- Optimize the solution for large grid sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide clear and concise output for each test case.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of the given dimensions and calculating the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle with specific dimensions and block arrangements. It must have obsidian blocks on its borders and vacant blocks inside, except for the corners which can be any type.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': means the number of rows (a) in the portal must be at least 5.\n    'greater than or equal to 4': means the number of columns (b) in the portal must be at least 4.\n\n# [degree adverb]\n    'fewest': means we need to find the minimum number of changes required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    - Iterate over all possible sub-rectangles of dimensions at least 5x4 within the given rectangle.\n    - For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n    - Ensure the borders meet the obsidian block criteria and the interior is vacant.\n    - Track the minimum number of changes across all sub-rectangles.\n\n# [edge case]\n    Case 1: A rectangle already meeting portal criteria\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The rectangle already meets the portal criteria, so no changes are needed.\n\n    Case 2: A rectangle with all vacant blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in 12 changes.\n\n    Case 3: A rectangle with alternating blocks\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on specific arrangement, but requires significant changes to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for rectangles already meeting portal criteria to return zero changes.\n        - Efficiently calculate changes for rectangles with all vacant blocks or alternating patterns.\n        - Use numpy for matrix manipulation to streamline operations and minimize computational complexity.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the portal structure. Efficient algorithms are needed to handle the maximum input size within the given limits.\nrequirement pool:\n- Develop an algorithm to identify potential portal sub-rectangles.\n- Implement a method to calculate the minimum number of changes needed.\n- Optimize the solution for large input sizes.\n- Ensure the solution is scalable and efficient.\n- Provide detailed output for each test case.\nWe will use a brute-force approach to check all possible sub-rectangles of dimensions at least 5x4 within the given rectangle. For each sub-rectangle, we will calculate the number of changes needed to transform it into a portal. The solution will leverage numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A sub-rectangle with specific dimensions and block arrangements that meet certain criteria.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': The dimension 'a' of the portal must be at least 5.\n    'greater than or equal to 4': The dimension 'b' of the portal must be at least 4.\n    'fewest number of changes': The minimum number of moves required to transform a sub-rectangle into a portal.\n\n# [degree adverb]\n    'fewest': Refers to the smallest number of changes needed to achieve the transformation.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and dimensions for each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n    3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n    4. Keep track of the minimum number of changes required for each test case.\n    5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: A rectangle with dimensions exactly 5x4 and all blocks are already arranged as a portal.\n    Explanation: No changes are needed, so the expected output is 0.\n    \n    Case 2: A rectangle with dimensions larger than 5x4 but no possible sub-rectangle can be transformed into a portal.\n    Explanation: The expected output is the minimum number of changes needed for any possible sub-rectangle transformation.\n    \n    Case 3: A rectangle with dimensions exactly 5x4 but all blocks are vacant.\n    Explanation: The expected output is the number of changes needed to transform all blocks into obsidian according to portal criteria.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute-force approach inherently considers all possible sub-rectangles and calculates the necessary changes for each, ensuring that edge cases are handled within the original logic.\n", "requirement analysis:\nThe task requires transforming a sub-rectangle of a given grid into a portal with specific conditions. The main challenge is to minimize the number of changes needed, which involves strategic planning and efficient algorithms to handle the constraints of up to 400x400 grids.\nrequirement pool:\n- Implement the main algorithm to transform sub-rectangles into portals.\n- Optimize the solution to handle maximum constraints efficiently.\n- Develop a user-friendly interface for input and output.\n- Ensure the solution is scalable and can handle multiple test cases.\n- Provide detailed documentation and examples for users.\nWe will implement a function that iterates over all possible sub-rectangles of the given grid and checks if they can be transformed into a portal with the minimum number of changes. The function will use a brute-force approach to evaluate each sub-rectangle, but will be optimized by precomputing the number of obsidian blocks in each row and column to quickly calculate the number of changes needed. This approach will leverage efficient matrix operations using NumPy to handle large inputs within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A grid structure with n rows and m columns.\n    'obsidian block': A block represented by '1' in the grid.\n    'vacant': A block represented by '0' in the grid.\n    'portal': A sub-rectangle meeting specific criteria for obsidian blocks.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to': Used to define the minimum dimensions of the portal (a \u2265 5, b \u2265 4).\n    Implementation: Use comparison operators (>=) in code to check dimensions.\n\n# [degree adverb]\n    'fewest': Refers to the minimum number of changes needed to transform a sub-rectangle into a portal.\n    Implementation: Use optimization techniques to minimize changes, such as iterating through possible sub-rectangles and calculating changes.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and dimensions of each grid.\n2. For each test case, iterate over all possible sub-rectangles with dimensions a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, calculate the number of changes needed to meet portal criteria:\n   - Ensure all border blocks (except corners) are obsidian.\n   - Ensure all inner blocks are vacant.\n4. Track the minimum number of changes across all sub-rectangles for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case]\n    Case 1: Minimum size grid that already meets portal criteria\n    Input: \n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already forms a portal, so no changes are needed.\n\n    Case 2: Grid with no obsidian blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in maximum changes.\n\n    Case 3: Grid with alternating blocks\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on specific arrangement; requires calculation.\n    Explanation: Changes depend on optimizing block arrangement to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases efficiently by precomputing block counts and optimizing change calculations.\n```python\nimport numpy as np\n\ndef min_changes_to_portal(test_cases):\n    results = []\n    \n    for n, m, grid in test_cases:\n        min_changes = float('inf')\n        \n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        \n        # Iterate over all possible sub-rectangles with dimensions a >= 5, b >= 4\n        for a_start in range(n - 4):\n            for b_start in range(m - 3):\n                for a_end in range(a_start + 5, n + 1):\n                    for b_end in range(b_start + 4, m + 1):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid_array, a_start, b_start, a_end, b_end)\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(grid_array, a_start, b_start, a_end, b_end):\n    changes = 0\n    \n    # Check border blocks (excluding corners)\n    for x in range(a_start + 1, a_end - 1):\n        if grid_array[x][b_start] != 1:\n            changes += 1\n        if grid_array[x][b_end - 1] != 1:\n            changes += 1\n    \n    for y in range(b_start + 1, b_end - 1):\n        if grid_array[a_start][y] != 1:\n            changes += 1\n        if grid_array[a_end - 1][y] != 1:\n            changes += 1\n    \n    # Check inner blocks\n    for x in range(a_start + 1, a_end - 1):\n        for y in range(b_start + 1, b_end - 1):\n            if grid_array[x][y] != 0:\n                changes += 1\n    \n    return changes\n\n# Example usage:\ntest_cases = [\n    (5, 4, [\"1000\", \"0000\", \"0110\", \"0000\", \"0001\"]),\n    (9, 9, [\"001010001\", \"101110100\", \"000010011\", \"100000001\", \"101010101\", \"110001111\", \"000001111\", \"111100000\", \"000110000\"])\n]\n\nprint(min_changes_to_portal(test_cases))\n```\n\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a portal with specific conditions. The main challenge is to minimize the number of changes needed to achieve this transformation. The solution must efficiently handle the constraints of the grid size and multiple test cases.\nrequirement pool:\n- Implement the algorithm to find the minimum number of changes for a portal.\n- Optimize the solution for large grid sizes up to 400x400.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide detailed comments and documentation for the code.\n- Include test cases to verify the correctness of the solution.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of changes required to transform it into a portal. The solution will be optimized by early termination if a sub-rectangle already satisfies the portal conditions. Libraries like NumPy can be used for efficient grid manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the grid of blocks with n rows and m columns, where each block can be either an obsidian block (1) or vacant (0).\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria: dimensions at least 5x4, specific border conditions with obsidian blocks, and empty interior.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': \n    Explanation: The number of rows (a) in the sub-rectangle must be at least 5.\n    Implementation: Check if a >= 5 in code.\n\n    'greater than or equal to 4': \n    Explanation: The number of columns (b) in the sub-rectangle must be at least 4.\n    Implementation: Check if b >= 4 in code.\n\n# [degree adverb] \n    'fewest': \n    Explanation: The goal is to minimize the number of changes needed to transform a sub-rectangle into a portal.\n    Implementation: Use a variable to track the minimum number of changes across all sub-rectangles.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n2. For each test case, iterate over all possible sub-rectangles with dimensions at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n4. Track the minimum number of changes required for each test case.\n5. Output the minimum number of changes for each test case.\n\n# [edge case] \n    Case 1: A grid that is already a portal.\n    Example: \n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Case 2: A grid with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in a total of 12 changes.\n\n    Case 3: A grid with maximum dimensions but no valid portal.\n    Example:\n    Input:\n    1\n    400 400\n    (all blocks are empty)\n    Expected Output: Large number (depends on implementation)\n    Explanation: The entire border of a sub-rectangle needs to be changed, which is computationally intensive.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for grids that are already portals to return zero changes immediately.\n        - Implement efficient counting and early termination for grids with no obsidian blocks or maximum dimensions.\n", "requirement analysis:\nThe task requires transforming a sub-rectangle of a given grid into a portal with specific conditions. The main challenge is to minimize the number of changes needed, which involves strategic planning and efficient computation. The constraints ensure that the solution must be optimized for both time and space complexity.\nrequirement pool:\n- Implement the main algorithm to transform sub-rectangles into portals.\n- Optimize the solution for large inputs to ensure scalability.\n- Provide clear and concise output for each test case.\n- Ensure the solution is robust and handles edge cases effectively.\n- Develop a user-friendly interface for input and output handling.\nWe will use a dynamic programming approach to efficiently calculate the minimum number of changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of the given grid and compute the cost of transforming each into a portal, while maintaining a minimum cost. Libraries such as NumPy can be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle A with dimensions n by m'\n    Explanation: This refers to the grid of blocks, where each block can be either an obsidian block or vacant. The grid has n rows and m columns.\n\n    'portal'\n    Explanation: A sub-rectangle within the grid that meets specific criteria: dimensions a by b where a \u2265 5 and b \u2265 4, with specific blocks being obsidian and others vacant.\n\n    'fewest number of changes'\n    Explanation: The minimum number of moves required to transform a sub-rectangle into a portal by switching blocks between obsidian and vacant.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5.\n    'greater than or equal to 4': b must be at least 4.\n    'for every 1 < x < a': This means for all x values between 1 and a, exclusive.\n    'for each 1 < x < b': This means for all x values between 1 and b, exclusive.\n\n# [degree adverb]\n    'fewest': This indicates the need to find the minimum number of changes required.\n\n# [code logic]\n1. Parse the input to get the number of test cases, and for each test case, read the dimensions n and m, followed by the grid.\n2. For each possible sub-rectangle of dimensions a by b (where a \u2265 5 and b \u2265 4), calculate the cost to transform it into a portal.\n3. Use dynamic programming to efficiently compute the cost of transforming each sub-rectangle.\n4. Track the minimum cost across all sub-rectangles for each test case.\n5. Output the minimum cost for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal.\n    Input:\n    1\n    5 4\n    1111\n    1001\n    1001\n    1001\n    1111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no changes are needed.\n\n    Case 2: A grid with no obsidian blocks.\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, resulting in a total of 12 changes.\n\n    Case 3: A grid with maximum dimensions but minimal changes needed.\n    Input:\n    1\n    400 400\n    (A grid where only one sub-rectangle needs minimal changes)\n    Expected Output: (depends on specific grid configuration)\n    Explanation: The output will depend on the specific configuration of the grid, but it should reflect the minimal changes needed for at least one sub-rectangle.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the grid is already a portal or has no obsidian blocks.\n    \n```python\ndef handle_edge_cases(grid, n, m):\n    # Check if the grid is already a portal\n    if is_portal(grid):\n        return 0\n    \n    # Check if there are no obsidian blocks\n    if all(grid[i][j] == '0' for i in range(n) for j in range(m)):\n        return calculate_full_portal_cost(n, m)\n    \n    # Other logic for handling edge cases can be added here\n\ndef is_portal(grid):\n    # Implement logic to check if the current grid is already a portal\n    pass\n\ndef calculate_full_portal_cost(n, m):\n    # Implement logic to calculate the cost of transforming an empty grid into a portal\n    pass\n```\n\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are clearly defined, ensuring the solution must adhere to these rules while optimizing for the least number of changes.\nrequirement pool:\n- Implement the main algorithm to transform rectangles into portals.\n- Optimize the algorithm for large inputs.\n- Ensure the output format is clear and concise.\n- Develop a user-friendly interface for input and output.\n- Include error handling for invalid inputs.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and check if they can be transformed into a portal with minimal changes. We will use a brute-force approach with optimizations to handle the constraints efficiently. The function will calculate the number of changes needed for each sub-rectangle and return the minimum value. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'rectangle': A 2D shape with n rows and m columns, consisting of blocks that can be either obsidian or vacant.\n    'portal': A specific sub-rectangle with dimensions a by b that meets certain criteria regarding block placement.\n\n# [phrase showing quantity relationship]\n    'greater than or equal to 5': a must be at least 5.\n    'greater than or equal to 4': b must be at least 4.\n    'fewest number of changes': The goal is to minimize the number of block switches needed to form a portal.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Iterate over all possible sub-rectangles of size at least 5x4 within the given rectangle.\n    2. For each sub-rectangle, check if it can be transformed into a portal by counting the number of changes needed.\n    3. Ensure the edges of the sub-rectangle meet the obsidian block criteria.\n    4. Calculate the number of changes required for each sub-rectangle and keep track of the minimum number of changes.\n    5. Return the minimum number of changes for each test case.\n\n# [edge case]\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Output: \n    0\n    Explanation: The entire rectangle is already a portal, so no changes are needed.\n\n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Output: \n    12\n    Explanation: All blocks need to be changed to form a portal, requiring maximum changes.\n\n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Output: \n    0\n    Explanation: The sub-rectangle is already a portal, so no changes are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the minimum number of changes will naturally handle these cases.\n"], "scores": [], "pass_results": [true, false, false, true, true, true, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 811, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 474}
