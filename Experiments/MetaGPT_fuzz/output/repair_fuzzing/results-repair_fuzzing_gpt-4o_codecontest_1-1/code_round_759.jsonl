{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the big island of Baltia, there reside N individuals, numbered from 1 to N, and there are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, with very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons and is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends, enabling everyone to focus on their phones without interruptions. Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the big island of Baltia, there reside N individuals, numbered from 1 to N, and there are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, with very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons and is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends, enabling everyone to focus on their phones without interruptions. Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the big island of Baltia, there reside N individuals, numbered from 1 to N, and there are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party, with very strict regulations on what a party is and when the party is successful. On the island of Baltia, a party includes exactly 5 persons. A party is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends, enabling everyone to focus on their phones without interruptions. Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the big island of Baltia, there reside N individuals, numbered from 1 to N, where there are exactly M pairs of people that are buddies with each other. The people of Baltia want to host a successful party with very strict regulations on what a party is and when the party is successful; on the island of Baltia, a party includes exactly 5 persons and is deemed successful if either all the attendees are friends with each other (allowing them to communicate freely) or no pair of people at the party are friends, enabling everyone to focus on their phones without interruptions. Please assist the people of Baltia in organizing a successful gathering or inform them if it's impossible to achieve. The task is to determine whether such a configuration is possible given the pairs of buddies.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship constraints.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check for a clique of size 5\n    def is_clique(group: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if group[j] not in adjacency_list[group[i]]:\n                    return False\n        return True\n\n    # Helper function to check for an independent set of size 5\n    def is_independent_set(group: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if group[j] in adjacency_list[group[i]]:\n                    return False\n        return True\n\n    # Check all combinations of 5 people\n    from itertools import combinations\n    for group in combinations(range(1, n + 1), 5):\n        if is_clique(group) or is_independent_set(group):\n            return list(group)\n\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple, Union\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> Union[List[int], int]:\n    \"\"\"Find a successful party configuration on the island of Baltia.\n\n    Args:\n        n (int): Number of people on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        Union[List[int], int]: List of 5 attendees for a successful party or -1 if impossible.\n    \"\"\"\n    # Create a graph to represent friendships\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\ndef main():\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Output interface\n    result = find_successful_party(n, m, friendships)\n    if isinstance(result, list):\n        print(' '.join(map(str, result)))\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    def is_clique(subset: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if subset[j] not in adjacency_list[subset[i]]:\n                    return False\n        return True\n\n    # Check for an independent set of size 5\n    def is_independent_set(subset: List[int]) -> bool:\n        for i in range(5):\n            for j in range(i + 1, 5):\n                if subset[j] in adjacency_list[subset[i]]:\n                    return False\n        return True\n\n    # Try to find a clique or independent set of size 5\n    people = list(range(1, n + 1))\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    for o in range(l + 1, n):\n                        subset = [people[i], people[j], people[k], people[l], people[o]]\n                        if is_clique(subset) or is_independent_set(subset):\n                            return subset\n\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function and print the result\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport itertools\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration of 5 people.\n\n    Args:\n        n (int): Number of people on the island.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people for a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for cliques of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in itertools.combinations(combination, 2)):\n            return list(combination)\n\n    # Check for independent sets of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in itertools.combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function to find a successful party\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\n# Program entry point\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration of 5 people.\n\n    A successful party is defined as either a clique of 5 people (all are friends)\n    or an independent set of 5 people (none are friends).\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (list): A list of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create a graph from the friendships\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # To find independent sets, we can check the complement graph for cliques\n    complement_G = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_G):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people either all friends or none friends.\n\n    Args:\n        N: The number of individuals on the island.\n        M: The number of friendship pairs.\n        friendships: A list of tuples representing friendship pairs.\n\n    Returns:\n        A list of 5 individuals forming a successful party or -1 if impossible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for nodes in combinations(range(1, N + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(nodes, 2)):\n            return list(nodes)\n\n    # Check for an independent set of size 5\n    for nodes in combinations(range(1, N + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(nodes, 2)):\n            return list(nodes)\n\n    return -1\n\n# Input and output interface\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship conditions.\n\n    Args:\n        n (int): The number of individuals on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 individuals forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency list to represent the friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check if a set of nodes form a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes form an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Check all combinations of 5 individuals\n    from itertools import combinations\n    for combination in combinations(range(1, n + 1), 5):\n        if is_clique(combination) or is_independent_set(combination):\n            return list(combination)\n\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Union\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> Union[List[int], int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship conditions.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        Union[List[int], int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for cliques of size 5\n    for combo in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combo, 2)):\n            return list(combo)\n\n    # Check for independent sets of size 5\n    for combo in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combo, 2)):\n            return list(combo)\n\n    # If no successful party configuration is found\n    return -1\n\n# Interface using input() and print()\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n    if isinstance(result, list):\n        print(' '.join(map(str, result)))\n    else:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship conditions.\n\n    Args:\n        N: The number of people on the island.\n        M: The number of friendship pairs.\n        friendships: A list of tuples representing friendships between people.\n\n    Returns:\n        A list of 5 integers representing the people to invite to the party if a successful configuration exists,\n        otherwise returns -1.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for combination in combinations(range(1, N + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in combinations(range(1, N + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people based on friendship conditions.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in a graph is a set of vertices no two of which are adjacent.\n    # To find independent sets, we can use the complement graph.\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M. The solution must handle large inputs and provide a clear output format.\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles edge cases, such as no friendships or maximum friendships.\n- Optimize the solution for large inputs to ensure scalability.\n- Provide clear documentation and examples for users to understand the output.\n- Consider user interface improvements for better usability.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (all friends) or an independent set of size 5 (no friends) in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will use a combination of depth-first search (DFS) and combinatorial checks to find the required configuration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': A subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n    'independent set': A set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include exactly 5 individuals.\n    'all the attendees are friends': All 5 individuals must be friends with each other.\n    'no pair of people at the party are friends': None of the 5 individuals should be friends with each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using adjacency lists.\n2. Check for a clique of size 5:\n   - Iterate through each person and use DFS to find if there exists a clique of size 5.\n3. Check for an independent set of size 5:\n   - Iterate through each person and use DFS to find if there exists an independent set of size 5.\n4. If either a clique or an independent set is found, print the 5 individuals.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With all possible friendships (complete graph), no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints on N and M.\nrequirement pool:\n- Develop an algorithm to check for a successful party configuration.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear output indicating the result.\n- Optimize for edge cases where M is 0 or very large.\n- Consider user-friendly error messages for invalid inputs.\nWe will use graph theory to solve this problem. Specifically, we will utilize the NetworkX library to represent the friendships as a graph. The problem can be approached by checking for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). NetworkX provides efficient methods to find cliques and independent sets, which will help us handle the constraints efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means a group of 5 people where everyone is friends with each other.\n\n    'independent set'\n    Explanation: An independent set in a graph is a set of vertices no two of which are adjacent. In this context, it means a group of 5 people where no one is friends with anyone else in the group.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This means the party must consist of exactly 5 individuals.\n    'either all... or no pair': This indicates a binary condition where either all attendees are friends or none are friends.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using NetworkX.\n2. Check for cliques of size 5 using NetworkX's clique finding methods.\n3. Check for independent sets of size 5 using NetworkX's independent set finding methods.\n4. If either a clique or an independent set of size 5 is found, print the members.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible friendship present, no group of 5 can be an independent set.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for finding cliques and independent sets inherently handles these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the given individuals. The constraints suggest that an efficient algorithm is necessary, likely involving graph theory concepts such as cliques and independent sets.\nrequirement pool:\n- Develop an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles the maximum constraints of N and M efficiently.\n- Provide clear output as specified in the requirements.\n- Consider edge cases such as no friendships or all possible friendships.\n- Optimize for readability and maintainability of the code.\nWe will use graph theory to solve this problem. The task is to find either a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). We will represent the friendships as an undirected graph and use adjacency lists to store the connections. We will then check for the existence of a clique or an independent set of size 5 using efficient graph traversal techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': A subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n    'independent set': A set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include exactly 5 individuals.\n    'either all the attendees are friends with each other or no pair of people at the party are friends': This defines the conditions for a successful party, either a complete clique or a complete independent set.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as an undirected graph using adjacency lists.\n    2. Check for a clique of size 5:\n        - Iterate through each person and their friends to find a subset of 5 people where each person is friends with every other person in the subset.\n    3. Check for an independent set of size 5:\n        - Iterate through each person and their non-friends to find a subset of 5 people where no person is friends with any other person in the subset.\n    4. If either a clique or an independent set is found, print the 5 people. Otherwise, print -1.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships (a complete graph), no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that either all are friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M.\nrequirement pool:\n- Efficiently check combinations of friendships among 5 people.\n- Handle large input sizes up to 200,000 efficiently.\n- Provide clear output format as specified.\n- Ensure no duplicate friendships are processed.\n- Consider edge cases where M is 0 or N is exactly 5.\nWe will use graph theory to solve this problem efficiently. The key is to check for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We can utilize adjacency lists to represent friendships and use combinations to check possible configurations. Given the constraints, we need to ensure our solution is optimized for large inputs, possibly using libraries like itertools for combinations and networkx for graph operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all 5 people at the party are friends with each other.\n    \n    'independent sets': An independent set in a graph is a set of vertices no two of which are adjacent. Here, it means none of the 5 people at the party are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This indicates that the party must consist of precisely 5 individuals.\n    \n    'no pairs': This means that in an independent set, there should be zero pairs of friends among the attendees.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for cliques of size 5 by iterating through combinations of 5 people and verifying if all are friends.\n    3. Check for independent sets of size 5 by iterating through combinations of 5 people and verifying if none are friends.\n    4. If either condition is met, print the combination; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is a friendship, no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers both cliques and independent sets, which covers all possible configurations.\n", "requirement analysis:\nThe task requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the given individuals. The solution must efficiently handle up to 200,000 individuals and friendships, suggesting the need for an algorithm with a time complexity better than O(N^5).\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles the maximum constraints effectively.\n- Provide clear output as specified in the requirements.\n- Optimize for edge cases where M is 0 or N is just 5.\n- Consider multiple successful configurations if possible.\nWe will use graph theory to solve this problem efficiently. The key is to check for cliques of size 5 (where all members are friends) or independent sets of size 5 (where no members are friends). We can utilize the NetworkX library to handle graph operations efficiently, as it provides functions to find cliques and independent sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all attendees are friends with each other.\n    \n    'independent sets': An independent set in graph theory is a set of vertices in a graph, no two of which are adjacent. In this context, it means no attendees are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This indicates that the party must consist of precisely 5 individuals.\n    \n    'no pairs are repeated': This means each friendship is unique and not duplicated in the input.\n\n# [degree adverb]\n    'successful': This means the party meets the criteria of either all attendees being friends or none being friends.\n\n# [code logic]\n    1. Parse the input to create a graph representation of friendships using NetworkX.\n    2. Check for cliques of size 5 using NetworkX's function for finding cliques.\n    3. Check for independent sets of size 5 using NetworkX's function for finding independent sets.\n    4. If either a clique or an independent set of size 5 is found, print the members of that set.\n    5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, it's impossible to have an independent set of size 5.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the given individuals. The solution must efficiently handle up to 200,000 people and friendships, suggesting the need for an algorithm with a complexity better than O(N^5).\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles edge cases, such as no friendships or maximum friendships.\n- Optimize the solution for large datasets to ensure scalability.\n- Provide clear and concise output as per the specified format.\n- Consider user-friendly documentation or comments within the code.\nWe will use graph theory to solve this problem. The task is to find a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). We will represent the friendships as an undirected graph and use adjacency lists for efficient traversal. The solution will involve checking combinations of nodes to find either a complete subgraph of size 5 or a set of 5 nodes with no edges between them. Given the constraints, we will use a combination of depth-first search (DFS) and combinatorial checks to efficiently find the required configuration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all 5 people at the party are friends with each other.\n    \n    'independent set': An independent set in graph theory is a set of vertices in a graph, no two of which are adjacent. Here, it means none of the 5 people at the party are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This indicates that the party must consist of precisely 5 individuals, no more, no less.\n    \n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as an undirected graph using adjacency lists.\n    2. Check for a clique of size 5 by iterating through combinations of nodes and verifying if all are connected.\n    3. Check for an independent set of size 5 by iterating through combinations of nodes and verifying if none are connected.\n    4. If either configuration is found, print the 5 individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 individuals is a friendship, it's impossible to have an independent set of size 5.\n\n    Input: 7 10\n    Output: -1\n    Explanation: If the friendships form a structure where neither a clique nor an independent set of size 5 can be formed, the output should be -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining if a successful party configuration is possible given the friendship pairs. The solution must efficiently handle large inputs and provide clear outputs. The challenge lies in checking both conditions for a successful party: all attendees are friends or none are friends.\nrequirement pool:\n- Efficiently check if a successful party configuration is possible.\n- Handle large numbers of individuals and friendships.\n- Provide clear output indicating party configuration or impossibility.\n- Optimize for performance with large datasets.\n- Ensure no duplicate friendship pairs are processed.\nWe will use graph theory to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will use a combination of depth-first search (DFS) and combinatorial checks to find the required configuration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means all 5 people at the party are friends with each other.\n    \n    'independent set': An independent set in a graph is a set of vertices such that no two vertices in the set are adjacent. Here, it means none of the 5 people at the party are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must consist of exactly 5 individuals.\n    \n    'no pairs are repeated': Each friendship pair is unique and appears only once.\n\n# [degree adverb]\n    'successful': The party is successful if either all attendees are friends or none are friends.\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for a clique of size 5:\n        - Use DFS to explore possible cliques.\n        - Verify if all members of a potential clique are friends with each other.\n    3. Check for an independent set of size 5:\n        - Use DFS to explore possible independent sets.\n        - Verify if no members of a potential set are friends with each other.\n    4. If either condition is met, print the 5 individuals; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 individuals forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 individuals\n    Explanation: With maximum friendships, any group of 5 individuals forms a clique.\n\n    Input: 7 0\n    Output: -1\n    Explanation: Although there are more than 5 individuals, no friendships exist to form a clique, and the independent set condition is trivially met but not unique.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic covers both clique and independent set conditions comprehensively.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship pairs. The solution must efficiently handle large inputs and provide clear output, either a list of 5 individuals or -1 if impossible. Edge cases, such as minimal friendships or maximum constraints, must be considered.\nrequirement pool:\n- Efficiently determine if a successful party configuration is possible\n- Handle large input sizes up to 200,000 individuals and friendships\n- Provide clear output format as specified\n- Consider edge cases with minimal or no friendships\n- Optimize for performance and memory usage\nWe will use a graph-based approach to solve this problem. The key is to check for cliques of size 5 (where everyone is friends with each other) or independent sets of size 5 (where no one is friends with each other). We can use adjacency lists to represent the friendships and then check for these conditions efficiently. Given the constraints, we need to ensure our solution is optimized for both time and space.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques': In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means a group of 5 people where everyone is friends with each other.\n    'independent sets': An independent set in a graph is a set of vertices no two of which are adjacent. Here, it means a group of 5 people where no one is friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This means the party must consist of precisely 5 individuals.\n    'no pairs are repeated': This indicates that each friendship pair is unique and appears only once.\n\n# [degree adverb]\n    'successful': This means the party meets the criteria of either all attendees being friends or none being friends.\n\n# [code logic]\n    1. Represent the friendships using an adjacency list.\n    2. Check for cliques of size 5 by iterating through combinations of 5 people and verifying if all are friends.\n    3. Check for independent sets of size 5 by iterating through combinations of 5 people and verifying if none are friends.\n    4. If either condition is met, print the 5 people; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is a friendship, no independent set of size 5 can exist.\n\n    Input: 7 0\n    Output: Any combination of 5 numbers from 1 to 7\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers both cliques and independent sets, which covers all possible configurations.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the given individuals. The solution must efficiently handle up to 200,000 individuals and friendships, suggesting the need for an algorithm with a time complexity better than O(N^5).\nrequirement pool:\n- Develop an efficient algorithm to check for successful party configurations.\n- Ensure the solution handles the maximum constraints of N and M efficiently.\n- Provide clear and concise output as specified in the requirements.\n- Consider edge cases such as no friendships or all individuals being friends.\n- Optimize for readability and maintainability of the code.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will use a combination of graph traversal and combinatorial checks to ensure the solution is efficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': A subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n    'independent set': A set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': The party must include exactly 5 people.\n    'either all the attendees are friends with each other or no pair of people at the party are friends': This defines the conditions for a successful party, either a complete clique or a complete independent set.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Represent the friendships as a graph using adjacency lists.\n    2. Check for a clique of size 5:\n        - For each person, check if they have at least 4 friends.\n        - For each combination of 5 people, check if they form a complete subgraph (clique).\n    3. Check for an independent set of size 5:\n        - For each combination of 5 people, check if none of them are friends with each other.\n    4. If either condition is met, print the 5 people. If neither condition is met, print -1.\n\n# [edge case] \n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With maximum friendships, no group of 5 can be an independent set, and if no clique of size 5 exists, return -1.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers both cliques and independent sets, which covers all possible configurations.\n", "requirement analysis:\nThe requirements focus on determining if a successful party configuration is possible given the constraints of friendships among individuals. The solution must efficiently handle large inputs and provide clear output indicating either a successful configuration or impossibility.\nrequirement pool:\n- Efficiently check for possible party configurations\n- Handle large datasets within constraints\n- Provide clear output format\n- Optimize for speed and scalability\n- Consider edge cases and multiple solutions\nWe will use graph theory to model the friendships as an undirected graph. The problem can be solved by checking for cliques of size 5 or independent sets of size 5. We will use the NetworkX library to efficiently handle graph operations and check for these conditions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'cliques of size 5'\n    Explanation: A clique of size 5 means a subset of 5 people where every pair of people are friends with each other.\n\n    'independent sets of size 5'\n    Explanation: An independent set of size 5 means a subset of 5 people where no two people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 persons': This means the party must include precisely 5 individuals.\n    'either all the attendees are friends with each other or no pair of people at the party are friends': This indicates two mutually exclusive conditions for a successful party.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Model the friendships as an undirected graph using NetworkX.\n2. Check for cliques of size 5 in the graph:\n   - Use a function to find all cliques in the graph and check if any have size 5.\n3. Check for independent sets of size 5:\n   - Use a function to find all independent sets in the graph and check if any have size 5.\n4. If either a clique or an independent set of size 5 is found, print the members.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: With every possible friendship present, no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, true, true, true, false, false, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 759, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "condense_two2one", "parent_index": 460}
