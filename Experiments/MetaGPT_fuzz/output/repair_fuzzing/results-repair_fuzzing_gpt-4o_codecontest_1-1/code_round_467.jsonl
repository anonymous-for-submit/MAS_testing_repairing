{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp is the coach of the Berland State University programming teams, and he decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet, with the i-th problem having a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different.\n\nYour task is to determine the number of ways to select three problems for the problemset, considering cases where topics or difficulties overlap carefully to ensure valid selections.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp is the coach of the Berland State University programming teams, and he decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet, with the i-th problem having a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different.\n\nYour task is to determine the number of ways to select three problems for the problemset, considering cases where topics or difficulties overlap carefully to ensure valid selections.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp is the coach of the Berland State University programming teams, and he decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The problems are described in specific terms, with the i-th problem having a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, meaning there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different.\n\nYour task is to determine the number of ways to select three problems for the problemset, considering cases where topics or difficulties overlap carefully to ensure valid selections.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp is the coach of the Berland State University programming teams, and he decided to compose a problemset for a training session for his teams. Monocarp has n problems that none of his students have seen yet, with the i-th problem having a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), and all problems are different, ensuring there are no two tasks that have the same topic and difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset, and the problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different.\n\nYour task is to determine the number of ways to select three problems for the problemset, considering cases where topics or difficulties overlap carefully to ensure valid selections.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate invalid combinations where neither condition is satisfied\n        invalid_combinations = 0\n\n        # Combinations with the same topic\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += comb(count, 3)\n\n        # Combinations with the same difficulty\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += comb(count, 3)\n\n        # Subtract invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Populate the dictionaries with the count of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate the total number of ways to choose any 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate the number of invalid combinations\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Calculate invalid combinations where both topic and difficulty are the same for a pair of problems\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Subtract invalid combinations from the total to get the valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import Counter\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid sets of three problems for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of tuples\n                    representing the topic and difficulty of each problem.\n\n    Returns:\n        A list of integers where each integer represents the number of valid sets of three problems\n        for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Count occurrences of each topic and difficulty\n        topic_count = Counter()\n        difficulty_count = Counter()\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n\n        # Invalid combinations where all three problems have the same topic\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Invalid combinations where all three problems have the same difficulty\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Subtract invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where all topics are the same\n        invalid_topic_combinations = sum(comb(count, 3) for count in topic_count.values() if count >= 3)\n\n        # Calculate invalid combinations where all difficulties are the same\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulty_count.values() if count >= 3)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom collections import Counter\nfrom math import comb\n\ndef calculate_valid_problem_sets(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the number of problems and a list of problems\n                           where each problem is represented as a tuple of topic and difficulty.\n\n    Returns:\n        list: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize counters for topics and difficulties\n        topic_counter = Counter()\n        difficulty_counter = Counter()\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_counter[topic] += 1\n            difficulty_counter[difficulty] += 1\n\n        # Calculate total combinations of 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where topics are not different\n        invalid_topic_combinations = sum(comb(count, 2) * (n - count) for count in topic_counter.values() if count >= 2)\n\n        # Calculate invalid combinations where difficulties are not different\n        invalid_difficulty_combinations = sum(comb(count, 2) * (n - count) for count in difficulty_counter.values() if count >= 2)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print the results\n    results = calculate_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize counters for topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties overlap\n        invalid_combinations = 0\n\n        # Subtract combinations where topics overlap\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Subtract combinations where difficulties overlap\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    def combination(n: int, k: int) -> int:\n        \"\"\"Calculate the number of combinations C(n, k).\n\n        Args:\n            n (int): Total number of items.\n            k (int): Number of items to choose.\n\n        Returns:\n            int: Number of combinations.\n        \"\"\"\n        if n < k:\n            return 0\n        if k == 0:\n            return 1\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        total_combinations = combination(n, 3)\n        invalid_combinations = 0\n\n        for topic, difficulty in problems:\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import Counter\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of tuples\n                    representing the topic and difficulty of each problem.\n\n    Returns:\n        A list of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_counter = Counter()\n        difficulty_counter = Counter()\n\n        for topic, difficulty in problems:\n            topic_counter[topic] += 1\n            difficulty_counter[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where all three problems have the same topic\n        invalid_same_topic = sum(comb(count, 3) for count in topic_counter.values() if count >= 3)\n\n        # Calculate invalid combinations where all three problems have the same difficulty\n        invalid_same_difficulty = sum(comb(count, 3) for count in difficulty_counter.values() if count >= 3)\n\n        # Calculate invalid combinations where both conditions are violated simultaneously\n        invalid_both = 0\n        for topic, difficulty in problems:\n            # For each problem, calculate how many sets it contributes to invalid_both\n            invalid_both += (topic_counter[topic] - 1) * (difficulty_counter[difficulty] - 1)\n\n        # Calculate valid sets\n        valid_sets = total_combinations - invalid_same_topic - invalid_same_difficulty + invalid_both\n        results.append(valid_sets)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Count the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize hash maps to count occurrences of topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not different\n        invalid_combinations = 0\n\n        # Count invalid combinations for topics\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Count invalid combinations for difficulties\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import Counter\nfrom math import comb\n\ndef count_valid_selections(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid selections of problems based on the given criteria.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid selections for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_counter = Counter()\n        difficulty_counter = Counter()\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_counter[topic] += 1\n            difficulty_counter[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where neither topics nor difficulties are different\n        invalid_combinations = 0\n\n        # Subtract combinations where all topics are the same\n        for count in topic_counter.values():\n            if count >= 3:\n                invalid_combinations += comb(count, 3)\n\n        # Subtract combinations where all difficulties are the same\n        for count in difficulty_counter.values():\n            if count >= 3:\n                invalid_combinations += comb(count, 3)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_selections(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to select three problems from a given set such that they meet at least one of the two conditions: all topics are different or all difficulties are different. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the selection process is both accurate and scalable.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems.\n- Ensure that the selected problems meet at least one of the specified conditions.\n- Optimize the algorithm to run within acceptable time limits for all test cases.\n- Provide clear and accurate output for each test case.\n- Consider edge cases where topics or difficulties overlap significantly.\nWe will use a combinatorial approach to efficiently calculate the number of valid problem sets. The key is to count the total number of ways to choose any three problems and then subtract the invalid combinations where neither condition is satisfied. We will use dictionaries to count occurrences of each topic and difficulty, which will help in calculating the invalid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either different topics or different difficulties, or both. This is crucial for determining valid combinations.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select exactly three problems from the given set.\n    'at least one': This means that the selected problems must satisfy at least one of the conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the total number of ways to choose any three problems from n problems using combinatorial formula C(n, 3).\n    2. Use dictionaries to count occurrences of each topic and difficulty.\n    3. Calculate invalid combinations where neither condition is satisfied:\n        - For each topic, calculate combinations of problems with the same topic.\n        - For each difficulty, calculate combinations of problems with the same difficulty.\n    4. Subtract invalid combinations from total combinations to get valid combinations.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (all three problems) satisfies both conditions.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No combination satisfies either condition.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of subtracting invalid combinations from total combinations will handle edge cases correctly.\n", "requirement analysis:\nThe task requires selecting three problems from a set of n problems such that either all topics or all difficulties are different. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the selection criteria are met without exceeding time limits.\nrequirement pool:\n- Efficiently handle up to 200,000 problems across multiple test cases.\n- Ensure that selected problems meet the criteria of different topics or difficulties.\n- Optimize the solution for quick execution and accurate results.\n- Provide clear and concise output for each test case.\n- Consider edge cases where n is minimal or maximal.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count combinations where either topics or difficulties are different, using hash maps to track occurrences of each topic and difficulty. This approach leverages Python's collections library for efficient counting and ensures scalability for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics of all three selected problems are different'\n    Explanation: This means that when selecting three problems, each problem must have a unique topic number.\n\n    'difficulties of all three selected problems are different'\n    Explanation: This means that when selecting three problems, each problem must have a unique difficulty level.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This indicates that the selection must consist of precisely three problems, no more, no less.\n    \n    'at least one of two conditions': This means that the selection must satisfy at least one of the conditions (different topics or different difficulties) or both.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems `n`.\n2. Initialize two dictionaries to count occurrences of each topic and difficulty.\n3. Iterate through each problem and populate the dictionaries with the count of each topic and difficulty.\n4. Calculate the total number of ways to choose any 3 problems from `n` using combinatorial formula C(n, 3).\n5. For each problem, calculate the number of invalid combinations where both topic and difficulty are the same for a pair of problems.\n6. Subtract these invalid combinations from the total to get the valid combinations.\n7. Output the result for each test case.\n\n# [edge case] \n    Test case with minimum n = 3:\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Expected Output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Test case with all topics and difficulties being unique:\n    Input: 1\n           4\n           1 2\n           2 3\n           3 4\n           4 5\n    Expected Output: 4\n    Explanation: All combinations of three problems will satisfy both conditions.\n\n    Test case with maximum overlap:\n    Input: 1\n           3\n           1 1\n           1 2\n           1 3\n    Expected Output: 0\n    Explanation: All problems have the same topic, so no valid selection is possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid combinations by subtracting invalid ones will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the constraints are respected and the output is accurate.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems.\n- Ensure the solution meets the criteria of different topics or difficulties.\n- Optimize for quick execution time across all test cases.\n- Provide clear and accurate output for each test case.\n- Consider edge cases where n is minimal or maximal.\nWe will use combinatorial counting to efficiently determine the number of valid sets of three problems. The key is to count combinations where either topics or difficulties are all different. We will utilize collections from Python's standard library to count occurrences and apply combinatorial logic to calculate the number of valid sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics': Refers to the unique identifier for the subject matter of each problem.\n    'difficulties': Refers to the unique identifier for the complexity level of each problem.\n    'combinatorial counting': A mathematical approach to count the number of ways to choose items from a set, considering specific conditions.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': We need to select precisely three problems from the given set.\n    'at least one of two conditions': The selection must satisfy at least one of the two specified conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and details for each test case.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use combinatorial counting to calculate the total number of ways to choose 3 problems from n (n choose 3).\n4. Count the occurrences of each topic and difficulty using collections.Counter.\n5. Calculate invalid combinations where topics or difficulties are not all different:\n   - For each topic, calculate invalid combinations where all three problems have the same topic.\n   - For each difficulty, calculate invalid combinations where all three problems have the same difficulty.\n6. Subtract these invalid combinations from the total combinations to get valid combinations.\n7. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum n (n=3):\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Expected Output: 1\n    Explanation: Only one way to select all three problems, satisfying both conditions.\n\n    Test case with maximum n (n=200000) but all topics and difficulties are unique:\n    Input: 1\n           200000\n           (1,1), (2,2), ..., (200000,200000)\n    Expected Output: C(200000, 3)\n    Explanation: All combinations are valid as all topics and difficulties are unique.\n\n    Test case with all problems having the same topic:\n    Input: 1\n           4\n           1 1\n           1 2\n           1 3\n           1 4\n    Expected Output: C(4, 3)\n    Explanation: Only one condition can be satisfied (different difficulties).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and subtracting invalid cases will handle these scenarios correctly.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either all topics or all difficulties are different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient algorithm to select valid problem sets\n- Ensure solution handles maximum input limits effectively\n- Optimize for performance with large datasets\n- Validate results against edge cases\n- Provide clear output format for test cases\nWe will use a combinatorial approach to efficiently calculate the number of valid problem sets. The key is to count the number of ways to select three problems such that either all topics or all difficulties are different. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to determine the number of valid combinations. This approach ensures that we handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either different topics or different difficulties, or both. This means that for a valid selection, the three problems should not share the same topic or difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means we need to select precisely three problems from the given set.\n    'number of ways': refers to calculating the total possible combinations that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the number of problems and their respective topics and difficulties.\n    2. Use dictionaries to count occurrences of each topic and difficulty.\n    3. Calculate the total number of ways to select any three problems using combinatorial formula C(n, 3).\n    4. Subtract invalid combinations where all topics or all difficulties are the same using the counts from dictionaries.\n    5. Return the number of valid combinations for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems where both topics and difficulties are different.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No valid selection as all combinations have either same topics or same difficulties.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations are valid as all topics and difficulties are different.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the constraints are met without exceeding time limits.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets.\n- Ensure the solution is scalable for large input sizes.\n- Optimize the algorithm to handle edge cases.\n- Provide clear and accurate output for each test case.\n- Implement additional features for user interaction.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count combinations where either topics or difficulties are all different, leveraging Python's collections library for efficient counting and handling large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial counting'\n    Explanation: This refers to using mathematical techniques to count the number of ways to choose items from a set, considering specific conditions. In this context, it involves counting combinations of problems where either topics or difficulties are all different.\n\n# [phrase showing quantity relationship]\n    'exactly 3': We need to select exactly three problems from the given set.\n    'different': The topics or difficulties of the selected problems must be different from each other.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the list of problems for each test case.\n    2. For each test case, initialize counters for topics and difficulties using collections.Counter.\n    3. Calculate the total number of ways to choose 3 problems from n using combinatorial formula C(n, 3).\n    4. Subtract invalid combinations where topics or difficulties are not different using the counters.\n    5. Return the valid combinations count for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one valid combination exists where both topics and difficulties are different.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No valid combination exists where either topics or difficulties are all different.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations are valid as both topics and difficulties are different for each problem.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting valid combinations inherently handles these scenarios by considering both topic and difficulty constraints.\n", "requirement analysis:\nThe requirement involves selecting three problems from a set of n problems such that either their topics or difficulties are all different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems across all test cases. The constraints ensure that no two problems have the same topic and difficulty simultaneously, simplifying the selection process.\nrequirement pool:\n- Implement efficient problem selection logic\n- Ensure solution handles maximum input constraints\n- Optimize for performance and speed\n- Provide clear output format\n- Consider edge cases in problem selection\nWe will use a combination of combinatorial counting and hash maps to efficiently determine the number of valid problem sets. The key is to count the number of ways to select three problems such that either their topics or difficulties are all different. We will use hash maps to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either all different topics or all different difficulties, or both. This is crucial for determining valid combinations.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means we need to select precisely three problems for each valid combination.\n    'number of ways': refers to calculating the total possible combinations that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize counters for each topic and difficulty using hash maps.\n    2. For each test case, iterate through the list of problems and update the counters for topics and difficulties.\n    3. Calculate the total number of ways to select any three problems using combinatorial counting (n choose 3).\n    4. Subtract invalid combinations where topics or difficulties overlap using the counters.\n    5. Return the number of valid combinations for each test case.\n\n# [edge case]\n    Test case with minimum n = 3:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination is possible where both topics and difficulties are different.\n\n    Test case with all same topics:\n    Input: 4\n           1 2\n           1 3\n           1 4\n           1 5\n    Output: 0\n    Explanation: No valid combination as all topics are the same.\n\n    Test case with all same difficulties:\n    Input: 4\n           1 1\n           2 1\n           3 1\n           4 1\n    Output: 0\n    Explanation: No valid combination as all difficulties are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on selecting three problems from a set of n problems, ensuring either unique topics or difficulties. The solution must efficiently handle up to 50000 test cases and a total of 200000 problems across all test cases. The algorithm should be optimized for performance and accuracy, especially for large datasets.\nrequirement pool:\n- Implement efficient problem selection algorithm\n- Ensure accurate results for large datasets\n- Optimize performance for high number of test cases\n- Provide clear output format\n- Handle edge cases and ensure robustness\nWe will use a combinatorial approach to solve this problem efficiently. The key is to count the number of valid combinations of three problems that satisfy the given conditions. We will use dictionaries to count occurrences of topics and difficulties, and then calculate the number of valid combinations by subtracting invalid ones from the total possible combinations. This approach ensures that we handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial approach'\n    Explanation: This refers to using combinatorial mathematics to count the number of ways to select three problems that meet the given conditions. It involves calculating combinations and subtracting invalid selections.\n\n    'topics' and 'difficulties'\n    Explanation: These are attributes of each problem. The requirement specifies that selected problems must have either different topics or different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': We need to select precisely three problems from the list.\n    Explanation: This means we are looking for combinations of three problems, not more or less.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and details for each test case.\n2. For each test case, initialize dictionaries to count occurrences of each topic and difficulty.\n3. Calculate the total number of ways to choose 3 problems from n using combinatorial formula C(n, 3).\n4. Subtract invalid combinations where topics or difficulties overlap.\n5. For each problem, calculate how many combinations are invalid due to overlapping topics or difficulties.\n6. Sum up valid combinations for each test case and print the result.\n\n# [edge case]\n    Test case with minimum n = 3:\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one way to select three problems, all topics and difficulties are different.\n\n    Test case with all same topics:\n    Input:\n    1\n    4\n    1 2\n    1 3\n    1 4\n    1 5\n    Output:\n    0\n    Explanation: No valid selection as all topics are the same.\n\n    Test case with all same difficulties:\n    Input:\n    1\n    4\n    2 1\n    3 1\n    4 1\n    5 1\n    Output:\n    0\n    Explanation: No valid selection as all difficulties are the same.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of subtracting invalid combinations from total combinations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the constraints are respected and the results are accurate.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems.\n- Ensure the solution meets the criteria of different topics or difficulties.\n- Optimize the algorithm for performance and scalability.\n- Provide clear and accurate output for each test case.\n- Consider edge cases where n is minimal or maximal.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count the number of ways to select three problems such that they satisfy the conditions of having different topics or different difficulties. We will utilize collections.Counter from the Python standard library to count occurrences of topics and difficulties, and then apply combinatorial logic to calculate the valid sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'different topics' and 'different difficulties'\n    Explanation: The requirement specifies that the selected problems must have either different topics or different difficulties, or both. This means that for a valid selection of three problems, either the topics or the difficulties must be unique among the selected problems.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means we need to select precisely three problems for each valid set.\n    'number of ways': refers to the total count of valid combinations of three problems that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the number of problems and their respective topics and difficulties.\n    2. Use collections.Counter to count occurrences of each topic and difficulty.\n    3. Calculate the total number of ways to select any three problems using combinatorial logic (n choose 3).\n    4. Subtract invalid combinations where neither condition is satisfied:\n        - Calculate invalid sets where all three problems have the same topic.\n        - Calculate invalid sets where all three problems have the same difficulty.\n    5. Add back sets that were subtracted twice (where both conditions are violated simultaneously).\n    6. Output the number of valid sets for each test case.\n\n# [edge case]\n    Input: \n    3\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one valid set exists where all topics and difficulties are different: (1,2,3).\n\n    Input: \n    4\n    1 1\n    1 2\n    2 1\n    2 2\n    Output: \n    0\n    Explanation: No valid set exists as all combinations violate both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The combinatorial logic inherently considers all possible combinations and filters out invalid ones based on the conditions provided.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the selection criteria are met without exceeding time limits.\nrequirement pool:\n- Efficiently handle large datasets up to 200,000 problems.\n- Ensure the selection criteria of different topics or difficulties are met.\n- Optimize for quick computation and output.\n- Provide clear and accurate output for each test case.\n- Maintain code readability and simplicity.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count combinations of problems that satisfy the conditions using hash maps to track occurrences of topics and difficulties. This approach leverages Python's collections library for efficient counting and ensures scalability for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial counting'\n    Explanation: This refers to using mathematical techniques to count combinations of items that meet certain criteria, which is essential for efficiently determining the number of valid problem sets.\n\n    'hash maps'\n    Explanation: Hash maps are data structures that store key-value pairs, allowing for efficient data retrieval and counting, which is useful for tracking occurrences of topics and difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': This means we need to select precisely three problems from the list.\n    Implementation: Use combinations from itertools to generate all possible sets of three problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the list of problems for each test case.\n    2. For each test case, initialize hash maps to count occurrences of each topic and difficulty.\n    3. Iterate through the list of problems, updating the hash maps with the count of each topic and difficulty.\n    4. Use combinatorial counting to determine the number of valid sets of three problems that meet either condition.\n    5. Output the result for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one set (1, 2, 3) satisfies both conditions as all topics and difficulties are different.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No set of three problems can be formed where all topics or all difficulties are different.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations of three problems satisfy both conditions as all topics and difficulties are different.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and hash maps will naturally account for these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a given set such that either their topics or difficulties are all different. The solution must efficiently handle multiple test cases and large datasets, ensuring accurate and clear output.\nrequirement pool:\n- Implement efficient problem selection algorithm\n- Ensure output clarity and correctness\n- Optimize for large datasets\n- Handle multiple test cases seamlessly\n- Provide detailed explanation of selection criteria\nWe will use combinatorial mathematics to efficiently calculate the number of valid selections. The key is to count combinations where either topics or difficulties are all different. We will utilize collections.Counter from the Python standard library to count occurrences of topics and difficulties, which will help in determining valid combinations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial mathematics'\n    Explanation: This refers to using mathematical techniques to count combinations or arrangements of items. In this context, it is used to calculate the number of ways to select problems based on their topics and difficulties.\n\n    'collections.Counter'\n    Explanation: A Python class from the collections module that helps count hashable objects. It will be used to count occurrences of topics and difficulties efficiently.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means we need to select precisely three problems for the problemset.\n    'different': means that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the number of problems and their respective topics and difficulties.\n    2. Use collections.Counter to count occurrences of each topic and difficulty.\n    3. Calculate the total number of ways to select 3 problems using combinatorial mathematics (n choose 3).\n    4. Subtract invalid combinations where neither topics nor difficulties are different.\n    5. Return the number of valid combinations for each test case.\n\n# [edge case]\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems where both topics and difficulties are different.\n\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No valid selection as neither topics nor difficulties can be all different.\n\n    Input: 5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations are valid as both topics and difficulties are different.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        from collections import Counter\n        from math import comb\n\n        def count_valid_combinations(n, problems):\n            topic_counter = Counter()\n            difficulty_counter = Counter()\n            for a, b in problems:\n                topic_counter[a] += 1\n                difficulty_counter[b] += 1\n            \n            total_combinations = comb(n, 3)\n            invalid_combinations = sum(comb(topic_counter[t], 3) for t in topic_counter if topic_counter[t] >= 3) + \\\n                                   sum(comb(difficulty_counter[d], 3) for d in difficulty_counter if difficulty_counter[d] >= 3)\n            \n            return total_combinations - invalid_combinations\n\n        # Read input and process each test case\n        t = int(input().strip())\n        for _ in range(t):\n            n = int(input().strip())\n            problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n            print(count_valid_combinations(n, problems))\n"], "scores": [], "pass_results": [false, false, false, true, false, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 467, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "condense_two2one", "parent_index": 214}
