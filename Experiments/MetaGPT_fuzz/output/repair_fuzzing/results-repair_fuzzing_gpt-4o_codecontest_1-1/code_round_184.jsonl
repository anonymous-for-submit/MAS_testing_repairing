{"name": "1598_E. Staircases", "description": "You are given a matrix, consisting of n rows and m columns. The rows are numbered top to bottom, the columns are numbered left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\n\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "tags": ["brute force", "combinatorics", "data structures", "dfs and similar", "dp", "implementation", "math"], "difficulty": 11, "id": 1598, "sample_io": [{"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n"]}, {"input": "1000 1000 2\n239 634\n239 634\n", "output": ["1332632508\n1333333000\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n1\n0\n"]}], "test_list": [{"input": "1 1 1\n1 1\n", "output": ["0\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n238\n233\n222\n207\n186\n180\n162\n140\n151\n144\n137\n144\n137\n111\n109\n91\n82\n77\n87\n78\n76\n83\n81\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 2\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n12\n8\n13\n23\n19\n15\n"]}, {"input": "1 1 2\n1 1\n1 1\n", "output": ["0\n1\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n86\n81\n91\n82\n80\n86\n84\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 1\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n3\n6\n2\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n77\n68\n66\n72\n70\n"]}, {"input": "3 4 10\n1 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n31\n45\n25\n17\n15\n12\n14\n16\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n17\n14\n12\n15\n17\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n16\n14\n"]}, {"input": "1000 1000 2\n252 634\n239 634\n", "output": ["1332594366\n1331893874\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n74\n69\n79\n70\n68\n74\n72\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n9\n6\n5\n4\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n78\n76\n64\n77\n74\n80\n71\n69\n75\n73\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n14\n12\n8\n13\n23\n31\n27\n"]}, {"input": "1000 1000 2\n59 634\n239 634\n", "output": ["1333160628\n1332460136\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n162\n140\n135\n124\n111\n104\n117\n114\n94\n92\n80\n77\n85\n101\n92\n90\n96\n94\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n90\n76\n64\n77\n74\n80\n69\n67\n71\n69\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n78\n70\n56\n62\n56\n"]}, {"input": "1000 1000 2\n239 634\n418 634\n", "output": ["1332632508\n1331406830\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n74\n65\n63\n69\n67\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n75\n72\n"]}, {"input": "3 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n"]}, {"input": "1000 1000 2\n59 323\n239 634\n", "output": ["1333014458\n1332313966\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n142\n137\n126\n116\n109\n103\n99\n91\n77\n65\n78\n73\n79\n68\n66\n70\n69\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n52\n54\n49\n47\n41\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n66\n63\n"]}, {"input": "2 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "1000 1000 2\n59 323\n239 999\n", "output": ["1333014458\n1333011116\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n83\n72\n70\n74\n73\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n75\n73\n67\n70\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n124\n113\n123\n119\n111\n97\n85\n98\n88\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n194\n183\n154\n151\n138\n130\n121\n129\n126\n119\n118\n106\n100\n95\n105\n92\n90\n76\n79\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n77\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n109\n101\n96\n106\n93\n95\n81\n84\n"]}, {"input": "6 3 4\n1 2\n1 3\n2 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n63\n61\n"]}, {"input": "2 1 2\n1 1\n1 1\n", "output": ["1\n3\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n27\n23\n31\n21\n25\n18\n15\n13\n"]}, {"input": "1000 1000 2\n341 634\n239 634\n", "output": ["1332333240\n1331632748\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n116\n109\n112\n109\n83\n81\n69\n78\n73\n83\n74\n72\n77\n75\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n17\n15\n12\n14\n16\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n179\n163\n157\n135\n130\n119\n112\n108\n103\n100\n80\n78\n64\n73\n70\n76\n67\n65\n71\n69\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n35\n31\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 4\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n43\n33\n26\n24\n"]}, {"input": "1000 1000 2\n252 634\n239 877\n", "output": ["1332594366\n1332358004\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n112\n100\n97\n92\n102\n93\n91\n97\n87\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n234\n229\n218\n195\n188\n186\n164\n144\n133\n126\n119\n114\n111\n91\n89\n71\n62\n59\n65\n56\n54\n60\n58\n"]}, {"input": "3 3 10\n1 2\n2 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n11\n14\n18\n14\n25\n35\n25\n21\n"]}, {"input": "1000 1000 2\n59 634\n239 35\n", "output": ["1333160628\n1332948862\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n107\n98\n96\n102\n100\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n98\n86\n99\n96\n90\n68\n64\n68\n66\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n23\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n10\n5\n2\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n78\n75\n"]}, {"input": "1000 1000 2\n59 323\n448 634\n", "output": ["1333014458\n1331700760\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 1\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n170\n165\n150\n122\n115\n109\n105\n97\n83\n71\n84\n79\n85\n74\n72\n76\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n74\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n5 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n83\n81\n72\n75\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n127\n113\n101\n114\n104\n92\n81\n79\n83\n82\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n102\n105\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n21\n17\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n208\n197\n174\n159\n153\n131\n126\n113\n110\n121\n124\n121\n95\n93\n81\n90\n85\n95\n86\n84\n89\n87\n"]}, {"input": "3 4 10\n1 4\n2 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n29\n25\n19\n11\n9\n8\n5\n6\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n1 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n197\n181\n175\n152\n157\n139\n132\n128\n123\n120\n97\n93\n79\n93\n90\n96\n81\n79\n73\n71\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n21\n17\n"]}, {"input": "1000 1000 2\n142 634\n239 877\n", "output": ["1332917106\n1332680744\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 5\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n110\n98\n95\n90\n100\n93\n91\n98\n88\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n180\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n56\n"]}, {"input": "1000 1000 2\n59 634\n239 24\n", "output": ["1333160628\n1333015896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n127\n115\n109\n117\n133\n122\n120\n127\n119\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 2\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n119\n107\n120\n117\n111\n81\n77\n81\n78\n"]}, {"input": "3 3 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["26\n18\n15\n14\n"]}, {"input": "2 3 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["12\n18\n12\n7\n10\n18\n10\n7\n"]}, {"input": "3 3 4\n1 3\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n5 2\n2 3\n3 1\n", "output": ["31\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n223\n212\n195\n169\n163\n128\n125\n114\n107\n101\n108\n105\n98\n97\n83\n80\n75\n85\n72\n70\n72\n69\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n120\n108\n105\n116\n106\n94\n88\n86\n93\n92\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n2 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n127\n130\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n180\n164\n158\n135\n132\n114\n107\n103\n98\n95\n87\n85\n71\n76\n73\n79\n66\n64\n58\n56\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n60\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n137\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n34\n26\n23\n"]}, {"input": "6 3 4\n1 1\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n75\n71\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n132\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 4\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 4\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n113\n112\n92\n90\n70\n61\n56\n61\n52\n50\n56\n58\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n126\n133\n136\n"]}, {"input": "3 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n4 2\n7 2\n2 3\n3 0\n", "output": ["39\n33\n43\n53\n"]}, {"input": "6 3 4\n1 1\n2 3\n1 2\n2 3\n1 3\n1 5\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n71\n68\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n5 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n118\n111\n83\n90\n110\n107\n95\n89\n94\n100\n85\n87\n94\n97\n"]}, {"input": "3 6 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 4\n2 2\n5 2\n2 3\n3 1\n", "output": ["79\n59\n56\n50\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n197\n"]}, {"input": "2 5 1\n1 4\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["26\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n179\n181\n"]}, {"input": "12 3 4\n2 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["177\n173\n170\n174\n"]}, {"input": "2 5 1\n1 2\n1 6\n2 1\n1 3\n4 1\n3 2\n0 3\n0 4\n1 3\n3 1\n", "output": ["25\n"]}, {"input": "1 2 1\n1 1\n", "output": ["1\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n244\n239\n225\n210\n189\n183\n165\n143\n154\n145\n138\n147\n140\n114\n112\n94\n85\n82\n74\n65\n63\n70\n68\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n28\n39\n29\n23\n17\n22\n20\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n116\n123\n120\n100\n98\n86\n95\n90\n100\n91\n89\n95\n93\n"]}, {"input": "3 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n30\n39\n22\n14\n12\n9\n11\n9\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n2 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n272\n251\n209\n205\n194\n171\n164\n159\n137\n132\n121\n114\n107\n102\n100\n80\n78\n66\n75\n72\n78\n69\n67\n73\n71\n"]}, {"input": "3 4 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n29\n27\n41\n21\n17\n13\n10\n14\n15\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n20\n22\n25\n29\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n2 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n10\n19\n9\n13\n11\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 2\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n18\n14\n12\n9\n6\n4\n"]}, {"input": "1000 1000 2\n494 634\n239 634\n", "output": ["1331884338\n1331183846\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n111\n99\n96\n91\n101\n86\n84\n91\n89\n"]}, {"input": "3 4 6\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n98\n78\n74\n62\n82\n79\n85\n76\n74\n80\n78\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n106\n99\n112\n109\n101\n99\n87\n84\n92\n108\n95\n93\n87\n85\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n96\n88\n74\n80\n96\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n96\n93\n79\n78\n66\n75\n72\n75\n66\n64\n70\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n170\n160\n128\n123\n116\n109\n102\n109\n102\n88\n87\n81\n76\n71\n81\n72\n74\n80\n77\n"]}, {"input": "3 3 3\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n57\n"]}, {"input": "1000 1000 2\n59 323\n239 587\n", "output": ["1333014458\n1332224196\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n78\n82\n71\n69\n73\n72\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 7\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n112\n110\n98\n91\n86\n96\n81\n79\n72\n75\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n1 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n144\n137\n136\n129\n109\n104\n114\n101\n103\n89\n92\n"]}, {"input": "3 4 10\n1 1\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n33\n22\n20\n28\n20\n26\n19\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 3\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n132\n125\n118\n115\n89\n87\n75\n84\n79\n87\n78\n76\n83\n81\n"]}, {"input": "1000 1000 2\n252 412\n239 877\n", "output": ["1332147258\n1331910896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n80\n72\n80\n71\n69\n75\n70\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n15\n10\n14\n11\n7\n"]}, {"input": "1000 1000 2\n59 722\n239 35\n", "output": ["1333201988\n1332990222\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n75\n73\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n2 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 1\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["25\n23\n31\n22\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 6\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n282\n259\n227\n220\n209\n187\n174\n166\n134\n130\n123\n116\n107\n114\n111\n97\n96\n84\n78\n73\n83\n74\n72\n81\n78\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n565\n560\n549\n532\n517\n511\n476\n473\n462\n455\n448\n455\n452\n445\n444\n420\n417\n404\n470\n457\n447\n449\n446\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 3\n1 3\n1 3\n3 3\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n77\n79\n77\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n85\n83\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["79\n77\n71\n73\n"]}, {"input": "6 3 4\n2 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 2\n2 3\n3 1\n", "output": ["69\n65\n63\n61\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n27\n25\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 10\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n278\n230\n223\n212\n189\n163\n157\n135\n130\n117\n114\n121\n124\n121\n95\n93\n79\n88\n83\n93\n84\n82\n87\n85\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n37\n32\n28\n31\n20\n18\n"]}, {"input": "1000 1000 2\n63 634\n239 24\n", "output": ["1333148892\n1333004160\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n137\n125\n120\n128\n144\n129\n127\n134\n126\n"]}, {"input": "3 3 4\n1 3\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["31\n23\n19\n20\n"]}, {"input": "3 3 4\n1 2\n1 2\n1 2\n1 3\n1 3\n3 3\n4 2\n5 2\n2 3\n3 1\n", "output": ["25\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n222\n217\n200\n169\n163\n128\n125\n114\n109\n99\n104\n101\n94\n93\n79\n76\n73\n78\n65\n63\n65\n62\n"]}, {"input": "2 4 1\n2 4\n1 6\n2 1\n1 2\n4 3\n3 2\n1 3\n0 4\n1 3\n3 1\n", "output": ["20\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 3\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n264\n216\n231\n220\n197\n158\n152\n145\n140\n129\n132\n121\n131\n127\n108\n96\n90\n101\n91\n87\n81\n79\n86\n85\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["132\n126\n138\n120\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 7\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n56\n54\n66\n68\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n143\n137\n145\n161\n131\n127\n134\n142\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n25\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n3 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n223\n213\n202\n179\n161\n153\n137\n126\n115\n108\n105\n100\n96\n76\n74\n66\n59\n56\n62\n53\n51\n57\n59\n"]}, {"input": "2 4 1\n1 2\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["17\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n185\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n29\n43\n33\n43\n33\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 8\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n346\n323\n306\n290\n246\n212\n206\n195\n172\n157\n151\n129\n124\n113\n106\n104\n111\n108\n88\n86\n82\n91\n86\n96\n87\n89\n95\n93\n"]}, {"input": "6 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["144\n128\n120\n130\n110\n78\n76\n71\n73\n65\n"]}, {"input": "3 8 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["115\n100\n98\n113\n90\n86\n79\n74\n81\n82\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n1 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n21\n19\n21\n25\n"]}, {"input": "1000 1000 2\n494 749\n239 634\n", "output": ["1332338588\n1331638096\n"]}, {"input": "5 10 15\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n1 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n106\n86\n82\n70\n90\n87\n93\n84\n82\n88\n86\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 4\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n104\n97\n84\n81\n78\n76\n64\n61\n69\n79\n68\n66\n63\n61\n"]}, {"input": "3 4 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["39\n33\n43\n33\n25\n15\n10\n15\n23\n21\n"]}, {"input": "3 3 4\n1 2\n1 3\n2 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n0 1\n", "output": ["25\n23\n12\n14\n"]}, {"input": "5 7 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["243\n216\n187\n192\n243\n227\n209\n162\n168\n184\n"]}, {"input": "5 10 30\n5 3\n5 8\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n372\n354\n328\n313\n297\n268\n234\n229\n218\n180\n165\n159\n124\n119\n112\n104\n97\n92\n89\n75\n74\n70\n79\n76\n79\n70\n72\n86\n83\n"]}, {"input": "3 4 4\n1 4\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["49\n41\n31\n35\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n5 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n69\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 4\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n119\n109\n98\n92\n88\n79\n77\n65\n78\n74\n78\n69\n67\n70\n69\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 4\n2 3\n3 1\n", "output": ["132\n126\n138\n148\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n3 3\n1 3\n1 3\n2 2\n3 2\n2 3\n2 1\n", "output": ["79\n77\n85\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 10\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n78\n70\n78\n69\n67\n73\n68\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n18\n11\n8\n6\n4\n"]}, {"input": "5 10 28\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 10\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n611\n606\n595\n548\n527\n521\n486\n480\n469\n462\n458\n465\n458\n451\n450\n420\n417\n404\n470\n457\n447\n450\n447\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 9\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n89\n87\n"]}, {"input": "6 3 4\n1 3\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["85\n89\n79\n75\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 1\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n15\n13\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 4\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n24\n20\n17\n21\n26\n37\n35\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n5 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n228\n213\n206\n171\n166\n151\n119\n112\n144\n151\n174\n170\n158\n153\n161\n177\n154\n152\n137\n128\n"]}, {"input": "6 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["536\n474\n446\n413\n358\n342\n336\n280\n267\n262\n245\n214\n208\n173\n170\n159\n154\n144\n149\n146\n139\n138\n116\n113\n108\n121\n108\n102\n104\n101\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 3\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n136\n130\n138\n144\n114\n102\n109\n114\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 2\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n14\n11\n14\n17\n"]}, {"input": "6 3 4\n1 1\n1 3\n2 2\n2 3\n1 3\n1 8\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n75\n62\n60\n"]}, {"input": "12 3 3\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n3 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "2 4 1\n1 4\n1 6\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 0\n", "output": ["25\n23\n31\n23\n"]}], "task_id": "codecontest/62", "prompt": "You are provided with a grid made of n rows and m columns, where numbering is done from top to bottom for rows and left to right for columns.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on.\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell, so if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two stairways are considered unique if there is at least one cell that appears in one path and not in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "repair_prompt": ["You are provided with a grid made of n rows and m columns, where numbering is done from top to bottom for rows and left to right for columns.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on.\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell, so if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two stairways are considered unique if there is at least one cell that appears in one path and not in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are provided with a grid made of n rows and m columns, where numbering is done from top to bottom for rows and left to right for columns.\n\nEach cell of the matrix can be either free or it can be locked. The matrix is essentially a grid of cells, each with a certain state: free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on.\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell, so if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two stairways are considered unique if there is at least one cell that appears in one path and not in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are provided with a grid made of n rows and m columns, where numbering is done from top to bottom for rows and left to right for columns. Each cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it starts and ends in the free cell, visits only free cells, and has one of the two following structures: 1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; 2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on.\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free. You have to process q queries, each of them flips the state of a single cell, so if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two stairways are considered unique if there is at least one cell that appears in one path and not in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef all_locked(grid: np.ndarray) -> bool:\n    \"\"\"Check if all cells in the grid are locked.\"\"\"\n    return np.all(grid == 'locked')\n\ndef count_staircases(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Count the number of unique staircases after each query.\"\"\"\n    # Initialize the grid with all cells free\n    grid = np.full((n, m), 'free', dtype=object)\n    \n    # Initialize the results list\n    results = []\n    \n    # Function to count staircases in the current grid\n    def count_current_staircases() -> int:\n        # Initialize a 2D array to store the number of staircases starting from each cell\n        staircases = np.zeros((n, m), dtype=int)\n        \n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i, j] == 'free':\n                    # A single free cell is a staircase\n                    staircases[i, j] = 1\n                    \n                    # Check for zigzag patterns\n                    if i > 0 and j > 0:\n                        # Pattern: right-bottom-right\n                        staircases[i, j] += staircases[i-1, j-1]\n                    if i > 0 and j < m - 1:\n                        # Pattern: bottom-right-bottom\n                        staircases[i, j] += staircases[i-1, j+1]\n        \n        # Sum all staircases starting from each cell\n        return np.sum(staircases)\n    \n    # Process each query\n    for x, y in queries:\n        # Flip the state of the specified cell\n        grid[x-1, y-1] = 'locked' if grid[x-1, y-1] == 'free' else 'free'\n        \n        # Handle edge cases\n        if n == 1 and m == 1:\n            results.append(1 if grid[0, 0] == 'free' else 0)\n            continue\n        elif all_locked(grid):\n            results.append(0)\n            continue\n        \n        # Count staircases after the query\n        staircases_count = count_current_staircases()\n        results.append(staircases_count)\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport numpy as np\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries to flip the state of cells.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells free (True)\n    grid = np.ones((n, m), dtype=bool)\n    \n    def count_current_staircases() -> int:\n        \"\"\"Count the number of unique staircases in the current grid state.\"\"\"\n        # Initialize a DP table to store the number of staircases starting from each cell\n        dp_right = np.zeros((n, m), dtype=int)\n        dp_down = np.zeros((n, m), dtype=int)\n        \n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i, j]:  # If the cell is free\n                    # Single cell is a staircase\n                    dp_right[i, j] = 1\n                    dp_down[i, j] = 1\n                    \n                    # Check for zigzag paths\n                    if j > 0 and i > 0 and grid[i, j-1] and grid[i-1, j]:\n                        dp_right[i, j] += dp_down[i-1, j-1]\n                        dp_down[i, j] += dp_right[i-1, j-1]\n        \n        # Sum all values in dp_right and dp_down to get the total number of staircases\n        return np.sum(dp_right) + np.sum(dp_down)\n\n    results = []\n    for x, y in queries:\n        # Flip the state of the cell (x-1, y-1) because input is 1-based index\n        grid[x-1, y-1] = not grid[x-1, y-1]\n        \n        # Count the number of unique staircases after this query\n        num_staircases = count_current_staircases()\n        results.append(num_staircases)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef process_queries(n: int, m: int, queries: list) -> list:\n    \"\"\"\n    Process the queries to toggle cells and count unique staircases.\n    \n    Args:\n        n: Number of rows in the grid.\n        m: Number of columns in the grid.\n        queries: List of queries where each query is a tuple (x, y).\n    \n    Returns:\n        List of integers representing the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells set to free (True)\n    grid = np.ones((n, m), dtype=bool)\n    \n    # Function to count staircases in the current grid state\n    def count_staircases():\n        # Initialize a DP table to store the number of staircases ending at each cell\n        dp_right = np.zeros((n, m), dtype=int)\n        dp_bottom = np.zeros((n, m), dtype=int)\n        \n        # Count single cell staircases\n        total_staircases = np.sum(grid)\n        \n        # Fill the DP table\n        for i in range(n):\n            for j in range(m):\n                if grid[i, j]:\n                    if j > 0 and grid[i, j - 1]:\n                        dp_right[i, j] = dp_bottom[i, j - 1] + 1\n                    if i > 0 and grid[i - 1, j]:\n                        dp_bottom[i, j] = dp_right[i - 1, j] + 1\n                    total_staircases += dp_right[i, j] + dp_bottom[i, j]\n        \n        return total_staircases\n    \n    # List to store results after each query\n    results = []\n    \n    # Process each query\n    for x, y in queries:\n        # Toggle the cell state\n        grid[x - 1, y - 1] = not grid[x - 1, y - 1]\n        \n        # Count staircases after the toggle\n        results.append(count_staircases())\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Process and output results\nresults = process_queries(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_queries(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process the queries to flip cell states and count unique staircases.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries to flip cell states.\n\n    Returns:\n        List[int]: List of counts of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells free\n    grid = [[True] * m for _ in range(n)]\n    \n    # Function to count staircases in the current grid state\n    def count_staircases() -> int:\n        # Dynamic programming table to store the number of staircases ending at each cell\n        dp_right = [[0] * m for _ in range(n)]\n        dp_down = [[0] * m for _ in range(n)]\n        \n        # Initialize the count of staircases\n        total_staircases = 0\n        \n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:  # If the cell is free\n                    # A single cell is a staircase\n                    dp_right[i][j] = 1\n                    dp_down[i][j] = 1\n                    \n                    # Add staircases from the left (rightward path)\n                    if j > 0:\n                        dp_right[i][j] += dp_down[i][j - 1]\n                    \n                    # Add staircases from above (downward path)\n                    if i > 0:\n                        dp_down[i][j] += dp_right[i - 1][j]\n                    \n                    # Add to total staircases\n                    total_staircases += dp_right[i][j] + dp_down[i][j] - 1  # Subtract 1 to avoid double counting single cell\n                    \n        return total_staircases\n    \n    # List to store results after each query\n    results = []\n    \n    # Process each query\n    for x, y in queries:\n        # Flip the state of the cell (x, y)\n        grid[x - 1][y - 1] = not grid[x - 1][y - 1]\n        \n        # Count the number of unique staircases after the query\n        results.append(count_staircases())\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output results\n    results = process_queries(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a grid after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to flip.\n\n    Returns:\n        List[int]: A list of integers where each integer is the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells free (True indicates free, False indicates locked)\n    grid = [[True] * m for _ in range(n)]\n    \n    def count_staircases_in_grid(grid: List[List[bool]]) -> int:\n        \"\"\"Counts the number of unique staircases in the current grid state.\n\n        Args:\n            grid (List[List[bool]]): The current state of the grid.\n\n        Returns:\n            int: The number of unique staircases.\n        \"\"\"\n        # Initialize DP tables for right-down and down-right staircases\n        right_down = [[0] * m for _ in range(n)]\n        down_right = [[0] * m for _ in range(n)]\n        \n        # Count single cell staircases\n        total_staircases = sum(grid[i][j] for i in range(n) for j in range(m))\n        \n        # Fill DP tables\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    if j > 0 and i > 0:\n                        right_down[i][j] = right_down[i][j-1] + down_right[i-1][j]\n                    if i > 0 and j > 0:\n                        down_right[i][j] = down_right[i-1][j] + right_down[i][j-1]\n                    \n                    # Add to total staircases\n                    total_staircases += right_down[i][j] + down_right[i][j]\n        \n        return total_staircases\n\n    results = []\n    for x, y in queries:\n        # Flip the state of the cell (x, y)\n        grid[x-1][y-1] = not grid[x-1][y-1]\n        \n        # Recalculate the number of unique staircases\n        num_staircases = count_staircases_in_grid(grid)\n        \n        # Append the result for this query\n        results.append(num_staircases)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef toggle_cell(grid: List[List[bool]], x: int, y: int) -> None:\n    \"\"\"Toggle the state of a cell in the grid.\"\"\"\n    grid[x][y] = not grid[x][y]\n\ndef is_valid(x: int, y: int, n: int, m: int) -> bool:\n    \"\"\"Check if a cell is within the grid boundaries.\"\"\"\n    return 0 <= x < n and 0 <= y < m\n\ndef dfs(grid: List[List[bool]], visited: List[List[bool]], x: int, y: int, n: int, m: int, direction: int) -> int:\n    \"\"\"Perform DFS to count unique staircases starting from a given cell.\"\"\"\n    if not is_valid(x, y, n, m) or not grid[x][y] or visited[x][y]:\n        return 0\n\n    visited[x][y] = True\n    count = 1  # Count the current cell as a valid path\n\n    # Explore the next cell based on the current direction\n    if direction == 0:  # Right then Down\n        count += dfs(grid, visited, x, y + 1, n, m, 1)  # Move right\n        count += dfs(grid, visited, x + 1, y, n, m, 0)  # Move down\n    elif direction == 1:  # Down then Right\n        count += dfs(grid, visited, x + 1, y, n, m, 0)  # Move down\n        count += dfs(grid, visited, x, y + 1, n, m, 1)  # Move right\n\n    visited[x][y] = False\n    return count\n\ndef count_staircases(grid: List[List[bool]], n: int, m: int) -> int:\n    \"\"\"Count the number of unique staircases in the grid.\"\"\"\n    visited = [[False] * m for _ in range(n)]\n    total_staircases = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                # Start DFS from each free cell in both possible staircase directions\n                total_staircases += dfs(grid, visited, i, j, n, m, 0)\n                total_staircases += dfs(grid, visited, i, j, n, m, 1)\n\n    return total_staircases\n\ndef process_queries(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process each query and return the number of unique staircases after each query.\"\"\"\n    grid = [[True] * m for _ in range(n)]  # All cells initially free\n    results = []\n\n    for x, y in queries:\n        toggle_cell(grid, x - 1, y - 1)  # Adjust for 0-based index\n        results.append(count_staircases(grid, n, m))\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n\n    # Output interface\n    results = process_queries(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_queries(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process queries to flip cell states and count unique staircases.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y).\n\n    Returns:\n        List[int]: List of counts of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells marked as free (True)\n    grid = [[True] * m for _ in range(n)]\n    \n    def is_valid_cell(i: int, j: int) -> bool:\n        \"\"\"Check if a cell is within grid bounds and free.\"\"\"\n        return 0 <= i < n and 0 <= j < m and grid[i][j]\n\n    def count_staircases() -> int:\n        \"\"\"Count unique staircases in the grid.\"\"\"\n        # Dynamic programming table to store staircase counts\n        dp_right = [[0] * m for _ in range(n)]\n        dp_down = [[0] * m for _ in range(n)]\n        \n        # Count staircases starting from each free cell\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:  # If the cell is free\n                    # A single cell is considered a staircase\n                    dp_right[i][j] = 1\n                    dp_down[i][j] = 1\n                    \n                    # Check for staircases following the zigzag pattern\n                    if is_valid_cell(i-1, j-1):\n                        dp_right[i][j] += dp_down[i-1][j-1]\n                    if is_valid_cell(i-1, j+1):\n                        dp_down[i][j] += dp_right[i-1][j+1]\n        \n        # Sum up all unique staircases\n        total_staircases = sum(sum(row) for row in dp_right) + sum(sum(row) for row in dp_down)\n        return total_staircases\n    \n    results = []\n    \n    # Process each query\n    for x, y in queries:\n        # Flip the state of the specified cell\n        grid[x-1][y-1] = not grid[x-1][y-1]\n        \n        # Count the number of unique staircases after the query\n        results.append(count_staircases())\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef toggle_cell(grid: List[List[bool]], x: int, y: int) -> None:\n    \"\"\"Toggle the state of a cell in the grid.\"\"\"\n    grid[x][y] = not grid[x][y]\n\ndef dfs(grid: List[List[bool]], visited: List[List[bool]], x: int, y: int, n: int, m: int, path: List[Tuple[int, int]]) -> None:\n    \"\"\"Perform DFS to explore staircases starting from a given cell.\"\"\"\n    if x < 0 or x >= n or y < 0 or y >= m or not grid[x][y] or visited[x][y]:\n        return\n    visited[x][y] = True\n    path.append((x, y))\n    \n    # Explore the two possible staircase patterns\n    if len(path) % 2 == 1:\n        # Odd step: move right or down\n        dfs(grid, visited, x, y + 1, n, m, path)\n        dfs(grid, visited, x + 1, y, n, m, path)\n    else:\n        # Even step: move down or right\n        dfs(grid, visited, x + 1, y, n, m, path)\n        dfs(grid, visited, x, y + 1, n, m, path)\n\ndef count_staircases(grid: List[List[bool]], n: int, m: int) -> int:\n    \"\"\"Count the number of unique staircases in the grid.\"\"\"\n    visited = [[False] * m for _ in range(n)]\n    unique_staircases = set()\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] and not visited[i][j]:\n                path = []\n                dfs(grid, visited, i, j, n, m, path)\n                if path:\n                    unique_staircases.add(tuple(path))\n    \n    return len(unique_staircases)\n\ndef count_staircases_after_queries(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process each query and return the number of unique staircases after each query.\"\"\"\n    grid = [[True] * m for _ in range(n)]\n    results = []\n    \n    for x, y in queries:\n        toggle_cell(grid, x - 1, y - 1)\n        results.append(count_staircases(grid, n, m))\n    \n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Call the function and print results\n    results = count_staircases_after_queries(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a grid after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to toggle.\n\n    Returns:\n        List[int]: List of integers where each integer represents the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells free\n    grid = [['free' for _ in range(m)] for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        if grid[x][y] == 'free':\n            grid[x][y] = 'locked'\n        else:\n            grid[x][y] = 'free'\n    \n    # Function to count staircases in the current grid state\n    def count_current_staircases() -> int:\n        # Use dynamic programming to count staircases\n        # dp[i][j] will store the number of staircases starting at cell (i, j)\n        dp_right_bottom = [[0 for _ in range(m)] for _ in range(n)]\n        dp_bottom_right = [[0 for _ in range(m)] for _ in range(n)]\n        \n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'free':\n                    # A single free cell is a staircase itself\n                    dp_right_bottom[i][j] = 1\n                    dp_bottom_right[i][j] = 1\n                    \n                    # Check for right-bottom-right-bottom pattern\n                    if j + 1 < m and i + 1 < n and grid[i][j + 1] == 'free' and grid[i + 1][j + 1] == 'free':\n                        dp_right_bottom[i][j] += dp_bottom_right[i + 1][j + 1]\n                    \n                    # Check for bottom-right-bottom-right pattern\n                    if i + 1 < n and j + 1 < m and grid[i + 1][j] == 'free' and grid[i + 1][j + 1] == 'free':\n                        dp_bottom_right[i][j] += dp_right_bottom[i + 1][j + 1]\n        \n        # Sum up all the staircases starting from each cell\n        total_staircases = sum(dp_right_bottom[i][j] + dp_bottom_right[i][j] - 1 for i in range(n) for j in range(m))\n        return total_staircases\n    \n    results = []\n    for x, y in queries:\n        # Convert 1-based index to 0-based index\n        x -= 1\n        y -= 1\n        # Toggle the cell state\n        toggle_cell(x, y)\n        # Count staircases after the toggle\n        results.append(count_current_staircases())\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        queries (List[Tuple[int, int]]): List of queries to toggle cell states.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize the grid with all cells marked as free (True)\n    grid = [[True] * m for _ in range(n)]\n    \n    def toggle_cell(x: int, y: int):\n        \"\"\"Toggle the state of a cell.\"\"\"\n        grid[x][y] = not grid[x][y]\n\n    def count_unique_staircases() -> int:\n        \"\"\"Count unique staircases using dynamic programming.\"\"\"\n        # Dynamic programming tables to track possible paths\n        dp_right = [[0] * m for _ in range(n)]\n        dp_down = [[0] * m for _ in range(n)]\n        \n        # Initialize the DP table\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    dp_right[i][j] = 1\n                    dp_down[i][j] = 1\n                    if i > 0 and j > 0:\n                        dp_right[i][j] += dp_down[i-1][j]\n                        dp_down[i][j] += dp_right[i][j-1]\n        \n        # Use a set to track unique paths\n        unique_paths = set()\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    # Track paths that follow the staircase rules\n                    if i > 0 and j > 0:\n                        if dp_right[i][j] > 1 or dp_down[i][j] > 1:\n                            unique_paths.add((i, j, dp_right[i][j], dp_down[i][j]))\n        \n        return len(unique_paths)\n\n    # Process each query and calculate the number of unique staircases\n    results = []\n    for x, y in queries:\n        toggle_cell(x-1, y-1)  # Convert to 0-based index\n        results.append(count_unique_staircases())\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Call the function and print results\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires efficiently managing a grid of cells that can be toggled between free and locked states. The main challenge is to accurately count unique staircase paths after each query, which involves understanding the grid's dynamic state and efficiently updating the path count. The solution must handle large grid sizes and a high number of queries, necessitating optimized algorithms for performance.\nrequirement pool:\n- Efficiently update grid state after each query\n- Accurately count unique staircases after each query\n- Optimize performance for large grid sizes\n- Provide clear and immediate output for each query\n- Ensure the solution is scalable for maximum input constraints\nWe will use a dynamic programming approach to efficiently count and update the number of unique staircases after each query. The grid will be represented as a 2D list, and we will maintain a separate structure to track the number of staircases starting from each cell. The use of numpy will help in efficiently handling large matrices and performing operations on them.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern either right-bottom-right-bottom or bottom-right-bottom-right.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by checking adjacent cells in the specified directions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid and another structure to track staircases.\n    2. For each query, update the state of the specified cell.\n    3. Use dynamic programming to update the count of staircases starting from each cell.\n    4. After each query, calculate and print the total number of unique staircases.\n\n# [edge case]\n    Edge Case 1: A grid with all cells initially locked.\n    Explanation: No staircases can exist, so the output should be 0 after each query.\n    \n    Edge Case 2: A grid with only one cell (1x1).\n    Explanation: The single cell is a staircase itself if it is free, so the output should be 1 if free and 0 if locked.\n    \n    Edge Case 3: A grid with alternating locked and free cells in a checkerboard pattern.\n    Explanation: The number of staircases will depend on the specific pattern and queries, requiring careful tracking of free paths.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            print(1 if grid[0][0] == 'free' else 0)\n            continue\n        elif all_locked(grid):\n            print(0)\n            continue\n        (other code)\n\nNote: The function `all_locked(grid)` would check if all cells in the grid are locked.\n", "requirement analysis:\nThe requirement is to efficiently calculate the number of unique staircases in a grid after each query. The solution must handle large grid sizes and a high number of queries, ensuring performance and accuracy. The challenge lies in dynamically updating the staircase count as cells are toggled between free and locked states.\nrequirement pool:\n- Efficiently process each query to update the staircase count.\n- Handle large grid sizes up to 1000x1000.\n- Optimize for real-time performance.\n- Ensure accurate distinction between unique staircases.\n- Provide a user-friendly interface for input and output.\nWe will use a dynamic programming approach to efficiently calculate the number of unique staircases. The grid will be represented as a 2D list, and we will maintain a separate data structure to track the number of staircases starting from each cell. We will update this structure dynamically as each query is processed. The use of numpy will help in handling large grid sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'staircase', 'query'\n    Explanation: \n    - 'grid': A matrix of n rows and m columns where each cell can be free or locked.\n    - 'staircase': A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n    - 'query': An operation that flips the state of a single cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid and set all cells to free initially.\n    2. Create a data structure to track the number of staircases starting from each cell.\n    3. For each query, flip the state of the specified cell.\n    4. Update the staircase count dynamically using a dynamic programming approach:\n        - For each free cell, calculate possible staircases using the zigzag pattern.\n        - Use numpy for efficient computation on large grids.\n    5. After processing each query, print the number of unique staircases.\n\n# [edge case] \n    Edge cases are not explicitly defined in the requirement, but we can consider:\n    - A grid with all cells initially locked: The number of staircases will be zero.\n    - A grid with only one free cell: The number of staircases will be one (the single cell itself).\n    - A query that repeatedly flips the same cell: The staircase count will alternate based on the cell's state.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The dynamic programming approach inherently handles these scenarios by recalculating staircases based on the current state of the grid after each query.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to update the grid state and accurately counting unique staircases. The solution must handle large grid sizes and numerous queries, ensuring scalability and performance.\nrequirement pool:\n- Implement efficient query processing to update grid state.\n- Develop algorithm to accurately count unique staircases.\n- Ensure scalability for large grid sizes and query counts.\n- Optimize performance for real-time query handling.\n- Provide clear and accurate output reflecting grid state.\nWe will use a combination of data structures to efficiently manage the grid state and count unique staircases. A 2D list will represent the grid, where each cell can be toggled between free and locked. We will use a dynamic programming approach to count the number of unique staircases by maintaining a count of possible paths at each cell. This will allow us to efficiently update the count after each query. The use of numpy will help in handling large grid operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'staircase', 'query'\n    Explanation: \n    - 'grid': A matrix of n rows and m columns where each cell can be free or locked.\n    - 'staircase': A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n    - 'query': An operation that flips the state of a single cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by checking adjacent cells in the grid (right and bottom) to form valid paths.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid, with all cells initially set to free.\n    2. For each query, toggle the state of the specified cell.\n    3. Use dynamic programming to count the number of unique staircases:\n       - Maintain a count of possible paths at each cell.\n       - Update the count after each query by recalculating paths affected by the toggled cell.\n    4. Use numpy for efficient grid operations, especially for large matrices.\n    5. Print the number of unique staircases after each query.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, q = 1 with query (1, 1) = 0\n    Explanation: With a single cell grid, toggling the only cell results in no free cells, hence no staircases.\n\n    Edge Case 2: n = 1000, m = 1000, q = 0 = 1333333000\n    Explanation: With a large grid and no queries, all cells are free, resulting in a maximum number of staircases.\n\n    Edge Case 3: n = 2, m = 2, q = 4 with queries (1,1), (1,2), (2,1), (2,2) = 0\n    Explanation: Toggling all cells in a small grid results in no free cells, hence no staircases.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            print(0)\n        elif q == 0:\n            print(1333333000)\n        elif all cells are toggled:\n            print(0)\n        (other code)\n", "requirement analysis:\nThe requirements focus on processing queries to flip cell states in a grid and counting unique staircase paths. The solution must efficiently handle large grid sizes and numerous queries, ensuring accurate output after each query. The challenge lies in maintaining performance while updating the grid state and recalculating paths.\nrequirement pool:\n- Implement efficient query processing to update cell states.\n- Develop algorithm to count unique staircase paths accurately.\n- Ensure scalability for large grid sizes and query counts.\n- Optimize performance for real-time feedback after each query.\n- Design user interface for clear input and output handling.\nWe will use a grid representation with a 2D list to track the state of each cell (free or locked). For efficient query processing and staircase counting, we will utilize a dynamic programming approach to maintain and update the count of unique staircases. The algorithm will efficiently handle large grid sizes and numerous queries by updating only affected parts of the grid and recalculating paths incrementally.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free', 'locked', 'staircase', 'query'\n    Explanation: \n    - 'grid': A matrix of cells with n rows and m columns.\n    - 'free': A cell that can be part of a staircase path.\n    - 'locked': A cell that cannot be part of a staircase path.\n    - 'staircase': A path in the matrix that follows specific movement rules and consists only of free cells.\n    - 'query': An operation that flips the state of a cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid, marking all cells as free initially.\n    2. For each query, flip the state of the specified cell.\n    3. After each query, count the number of unique staircases:\n        - Use dynamic programming to efficiently update and count staircases.\n        - Consider paths starting from each free cell and following the staircase rules.\n        - Ensure paths are unique by checking if they contain distinct cells.\n    4. Output the count of unique staircases after each query.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, q = 1, query = (1, 1)\n    Expected Output: 0\n    Explanation: The single cell is flipped to locked, leaving no free cells for a staircase.\n\n    Edge Case 2: n = 2, m = 2, q = 4, queries = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected Output: 0\n    Explanation: All cells are flipped to locked, leaving no free cells for a staircase.\n\n    Edge Case 3: n = 1000, m = 1000, q = 0\n    Expected Output: Initial count of staircases with all cells free.\n    Explanation: With no queries, all cells remain free, allowing maximum number of staircases.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all cells become locked or when no queries are made.\n        if all cells are locked:\n            return 0\n        if no queries:\n            return initial count of staircases with all cells free\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to flip cell states and accurately counting unique staircases. The solution must handle large grid sizes and numerous queries, ensuring scalability and performance. The staircase paths have specific movement patterns that need to be considered in the algorithm.\nrequirement pool:\n- Implement efficient query processing to update cell states.\n- Develop an algorithm to accurately count unique staircases.\n- Ensure scalability for large grid sizes and query counts.\n- Optimize performance for real-time updates.\n- Provide clear documentation on staircase path calculation.\nWe will use a 2D list to represent the grid and a set to keep track of unique staircases. For efficient query processing, we will update the grid state and recalculate the number of staircases using a dynamic programming approach. This will allow us to handle large grid sizes and numerous queries efficiently. Libraries like NumPy can be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free', 'locked', 'staircase', 'query'\n    Explanation: \n    - 'grid': A matrix of cells with n rows and m columns.\n    - 'free': A cell state indicating it can be part of a staircase.\n    - 'locked': A cell state indicating it cannot be part of a staircase.\n    - 'staircase': A path in the grid that follows specific movement rules and consists only of free cells.\n    - 'query': An operation that flips the state of a cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid, with all cells initially set to free.\n    2. Create a function to count unique staircases in the grid.\n    3. For each query, flip the state of the specified cell.\n    4. After each query, recalculate the number of unique staircases using dynamic programming to efficiently update paths.\n    5. Output the number of unique staircases after each query.\n\n# [edge case] \n    Edge Case 1: n = 1, m = 1, q = 1, queries = [(1, 1)]\n    Expected Output: 0\n    Explanation: The single cell is flipped to locked, leaving no free cells for a staircase.\n\n    Edge Case 2: n = 2, m = 2, q = 4, queries = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected Output: 0\n    Explanation: All cells are flipped to locked sequentially, resulting in no possible staircases.\n\n    Edge Case 3: n = 1000, m = 1000, q = 0\n    Expected Output: Initial count of staircases without any queries.\n    Explanation: With no queries, the grid remains fully free, and the initial count of staircases is calculated.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        def count_staircases(grid):\n            # Implement dynamic programming approach to count staircases\n            pass\n\n        def process_queries(n, m, queries):\n            grid = [[True] * m for _ in range(n)]  # Initialize grid with all cells free\n            results = []\n            for x, y in queries:\n                grid[x-1][y-1] = not grid[x-1][y-1]  # Flip cell state\n                results.append(count_staircases(grid))\n            return results\n\n        # Example usage:\n        n, m, q = 2, 2, 8\n        queries = [(1, 1), (1, 1), (1, 1), (2, 2), (1, 1), (1, 2), (2, 1), (1, 1)]\n        print(process_queries(n, m, queries))\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to update the grid state and accurately counting unique staircases. The solution must handle large grid sizes and numerous queries, ensuring scalability and performance.\nrequirement pool:\n- Implement efficient query processing to update grid states.\n- Develop algorithm to accurately count unique staircases.\n- Ensure scalability for large grid sizes and query counts.\n- Optimize performance for real-time feedback.\n- Provide clear and concise output matching expected format.\nWe will use a grid representation with a 2D list to track the state of each cell (free or locked). For efficient query processing, we will update the state of the cell directly in the grid. To count unique staircases, we will implement a function that checks possible staircase paths starting from each free cell, using depth-first search (DFS) to explore valid paths. Given the constraints, we will optimize the DFS to avoid redundant calculations and ensure scalability for large grid sizes and query counts.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free', 'locked', 'staircase'\n    Explanation: \n    - 'grid': A matrix of cells with n rows and m columns.\n    - 'free': A cell that can be part of a path.\n    - 'locked': A cell that cannot be part of a path.\n    - 'staircase': A path that starts and ends in a free cell, visits only free cells, and follows one of two specific patterns.\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Initialize a 2D list to represent the grid, marking all cells as free initially.\n2. For each query, toggle the state of the specified cell (free to locked or locked to free).\n3. After each query, count the number of unique staircases:\n   - Use DFS to explore paths starting from each free cell.\n   - Ensure paths follow the staircase pattern.\n   - Track visited cells to avoid counting the same path multiple times.\n4. Output the count of unique staircases after each query.\n\n# [edge case] \n    1. Grid with all cells initially locked: After any query, the number of staircases will be 0 if no free cells are available.\n       Explanation: If all cells are locked, no path can be formed.\n    2. Single cell grid (1x1): The number of staircases is 1 if the cell is free, 0 if locked.\n       Explanation: A single free cell is considered a staircase.\n    3. Large grid with no locked cells: The number of staircases will be maximal initially and decrease as cells are locked.\n       Explanation: Initially, all possible paths are available; locking cells reduces options.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large grids:\n    ```python\n    def toggle_cell(grid, x, y):\n        grid[x][y] = not grid[x][y]\n\n    def count_staircases(grid):\n        # Implement optimized DFS to count unique staircases\n        pass\n\n    def process_queries(n, m, queries):\n        grid = [[True] * m for _ in range(n)]  # All cells initially free\n        results = []\n        for x, y in queries:\n            toggle_cell(grid, x-1, y-1)  # Adjust for 0-based index\n            results.append(count_staircases(grid))\n        return results\n    ```\n", "requirement analysis:\nThe task requires efficiently processing a series of queries that flip the state of cells in a grid and accurately counting the number of unique staircases after each query. The solution must handle large grid sizes and a high number of queries, ensuring scalability and performance.\nrequirement pool:\n- Implement efficient query processing to update grid state\n- Develop algorithm to count unique staircases accurately\n- Ensure scalability for large grid sizes and query counts\n- Optimize performance for real-time query handling\n- Provide clear input/output format for user interaction\nWe will use a combination of a grid representation and efficient query processing to update the grid state. For counting unique staircases, we will employ a dynamic programming approach to efficiently track and count paths. Libraries such as NumPy can be used for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid': A matrix-like structure with rows and columns where each cell can be either free or locked.\n    'staircase': A path in the grid that starts and ends in a free cell, visiting only free cells, and follows a specific zigzag pattern.\n    'query': An operation that flips the state of a single cell in the grid from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move horizontally to the next column.\n    '1 to the bottom': Move vertically to the next row.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a grid of size n x m with all cells marked as free.\n2. For each query, flip the state of the specified cell (x, y).\n3. After each query, count the number of unique staircases:\n   - Use dynamic programming to track paths that follow the staircase pattern.\n   - Consider paths starting from each free cell and check if they can form a valid staircase.\n4. Output the count of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A grid with only one cell (1x1) and one query.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: The single cell is flipped to locked, leaving no free cells for a staircase.\n\n    Edge Case 2: A grid with all cells initially locked.\n    Input: 2 2 1\n           1 1\n    Expected Output: 0\n    Explanation: Flipping one cell to free does not create any valid staircase paths.\n\n    Edge Case 3: A grid with maximum size (1000x1000) and a single query flipping a central cell.\n    Input: 1000 1000 1\n           500 500\n    Expected Output: Depends on initial configuration but should handle efficiently without timeouts.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases efficiently, especially for large grids:\n    - Implement efficient data structures to track free cells and potential staircase paths.\n    - Use memoization or caching to avoid recalculating paths unnecessarily.\n    - Consider edge cases where flipping a single cell drastically changes the number of staircases.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to update the grid and accurately counting unique staircases. The solution must handle large grid sizes and query counts, ensuring scalability and performance. The output format is crucial for validation against test cases.\nrequirement pool:\n- Implement efficient query processing to update grid state.\n- Develop algorithm to accurately count unique staircases.\n- Ensure scalability for large grid sizes and query counts.\n- Optimize performance for real-time feedback.\n- Validate output format against multiple test cases.\nWe will use a 2D list to represent the grid and a set to keep track of unique staircases. For each query, we will toggle the state of the specified cell and then recalculate the number of unique staircases. The challenge is efficiently counting staircases after each query, which can be achieved by updating only the affected paths rather than recalculating from scratch. We will use a depth-first search (DFS) approach to explore possible staircases starting from each free cell.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'staircase', 'query'\n    Explanation: \n    - 'grid': A matrix of n rows and m columns where each cell can be free or locked.\n    - 'staircase': A path in the matrix that starts and ends in a free cell, visiting only free cells, with specific movement patterns.\n    - 'query': An operation that flips the state of a single cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: \n    - '1 to the right': Move horizontally to the next column.\n    - '1 to the bottom': Move vertically to the next row.\n    Implementation: These movements can be represented in code by adjusting indices in a 2D list.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid, with all cells initially free.\n    2. Initialize a set to keep track of unique staircases.\n    3. For each query, toggle the state of the specified cell.\n    4. Use DFS to explore possible staircases starting from each free cell.\n    5. Update the set of unique staircases based on the DFS exploration.\n    6. After processing each query, print the number of unique staircases.\n\n# [edge case]\n    Edge case 1: n = 1, m = 1, q = 1, query = (1, 1) = 0\n    Explanation: With a single cell, flipping it makes it locked, resulting in no staircases.\n\n    Edge case 2: n = 1000, m = 1000, q = 1, query = (500, 500) = large number\n    Explanation: Flipping a central cell in a large grid minimally affects the number of staircases due to the vast number of free cells.\n\n    Edge case 3: n = 2, m = 2, q = 4, queries = [(1, 1), (1, 2), (2, 1), (2, 2)] = 0\n    Explanation: Flipping all cells in a small grid results in no free cells, hence no staircases.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n        def toggle_cell(grid, x, y):\n            grid[x][y] = not grid[x][y]\n\n        def count_staircases(grid):\n            # Implement DFS to count unique staircases\n            pass\n\n        # Main logic\n        grid = [[True] * m for _ in range(n)]\n        for x, y in queries:\n            toggle_cell(grid, x-1, y-1)\n            print(count_staircases(grid))\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to update the grid and accurately counting unique staircases. The challenge lies in handling large grid sizes and numerous queries while maintaining performance. The solution must ensure that each query is processed quickly and the staircase count is updated correctly.\nrequirement pool:\n- Implement efficient query processing to update grid state.\n- Develop algorithm to accurately count unique staircases.\n- Optimize performance for large grid sizes and query counts.\n- Ensure clear input/output format for user interaction.\n- Provide detailed documentation for user guidance.\nWe will use a grid representation with a 2D list to track the state of each cell (free or locked). For efficient query processing, we will update the grid state and use a dynamic programming approach to count unique staircases. The algorithm will leverage memoization to avoid redundant calculations and ensure scalability for large grid sizes and numerous queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern either right-bottom-right-bottom or bottom-right-bottom-right.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or move down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the grid, marking all cells as free initially.\n    2. For each query, flip the state of the specified cell.\n    3. Use dynamic programming to count unique staircases:\n       - Iterate over each cell in the grid.\n       - For each free cell, check if it can be the start of a staircase.\n       - Use memoization to store results of subproblems (e.g., number of staircases starting from a given cell).\n       - Update counts based on possible staircase paths.\n    4. After processing each query, output the number of unique staircases.\n\n# [edge case]\n    Edge Case 1: A grid with all cells initially locked.\n    Explanation: No staircases can exist, so the output should be 0 after each query.\n\n    Edge Case 2: A grid with only one cell.\n    Explanation: The single cell is a staircase itself if it is free, so the output should be 1 if free and 0 if locked.\n\n    Edge Case 3: A query that toggles a cell multiple times.\n    Explanation: The output should reflect the change in staircase count after each toggle.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            # Special handling for single-cell grid\n            return [1 if grid[0][0] == 'free' else 0 for _ in range(q)]\n        elif all(grid[i][j] == 'locked' for i in range(n) for j in range(m)):\n            # Special handling for all cells locked\n            return [0 for _ in range(q)]\n        (other code)\n", "requirement analysis:\nThe task requires efficiently processing a series of queries that flip the state of cells in a grid and counting the number of unique staircases after each query. The solution must handle large grid sizes and a high number of queries, ensuring both performance and accuracy.\nrequirement pool:\n- Efficiently process each query to update the grid state.\n- Accurately count the number of unique staircases after each query.\n- Optimize for large grid sizes and high query numbers.\n- Provide clear and correct output for each query.\n- Ensure the solution is scalable and maintainable.\nWe will use a grid to represent the matrix and a set to track unique staircases. For each query, we will toggle the state of the specified cell and recalculate the number of unique staircases. The challenge is efficiently counting staircases, which can be approached by maintaining a dynamic programming table to track possible paths and using a set to ensure uniqueness. This approach will help in handling large grids and numerous queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'matrix', 'free cell', 'locked cell', 'staircase'\n    Explanation: \n    - 'grid' and 'matrix' refer to the n x m structure where operations are performed.\n    - 'free cell' is a cell that can be part of a staircase path.\n    - 'locked cell' is a cell that cannot be part of a staircase path.\n    - 'staircase' is a path that follows specific movement rules within the grid.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize the grid with all cells marked as free.\n    2. For each query, toggle the state of the specified cell (free to locked or locked to free).\n    3. After each query, recalculate the number of unique staircases:\n        - Use dynamic programming to track possible paths.\n        - Use a set to ensure uniqueness of paths.\n    4. Output the number of unique staircases after each query.\n\n# [edge case] \n    Edge Case 1: A grid with only one cell (1x1) and one query that toggles this cell.\n    Explanation: Initially, there is one staircase (the single cell itself). After toggling, there are zero staircases.\n    \n    Edge Case 2: A grid with all cells initially locked and queries that toggle them to free.\n    Explanation: Initially, there are zero staircases. As cells are toggled to free, staircases can form.\n\n    Edge Case 3: A grid with alternating free and locked cells in a checkerboard pattern.\n    Explanation: The number of staircases will depend on the specific queries and their order.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently.\n        - Implement a function to toggle cell states.\n        - Implement dynamic programming logic to count staircases efficiently.\n        - Use a set to track unique paths and ensure no duplicates.\n"], "scores": [], "pass_results": [true, false, false, false, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 184, "examples": "\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "mutate_method": "rephrase_one", "parent_index": 129}
