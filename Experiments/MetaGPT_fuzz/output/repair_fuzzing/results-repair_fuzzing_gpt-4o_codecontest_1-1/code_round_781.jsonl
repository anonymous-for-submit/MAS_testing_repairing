{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon by using resources sparingly to guarantee triumph.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon by using resources sparingly to guarantee triumph.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon. He aims to use resources sparingly to guarantee triumph.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon by using resources sparingly to guarantee triumph.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_impact(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to ensure the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Find the minimum value of k for each test case such that Monocarp's attacks deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if can_deal_damage(n, h, attacks, mid):\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n\n    return results\n\ndef can_deal_damage(n: int, h: int, attacks: List[int], k: int) -> bool:\n    \"\"\"Check if a given k can deal at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage.\n        attacks (List[int]): List of attack times.\n        k (int): Current value of k being tested.\n\n    Returns:\n        bool: True if the damage dealt is at least h, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = find_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Find the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        \n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        # After exiting the loop, low is the minimum k that satisfies the condition\n        results.append(low)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    results = find_minimum_k(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_k(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp will cause at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing n, h, and a list of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, a in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        \n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, a[i + 1] - a[i])\n            \n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n    \n    # Call the function and print results\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\n# Program entry point\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Finds the minimum value of k for each test case such that Monocarp will cause at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): A list of tuples, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attacks (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: A list of integers representing the minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low <= high:\n            mid = (low + high) // 2\n            if can_deal_damage(n, h, attacks, mid):\n                high = mid - 1\n            else:\n                low = mid + 1\n        results.append(low)\n\n    return results\n\ndef can_deal_damage(n: int, h: int, attacks: List[int], k: int) -> bool:\n    \"\"\"Checks if the total damage dealt with a given k is at least h.\n\n    Args:\n        n (int): Number of Monocarp's attacks.\n        h (int): Amount of damage that needs to be dealt.\n        attacks (List[int]): List of integers representing the seconds when each attack is performed.\n        k (int): The current value of k being tested.\n\n    Returns:\n        bool: True if the total damage is at least h, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = find_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_min_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Find the minimum value of k for each test case such that Monocarp deals at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate the total damage with k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, a[i + 1] - a[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    results = find_min_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_impact(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp's attacks deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            if can_deal_damage(n, h, attack_times, mid):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef can_deal_damage(n: int, h: int, attack_times: List[int], k: int) -> bool:\n    \"\"\"Check if a given k can deal at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage.\n        attack_times (List[int]): List of attack times.\n        k (int): Current candidate for minimum k.\n\n    Returns:\n        bool: True if k can deal at least h damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attack_times[i + 1] - attack_times[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Find the minimum value of k for each test case such that Monocarp's attacks deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attack_times (List[int]): List of integers representing the seconds when attacks are performed.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = find_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_impact(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison impact needed to defeat the dragon for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attacks (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: List of integers representing the minimum value of the parameter k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_impact(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp will cause at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attacks (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat the dragon efficiently. The solution must handle multiple test cases and ensure that the damage dealt meets or exceeds the required amount using the least resources.\nrequirement pool:\n- Calculate minimum poison impact for each test case.\n- Ensure attacks are timed optimally.\n- Handle large input values efficiently.\n- Provide accurate output for all test cases.\n- Optimize resource usage.\nWe will use a binary search approach to efficiently determine the minimum value of k that ensures the total damage is at least h. This approach is suitable given the constraints, as it allows us to handle large input values efficiently. We will iterate over each test case, and for each, perform a binary search on the possible values of k, checking if the total damage with that k is sufficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures the total damage dealt is at least h.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the smallest k) to achieve the goal.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the calculated damage is >= h.\n\n# [degree adverb] \n    'minimum value'\n    Explanation: We need to find the smallest possible k that satisfies the condition. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case:\n   - Parse n and h.\n   - Parse the list of attack times.\n   - Use binary search to find the minimum k:\n     - Set initial low and high bounds for k.\n     - While low is less than high:\n       - Calculate mid as the average of low and high.\n       - Calculate total damage for this mid value of k.\n       - If total damage is at least h, adjust high to mid.\n       - Otherwise, adjust low to mid + 1.\n   - Output the found minimum k.\n\n# [edge case] \n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack needed and h = 1, k must be at least 1 to deal the required damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value close to h/n\n    Explanation: The maximum possible damage per attack is limited by the number of attacks and their timing.\n\n    Case 3: n = 2, h = 10, a = [1, 1000000000]\n    Expected output: 5\n    Explanation: The large gap between attacks means k must be large enough to cover the gap and still deal at least h damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe task requires developing an algorithm to find the minimum k such that the total damage dealt is at least h. The solution must efficiently handle up to 1000 test cases and large values of h, up to 10^18. The input format is crucial, and the output must be correctly formatted for each test case.\nrequirement pool:\n- Develop an efficient algorithm to calculate minimum k\n- Ensure the solution can handle large values of h\n- Optimize the algorithm for performance with large n\n- Provide clear and concise output formatting\n- Include detailed comments and documentation in the code\nWe will use a binary search algorithm to efficiently determine the minimum value of k. This approach is suitable for handling large values of h and multiple test cases, as it reduces the complexity of finding the optimal k by narrowing down the search space iteratively. The algorithm will calculate the damage dealt for each potential k and adjust the search range based on whether the damage meets or exceeds h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures Monocarp's attacks deal at least h damage to the dragon.\n\n    'resources sparingly'\n    Explanation: This implies using the least amount of resources (or the smallest k) to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the calculated damage for a given k is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., low = 1, high = h).\n        - Calculate the damage for a mid value of k.\n        - Adjust the bounds based on whether the damage is >= h.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values: \n    Input: 1 1\n           1\n    Output: 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Test case with maximum h:\n    Input: 1 10^18\n           1\n    Output: 10^18\n    Explanation: With only one attack time, k must be equal to h to deal the required damage.\n\n    Test case with attacks spaced far apart:\n    Input: 2 10\n           1 1000000000\n    Output: 10\n    Explanation: The attacks are spaced far apart, so k must be large enough to cover the gap and deal at least h damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum value of parameter k such that Monocarp's attacks cause at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large values for n and h, ensuring optimal performance.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case.\n- Ensure the solution handles large input sizes efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance.\n- Include detailed comments and documentation for the code.\nWe will use a binary search algorithm to efficiently determine the minimum value of k for each test case. This approach is suitable given the constraints, as it allows us to handle large input sizes and multiple test cases efficiently. The binary search will help us find the smallest k such that the total damage is at least h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures the total damage dealt is at least h.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources, which in this context means finding the smallest k.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. For each test case, read n, h, and the list of attack times.\n2. Initialize binary search bounds: low = 1, high = h.\n3. While low < high:\n   - Calculate mid = (low + high) // 2.\n   - Calculate total damage for k = mid.\n   - If total damage >= h, set high = mid.\n   - Otherwise, set low = mid + 1.\n4. After exiting the loop, low will be the minimum k that satisfies the condition.\n5. Output low for each test case.\n\n# [edge case]\n    Test case 1: (n=1, h=1, a=[1]) = 1\n    Explanation: With only one attack needed and h=1, k=1 is sufficient.\n\n    Test case 2: (n=2, h=10^18, a=[1, 10^9]) = 10^18\n    Explanation: The damage required is extremely large, so k must be at least h.\n\n    Test case 3: (n=100, h=1000, a=[1, 2, ..., 100]) = 10\n    Explanation: With attacks every second, k=10 ensures at least 1000 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the search space based on the damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum value of k such that the total damage dealt is at least h. This involves calculating the damage over time based on the attack timings and optimizing the parameter k to achieve the desired damage with minimal resource usage.\nrequirement pool:\n- Implement the algorithm to calculate minimum k for each test case.\n- Ensure the solution handles large values of h efficiently.\n- Optimize the code for faster execution with multiple test cases.\n- Provide clear and formatted output for each test case.\n- Include comments and documentation for better code understanding.\nWe will use a binary search algorithm to efficiently determine the minimum value of k that allows Monocarp to deal at least h damage to the dragon. This approach is suitable given the constraints, as it allows us to handle large values of h and multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that allows Monocarp to deal at least h damage to the dragon efficiently.\n\n    'resources sparingly'\n    Explanation: This implies using the least amount of resources (or the smallest k) to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the total damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - While low <= high:\n            - Calculate mid as (low + high) // 2.\n            - Calculate total damage for k = mid.\n            - If total damage >= h, update high to mid - 1.\n            - Otherwise, update low to mid + 1.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal at least 1 damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large number close to h/n\n    Explanation: The large value of h requires a large k to accumulate enough damage over multiple attacks.\n\n    Case 3: n = 2, h = 10^9, a = [1, 10^9]\n    Expected output: A value close to 10^9\n    Explanation: The large gap between attack times means k must be large enough to cover the gap and deal sufficient damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the bounds based on the calculated damage.\n", "requirement analysis:\nThe requirement is to find the minimum value of k such that the total damage dealt is at least h. The solution must efficiently handle up to 1000 test cases and large values of h and n. The attacks are performed at increasing seconds, and the solution should consider the intervals between attacks to optimize the damage calculation.\nrequirement pool:\n- Calculate minimum k for each test case\n- Handle large values of h and n efficiently\n- Ensure solution accuracy across all test cases\n- Optimize performance for large input values\n- Provide clear output format as specified\nWe will use a binary search algorithm to efficiently determine the minimum value of k. The binary search will be applied on the possible values of k, ranging from 1 to the maximum possible damage needed. For each k, we will simulate the damage dealt by Monocarp's attacks and check if it meets or exceeds the required damage h. This approach ensures that we handle large values of h and n efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that allows Monocarp to deal at least h damage to the dragon.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources, which in this context means finding the smallest k.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented as a condition where the sum of damage is checked against h.\n\n# [degree adverb]\n    'minimum value'\n    Explanation: This indicates that we need to find the smallest possible k that satisfies the condition. In code, this can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read integers n and h.\n   - Read the list of attack times a.\n3. Implement a binary search for k:\n   - Set initial bounds for k (low = 1, high = h).\n   - While low is less than or equal to high:\n     - Calculate mid as (low + high) // 2.\n     - Simulate the damage dealt with k = mid.\n     - If the total damage is at least h, update high to mid - 1.\n     - Otherwise, update low to mid + 1.\n4. Output the minimum k found for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack needed and h = 1, the minimum k is 1.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large number close to h/n\n    Explanation: The large value of h requires a large k to ensure enough damage is dealt.\n\n    Case 3: n = 2, h = 10^9, a = [1, 10^9]\n    Expected output: 10^9\n    Explanation: The attacks are spaced far apart, requiring a large k to cover the gap and meet the damage requirement.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe main requirement is to determine the minimum value of k for each test case such that the total damage is at least h. The solution must efficiently handle up to 1000 test cases with large input values for h and a_i.\nrequirement pool:\n- Implement an efficient algorithm to calculate the minimum k for each test case.\n- Ensure the solution handles large values of h and a_i efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the code for performance with multiple test cases.\n- Include comments and documentation for better understanding.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k for each test case. This approach is suitable given the constraints, as it allows us to handle large values of h and a_i efficiently. We will use Python's built-in capabilities without additional frameworks, ensuring simplicity and performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that will ensure Monocarp deals at least h damage to the dragon efficiently.\n\n    'resources sparingly'\n    Explanation: This implies using the least amount of resources (or the smallest k) to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: Monocarp needs to deal damage that is greater than or equal to h. In code, this can be implemented by checking if the total damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., low = 1, high = h).\n        - While low <= high:\n            - Calculate mid as (low + high) // 2.\n            - Simulate the damage dealt with k = mid.\n            - If the damage is >= h, update high to mid - 1.\n            - Otherwise, update low to mid + 1.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large number close to h/n\n    Explanation: With maximum constraints, k needs to be large enough to accumulate sufficient damage over all attacks.\n\n    Case 3: n = 2, h = 5, a = [1, 10]\n    Expected output: 3\n    Explanation: The attacks are spaced out, requiring k to be large enough to cover gaps between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum value of parameter k such that Monocarp will cause at least h damage to the dragon. This involves calculating the damage over time based on the attack timings and ensuring the total damage meets or exceeds the required amount.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the code for quick execution.\n- Include detailed comments and documentation.\nWe will use a binary search algorithm to efficiently determine the minimum value of k. The binary search will be applied over the possible values of k, and for each candidate k, we will simulate the damage dealt to the dragon by iterating over the attack times and calculating the cumulative damage. This approach ensures that we handle the maximum constraints efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures Monocarp's attacks deal at least h damage to the dragon.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the smallest k) to achieve the goal.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the cumulative damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the attack times.\n    3. Implement a binary search for k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - For each candidate k, calculate the total damage:\n            - Iterate over attack times and calculate damage intervals.\n            - Sum up the damage intervals and check if it meets or exceeds h.\n        - Adjust binary search bounds based on whether the current k meets the damage requirement.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values: \n    Input: 1 1\n           1\n    Output: 1\n    Explanation: With only one attack at time 1 and needing only 1 damage, k=1 is sufficient.\n\n    Test case with maximum h:\n    Input: 1 1000000000000000000\n           1\n    Output: 1000000000000000000\n    Explanation: With one attack at time 1 and needing maximum possible damage, k must be equal to h.\n\n    Test case with attacks spaced far apart:\n    Input: 2 10\n           1 1000000000\n    Output: 5\n    Explanation: The attacks are far apart, so k must be large enough to cover the gap between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting k based on the cumulative damage calculation.\n", "requirement analysis:\nThe main requirement is to determine the minimum value of k such that the total damage dealt is at least h. This involves calculating the damage over time based on the attack timings and ensuring the solution is efficient for large values of h and multiple test cases.\nrequirement pool:\n- Implement the algorithm to calculate the minimum k for each test case.\n- Ensure the solution handles large input sizes efficiently.\n- Provide clear input and output instructions for the user.\n- Optimize the code for performance and scalability.\n- Include detailed comments and documentation for maintainability.\nWe will use a binary search algorithm to efficiently determine the minimum value of k for each test case. This approach is suitable given the constraints, as it allows us to handle large values of h and multiple test cases efficiently. The binary search will help us find the smallest k such that the total damage dealt is at least h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures Monocarp's attacks deal at least h damage to the dragon.\n\n    'resources sparingly'\n    Explanation: This implies using the least amount of resources (or smallest k) to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt by Monocarp's attacks must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., low = 1, high = h).\n        - Calculate mid = (low + high) // 2.\n        - Simulate the damage dealt with k = mid.\n        - If the damage is at least h, adjust high = mid.\n        - Otherwise, adjust low = mid + 1.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Test case with maximum h:\n    2 10^18\n    1 10^9\n    Expected output: A large value close to 10^9\n    Explanation: The large h requires a large k to accumulate enough damage.\n\n    Test case with consecutive attacks:\n    3 6\n    1 2 3\n    Expected output: 2\n    Explanation: With k=2, damage is dealt in seconds [1, 2, 3, 4, 5], totaling at least 6.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the bounds based on the damage calculation.\n", "requirement analysis:\nThe requirement focuses on determining the minimum poison impact needed to defeat a dragon using a series of timed attacks. The solution must handle large input sizes efficiently and provide accurate results for multiple test cases.\nrequirement pool:\n- Implement the algorithm to calculate the minimum poison impact.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide detailed documentation for the algorithm.\n- Include test cases to validate the solution.\nWe will implement a binary search algorithm to efficiently determine the minimum poison impact needed to defeat the dragon. This approach is suitable for handling large input sizes due to its logarithmic time complexity. We will use Python's built-in capabilities to manage input and output, ensuring the solution is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of the parameter k that ensures Monocarp deals at least h damage to the dragon.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the minimum k) to achieve the desired outcome.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Implement a binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - Calculate the total damage for a given k by iterating over attack times and summing up the damage dealt in each interval.\n   - Adjust the bounds based on whether the total damage is sufficient.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] = 1\n    Explanation: With only one attack needed and h = 1, k = 1 is sufficient to deal the required damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100] = 10^18\n    Explanation: The maximum possible h requires careful calculation to ensure k is large enough to meet the requirement.\n\n    Case 3: n = 2, h = 10, a = [1, 1000000000] = 5\n    Explanation: With widely spaced attacks, k must be large enough to cover the gap between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on whether the accumulated damage meets or exceeds h.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat a dragon using efficient resource management. The solution should handle multiple test cases and provide the minimum parameter k for each scenario.\nrequirement pool:\n- Calculate minimum poison impact for dragon defeat\n- Handle multiple test cases efficiently\n- Optimize resource usage\n- Provide clear output for each test case\n- Ensure scalability for large input values\nWe will use a binary search algorithm to efficiently determine the minimum value of k. The binary search will help us find the smallest k such that the total damage dealt is at least h. This approach is efficient given the constraints, and we will iterate over each test case to apply this logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that allows Monocarp to deal at least h damage to the dragon using the least resources.\n\n    'test cases'\n    Explanation: The problem involves multiple scenarios (test cases) where the solution must be applied independently.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb] \n    'minimum value'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Use binary search to find the minimum k:\n     - Initialize low and high bounds for k.\n     - While low < high:\n       - Calculate mid as the average of low and high.\n       - Calculate total damage for k = mid.\n       - If total damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n   - Output the found minimum k.\n\n# [edge case] \n    Edge Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack needed and h = 1, the minimum k is 1.\n\n    Edge Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100] => Expected output: A large k\n    Explanation: The large value of h requires a large k to accumulate enough damage over many attacks.\n\n    Edge Case 3: n = 2, h = 10^9, a = [1, 10^9] => Expected output: 10^9\n    Explanation: The large gap between attacks means k must be at least as large as the gap to ensure sufficient damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 781, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "condense_two2one", "parent_index": 298}
