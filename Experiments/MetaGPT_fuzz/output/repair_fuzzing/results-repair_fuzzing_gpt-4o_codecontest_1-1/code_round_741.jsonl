{"name": "1582_A. Luntik and Concerts", "description": "Luntik has decided to try singing. He has a one-minute songs, b two-minute songs and c three-minute songs. He wants to distribute all songs into two concerts such that every song should be included to exactly one concert.\n\nHe wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert.\n\nPlease help Luntik and find the minimal possible difference in minutes between the concerts durations.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "tags": ["math"], "difficulty": 7, "id": 1582, "sample_io": [{"input": "4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}], "test_list": [{"input": "4\n1 1 1\n2 1 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 5\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 1 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 4\n2 2 2\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 0\n4 1 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 2 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 1 1\n3 2 8\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 7\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n1 2 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 4 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n5 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 5\n1 2 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n2 4 0\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 3 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 1 2\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n4 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 3 2\n3 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 4 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 2 1\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 4\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 4 0\n4 2 0\n10 4 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n2 4 0\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 3\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 9\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 3 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n4 2 1\n1 4 0\n1 1 0\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 3\n2 2 2\n3 2 1\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 5\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n2 1 1\n4 2 1\n3 4 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n1 2 1\n3 8 5\n2 2 2\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 3\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 1\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 5 4\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 0\n6 4 6\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 3\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 6\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n2 2 3\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n3 8 4\n2 2 2\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n2 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 2 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 3\n3 1 2\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n2 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n2 3 1\n10 4 2\n1 1 6\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 4\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 6\n1 2 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 2\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 3\n1 1 2\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n1 2 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 4\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n3 1 1\n3 3 1\n10 4 0\n1 1 6\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 4 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 4 6\n1 1 2\n3 1 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n4 8 6\n0 2 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 4 1\n7 1 1\n6 3 2\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n4 1 3\n5 5 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 3\n5 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n4 1 1\n4 2 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 1\n4 1 1\n3 2 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 1 1\n3 2 2\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n4 2 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 4 5\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 1 1\n2 2 0\n5 2 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 0\n2 1 1\n3 2 5\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 3\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n4 2 1\n12 4 5\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n7 1 5\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n3 2 2\n4 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 0\n4 2 1\n6 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 0 0\n4 2 1\n6 4 1\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 1 1\n5 4 5\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 4 1\n2 1 1\n3 2 10\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 2 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n2 4 5\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 2\n2 2 1\n3 2 2\n1 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n11 4 9\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 1 1\n2 3 3\n4 1 5\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 2 2\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 0\n9 4 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 2 0\n4 2 1\n6 4 0\n1 1 1\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 1 1\n2 1 1\n6 2 6\n1 1 4\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 1 8\n1 1 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 1\n3 2 5\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 2\n2 2 1\n1 4 5\n2 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n3 2 2\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 4\n2 2 1\n6 4 9\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n2 2 4\n3 1 5\n1 1 2\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n1 1 2\n2 2 1\n4 4 2\n2 1 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n2 2 0\n4 2 0\n5 4 5\n1 1 0\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n2 1 1\n2 1 1\n6 2 5\n1 1 6\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 0\n2 1 1\n3 4 1\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 2 0\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n1 1 1\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n6 4 5\n2 3 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 0\n2 2 1\n4 1 2\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 7 9\n1 1 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 1 1\n0 2 4\n6 1 5\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n1 1 2\n2 2 0\n4 3 2\n3 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n5 2 1\n3 4 5\n1 1 4\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4 2 1\n4 2 1\n2 4 0\n1 1 2\n", "output": ["1\n1\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n2 2 0\n0 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n1 2 4\n2 2 2\n3 2 3\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 2\n2 2 1\n3 4 8\n2 1 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 13\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 2 1\n5 2 1\n6 3 5\n1 1 1\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n1 2 0\n2 1 1\n6 2 1\n2 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 2 1\n0 2 2\n", "output": ["1\n1\n0\n0\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 6 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n4 3 1\n1 4 0\n1 1 4\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 2 1\n6 2 1\n2 1 2\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n3 5 0\n0 2 2\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n1 2 10\n2 2 2\n3 2 3\n1 1 2\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 2\n1 2 1\n3 2 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n1 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["0\n1\n1\n0\n"]}, {"input": "4\n1 4 1\n4 2 1\n6 1 5\n1 1 4\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 4 1\n4 2 0\n10 4 3\n1 1 2\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n2 2 1\n3 2 1\n1 4 0\n1 1 0\n", "output": ["1\n0\n1\n1\n"]}, {"input": "4\n2 1 1\n2 2 1\n3 4 0\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n1 2 3\n2 2 1\n3 2 1\n1 1 2\n", "output": ["0\n1\n0\n1\n"]}, {"input": "4\n1 2 0\n1 2 1\n3 8 5\n2 1 2\n", "output": ["1\n0\n0\n0\n"]}, {"input": "4\n2 2 1\n2 2 1\n6 4 3\n1 1 3\n", "output": ["1\n1\n1\n0\n"]}, {"input": "4\n2 4 1\n7 2 0\n10 4 3\n1 2 2\n", "output": ["1\n1\n1\n1\n"]}, {"input": "4\n2 2 0\n2 1 1\n6 3 1\n3 2 2\n", "output": ["0\n1\n1\n1\n"]}, {"input": "4\n1 2 6\n2 2 2\n3 2 1\n1 1 4\n", "output": ["1\n0\n0\n1\n"]}, {"input": "4\n1 2 1\n2 2 1\n3 8 5\n2 2 2\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n2 1 1\n3 3 1\n6 4 3\n1 1 3\n", "output": ["1\n0\n1\n0\n"]}, {"input": "4\n1 4 2\n4 2 1\n6 3 2\n1 1 4\n", "output": ["1\n1\n0\n1\n"]}], "task_id": "codecontest/28", "prompt": "Luntik has decided to try singing and he has a one-minute songs, b two-minute songs and c three-minute songs. Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert and he wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are extreme number of songs, both few and many in each category.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "repair_prompt": ["Luntik has decided to try singing and he has a one-minute songs, b two-minute songs and c three-minute songs. Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert and he wants to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are extreme number of songs, both few and many in each category.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "Luntik has decided to try singing and he has a one-minute songs, b two-minute songs and c three-minute songs. Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert. He aims for his concerts to have durations that are as similar as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are extreme number of songs, both few and many in each category.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "Luntik has decided to try singing and he has a one-minute songs, b two-minute songs and c three-minute songs. Luntik wants to distribute all songs into two concerts such that every song should be included to exactly one concert, aiming to make the absolute difference of durations of the concerts as small as possible. The duration of the concert is the sum of durations of all songs in that concert. Please help Luntik and find the minimal possible difference in minutes between the concerts durations. Consider edge cases where there are extreme number of songs, both few and many in each category.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_concert_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers\n            representing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: A list of integers representing the minimal possible difference for each test case.\n    \"\"\"\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        for count, duration in [(a, 1), (b, 2), (c, 3)]:\n            current_sums = list(possible_sums)\n            for _ in range(count):\n                for s in current_sums:\n                    possible_sums.add(s + duration)\n        \n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        \n        results.append(min_diff)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Call the function and print results\n    results = minimal_concert_difference(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples, each containing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate total duration\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 1 and b == 0 and c == 0:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach\n        # We will use a set to track possible sums\n        possible_sums = {0}\n        \n        # Add one-minute songs\n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        \n        # Add two-minute songs\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        \n        # Add three-minute songs\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest possible sum to half of the total duration\n        half_duration = total_duration // 2\n        closest_sum = min(possible_sums, key=lambda x: abs(x - half_duration))\n        \n        # Calculate the minimal absolute difference\n        minimal_diff = abs(total_duration - 2 * closest_sum)\n        results.append(minimal_diff)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Call the function and print results\n    results = minimal_difference(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers\n            representing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: A list of integers representing the minimal possible difference for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # If the total duration is even, the minimal difference is 0\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            # If the total duration is odd, the minimal difference is 1\n            results.append(1)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = minimal_difference(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples containing counts of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate total duration\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a + b + c == 1:\n            results.append(max(a, b, c))\n            continue\n        \n        # Dynamic programming approach to find the closest sum to half of the total duration\n        half_duration = total_duration // 2\n        possible_sums = {0}\n        \n        for _ in range(a):\n            possible_sums.update({x + 1 for x in possible_sums})\n        for _ in range(b):\n            possible_sums.update({x + 2 for x in possible_sums})\n        for _ in range(c):\n            possible_sums.update({x + 3 for x in possible_sums})\n        \n        # Find the closest sum to half_duration\n        closest_sum = max(x for x in possible_sums if x <= half_duration)\n        \n        # Calculate minimal difference\n        minimal_diff = abs(total_duration - 2 * closest_sum)\n        results.append(minimal_diff)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresults = minimal_difference(n, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples, each containing the number of one-minute, \n                                                 two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal differences for each test case.\n    \"\"\"\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        for count, duration in [(a, 1), (b, 2), (c, 3)]:\n            for _ in range(count):\n                for j in range(half_duration, duration - 1, -1):\n                    if dp[j - duration]:\n                        dp[j] = True\n        \n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                min_diff = total_duration - 2 * i\n                results.append(min_diff)\n                break\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = minimal_difference(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples containing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration == 0:\n            results.append(0)\n            continue\n        \n        # Dynamic programming approach to find minimal difference\n        # Initialize DP array\n        dp = [False] * (total_duration // 2 + 1)\n        dp[0] = True\n        \n        # Update DP array for each song type\n        for duration, count in [(1, a), (2, b), (3, c)]:\n            for _ in range(count):\n                for j in range(total_duration // 2, duration - 1, -1):\n                    dp[j] = dp[j] or dp[j - duration]\n        \n        # Find the closest sum to half of total_duration\n        for i in range(total_duration // 2, -1, -1):\n            if dp[i]:\n                min_diff = total_duration - 2 * i\n                results.append(min_diff)\n                break\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [tuple(map(int, input(): \").split())) for _ in range(n)]\n    \n    results = minimal_difference(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers\n            representing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: A list of integers representing the minimal possible difference for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The target for each concert is to have a duration close to half of the total duration\n        target = total_duration // 2\n        \n        # Initialize the current duration of the first concert\n        current_duration = 0\n        \n        # Use a greedy approach to distribute songs starting with the largest duration songs\n        # Add three-minute songs\n        three_minute_songs = min(c, target // 3)\n        current_duration += three_minute_songs * 3\n        target -= three_minute_songs * 3\n        \n        # Add two-minute songs\n        two_minute_songs = min(b, target // 2)\n        current_duration += two_minute_songs * 2\n        target -= two_minute_songs * 2\n        \n        # Add one-minute songs\n        one_minute_songs = min(a, target)\n        current_duration += one_minute_songs * 1\n        target -= one_minute_songs * 1\n        \n        # Calculate the difference between the two concerts\n        difference = abs(total_duration - 2 * current_duration)\n        \n        # Store the minimal difference found\n        results.append(difference)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresults = minimal_difference(n, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int]]): List of tuples where each tuple contains\n            the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: List of minimal possible differences for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate total duration\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # The minimal difference is the remainder when total_duration is divided by 2\n        # This is because we want to split the total duration as evenly as possible\n        minimal_diff = total_duration % 2\n        \n        results.append(minimal_diff)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Process and output results\n    results = minimal_difference(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in concert durations.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing three integers representing\n                    the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        A list of integers representing the minimal possible difference in minutes\n        between the concerts durations for each test case.\n    \"\"\"\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # If total_duration is even, we can potentially split it perfectly\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            # If odd, the minimal difference will be at least 1\n            results.append(1)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    # Call the function\n    results = minimal_difference(t, test_cases)\n    # Output results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimal_concert_difference(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Calculate the minimal possible difference in minutes between the concerts durations.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers\n            representing the number of one-minute, two-minute, and three-minute songs.\n\n    Returns:\n        List[int]: A list of integers representing the minimal possible difference for each test case.\n    \"\"\"\n    results = []\n    \n    for a, b, c in test_cases:\n        # Calculate the total duration of all songs\n        total_duration = a * 1 + b * 2 + c * 3\n        \n        # Edge case handling\n        if a == 0 and b == 0 and c == 0:\n            results.append(0)\n            continue\n        if a == 1 and b == 0 and c == 0:\n            results.append(1)\n            continue\n        \n        # Dynamic programming approach\n        # We need to find the closest possible sum to half of the total duration\n        half_duration = total_duration // 2\n        \n        # Initialize a DP table\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        # Update the DP table for each song type\n        for _ in range(a):\n            for j in range(half_duration, 0, -1):\n                if j >= 1:\n                    dp[j] = dp[j] or dp[j - 1]\n        \n        for _ in range(b):\n            for j in range(half_duration, 1, -1):\n                if j >= 2:\n                    dp[j] = dp[j] or dp[j - 2]\n        \n        for _ in range(c):\n            for j in range(half_duration, 2, -1):\n                if j >= 3:\n                    dp[j] = dp[j] or dp[j - 3]\n        \n        # Find the maximum sum that can be achieved which is closest to half of the total duration\n        max_possible_sum = 0\n        for i in range(half_duration + 1):\n            if dp[i]:\n                max_possible_sum = i\n        \n        # Calculate the minimal difference\n        minimal_difference = abs(total_duration - 2 * max_possible_sum)\n        results.append(minimal_difference)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Function call\nresults = minimal_concert_difference(n, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on distributing songs into two concerts with minimal duration difference. The solution must efficiently handle up to 1000 test cases and large numbers of songs, ensuring accurate results even in edge cases.\nrequirement pool:\n- Efficient algorithm to minimize concert duration difference\n- Handle large input sizes up to 10^9 for song counts\n- Ensure solution accuracy for all edge cases\n- Optimize performance for up to 1000 test cases\n- Provide clear output format as specified\nWe will use a dynamic programming approach to solve this problem. The key idea is to treat it as a variation of the subset sum problem, where we try to partition the songs into two groups with minimal difference in their total durations. Given the constraints, we need an efficient solution that can handle large numbers of songs. We will use a dictionary to store possible sums and their differences, iterating over each song type to update possible sums. This approach will efficiently handle the large input sizes and ensure accurate results.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The absolute difference between two values is the non-negative difference between them, calculated as |a - b|. In this requirement, it refers to the difference in total durations of the two concerts.\n\n    'minimal possible difference'\n    Explanation: This means finding the smallest possible value of the absolute difference between the durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, they represent the values 1, 2, and 3 respectively, which are used to calculate the total duration of songs in each concert.\n\n# [degree adverb]\n    'minimal'\n    Explanation: This indicates that we need to find the smallest possible value for the difference in concert durations. In code, this involves finding a partition of songs that results in the smallest absolute difference.\n\n# [code logic]\n1. Initialize a dictionary to store possible sums and their differences.\n2. For each test case, calculate the total duration of all songs.\n3. Use dynamic programming to explore all possible partitions of songs into two groups.\n4. For each song type (one-minute, two-minute, three-minute), update possible sums by adding the song's duration to existing sums.\n5. Track the minimal possible difference between the two groups' total durations.\n6. Output the minimal difference for each test case.\n\n# [edge case]\n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n\n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0.\n\n    Edge Case 3: (1000000000, 1000000000, 1000000000) = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between the two concerts, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no songs are present or when there is only one song.\n    \n```python\ndef minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration == 0:\n            results.append(0)\n            continue\n        # Initialize a set to store possible sums\n        possible_sums = {0}\n        for count, duration in [(a, 1), (b, 2), (c, 3)]:\n            current_sums = list(possible_sums)\n            for _ in range(count):\n                for s in current_sums:\n                    possible_sums.add(s + duration)\n        min_diff = float('inf')\n        for s in possible_sums:\n            min_diff = min(min_diff, abs(total_duration - 2 * s))\n        results.append(min_diff)\n    return results\n\n# Example usage:\nt = 4\ntest_cases = [(1, 1, 1), (2, 1, 3), (5, 5, 5), (1, 1, 2)]\nprint(minimal_difference(t, test_cases))\n```\nThis code handles edge cases by checking if the total duration is zero and uses dynamic programming to find the minimal possible difference efficiently.\n", "requirement analysis:\nThe problem requires distributing songs into two concerts such that the absolute difference in their durations is minimized. The solution must efficiently handle up to 1000 test cases with potentially large numbers of songs in each category. Edge cases with extreme values need careful consideration to ensure performance and correctness.\nrequirement pool:\n- Develop an algorithm to minimize the difference in concert durations.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm for large input values.\n- Provide clear and correct output for each test case.\n- Consider edge cases with extreme numbers of songs.\nWe will use a dynamic programming approach to solve this problem. The idea is to calculate the total duration of all songs and then try to partition them into two subsets such that the absolute difference between their sums is minimized. This is similar to the 'Partition Problem' which can be solved using a dynamic programming approach. We will use a boolean DP table to track possible sums that can be achieved with the given songs, and then find the closest possible sum to half of the total duration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The requirement is to minimize the absolute difference between the durations of two concerts, meaning the difference should be non-negative and as small as possible.\n\n    'partition problem'\n    Explanation: This refers to dividing a set into two subsets such that the difference between their sums is minimized, a common problem in dynamic programming.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, they represent the values 1, 2, and 3 respectively, which will be used to calculate the total duration of songs in each concert.\n\n# [degree adverb]\n    'minimal'\n    Explanation: The requirement is to find the smallest possible absolute difference between the durations of the two concerts.\n\n# [code logic]\n    1. Calculate the total duration of all songs.\n    2. Use dynamic programming to find possible sums that can be achieved with the given songs.\n    3. Find the closest possible sum to half of the total duration.\n    4. Calculate the absolute difference between this sum and the remaining sum.\n    5. Return the minimal absolute difference for each test case.\n\n# [edge case]\n    Edge Case 1: 1 0 0 = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n\n    Edge Case 2: 0 0 0 = 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0 minutes.\n\n    Edge Case 3: 1000000000 1000000000 1000000000 = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between two concerts, resulting in a difference of 0 minutes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a == 1 and b == 0 and c == 0:\n            return 1\n        # Implement dynamic programming logic for other cases\n        (other code)\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases and large numbers of songs efficiently. Edge cases with extreme numbers of songs must be considered to ensure accuracy.\nrequirement pool:\n- Efficient algorithm to minimize duration difference\n- Handle large input sizes up to 10^9\n- Ensure accuracy for edge cases\n- Optimize for performance with multiple test cases\n- User-friendly input and output format\nWe will use a dynamic programming approach to solve the problem efficiently. The key is to calculate the total duration of all songs and then try to partition them into two subsets such that the difference between their sums is minimized. This is similar to the subset sum problem, which can be solved using dynamic programming. Given the constraints, we need to ensure the solution is optimized for large numbers of songs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts'\n    Explanation: The requirement involves distributing songs into two concerts such that the absolute difference in their durations is minimized.\n\n    'absolute difference'\n    Explanation: The requirement is to minimize the absolute difference between the total durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, they can be represented as constants or variables that contribute to the total duration of each concert.\n\n# [degree adverb]\n    'minimal'\n    Explanation: The requirement is to find the smallest possible difference between the durations of the two concerts. This can be implemented by iterating through possible distributions and selecting the one with the smallest difference.\n\n# [code logic]\n    1. Calculate the total duration of all songs.\n    2. Use dynamic programming to find two subsets of songs such that the difference between their sums is minimized.\n    3. Iterate through possible distributions and calculate the difference for each.\n    4. Return the minimal difference found.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n    \n    0 0 0 = 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0.\n    \n    1000000000 1000000000 1000000000 = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between the two concerts, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a == 1 and b == 0 and c == 0:\n            return 1\n        # Implement dynamic programming logic for general cases\n        # (other code)\n", "requirement analysis:\nThe problem requires distributing songs into two concerts such that the difference in their total durations is minimized. The solution must efficiently handle up to 1000 test cases with potentially large numbers of songs in each category. The output must be clear and follow the specified format. Edge cases, such as extreme numbers of songs, must be considered to ensure robustness.\nrequirement pool:\n- Efficiently handle large input sizes and multiple test cases.\n- Minimize the difference in concert durations accurately.\n- Provide clear and concise output format.\n- Consider edge cases for robustness.\n- Optimize for both small and large inputs.\nWe will use a dynamic programming approach to solve the problem efficiently. The goal is to partition the songs into two groups such that the difference in their total durations is minimized. We will calculate the total duration of all songs and use a subset sum approach to find the closest possible sum to half of the total duration. This will help us achieve the minimal difference between the two concerts.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': refers to the two separate events where songs are distributed.\n    'duration': refers to the total time of songs in each concert.\n    'minimal possible difference': means the smallest difference in total duration between the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': refers to the duration of each song type. These are used to calculate the total duration of songs in each concert.\n    'as similar as possible': means the goal is to make the durations of the two concerts as close as possible.\n\n# [degree adverb]\n    'minimal': means the smallest possible difference in duration between the two concerts.\n\n# [code logic]\n    1. Calculate the total duration of all songs.\n    2. Use dynamic programming to find a subset of songs whose total duration is closest to half of the total duration.\n    3. Calculate the difference between this subset's duration and the remaining songs' duration.\n    4. Return the minimal difference for each test case.\n\n# [edge case]\n    Input: 1 0 0\n    Output: 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n\n    Input: 0 0 0\n    Output: 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0 minutes.\n\n    Input: 1000000000 1000000000 1000000000\n    Output: 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between the two concerts.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a + b + c == 1:\n            return max(a, b, c)\n        (other code for dynamic programming approach)\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the difference in their total durations is minimized. The solution must handle up to 1000 test cases and large numbers of songs efficiently. The edge cases include scenarios with extreme numbers of songs in each category.\nrequirement pool:\n- Efficiently calculate the minimal difference in concert durations.\n- Handle up to 1000 test cases in a single run.\n- Ensure the solution is scalable for large input values.\n- Provide clear and concise output for each test case.\n- Optimize for performance and memory usage.\nWe will use a dynamic programming approach to solve the problem of distributing songs into two concerts with minimal difference in durations. The problem can be reduced to a subset sum problem where we aim to partition the total duration of songs into two subsets with minimal difference. Given the constraints, we will optimize for performance and memory usage by using a 1D DP array to track possible sums.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts': Refers to the two separate events where songs are distributed.\n    'minimal possible difference': The goal is to make the total duration of songs in each concert as close as possible.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': These indicate the duration of each type of song. In code, this means multiplying the number of each type of song by its duration to get the total duration.\n\n# [degree adverb]\n    'minimal': This indicates that we need to find the smallest possible difference between the total durations of the two concerts.\n\n# [code logic]\n1. Calculate the total duration of all songs.\n2. Use a dynamic programming approach to determine if a certain sum can be achieved with the given songs.\n3. Iterate over possible sums to find the closest to half of the total duration.\n4. Calculate the difference between this sum and the remaining songs' sum.\n5. Return the minimal difference for each test case.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n    \n    0 0 0 = 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0.\n    \n    1000000000 1000000000 1000000000 = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between the two concerts.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    \n```python\ndef minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        half_duration = total_duration // 2\n        dp = [False] * (half_duration + 1)\n        dp[0] = True\n        \n        for count, duration in [(a, 1), (b, 2), (c, 3)]:\n            for _ in range(count):\n                for j in range(half_duration, duration - 1, -1):\n                    if dp[j - duration]:\n                        dp[j] = True\n        \n        for i in range(half_duration, -1, -1):\n            if dp[i]:\n                min_diff = total_duration - 2 * i\n                results.append(min_diff)\n                break\n    \n    return results\n\n# Example usage:\nt = 4\ntest_cases = [(1, 1, 1), (2, 1, 3), (5, 5, 5), (1, 1, 2)]\nprint(minimal_difference(t, test_cases)) # Output: [0, 1, 0, 1]\n```\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the difference in their durations is minimized. The solution must handle up to 1000 test cases and large input values efficiently. The output should be the minimal possible difference for each test case.\nrequirement pool:\n- Develop an algorithm to minimize the difference in concert durations\n- Ensure the solution handles up to 1000 test cases efficiently\n- Optimize the algorithm for large input values\n- Provide clear documentation and examples for the output format\n- Consider edge cases with extreme numbers of songs\nWe will use a dynamic programming approach to solve the problem efficiently. The goal is to partition the songs into two groups such that the difference in their total durations is minimized. We will calculate the total duration of all songs and use a subset sum approach to find the closest possible half of this total duration. This will help us achieve the minimal difference between the two concerts.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts durations': The total time of songs in each concert.\n    'minimal possible difference': The smallest difference in total time between the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute': These indicate the duration of each type of song.\n    'minimal possible difference': This means finding the smallest absolute difference between the total durations of the two concerts.\n\n# [degree adverb]\n    'minimal': This indicates that we need to find the smallest possible difference in durations between the two concerts.\n\n# [code logic]\n1. Calculate the total duration of all songs.\n2. Use a dynamic programming approach to find the closest possible sum to half of the total duration.\n3. The goal is to partition the songs into two groups such that the difference in their total durations is minimized.\n4. For each test case, calculate the minimal possible difference and store the result.\n\n# [edge case]\n    1 0 0 = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n    \n    0 0 0 = 0\n    Explanation: With no songs, both concerts have a duration of 0, resulting in a difference of 0 minutes.\n    \n    1000000000 1000000000 1000000000 = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between the two concerts, resulting in a difference of 0 minutes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or only one type of song.\n    \n```python\ndef minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        if total_duration == 0:\n            results.append(0)\n            continue\n        # Dynamic programming approach to find minimal difference\n        # Initialize DP array\n        dp = [False] * (total_duration // 2 + 1)\n        dp[0] = True\n        \n        # Update DP array for each song type\n        for duration, count in [(1, a), (2, b), (3, c)]:\n            for _ in range(count):\n                for j in range(total_duration // 2, duration - 1, -1):\n                    dp[j] = dp[j] or dp[j - duration]\n        \n        # Find the closest sum to half of total_duration\n        for i in range(total_duration // 2, -1, -1):\n            if dp[i]:\n                min_diff = total_duration - 2 * i\n                results.append(min_diff)\n                break\n    \n    return results\n\n# Example usage:\nt = 4\ntest_cases = [(1, 1, 1), (2, 1, 3), (5, 5, 5), (1, 1, 2)]\nprint(minimal_difference(t, test_cases)) # Output: [0, 1, 0, 1]\n```\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases and large numbers of songs efficiently. Edge cases with extreme values must be considered to ensure accuracy.\nrequirement pool:\n- Efficiently calculate minimal difference in concert durations\n- Handle large input sizes effectively\n- Ensure accurate results for all edge cases\n- Provide clear instructions for input format\n- Optimize for speed and performance\nWe will use a greedy algorithm to distribute the songs into two concerts. The goal is to minimize the absolute difference in durations by balancing the total duration of songs in each concert. We will iterate through each test case, calculate the total duration of all songs, and attempt to split them as evenly as possible. Given the constraints, we will handle large numbers efficiently by focusing on the sum of durations rather than individual song counts.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'one-minute songs', 'two-minute songs', 'three-minute songs'\n    Explanation: These refer to the duration of each type of song that Luntik has. The goal is to distribute these songs into two concerts such that the absolute difference in total duration between the two concerts is minimized.\n\n    'absolute difference of durations'\n    Explanation: This refers to the absolute value of the difference in total minutes between the two concerts. The aim is to make this value as small as possible.\n\n# [phrase showing quantity relationship]\n    'as small as possible': This indicates that the goal is to minimize the difference in durations between the two concerts.\n\n# [degree adverb]\n    'minimal': This means the smallest possible value for the absolute difference in durations between the two concerts.\n\n# [code logic]\n1. For each test case, calculate the total duration of all songs: `total_duration = a * 1 + b * 2 + c * 3`.\n2. The target for each concert is to have a duration close to `total_duration / 2`.\n3. Use a greedy approach to distribute songs by starting with the largest duration songs (three-minute songs) and working down to one-minute songs.\n4. Track the current duration of each concert and adjust as you add each song type.\n5. Calculate the absolute difference between the two concert durations and store the minimal difference found.\n\n# [edge case]\n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, it must go into one concert, resulting in a difference of 1 minute.\n\n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: No songs to distribute, so the difference is naturally 0.\n\n    Edge Case 3: (1000000000, 1000000000, 1000000000) = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between two concerts.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The greedy algorithm inherently handles these cases by attempting to balance the total duration across both concerts.\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases and large input values efficiently. The output should be the minimal possible difference for each test case.\nrequirement pool:\n- Implement an algorithm to calculate the minimal difference in concert durations.\n- Ensure the solution can handle the maximum constraints efficiently.\n- Provide a user-friendly output format.\n- Optimize the algorithm for performance.\n- Consider edge cases with extreme numbers of songs.\nWe will use a greedy algorithm to distribute the songs into two concerts. The goal is to minimize the absolute difference in durations by balancing the total duration of songs in each concert. We will iterate through each test case, calculate the total duration of all songs, and attempt to split them into two groups with minimal difference. Given the constraints, we will ensure the solution is efficient and handles large input values using basic arithmetic operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'concerts'\n    Explanation: In the requirement, concerts refer to two separate groups or collections of songs that Luntik wants to organize. Each concert has a total duration based on the sum of the durations of the songs included in it.\n\n    'minimal possible difference'\n    Explanation: This refers to the goal of making the difference in total duration between the two concerts as small as possible. The difference is calculated as the absolute value of the difference between the total durations of the two concerts.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. A one-minute song contributes 1 minute to a concert's duration, a two-minute song contributes 2 minutes, and a three-minute song contributes 3 minutes.\n\n# [degree adverb] \n    'minimal'\n    Explanation: This indicates that the goal is to achieve the smallest possible difference in concert durations. In code, this often involves finding a way to balance or distribute items to achieve this minimal difference.\n\n# [code logic]\n1. For each test case, calculate the total duration of all songs: `total_duration = a * 1 + b * 2 + c * 3`.\n2. The target is to split this total duration into two parts with minimal difference.\n3. Use a greedy approach to distribute songs:\n   - Start by trying to balance the number of three-minute songs between the two concerts.\n   - Then balance the two-minute songs.\n   - Finally, balance the one-minute songs.\n4. Calculate the difference between the two concert durations and keep track of the minimal difference found.\n\n# [edge case] \n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, it must go into one concert, resulting in a difference of 1 minute.\n\n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: No songs mean both concerts have a duration of 0, so the difference is 0.\n\n    Edge Case 3: (1000000000, 1000000000, 1000000000) = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between the two concerts, resulting in a difference of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic should naturally handle these scenarios by considering all possible distributions and calculating the minimal difference.\n", "requirement analysis:\nThe main requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases and large numbers of songs efficiently. The output should be formatted correctly for each test case.\nrequirement pool:\n- Implement the algorithm to calculate minimal difference in concert durations.\n- Ensure the solution handles edge cases with large input values efficiently.\n- Optimize the algorithm for performance with large datasets.\n- Provide clear and concise output for each test case.\n- Include detailed comments and documentation for maintainability.\nWe will implement a function to calculate the minimal possible difference in concert durations using a greedy algorithm. The approach will involve calculating the total duration of all songs and then attempting to split them into two groups with minimal difference. We will use Python's built-in capabilities to handle large integers efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'one-minute songs', 'two-minute songs', 'three-minute songs'\n    Explanation: These refer to the duration of each type of song that Luntik has. The goal is to distribute these songs into two concerts such that the absolute difference in total duration between the two concerts is minimized.\n\n    'absolute difference'\n    Explanation: This refers to the non-negative difference between the total durations of the two concerts. The aim is to make this difference as small as possible.\n\n# [phrase showing quantity relationship]\n    'minimal possible difference': This means we need to find the smallest non-negative value for the difference in durations between the two concerts.\n\n# [degree adverb] \n    'minimal': This indicates that we are looking for the smallest possible value for the difference in durations.\n\n# [code logic]\n1. Calculate the total duration of all songs: `total_duration = a * 1 + b * 2 + c * 3`.\n2. The goal is to split this total duration into two parts with minimal difference.\n3. Use a greedy approach to try different combinations of distributing songs into two groups.\n4. Iterate over possible sums for one concert and calculate the other as `total_duration - sum1`.\n5. Calculate the absolute difference and keep track of the minimal difference found.\n6. Return the minimal difference for each test case.\n\n# [edge case] \n    Edge Case 1: (1, 0, 0) = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n\n    Edge Case 2: (0, 0, 0) = 0\n    Explanation: No songs to distribute, so the difference is naturally 0.\n\n    Edge Case 3: (1000000000, 1000000000, 1000000000) = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between two concerts.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no songs or an extreme number of songs.\n    \n```python\ndef minimal_difference(t, test_cases):\n    results = []\n    for a, b, c in test_cases:\n        total_duration = a * 1 + b * 2 + c * 3\n        # If total_duration is even, we can potentially split it perfectly\n        if total_duration % 2 == 0:\n            results.append(0)\n        else:\n            # If odd, the minimal difference will be at least 1\n            results.append(1)\n    return results\n```\n\nThis code handles cases where there are no songs by default since `total_duration` would be zero, and it efficiently checks if a perfect split is possible by checking if `total_duration` is even.\n", "requirement analysis:\nThe requirement is to distribute songs into two concerts such that the absolute difference in their durations is minimized. The solution must handle up to 1000 test cases with potentially very large numbers of songs, ensuring efficiency and accuracy. Edge cases, such as extreme numbers of songs in each category, must be considered.\nrequirement pool:\n- Implement an algorithm to distribute songs minimizing duration difference.\n- Ensure the solution handles large input sizes efficiently.\n- Optimize for edge cases with extreme song counts.\n- Provide clear input and output format compliance.\n- Include comprehensive test cases for validation.\nWe will use a dynamic programming approach to solve this problem. The idea is to treat it as a variation of the subset sum problem, where we try to partition the songs into two groups with minimal difference in their total durations. We will calculate the total duration of all songs and then use a DP table to find the closest possible sum to half of the total duration. This will help us determine the minimal difference between the two concert durations. Given the constraints, this approach will efficiently handle large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'absolute difference'\n    Explanation: The requirement is to minimize the absolute difference between the total durations of two concerts. This means we need to find two subsets of songs such that the difference in their total durations is as small as possible.\n\n    'dynamic programming'\n    Explanation: The plan suggests using dynamic programming, which is a method for solving complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems like this one.\n\n# [phrase showing quantity relationship]\n    'one-minute', 'two-minute', 'three-minute'\n    Explanation: These phrases indicate the duration of each type of song. In code, they can be represented as constants or variables that denote the duration of each song type.\n\n# [degree adverb]\n    'minimal'\n    Explanation: The requirement is to find the smallest possible difference between the durations of the two concerts. This implies an optimization problem where we aim to minimize a certain value.\n\n# [code logic]\n    1. Calculate the total duration of all songs.\n    2. Use dynamic programming to find the closest possible sum to half of the total duration.\n    3. Initialize a DP table where dp[i] represents whether a sum i can be achieved with the given songs.\n    4. Iterate over each song type and update the DP table accordingly.\n    5. Find the maximum sum that can be achieved which is closest to half of the total duration.\n    6. Calculate the minimal difference using this sum.\n\n# [edge case]\n    Edge Case 1: 1 0 0 = 1\n    Explanation: With only one one-minute song, it must be placed in one concert, resulting in a difference of 1 minute.\n\n    Edge Case 2: 0 0 0 = 0\n    Explanation: No songs are present, so both concerts have a duration of 0, resulting in a difference of 0 minutes.\n\n    Edge Case 3: 1000000000 1000000000 1000000000 = 0\n    Explanation: With an equal number of each type of song, they can be perfectly balanced between two concerts, resulting in a difference of 0 minutes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a == 1 and b == 0 and c == 0:\n            return 1\n        # Implement dynamic programming logic for other cases\n"], "scores": [], "pass_results": [true, true, true, true, true, true, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 741, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integers a, b, c (1 \u2264 a, b, c \u2264 10^9) \u2014 the number of one-minute, two-minute and three-minute songs.\n\nOutput\n\nFor each test case print the minimal possible difference in minutes between the concerts durations.\n\nExample\n\nInput\n\n\n4\n1 1 1\n2 1 3\n5 5 5\n1 1 2\n\n\nOutput\n\n\n0\n1\n0\n1\n\nNote\n\nIn the first test case, Luntik can include a one-minute song and a two-minute song into the first concert, and a three-minute song into the second concert. Then the difference will be equal to 0.\n\nIn the second test case, Luntik can include two one-minute songs and a two-minute song and a three-minute song into the first concert, and two three-minute songs into the second concert. The duration of the first concert will be 1 + 1 + 2 + 3 = 7, the duration of the second concert will be 6. The difference of them is |7-6| = 1.", "mutate_method": "add_1_sentence_at_end", "parent_index": 267}
