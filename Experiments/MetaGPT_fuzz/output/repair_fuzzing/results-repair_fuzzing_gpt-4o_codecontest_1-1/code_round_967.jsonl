{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones has returned to assist his distant relative, Indiana Jones, in locating a hidden treasure within a maze beneath a desert teeming with illusions, with the maze's layout being a tree consisting of n chambers indexed from 1 to n, connected by n - 1 tunnels that permit movement between any pair of rooms. The i-th chamber (1 \u2264 i \u2264 n) possesses an illusion rate a_i, and traversing a tunnel from room x to room y requires energy given by max(|a_x + a_y|, |a_x - a_y|), where |z| signifies the absolute value of z. To thwart treasure thieves, the maze can alter the illusion rate of any chamber, leading Chanek and Indiana to pose q inquiries. Two kinds of questions need to be addressed: * 1\\ u\\ c \u2014 The illusion rate in the x-th room gets updated to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the least total energy required to reach the secret treasure in room v starting from room u (1 \u2264 u, v \u2264 n). Assist them, and you'll earn a share of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones has returned to assist his distant relative, Indiana Jones, in locating a hidden treasure within a maze beneath a desert teeming with illusions, with the maze's layout being a tree consisting of n chambers indexed from 1 to n, connected by n - 1 tunnels that permit movement between any pair of rooms. The i-th chamber (1 \u2264 i \u2264 n) possesses an illusion rate a_i, and traversing a tunnel from room x to room y requires energy given by max(|a_x + a_y|, |a_x - a_y|), where |z| signifies the absolute value of z. To thwart treasure thieves, the maze can alter the illusion rate of any chamber, leading Chanek and Indiana to pose q inquiries. Two kinds of questions need to be addressed: * 1\\ u\\ c \u2014 The illusion rate in the x-th room gets updated to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the least total energy required to reach the secret treasure in room v starting from room u (1 \u2264 u, v \u2264 n). Assist them, and you'll earn a share of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his distant relative, Indiana Jones, in locating a hidden treasure within a maze beneath a desert teeming with illusions. The maze's layout is a tree consisting of n chambers indexed from 1 to n, connected by n - 1 tunnels that permit movement between any pair of rooms. The i-th chamber (1 \u2264 i \u2264 n) possesses an illusion rate a_i, and traversing a tunnel from room x to room y requires energy given by max(|a_x + a_y|, |a_x - a_y|), where |z| signifies the absolute value of z. To thwart treasure thieves, the maze can alter the illusion rate of any chamber, leading Chanek and Indiana to pose q inquiries. Two kinds of questions need to be addressed: * 1\\ u\\ c \u2014 The illusion rate in the x-th room gets updated to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the least total energy required to reach the secret treasure in room v starting from room u (1 \u2264 u, v \u2264 n). Assist them, and you'll earn a share of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his distant relative, Indiana Jones, in locating a hidden treasure within a maze beneath a desert teeming with illusions, with the maze's layout being a tree consisting of n chambers indexed from 1 to n and connected by n - 1 tunnels that permit movement between any pair of rooms. The i-th chamber (1 \u2264 i \u2264 n) possesses an illusion rate a_i, and traversing a tunnel from room x to room y requires energy given by max(|a_x + a_y|, |a_x - a_y|), where |z| signifies the absolute value of z. To thwart treasure thieves, the maze can alter the illusion rate of any chamber, leading Chanek and Indiana to pose q inquiries, and two kinds of questions need to be addressed: * 1\\ u\\ c \u2014 The illusion rate in the x-th room gets updated to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the least total energy required to reach the secret treasure in room v starting from room u (1 \u2264 u, v \u2264 n). Assist them, and you'll earn a share of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree for efficient updates and queries of illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at a specific index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef find_min_energy_path(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Finds the minimum energy path between two rooms using DFS.\"\"\"\n    def dfs(current: int, target: int, visited: set, path_energy: int) -> int:\n        if current == target:\n            return path_energy\n        visited.add(current)\n        for neighbor in adjacency_list[current]:\n            if neighbor not in visited:\n                energy_cost = max(abs(illusion_rates[current - 1] + illusion_rates[neighbor - 1]),\n                                  abs(illusion_rates[current - 1] - illusion_rates[neighbor - 1]))\n                result = dfs(neighbor, target, visited, path_energy + energy_cost)\n                if result != float('inf'):\n                    return result\n        visited.remove(current)\n        return float('inf')\n    \n    adjacency_list = {i: [] for i in range(1, len(illusion_rates) + 1)}\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    \n    return dfs(u, v, set(), 0)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = find_min_energy_path(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\nsys.setrecursionlimit(200000)\n\nclass SegmentTree:\n    \"\"\"Segment Tree for efficiently updating and querying illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree from the initial data.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Updates the value at position `pos` to `value`.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(u: int, parent: int, graph: List[List[int]], illusion_rates: List[int], target: int, path: List[int], min_energy: List[int]):\n    \"\"\"Performs DFS to find the path and calculate the minimum energy.\"\"\"\n    if u == target:\n        energy = 0\n        for i in range(len(path) - 1):\n            x, y = path[i], path[i + 1]\n            energy += max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n        min_energy[0] = min(min_energy[0], energy)\n        return\n    \n    for v in graph[u]:\n        if v != parent:\n            path.append(v)\n            dfs(v, u, graph, illusion_rates, target, path, min_energy)\n            path.pop()\n\ndef update_illusion_rate(room_index: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specific room.\"\"\"\n    illusion_rates[room_index] = new_rate\n\ndef calculate_min_energy(start_room: int, end_room: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from start_room to end_room.\"\"\"\n    n = len(illusion_rates)\n    graph = [[] for _ in range(n)]\n    for u, v in tunnels:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    \n    min_energy = [float('inf')]\n    dfs(start_room - 1, -1, graph, illusion_rates, end_room - 1, [start_room - 1], min_energy)\n    return min_energy[0]\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u - 1, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Dict\n\ndef update_illusion_rate(room_index: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified chamber.\"\"\"\n    illusion_rates[room_index - 1] = new_rate\n\ndef calculate_min_energy(start_room: int, end_room: int, illusion_rates: List[int], tree_structure: Dict[int, List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from start_room to end_room.\"\"\"\n    # Create a graph from the tree structure\n    graph = nx.Graph(tree_structure)\n    \n    # Find the path using DFS\n    path = nx.shortest_path(graph, source=start_room, target=end_room)\n    \n    # Calculate the total energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        x = path[i]\n        y = path[i + 1]\n        energy = max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n        total_energy += energy\n    \n    return total_energy\n\ndef main():\n    # Read input values\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree_structure = {}\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        if s not in tree_structure:\n            tree_structure[s] = []\n        if t not in tree_structure:\n            tree_structure[t] = []\n        tree_structure[s].append(t)\n        tree_structure[t].append(s)\n    \n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            room_index = int(query[1])\n            new_rate = int(query[2])\n            update_illusion_rate(room_index, new_rate, illusion_rates)\n        elif query[0] == '2':\n            start_room = int(query[1])\n            end_room = int(query[2])\n            result = calculate_min_energy(start_room, end_room, illusion_rates, tree_structure)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: list) -> None:\n    \"\"\"Update the illusion rate of a specified room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (list): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: list, tree: dict) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (list): The list of current illusion rates for all rooms.\n        tree (dict): The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Precompute LCA and other necessary data structures\n    parent = [-1] * len(illusion_rates)\n    depth = [-1] * len(illusion_rates)\n    max_depth = 0\n\n    def dfs(node, par, dep):\n        nonlocal max_depth\n        parent[node] = par\n        depth[node] = dep\n        max_depth = max(max_depth, dep)\n        for neighbor in tree[node]:\n            if neighbor != par:\n                dfs(neighbor, node, dep + 1)\n\n    # Start DFS from node 1 (0-indexed)\n    dfs(0, -1, 0)\n\n    # Binary lifting table\n    LOG = max_depth.bit_length()\n    up = [[-1] * LOG for _ in range(len(illusion_rates))]\n\n    for i in range(len(illusion_rates)):\n        up[i][0] = parent[i]\n\n    for j in range(1, LOG):\n        for i in range(len(illusion_rates)):\n            if up[i][j - 1] != -1:\n                up[i][j] = up[up[i][j - 1]][j - 1]\n\n    def lca(a, b):\n        if depth[a] < depth[b]:\n            a, b = b, a\n        # Lift a to the same depth as b\n        for i in range(LOG - 1, -1, -1):\n            if depth[a] - (1 << i) >= depth[b]:\n                a = up[a][i]\n        if a == b:\n            return a\n        for i in range(LOG - 1, -1, -1):\n            if up[a][i] != up[b][i]:\n                a = up[a][i]\n                b = up[b][i]\n        return parent[a]\n\n    def calculate_energy(x, y):\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n\n    # Find LCA of u and v\n    lca_node = lca(u - 1, v - 1)\n\n    # Calculate energy from u to LCA and LCA to v\n    total_energy = 0\n    current = u - 1\n    while current != lca_node:\n        total_energy += calculate_energy(current, parent[current])\n        current = parent[current]\n\n    current = v - 1\n    while current != lca_node:\n        total_energy += calculate_energy(current, parent[current])\n        current = parent[current]\n\n    return total_energy\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tree = {i: [] for i in range(n)}\n    for _ in range(n - 1):\n        s = int(data[index]) - 1\n        t = int(data[index + 1]) - 1\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        if query_type == 1:\n            c = int(data[index + 2])\n            update_illusion_rate(u, c, illusion_rates)\n            index += 3\n        elif query_type == 2:\n            v = int(data[index + 2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n            index += 3\n\n    for result in results:\n        print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\nsys.setrecursionlimit(200000)\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, pos: int, value: int):\n        # Update the value at position pos\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left: int, right: int) -> int:\n        # Query the sum in the range [left, right)\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(node: int, parent: int, graph: Dict[int, List[int]], depth: List[int], parent_list: List[int]):\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(neighbor, node, graph, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    # Bring both nodes to the same depth\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while depth[v] > depth[u]:\n        v = parent_list[v]\n    # Find the common ancestor\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_list: List[int]) -> int:\n    energy = 0\n    while u != v:\n        energy += max(abs(illusion_rates[u] + illusion_rates[parent_list[u]]),\n                      abs(illusion_rates[u] - illusion_rates[parent_list[u]]))\n        u = parent_list[u]\n    return energy\n\ndef update_illusion_rate(room_index: int, new_rate: int, illusion_rates: List[int]) -> None:\n    illusion_rates[room_index] = new_rate\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    n = len(illusion_rates)\n    graph = {i: [] for i in range(n)}\n    for s, t in tunnels:\n        graph[s - 1].append(t - 1)\n        graph[t - 1].append(s - 1)\n\n    depth = [0] * n\n    parent_list = [-1] * n\n    dfs(0, -1, graph, depth, parent_list)\n\n    ancestor = lca(u - 1, v - 1, depth, parent_list)\n    energy_u_to_ancestor = calculate_energy(u - 1, ancestor, illusion_rates, parent_list)\n    energy_v_to_ancestor = calculate_energy(v - 1, ancestor, illusion_rates, parent_list)\n\n    return energy_u_to_ancestor + energy_v_to_ancestor\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    for query in queries:\n        if query[0] == '1':\n            room_index = int(query[1]) - 1\n            new_rate = int(query[2])\n            update_illusion_rate(room_index, new_rate, illusion_rates)\n        elif query[0] == '2':\n            u = int(query[1])\n            v = int(query[2])\n            result = min_energy_path(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict, deque\n\ndef update_illusion_rate(room_index: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room_index - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    # Build the adjacency list for the tree\n    tree = defaultdict(list)\n    for s, t in tunnels:\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    # Use BFS to find the path from u to v\n    def bfs(start: int, end: int) -> List[int]:\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in tree[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Reconstruct the path from u to v\n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    path = bfs(u, v)\n    \n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        a_x, a_y = illusion_rates[x - 1], illusion_rates[y - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n    \n    return total_energy\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    # Output interface\n    for query in queries:\n        if query[0] == '1':\n            room_index = int(query[1])\n            new_rate = int(query[2])\n            update_illusion_rate(room_index, new_rate, illusion_rates)\n        elif query[0] == '2':\n            u = int(query[1])\n            v = int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room in the segment tree.\"\"\"\n    # Update the illusion rate in the original list\n    illusion_rates[room - 1] = new_rate\n    # Update the segment tree\n    update_segment_tree(segment_tree, room - 1, new_rate, 0, len(illusion_rates) - 1, 0)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], lca: List[List[int]], depth: List[int]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    # Find the LCA of u and v\n    ancestor = find_lca(u, v, lca, depth)\n    # Calculate the energy required to move from u to v using the path through the LCA\n    energy = calculate_energy_path(u, ancestor, illusion_rates, tree) + calculate_energy_path(v, ancestor, illusion_rates, tree)\n    return energy\n\ndef update_segment_tree(segment_tree: List[int], index: int, value: int, start: int, end: int, node: int) -> None:\n    \"\"\"Update the segment tree with a new value at a specific index.\"\"\"\n    if start == end:\n        segment_tree[node] = value\n    else:\n        mid = (start + end) // 2\n        if start <= index <= mid:\n            update_segment_tree(segment_tree, index, value, start, mid, 2 * node + 1)\n        else:\n            update_segment_tree(segment_tree, index, value, mid + 1, end, 2 * node + 2)\n        segment_tree[node] = max(segment_tree[2 * node + 1], segment_tree[2 * node + 2])\n\ndef find_lca(u: int, v: int, lca: List[List[int]], depth: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    # Bring u and v to the same depth\n    diff = depth[u] - depth[v]\n    for i in range(len(lca[0])):\n        if diff & (1 << i):\n            u = lca[u][i]\n    if u == v:\n        return u\n    # Find the LCA\n    for i in range(len(lca[0]) - 1, -1, -1):\n        if lca[u][i] != lca[v][i]:\n            u = lca[u][i]\n            v = lca[v][i]\n    return lca[u][0]\n\ndef calculate_energy_path(u: int, ancestor: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the energy required to move from a node to its ancestor.\"\"\"\n    energy = 0\n    while u != ancestor:\n        parent = tree[u][0]  # Assuming tree[u] contains the parent as the first element\n        energy += max(abs(illusion_rates[u - 1] + illusion_rates[parent - 1]), abs(illusion_rates[u - 1] - illusion_rates[parent - 1]))\n        u = parent\n    return energy\n\ndef preprocess_tree(n: int, tree: List[List[int]], depth: List[int], lca: List[List[int]]) -> None:\n    \"\"\"Preprocess the tree using DFS to calculate depth and parent information for LCA.\"\"\"\n    def dfs(node: int, parent: int, d: int):\n        depth[node] = d\n        lca[node][0] = parent\n        for i in range(1, len(lca[node])):\n            if lca[node][i - 1] != -1:\n                lca[node][i] = lca[lca[node][i - 1]][i - 1]\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, d + 1)\n    \n    dfs(1, -1, 0)  # Start DFS from node 1 with no parent and depth 0\n\ndef build_segment_tree(illusion_rates: List[int]) -> List[int]:\n    \"\"\"Build a segment tree from the initial illusion rates.\"\"\"\n    n = len(illusion_rates)\n    segment_tree = [0] * (4 * n)\n    def build(start: int, end: int, node: int):\n        if start == end:\n            segment_tree[node] = illusion_rates[start]\n        else:\n            mid = (start + end) // 2\n            build(start, mid, 2 * node + 1)\n            build(mid + 1, end, 2 * node + 2)\n            segment_tree[node] = max(segment_tree[2 * node + 1], segment_tree[2 * node + 2])\n    \n    build(0, n - 1, 0)\n    return segment_tree\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = [input().strip() for _ in range(q)]\n    \n    # Preprocess the tree for LCA\n    depth = [-1] * (n + 1)\n    lca = [[-1] * (n.bit_length()) for _ in range(n + 1)]\n    preprocess_tree(n, tree, depth, lca)\n    \n    # Build the segment tree\n    segment_tree = build_segment_tree(illusion_rates)\n    \n    # Process each query\n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            u, c = int(parts[1]), int(parts[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif parts[0] == '2':\n            u, v = int(parts[1]), int(parts[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree, lca, depth)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree for efficient updates and queries on illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]) -> None:\n        \"\"\"Builds the segment tree from the initial data.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int) -> None:\n        \"\"\"Updates the value at a specific index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room_index: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room_index - 1] = new_rate\n    segment_tree.update(room_index - 1, new_rate)\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Finds the minimum energy required to travel from room u to room v.\"\"\"\n    def dfs(current: int, target: int, visited: List[bool], path_energy: int) -> int:\n        if current == target:\n            return path_energy\n        visited[current] = True\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                energy_cost = max(abs(illusion_rates[current - 1] + illusion_rates[neighbor - 1]),\n                                  abs(illusion_rates[current - 1] - illusion_rates[neighbor - 1]))\n                result = dfs(neighbor, target, visited, path_energy + energy_cost)\n                if result != -1:\n                    return result\n        return -1\n    \n    visited = [False] * (len(tree))\n    return dfs(u, v, visited, 0)\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates, segment_tree)\n        elif query[0] == 2:\n            result = min_energy_path(query[1], query[2], illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Update the illusion rate of a specified room.\n\n    Args:\n        illusion_rates: A list of current illusion rates for each room.\n        u: The index of the room to update (1-based index).\n        c: The new illusion rate for the room.\n    \"\"\"\n    illusion_rates[u - 1] = c\n\ndef dfs(node: int, parent: int, depth: int, adj_list: List[List[int]], \n        parent_list: List[int], depth_list: List[int]) -> None:\n    \"\"\"Perform Depth First Search to compute parent and depth information.\n\n    Args:\n        node: The current node being visited.\n        parent: The parent of the current node.\n        depth: The depth of the current node.\n        adj_list: The adjacency list representing the tree.\n        parent_list: A list to store the parent of each node.\n        depth_list: A list to store the depth of each node.\n    \"\"\"\n    parent_list[node] = parent\n    depth_list[node] = depth\n    for neighbor in adj_list[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, adj_list, parent_list, depth_list)\n\ndef lca(u: int, v: int, parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor of two nodes.\n\n    Args:\n        u: The first node.\n        v: The second node.\n        parent_list: A list containing the parent of each node.\n        depth_list: A list containing the depth of each node.\n\n    Returns:\n        The Lowest Common Ancestor of nodes u and v.\n    \"\"\"\n    # Bring both nodes to the same depth\n    while depth_list[u] > depth_list[v]:\n        u = parent_list[u]\n    while depth_list[v] > depth_list[u]:\n        v = parent_list[v]\n    \n    # Find the common ancestor\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    \n    return u\n\ndef calculate_energy(u: int, v: int, lca_node: int, illusion_rates: List[int], \n                     parent_list: List[int]) -> int:\n    \"\"\"Calculate the total energy required to travel from node u to node v.\n\n    Args:\n        u: The starting node.\n        v: The destination node.\n        lca_node: The Lowest Common Ancestor of nodes u and v.\n        illusion_rates: A list of current illusion rates for each room.\n        parent_list: A list containing the parent of each node.\n\n    Returns:\n        The total energy required to travel from node u to node v.\n    \"\"\"\n    total_energy = 0\n    # Calculate energy from u to LCA\n    current = u\n    while current != lca_node:\n        parent = parent_list[current]\n        total_energy += max(abs(illusion_rates[current] + illusion_rates[parent]),\n                            abs(illusion_rates[current] - illusion_rates[parent]))\n        current = parent\n    \n    # Calculate energy from v to LCA\n    current = v\n    while current != lca_node:\n        parent = parent_list[current]\n        total_energy += max(abs(illusion_rates[current] + illusion_rates[parent]),\n                            abs(illusion_rates[current] - illusion_rates[parent]))\n        current = parent\n    \n    return total_energy\n\ndef min_energy_path(n: int, queries: List[Tuple[int, int, int]], \n                    illusion_rates: List[int], edges: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process queries to find the minimum energy path or update illusion rates.\n\n    Args:\n        n: The number of rooms in the maze.\n        queries: A list of queries to process.\n        illusion_rates: A list of initial illusion rates for each room.\n        edges: A list of edges representing the tree structure.\n\n    Returns:\n        A list of results for each type 2 query.\n    \"\"\"\n    # Initialize adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n    for s, t in edges:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n    \n    # Prepare parent and depth lists\n    parent_list = [-1] * (n + 1)\n    depth_list = [0] * (n + 1)\n    \n    # Perform DFS to compute parent and depth information\n    dfs(1, -1, 0, adj_list, parent_list, depth_list)\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            # Type 1 query: Update illusion rate\n            _, u, c = query\n            update_illusion_rate(illusion_rates, u, c)\n        elif query[0] == 2:\n            # Type 2 query: Calculate minimum energy path\n            _, u, v = query\n            lca_node = lca(u, v, parent_list, depth_list)\n            energy = calculate_energy(u, v, lca_node, illusion_rates, parent_list)\n            results.append(energy)\n    \n    return results\n\n# Input and Output Interface\nif __name__ == \"__main__\":\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    results = min_energy_path(n, queries, illusion_rates, edges)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\ndef update_illusion_rate(u: int, c: int) -> None:\n    \"\"\"Update the illusion rate of a room.\n\n    Args:\n        u (int): The room index to update.\n        c (int): The new illusion rate for the room.\n    \"\"\"\n    # Update the illusion rate in the segment tree\n    segment_tree.update(u - 1, c)\n    illusion_rates[u - 1] = c\n\n\ndef calculate_min_energy(u: int, v: int) -> int:\n    \"\"\"Calculate the minimum energy required to reach the treasure.\n\n    Args:\n        u (int): The starting room index.\n        v (int): The destination room index.\n\n    Returns:\n        int: The minimum energy required to reach the destination.\n    \"\"\"\n    # Find the Lowest Common Ancestor (LCA) of u and v\n    lca = find_lca(u - 1, v - 1)\n    \n    # Calculate the energy required from u to v via LCA\n    energy_u_to_lca = calculate_energy_path(u - 1, lca)\n    energy_v_to_lca = calculate_energy_path(v - 1, lca)\n    \n    return energy_u_to_lca + energy_v_to_lca\n\n\ndef calculate_energy_path(start: int, end: int) -> int:\n    \"\"\"Calculate the energy required to traverse a path in the tree.\n\n    Args:\n        start (int): The starting node index.\n        end (int): The ending node index.\n\n    Returns:\n        int: The energy required to traverse the path.\n    \"\"\"\n    energy = 0\n    while start != end:\n        parent = parent_of[start]\n        energy += max(abs(illusion_rates[start] + illusion_rates[parent]),\n                      abs(illusion_rates[start] - illusion_rates[parent]))\n        start = parent\n    return energy\n\n\ndef find_lca(u: int, v: int) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\n\n    Args:\n        u (int): The first node index.\n        v (int): The second node index.\n\n    Returns:\n        int: The index of the LCA node.\n    \"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent_of[u]\n    while u != v:\n        u = parent_of[u]\n        v = parent_of[v]\n    return u\n\n\nclass SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data):\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, pos, value):\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left, right):\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\n\ndef dfs(node, parent, d):\n    parent_of[node] = parent\n    depth[node] = d\n    for neighbor in adjacency_list[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, d + 1)\n\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Initialize data structures\nparent_of = [-1] * n\ndepth = [0] * n\nadjacency_list = [[] for _ in range(n)]\n\n# Build the tree\nfor s, t in edges:\n    adjacency_list[s - 1].append(t - 1)\n    adjacency_list[t - 1].append(s - 1)\n\n# Preprocess the tree using DFS\ndfs(0, -1, 0)\n\n# Initialize the segment tree\nsegment_tree = SegmentTree(illusion_rates)\n\n# Output interface\nfor query in queries:\n    if query[0] == 1:\n        update_illusion_rate(query[1], query[2])\n    elif query[0] == 2:\n        result = calculate_min_energy(query[1], query[2])\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on efficiently processing queries related to pathfinding and dynamic updates in a tree-structured maze. The solution must handle large input sizes and provide accurate energy calculations based on the illusion rates of chambers.\nrequirement pool:\n- Efficient query processing for pathfinding\n- Dynamic updates to chamber illusion rates\n- Accurate energy calculation for paths\n- Robust handling of edge cases\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) for pathfinding and Segment Tree for efficient updates and queries. The Segment Tree will help in managing the dynamic updates to the illusion rates efficiently, while DFS will be used to calculate the minimum energy path between two chambers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, meaning there is exactly one path between any two nodes. In this problem, the maze is structured as a tree of chambers connected by tunnels.\n\n    'illusion rate'\n    Explanation: Each chamber has an associated illusion rate, which affects the energy cost of moving through tunnels. The illusion rate can be updated dynamically.\n\n    'energy cost'\n    Explanation: The energy required to move between two chambers is determined by the maximum of the absolute sum or difference of their illusion rates.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is determined by taking the maximum value between the absolute sum and absolute difference of the illusion rates of two connected chambers. In code, this can be implemented using the `max` and `abs` functions: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'least': This indicates that we need to find the minimum total energy required to travel from one chamber to another. In code, this involves finding the path with the smallest sum of energy costs.\n\n# [code logic]\n1. Parse the input to extract the number of chambers, queries, initial illusion rates, and tunnel connections.\n2. Construct a tree representation of the maze using adjacency lists.\n3. Implement a Segment Tree to handle dynamic updates to illusion rates efficiently.\n4. For each query:\n   - If it's an update query (type 1), update the illusion rate in the Segment Tree.\n   - If it's a path query (type 2), use DFS to find the path from room u to room v and calculate the total energy cost using the current illusion rates.\n5. Output the result for each type 2 query.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected output: 10\n       Explanation: With only two rooms, the energy cost is simply `max(|5 + (-5)|, |5 - (-5)|) = 10`.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected output: 0\n       Explanation: Since all illusion rates are zero, any path will have zero energy cost.\n\n    3. Maximum possible illusion rate change:\n       Input:\n       ```\n       3 2\n       1000000000 -1000000000 0\n       1 2\n       2 3\n       1 1 -1000000000\n       2 1 3\n       ```\n       Expected output: 2000000000\n       Explanation: After updating room 1's illusion rate to -1000000000, moving from room 1 to room 3 involves maximum energy cost due to large absolute values.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of using DFS for pathfinding and Segment Tree for updates. The original logic already considers dynamic updates and path calculations efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree structure with dynamic updates and pathfinding queries. The solution must be optimized for large input sizes and ensure accurate energy calculations based on the illusion rates.\nrequirement pool:\n- Implement efficient pathfinding algorithm for tree structure.\n- Ensure quick updates to illusion rates in rooms.\n- Optimize for large input sizes and numerous queries.\n- Provide accurate energy calculations based on given formula.\n- Develop a user-friendly interface for input and output handling.\nWe will use a combination of Depth First Search (DFS) for pathfinding and Segment Tree for efficiently handling updates to the illusion rates. DFS will help in calculating the minimum energy required to traverse from one room to another, while the Segment Tree will allow quick updates to the illusion rates of rooms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, consisting of nodes (rooms) and edges (tunnels). In this problem, the maze is structured as a tree, meaning there is exactly one path between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost of moving through tunnels. The illusion rate can be updated, impacting the energy calculations.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to traverse a tunnel is the maximum of the absolute values of the sum and difference of the illusion rates of the connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'least': This indicates that we need to find the minimum total energy required to reach the treasure from a starting room. In code, this involves finding the path with the lowest energy cost using algorithms like DFS or Dijkstra's algorithm.\n\n# [code logic]\n1. Parse input to construct the tree structure and initialize illusion rates.\n2. Implement DFS to find paths between rooms and calculate energy costs.\n3. Use a Segment Tree or similar data structure to efficiently handle updates to illusion rates.\n4. For each query:\n   - If it's an update query (type 1), update the illusion rate in the data structure.\n   - If it's a path query (type 2), use DFS to calculate the minimum energy required from room u to room v.\n\n# [edge case]\n    1. Minimum number of rooms: Input with n = 2, q = 1, and simple queries to test basic functionality.\n       Explanation: With only two rooms, the path is direct, and updates should be straightforward.\n    2. Maximum illusion rate: Input with maximum possible values for illusion rates (10^9) to test handling of large numbers.\n       Explanation: Ensures that calculations involving large numbers do not cause overflow or errors.\n    3. All rooms have zero illusion rate initially: Input where all initial illusion rates are zero, testing if updates and calculations handle zero values correctly.\n       Explanation: Tests if the code correctly handles cases where initial energy costs are zero.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases involving large numbers and zero values.\n    - Ensure that calculations involving large numbers are handled using Python's arbitrary-precision integers.\n    - Add checks for zero values in energy calculations to avoid unnecessary computations or errors.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to updating illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must be optimized for large input sizes and ensure quick response times for both types of queries.\nrequirement pool:\n- Implement efficient pathfinding algorithm for tree structure.\n- Develop a mechanism to update illusion rates quickly.\n- Optimize energy calculation for large datasets.\n- Ensure scalability for up to 100,000 rooms and queries.\n- Provide clear documentation and examples for users.\nWe will use Depth First Search (DFS) for pathfinding in the tree structure to efficiently calculate the minimum energy required for queries. For updating the illusion rates, we will use a simple list update operation. The networkx library can be used to handle the tree structure efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, consisting of nodes (chambers) and edges (tunnels). In this problem, the maze is represented as a tree with n chambers and n-1 tunnels.\n\n    'illusion rate'\n    Explanation: Each chamber has an associated illusion rate, which affects the energy cost of moving between chambers. The illusion rate can be updated as per the queries.\n\n    'energy calculation'\n    Explanation: The energy required to move between two chambers is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective chambers.\n\n# [phrase showing quantity relationship]\n    'n chambers indexed from 1 to n'\n    Explanation: There are n chambers, and they are indexed sequentially from 1 to n.\n\n    'n - 1 tunnels'\n    Explanation: There are n-1 tunnels connecting the chambers, forming a tree structure.\n\n# [degree adverb]\n    'least total energy'\n    Explanation: The goal is to find the minimum sum of energy required to travel from one chamber to another, considering the illusion rates.\n\n# [code logic]\n1. Parse the input to extract the number of chambers (n), number of queries (q), initial illusion rates, and the connections between chambers.\n2. Construct the tree using the networkx library or an adjacency list to represent the connections.\n3. Implement a DFS function to calculate the path and energy cost between two chambers for type 2 queries.\n4. For type 1 queries, update the illusion rate of the specified chamber.\n5. For each type 2 query, use DFS to find the path and calculate the total energy required, then output the result.\n\n# [edge case]\n    1. Minimum input size: n = 2, q = 1\n       Input: \n       ```\n       2 1\n       0 0\n       1 2\n       2 1 2\n       ```\n       Expected Output: 0\n       Explanation: With both illusion rates at 0, the energy cost is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output: 0\n       Explanation: All paths have zero energy cost due to zero illusion rates.\n\n    3. Maximum possible illusion rate:\n       Input:\n       ```\n       2 1\n       1000000000 -1000000000\n       1 2\n       2 1 2\n       ```\n       Expected Output: max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000\n       Explanation: The energy cost is determined by the maximum possible difference in illusion rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and updating operations will naturally handle these scenarios.\n", "requirement analysis:\nThe primary requirement is to efficiently handle updates to the illusion rates and calculate the minimum energy path between rooms in a tree structure. The solution must be optimized for large input sizes and frequent queries, ensuring quick response times. The challenge lies in maintaining accuracy while processing up to 100,000 queries and updates.\nrequirement pool:\n- Efficiently process type 1 and type 2 queries to handle up to 100,000 operations.\n- Accurately calculate the minimum energy required for any given path.\n- Optimize data structures to support quick updates and queries.\n- Ensure the solution scales well with the maximum constraints.\n- Provide a user-friendly interface for input and output operations.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. For the type 1 query, we will update the illusion rate of a room in constant time. For the type 2 query, we will use LCA to find the path between two rooms and calculate the minimum energy required using precomputed values. This approach ensures that both updates and queries are handled in logarithmic time, which is efficient for the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this context, it represents the maze layout where each chamber is a node and each tunnel is an edge.\n\n    'illusion rate'\n    Explanation: This is a value associated with each chamber that affects the energy cost of moving between chambers.\n\n    'energy calculation'\n    Explanation: The energy required to move between two chambers is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective chambers.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that for each movement between two rooms, the energy cost is the maximum of the absolute sum or difference of their illusion rates. In code, this can be implemented using the `max` function with `abs`.\n\n# [degree adverb]\n    'least': This refers to finding the minimum total energy required for a path. In code, this involves calculating the energy for all possible paths and selecting the smallest one.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Precompute necessary data structures for LCA to efficiently find paths between rooms.\n4. For type 1 queries, update the illusion rate of a specified room.\n5. For type 2 queries, use LCA to determine the path between two rooms and calculate the total energy using the precomputed values and current illusion rates.\n6. Output the result for each type 2 query.\n\n# [edge case]\n    1. Single path from start to end: If there's only one direct path between two rooms, calculate energy directly.\n    2. All rooms have zero illusion rate: The energy for any path should be zero since max(|0 + 0|, |0 - 0|) = 0.\n    3. Maximum possible illusion rate change: Test with maximum allowed values for illusion rates to ensure calculations handle large numbers correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of using LCA and energy calculation formula. The original logic should suffice if implemented correctly with attention to numerical limits and path calculations.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to path traversal and dynamic updates in a tree-structured maze. The solution must ensure quick processing of both types of queries while maintaining accuracy in energy calculations. Given the constraints on input size, the implementation should prioritize performance and scalability.\nrequirement pool:\n- Efficiently process type 2 queries to find minimum energy paths.\n- Implement dynamic updates for illusion rates in type 1 queries.\n- Optimize data structures for handling large input sizes.\n- Ensure accurate energy calculations for path traversal.\n- Provide clear documentation for query formats and expected outputs.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. DFS will help in calculating the initial paths and illusion rates, while the Segment Tree will allow us to handle dynamic updates and efficiently process queries related to path traversal.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, consisting of nodes (chambers) and edges (tunnels). In this problem, the maze is structured as a tree.\n\n    'illusion rate'\n    Explanation: Each chamber has an associated illusion rate, which affects the energy cost of moving between chambers.\n\n    'energy cost'\n    Explanation: The energy required to move between two chambers is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective chambers.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is determined by taking the maximum of the absolute values of the sum and difference of the illusion rates of two connected chambers. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'least': This indicates that for type 2 queries, we need to find the minimum total energy required to traverse from one chamber to another. This can be implemented using algorithms that find the shortest path in a tree, such as DFS or BFS.\n\n# [code logic]\n1. Parse the input to get the number of chambers (n), number of queries (q), initial illusion rates, and the connections between chambers.\n2. Construct the tree using adjacency lists based on the given connections.\n3. Implement DFS to calculate initial paths and store necessary information for path traversal.\n4. Use a Segment Tree to handle updates to illusion rates and efficiently process type 2 queries.\n5. For each query:\n   - If it's a type 1 query, update the illusion rate in the Segment Tree.\n   - If it's a type 2 query, use DFS or BFS to calculate the minimum energy required from chamber u to chamber v.\n\n# [edge case]\n    Edge Case 1: Minimum number of chambers (n=2) with maximum illusion rates.\n    Input: \n    ```\n    2 1\n    1000000000 -1000000000\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    2000000000\n    ```\n    Explanation: The energy cost is max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000.\n\n    Edge Case 2: All chambers have zero illusion rate.\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: The energy cost is zero since all illusion rates are zero.\n\n    Edge Case 3: Single update query followed by a path query.\n    Input:\n    ```\n    3 2\n    1 2 3\n    1 2\n    2 3\n    1 1 -1\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    5\n    ```\n    Explanation: After updating chamber 1's illusion rate to -1, the path from chamber 1 to chamber 3 has an energy cost of max(|-1 + 2|, |-1 - 2|) + max(|2 + 3|, |2 - 3|) = 3 + 2 = 5.\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently using a Segment Tree or similar data structure to ensure that updates and queries are processed within time limits for large inputs. The original logic should be adapted to include this data structure for handling dynamic updates and queries efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to updating illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must be optimized for large input sizes and ensure quick response times for both types of queries.\nrequirement pool:\n- Implement efficient data structures to handle tree traversal and updates.\n- Optimize energy calculation algorithm for quick results.\n- Ensure scalability to handle maximum input constraints.\n- Provide clear output format for energy calculations.\n- Include error handling for invalid inputs.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The Segment Tree will help in managing the illusion rates and calculating the minimum energy required for paths efficiently. This approach ensures that both types of queries are handled in logarithmic time, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, consisting of nodes (chambers) and edges (tunnels). In this problem, the maze is structured as a tree.\n\n    'illusion rate'\n    Explanation: Each chamber has an associated illusion rate, which affects the energy cost of moving between chambers.\n\n    'energy calculation'\n    Explanation: The energy required to move between two chambers is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective chambers.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two chambers is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb] \n    'least': This indicates that we need to find the minimum total energy required to reach the treasure. In code, this can be implemented by finding the shortest path in terms of energy cost using algorithms like Dijkstra's or BFS with priority queue.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists to represent tunnels between rooms.\n3. Implement a Segment Tree or similar data structure to efficiently handle updates to illusion rates and queries for minimum energy paths.\n4. For type 1 queries, update the illusion rate of a specified room.\n5. For type 2 queries, use a graph traversal algorithm (like DFS or BFS) to calculate the minimum energy path from room u to room v, considering current illusion rates.\n6. Output the result for each type 2 query.\n\n# [edge case] \n    Edge Case 1: Single path from start to end\n    Input: \n    3 1\n    5 10 15\n    1 2\n    2 3\n    2 1 3\n    Expected Output: \n    Explanation: The path is straightforward with no branches, so the calculation is direct.\n\n    Edge Case 2: All illusion rates are zero\n    Input:\n    4 1\n    0 0 0 0\n    1 2\n    2 3\n    3 4\n    2 1 4\n    Expected Output: \n    Explanation: Since all illusion rates are zero, the energy cost for any path is zero.\n\n    Edge Case 3: Maximum possible illusion rate change\n    Input:\n    2 2\n    1000000000 -1000000000\n    1 2\n    1 1 -1000000000\n    2 1 2\n    Expected Output: \n    Explanation: The update changes the illusion rate drastically, testing the system's ability to handle large numbers.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to large numbers and ensure that updates and queries are efficiently managed.\n    \n```python\ndef update_illusion_rate(segment_tree, index, new_value):\n    # Update logic for segment tree\n\ndef calculate_min_energy(tree, start, end, illusion_rates):\n    # Use BFS or Dijkstra's algorithm to find minimum energy path\n\n# Example usage:\n# update_illusion_rate(segment_tree, u, c)\n# calculate_min_energy(tree, u, v, current_illusion_rates)\n```\n\nThis approach ensures that both types of queries are handled efficiently while considering edge cases related to input constraints and potential pitfalls in calculations.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to updating illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must handle large input sizes and ensure quick updates and calculations.\nrequirement pool:\n- Efficiently process type 1 queries to update illusion rates.\n- Accurately calculate minimum energy for type 2 queries.\n- Optimize data structures for handling large input sizes.\n- Ensure the solution is scalable and performs well under load.\n- Provide clear documentation for users to understand query formats.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to find the minimum energy path between two nodes. We will use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each chamber that affects the energy required to traverse tunnels between rooms. It can be updated and influences the calculation of energy needed for movement.\n\n    'tree'\n    Explanation: The maze layout is a tree structure, meaning there are n chambers connected by n-1 tunnels, allowing movement between any pair of rooms without cycles.\n\n    'query'\n    Explanation: There are two types of queries: updating the illusion rate of a room and calculating the minimum energy required to move from one room to another.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates the calculation of energy required to traverse a tunnel between two rooms. It involves finding the maximum of two absolute values, which can be implemented using Python's `max` and `abs` functions.\n\n# [degree adverb]\n    'least': This indicates that for type 2 queries, we need to find the minimum sum of energy required to reach the secret treasure from a starting room. This can be implemented using algorithms that efficiently calculate paths, such as DFS combined with LCA.\n\n# [code logic]\n    1. Parse the input to retrieve the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on the tunnel connections.\n    3. Preprocess the tree using DFS to calculate necessary paths and prepare for LCA queries.\n    4. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    5. For type 1 queries, update the illusion rate in the Segment Tree.\n    6. For type 2 queries, use LCA to find the path between two rooms and calculate the minimum energy required using the preprocessed data.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: With both rooms having an illusion rate of 0, the energy required to move between them is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Output: 2000000000\n    Explanation: The initial energy calculation involves large numbers, testing the handling of maximum values.\n\n    Input: 4 3\n           -1 -1 -1 -1\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 4 -10\n           2 1 4\n    Output: 6\n            Explanation: The update changes one room's illusion rate significantly, affecting subsequent energy calculations.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases involving large numbers and zero values efficiently.\n        (Implement checks for large values and zero handling in energy calculations)\n        (Ensure Segment Tree updates are efficient for large values)\n        (Use Python's built-in functions to handle large integer calculations)\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree-structured maze with dynamic updates and queries. The main challenge is to ensure that the solution can handle up to 100,000 rooms and queries efficiently, which requires an optimal data structure and algorithm for both updates and path calculations.\nrequirement pool:\n- Implement efficient pathfinding algorithm for tree structure.\n- Optimize update operations for illusion rates.\n- Ensure scalability for large input sizes.\n- Provide clear and concise output for each query.\n- Maintain code readability and modularity.\nWe will use Depth First Search (DFS) for pathfinding in the tree structure and Segment Tree for efficiently handling updates to the illusion rates. The Segment Tree will allow us to update and query the illusion rates in logarithmic time, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, consisting of nodes (chambers) and edges (tunnels). In this problem, the tree structure allows traversal between any two rooms.\n\n    'illusion rate'\n    Explanation: Each chamber has an illusion rate, which affects the energy cost of moving through tunnels. The illusion rate can be updated, impacting the energy calculations.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is determined by taking the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'least': This indicates that for type 2 queries, we need to find the minimum total energy required to travel from one room to another. This involves finding the path with the lowest energy cost.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Implement a Segment Tree to handle updates to the illusion rates efficiently.\n3. For type 1 queries, update the illusion rate of a specified room using the Segment Tree.\n4. For type 2 queries, use Depth First Search (DFS) or Breadth First Search (BFS) to find the path from room u to room v, calculating the energy cost for each step using the current illusion rates.\n5. Return the total energy cost for each type 2 query.\n\n# [edge case]\n    1. Input: 2 1\n             0 0\n             1 2\n             2 1 2\n       Output: 0\n       Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    2. Input: 3 2\n             1000000000 -1000000000 0\n             1 2\n             2 3\n             2 1 3\n             1 1 -1000000000\n       Output: 2000000000\n       Explanation: Initially, moving from room 1 to room 3 requires max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000 energy.\n\n    3. Input: 4 3\n             5 -5 5 -5\n             1 2\n             2 3\n             3 4\n             2 1 4\n             1 2 5\n             2 1 4\n       Output: \n       First query: max(|5 + (-5)|, |5 - (-5)|) + max(|-5 + 5|, |-5 - 5|) + max(|5 + (-5)|, |5 - (-5)|) = 10 + 10 + 10 = 30\n       Second query after update: max(|5 + (5)|, |5 - (5)|) + max(|5 + (-5)|, |5 - (-5)|) + max(|5 + (-5)|, |5 - (-5)|) = 10 + 10 + 10 = 30\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS/BFS and Segment Tree will handle these cases efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to a tree-structured maze with dynamic updates to illusion rates. The solution must handle large datasets and provide accurate energy calculations for traversing the maze.\nrequirement pool:\n- Efficient query processing for type 2 queries\n- Dynamic updates to illusion rates for type 1 queries\n- Accurate energy calculation between chambers\n- Scalability to handle up to 100,000 queries\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the type 2 queries for finding the minimum energy path in the tree. For type 1 queries, we will update the illusion rates directly in an array. The DFS will help in precomputing necessary data for LCA, and the LCA will allow us to quickly find the path between any two nodes. We will use adjacency lists to represent the tree structure and segment trees to handle updates and queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, consisting of nodes (chambers) and edges (tunnels). In this problem, the tree structure allows traversal between any two rooms.\n\n    'illusion rate'\n    Explanation: Each chamber has an associated illusion rate, which affects the energy cost of moving through tunnels.\n\n    'energy cost'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is determined by taking the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'least': This indicates that for type 2 queries, we need to find the minimum total energy required to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest value.\n\n# [code logic]\n1. Parse input to read the number of rooms (n), number of queries (q), initial illusion rates, and the tree structure.\n2. Use Depth First Search (DFS) to precompute necessary data for Lowest Common Ancestor (LCA) calculations.\n3. Implement LCA to efficiently find paths between any two nodes.\n4. For type 1 queries, update the illusion rate of a specified room.\n5. For type 2 queries, calculate the minimum energy required to travel from one room to another using precomputed LCA data and update results accordingly.\n\n# [edge case]\n    1. Input: 2 1\n             0 0\n             1 2\n             2 1 2\n       Output: 0\n       Explanation: With both rooms having an illusion rate of 0, the energy cost is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. Input: 3 1\n             1000000000 -1000000000 0\n             1 2\n             2 3\n             2 1 3\n       Output: 2000000000\n       Explanation: The path from room 1 to room 3 involves moving through room 2, with energy costs max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000.\n\n    3. Input: 4 2\n             -5 -5 -5 -5\n             1 2\n             2 3\n             3 4\n             1 1 -10\n             2 1 4\n       Output: 15\n       Explanation: After updating room 1's illusion rate to -10, the path from room 1 to room 4 has energy costs max(|-10 + (-5)|, |-10 - (-5)|) = 15 for each segment.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA will handle these cases correctly by ensuring that all paths are considered and updates are applied as specified.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to updating illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must handle large input sizes and provide accurate results promptly.\nrequirement pool:\n- Implement efficient data structures for query processing\n- Optimize energy calculation using tree traversal algorithms\n- Ensure scalability for large input sizes\n- Provide clear and concise output formatting\n- Develop a user-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to quickly find the path between any two nodes. We will also use a Segment Tree to handle the updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each chamber that affects the energy required to traverse between rooms. It can be updated and influences the calculation of energy needed for movement.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n chambers connected by n-1 tunnels, allowing movement between any pair of rooms. This structure is crucial for efficiently finding paths and handling queries.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy required to move between two rooms, x and y. It is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'least'\n    Explanation: Refers to finding the minimum sum of energy required to reach the secret treasure from one room to another. This involves calculating the path with the lowest energy cost using techniques like DFS and LCA.\n\n# [code logic]\n    1. Preprocess the tree using DFS to calculate necessary paths and store information for LCA.\n    2. Implement LCA to quickly find paths between any two nodes.\n    3. Use a Segment Tree to efficiently handle updates to illusion rates.\n    4. For type 2 queries, calculate the minimum energy required using preprocessed data and LCA.\n    5. For type 1 queries, update the illusion rate using the Segment Tree.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 2 0\n           2 1 3\n    Expected Output: 2000000000, 2000000000\n    Explanation: Initially, moving from room 1 to room 3 requires max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = max(0, 2000000000). After updating room 2's illusion rate to 0, the energy remains max(|1000000000 + 0|, |1000000000 - 0|) = max(1000000000, 1000000000).\n\n    Input: 4 3\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 3 -10\n           2 1 4\n    Expected Output: 15, 20\n    Explanation: Initially, moving from room 1 to room 4 requires max(|-5 + (-5)|, |-5 - (-5)|) = max(-10, 0) = 10 for each segment. After updating room 3's illusion rate to -10, the energy changes accordingly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will efficiently handle all cases including edge cases.\n"], "scores": [], "pass_results": [true, true, true, false, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 967, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "condense_two2one", "parent_index": 581}
