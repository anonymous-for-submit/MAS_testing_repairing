{"name": "1582_C. Grandma Capa Knits a Scarf", "description": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "tags": ["brute force", "data structures", "greedy", "strings", "two pointers"], "difficulty": 9, "id": 1582, "sample_io": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}], "test_list": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["3\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhhyhhyyky\n", "output": ["-1\n-1\n1\n3\n3\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyzxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabcaacba\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhkhhhy\n", "output": ["-1\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nxkhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxzxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrpparlar\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxxzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyyxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nyyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcbacaa\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabbaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabca\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyzyhhhhky\n", "output": ["2\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhhyky\n", "output": ["2\n1\n1\n3\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxzzxyy\n4\nbaba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwxz\n4\nbaba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n1\n1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyx\n4\nacbb\n8\nsakparpr\n10\nkyyyhhhhky\n", "output": ["2\n1\n-1\n-1\n4\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["-1\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\naabb\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n2\n-1\n4\n"]}, {"input": "5\n8\nabcaacba\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["0\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbcaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n-1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyx\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbabca\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzzyx\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n0\n0\n-1\n-1\n"]}, {"input": "5\n8\naacaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["-1\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["3\n1\n1\n3\n2\n"]}, {"input": "5\n8\naccabcaa\n6\nxyzxyy\n4\nabbc\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["3\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nacba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nbbcaacbb\n6\nzyxzyx\n4\nabba\n8\nroqarlap\n10\nykhxhhyyhk\n", "output": ["0\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyhyhyhhky\n", "output": ["2\n1\n1\n-1\n3\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhiyyhk\n", "output": ["-1\n2\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzxx\n4\nabbb\n8\nqprarlap\n10\nkhhyyhyhky\n", "output": ["2\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nbabb\n8\nrpqapkas\n10\njyyyhhhhky\n", "output": ["2\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nzzzxyx\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyxzyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhhyky\n", "output": ["3\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkgyyhhyhky\n", "output": ["3\n1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcabcba\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbabaadba\n6\nxyyxxy\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n3\n-1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nyzywyz\n4\nacda\n8\napqrrlap\n10\nykhxhhyyhk\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbabaadba\n6\nyxxxyx\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n1\n-1\n-1\n-1\n"]}, {"input": "5\n8\ncbabacbb\n6\nyyzyxx\n4\naabb\n8\nrpqarlap\n10\nkyyyhhhhkx\n", "output": ["3\n-1\n2\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhghhyyyk\n", "output": ["2\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n0\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyyhyhhk\n", "output": ["-1\n-1\n2\n-1\n3\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaslap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqpr\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbbaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nacba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrplarqap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\ncaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrpsarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlbp\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\npalraqps\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpparlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naaba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxghyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\njhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrpraqlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\naaba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbbcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nylhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykgk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyxxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\naaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nzxxzyw\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxzxxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\ncbcaaaab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqlraap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqaralp\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaaa\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqor\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabbb\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzzx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\npalrarpr\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nzywzxx\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nacba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nzyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nyhkyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqaalrp\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacba\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}], "task_id": "codecontest/30", "prompt": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. It is important for her to erase as few symbols as possible to create a palindrome. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "repair_prompt": ["Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. It is important for her to erase as few symbols as possible to create a palindrome. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some occurrences of that letter in string s. She will make sure that the removal is done carefully and precisely. It can be done at her choice, possibly none or all.\n\nShe also wants to minimize the number of erased symbols from the pattern. It is important for her to erase as few symbols as possible to create a palindrome. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, writing a string s of length n. Grandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome, so she wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. It is important for her to erase as few symbols as possible to create a palindrome. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erased_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erased symbols required to make the string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum number of erased symbols for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_deletions_to_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                deletions += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')  # Impossible to form a palindrome by removing this character\n\n        return deletions\n\n    results = []\n\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = min_deletions_to_palindrome(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        if min_deletions == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_deletions)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_erased_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings to be processed.\n\n    Returns:\n        List[int]: List of minimum erasures required for each test case, or -1 if impossible.\n    \"\"\"\n    def can_form_palindrome_by_removing_char(s: str, char: str) -> int:\n        \"\"\"Check if a palindrome can be formed by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to be processed.\n            char (str): The character to be removed.\n\n        Returns:\n            int: Minimum number of removals required, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n    for s in test_cases:\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = can_form_palindrome_by_removing_char(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_erasures_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum erasures required for each test case, or -1 if impossible.\n    \"\"\"\n    def can_form_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Check if a palindrome can be formed by removing occurrences of a specific character.\n\n        Args:\n            s (str): The input string.\n            char_to_remove (str): The character to remove from the string.\n\n        Returns:\n            int: Minimum number of removals required to form a palindrome, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n\n    for n, s in test_cases:\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = can_form_palindrome(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append((n, s))\n\n    # Call the function and print results\n    results = min_erasures_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum removals required for each test case or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals required or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of character removals needed to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def can_form_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Check if a string can be a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to check.\n            char_to_remove (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals needed, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n    for s in test_cases:\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = can_form_palindrome(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nnum_cases = int(input())\ntest_cases = []\nfor _ in range(num_cases):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Function call\nresults = min_removals_to_palindrome(num_cases, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals needed to make each string a palindrome.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[str]): A list of strings for each test case.\n\n    Returns:\n        List[int]: A list of integers representing the minimum number of removals\n                   needed for each test case, or -1 if it's impossible.\n    \"\"\"\n    def can_form_palindrome_by_removing(s: str, char_to_remove: str) -> int:\n        \"\"\"Check if a string can be a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to check.\n            char_to_remove (str): The character to remove from the string.\n\n        Returns:\n            int: The minimum number of removals needed, or -1 if it's impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n\n    for s in test_cases:\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = can_form_palindrome_by_removing(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_removals_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[str]): A list of strings for each test case.\n\n    Returns:\n        List[int]: A list of integers representing the minimum number of erasures for each test case,\n                   or -1 if it's impossible to form a palindrome.\n    \"\"\"\n    def can_form_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Check if a palindrome can be formed by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to check.\n            char_to_remove (str): The character to remove from the string.\n\n        Returns:\n            int: The number of deletions required to form a palindrome, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                deletions += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                deletions += 1\n            else:\n                return -1\n\n        return deletions\n\n    results = []\n\n    for s in test_cases:\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = can_form_palindrome(s, char)\n            if deletions != -1:\n                min_deletions = min(min_deletions, deletions)\n\n        if min_deletions == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_deletions)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_erasures_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum deletions required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum deletions required, or a large number if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                deletions += 1\n            elif s[right] == char:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')  # Impossible to form a palindrome\n\n        return deletions\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        min_deletions = float('inf')\n        for char in set(s):\n            deletions = min_deletions_for_char(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        results.append(min_deletions if min_deletions != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_deletions_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings to be processed.\n\n    Returns:\n        List[int]: List of minimum deletions required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum deletions required, or float('inf') if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                deletions += 1\n            elif s[right] == char:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')\n\n        return deletions\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = min_deletions_for_char(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        results.append(min_deletions if min_deletions != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_deletions_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erased_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erased symbols required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum number of erased symbols for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str) -> int:\n        \"\"\"Find the minimum number of removals to make the string a palindrome.\n\n        Args:\n            s (str): The string to process.\n\n        Returns:\n            int: Minimum number of removals, or -1 if impossible.\n        \"\"\"\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            left, right = 0, len(s) - 1\n            removals = 0\n\n            while left < right:\n                if s[left] == s[right]:\n                    left += 1\n                    right -= 1\n                elif s[left] == char:\n                    left += 1\n                    removals += 1\n                elif s[right] == char:\n                    right -= 1\n                    removals += 1\n                else:\n                    removals = float('inf')\n                    break\n\n            if removals < min_removals:\n                min_removals = removals\n\n        return min_removals if min_removals != float('inf') else -1\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n        else:\n            results.append(min_removals_to_palindrome(s))\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_erased_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a string to make it a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring the sum of lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Implement the main algorithm to find the minimum number of erased symbols\n- Ensure the solution handles edge cases and large inputs efficiently\n- Optimize the algorithm for better performance\n- Provide clear documentation and comments within the code\n- Test the solution with a variety of test cases to ensure accuracy\nWe will implement a function that iterates over each character in the string and attempts to form a palindrome by removing occurrences of that character. The function will use a two-pointer technique to check if the remaining string can be a palindrome after removing the chosen character. This approach ensures that we efficiently handle large inputs by minimizing unnecessary operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. The requirement is to transform the given string into a palindrome by removing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest possible occurrences of a chosen letter to make the string a palindrome. This means we need to find the optimal letter whose removal results in the least number of deletions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest number of deletions required to achieve a palindrome, which involves choosing the optimal letter for removal.\n\n# [code logic]\n    1. For each test case, iterate over each unique character in the string.\n    2. For each character, use a two-pointer approach to simulate removing occurrences of that character and check if the remaining string can be a palindrome.\n    3. Track the number of deletions required for each character and update the minimum deletions found.\n    4. If no character can be removed to form a palindrome, return -1 for that test case.\n    5. Return the minimum number of deletions for each test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Removing two 'a's (first and last) results in 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single letter can be removed to form a palindrome, so the output is -1.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and using a two-pointer approach inherently handles these scenarios.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to convert a given string into a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with a total string length not exceeding 200,000 characters.\nrequirement pool:\n- Implement the main algorithm to find the minimum erasures for palindrome conversion\n- Ensure the solution handles large input sizes efficiently\n- Provide clear output format as specified in the requirements\n- Develop an intuitive user interface for input and output\n- Optimize the algorithm for edge cases and performance\nWe will implement a function that iterates over each character in the string and attempts to form a palindrome by removing occurrences of that character. The function will use a two-pointer technique to check if the string can be a palindrome after removing certain characters. The solution will be efficient enough to handle the constraints provided, using O(n) time complexity for each test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. The requirement is to transform the given string into a palindrome by removing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest possible occurrences of a chosen letter to make the string a palindrome. This implies optimizing the number of deletions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This indicates that the solution should aim to minimize the number of deletions required to achieve a palindrome.\n\n# [code logic]\n    1. For each test case, iterate over each unique character in the string.\n    2. Use a two-pointer approach to attempt forming a palindrome by removing occurrences of the current character.\n    3. Count the number of deletions required for each character and track the minimum deletions across all characters.\n    4. If a palindrome can be formed, return the minimum number of deletions; otherwise, return -1.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: By removing two 'a's (first and last), the string becomes 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single letter can be removed to form a palindrome, hence it's impossible.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and using two pointers will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to convert a given string into a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with string lengths up to 10^5, ensuring the sum of all string lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum erasures needed for palindrome formation\n- Ensure the solution handles multiple test cases with large input sizes\n- Optimize the algorithm for minimal computational complexity\n- Provide clear output format as specified in the requirements\n- Integrate the solution into existing systems for seamless operation\nWe will implement a function that iterates over each possible letter in the string and attempts to form a palindrome by removing occurrences of that letter. The function will use a two-pointer technique to check if the string can be a palindrome after removing the chosen letter. If a palindrome can be formed, it will calculate the minimum number of removals required. If no palindrome can be formed by removing any single letter, it will return -1. This approach ensures efficiency by minimizing unnecessary computations and handling large inputs effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. For example, 'racecar' and 'level' are palindromes.\n\n    'erase some occurrences of one letter'\n    Explanation: This means you can choose one specific letter in the string and remove any number of its occurrences (including none or all) to try to form a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means you need to find the smallest possible number of deletions required to make the string a palindrome by removing occurrences of a single chosen letter.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to achieve the smallest number of deletions possible to form a palindrome.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of deletions required, starting with a large value.\n3. Iterate over each unique character in the string s.\n4. For each character, use a two-pointer approach to check if the string can be made into a palindrome by removing occurrences of that character.\n5. If it can be made into a palindrome, calculate the number of deletions required and update the minimum if this is smaller.\n6. If no palindrome can be formed by removing any single letter, return -1 for that test case.\n7. Output the minimum number of deletions for each test case.\n\n# [edge case]\n    Test case 1: \"a\" = 0\n    Explanation: A single character is already a palindrome, so no deletions are needed.\n\n    Test case 2: \"abcba\" = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n    Test case 3: \"abcd\" = -1\n    Explanation: No single letter can be removed to make this string a palindrome, so the output is -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each character and using two pointers will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a given string to make it a palindrome, by only removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with string lengths up to 100,000, ensuring the sum of all string lengths does not exceed 200,000.\nrequirement pool:\n- Efficiently handle large input sizes\n- Provide clear output format\n- Optimize for minimal character removal\n- Handle edge cases effectively\n- Ensure solution is user-friendly\nWe will implement a function that iterates over each character in the string and attempts to make the string a palindrome by removing occurrences of that character. We will use a two-pointer technique to check if the string can be a palindrome after removing certain characters. The function will return the minimum number of removals required or -1 if it's impossible. This approach ensures efficiency even for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. For example, 'radar' and 'level' are palindromes.\n\n    'erase some occurrences'\n    Explanation: This means selectively removing instances of a chosen character from the string to achieve a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This refers to the smallest count of character removals needed to transform the string into a palindrome. In code, this can be implemented by iterating over possible characters to remove and keeping track of the minimum removals needed.\n\n# [degree adverb] \n    'minimum'\n    Explanation: The least amount of something, in this case, the fewest characters that need to be removed. In code, this is typically implemented by maintaining a variable that tracks the smallest value encountered during iterations.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of removals required, starting with a large value.\n3. Iterate over each unique character in the string:\n   - Use a two-pointer approach to check if the string can be made into a palindrome by removing occurrences of this character.\n   - If it can be made into a palindrome, calculate the number of removals needed and update the minimum if this is less than the current minimum.\n4. If no palindrome can be formed by removing any single character, return -1 for that test case.\n5. Otherwise, return the minimum number of removals found.\n\n# [edge case] \n    Test case 1: \"a\" = 0\n    Explanation: A single character is already a palindrome, so no removals are needed.\n\n    Test case 2: \"abc\" = -1\n    Explanation: No single character removal can make this string a palindrome.\n\n    Test case 3: \"aaabaaa\" = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and using a two-pointer approach will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to remove from a string to make it a palindrome, by removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring the sum of lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Efficiently handle large input sizes\n- Determine if a palindrome can be formed\n- Minimize the number of removals\n- Provide clear output format\n- Handle edge cases effectively\nWe will implement a function that iterates over each character in the string and attempts to form a palindrome by removing occurrences of that character. The function will use a two-pointer technique to check if the string can be a palindrome after removing certain characters. We will use the collections library to efficiently count character occurrences.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. For example, 'racecar' and 'level' are palindromes.\n\n    'erase some occurrences'\n    Explanation: This means selectively removing instances of a chosen character from the string to potentially form a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This refers to the smallest count of character removals needed to transform the string into a palindrome. In code, this can be implemented by iterating over possible characters to remove and calculating the minimum removals required.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The least amount of something, in this case, the fewest characters that need to be removed. In code, this is achieved by keeping track of the smallest number of removals across all possible character choices.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Define a function to check if a string can be a palindrome by removing occurrences of a specific character.\n3. Use two pointers (left and right) to traverse the string from both ends.\n4. If characters at both pointers match, move both pointers inward.\n5. If they don't match, check if removing one of them (if it matches the chosen character) can still lead to a palindrome.\n6. Track the minimum number of removals needed for each character choice.\n7. If no character choice results in a palindrome, return -1 for that test case.\n8. Output the minimum number of removals for each test case.\n\n# [edge case]\n    Test case: 1\n    Input: 1\n           a\n    Output: 0\n    Explanation: The string is already a palindrome as it consists of a single character.\n\n    Test case: 2\n    Input: 2\n           aa\n    Output: 0\n    Explanation: The string is already a palindrome as both characters are the same.\n\n    Test case: 3\n    Input: 3\n           abc\n    Output: -1\n    Explanation: No single character removal can make this string a palindrome.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each character and using two pointers will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a string to make it a palindrome by only removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum number of erasures needed.\n- Ensure the solution handles edge cases, such as already palindromic strings.\n- Optimize the solution to run within time constraints for large inputs.\n- Provide clear error handling for impossible cases.\n- Enhance user experience with detailed output explanations.\nWe will implement a function that iterates over each character in the string and attempts to make the string a palindrome by removing occurrences of that character. We will use a two-pointer technique to check if the string can be a palindrome after removing certain characters. The function will return the minimum number of removals needed or -1 if it's impossible. This approach ensures efficiency given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. For example, 'kek', 'abacaba', and 'r' are palindromes.\n\n    'erase some occurrences'\n    Explanation: This means selectively removing instances of a chosen character from the string to achieve a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This refers to the smallest possible count of character removals needed to transform the string into a palindrome.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the length of the string and the string itself.\n    2. Define a function to check if a string can be a palindrome by removing occurrences of a specific character.\n    3. Use a two-pointer approach to attempt forming a palindrome by removing characters.\n    4. Iterate over each unique character in the string and calculate the minimum number of removals needed.\n    5. If no palindrome can be formed, return -1 for that test case.\n    6. Output the results for all test cases.\n\n# [edge case] \n    Test case: \"a\" = 0\n    Explanation: A single character is already a palindrome, so no removals are needed.\n\n    Test case: \"abcba\" = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n    Test case: \"abccba\" = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if a string is already a palindrome or can be made into one by removing characters will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to make a string a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with string lengths summing up to 200,000. The output should clearly indicate the minimum erasures or if it's impossible.\nrequirement pool:\n- Develop an algorithm to find the minimum erasures for palindrome formation.\n- Ensure the solution is optimized for large input sizes.\n- Provide detailed output for each test case.\n- Handle edge cases where no erasures are needed.\n- Include comprehensive test coverage for various scenarios.\nWe will implement a function that iterates over each character in the string and attempts to form a palindrome by removing occurrences of that character. The function will check if the remaining string can be rearranged into a palindrome by comparing the characters from both ends. If a palindrome can be formed, it will calculate the number of deletions required and keep track of the minimum deletions across all characters. If no palindrome can be formed, it will return -1. This approach ensures that we efficiently handle the constraints of up to 200,000 characters across all test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The requirement is to transform the given string into a palindrome by erasing occurrences of one chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest possible occurrences of a single chosen letter to make the string a palindrome. This means finding the optimal letter whose removal results in the least number of deletions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to minimize the number of deletions needed to achieve a palindrome. This involves calculating the least number of deletions for each possible letter choice and selecting the smallest value.\n\n# [code logic]\n    1. Iterate over each test case.\n    2. For each test case, iterate over each unique character in the string.\n    3. For each character, attempt to form a palindrome by removing occurrences of that character.\n    4. Use two pointers to check if the remaining string can be rearranged into a palindrome.\n    5. Calculate the number of deletions required for each character choice.\n    6. Track the minimum number of deletions across all character choices.\n    7. If no palindrome can be formed, return -1 for that test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Choose 'a' and erase its first and last occurrences to get 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: It is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and checking for palindrome formation inherently handles edge cases like already palindromic strings or impossible transformations.\n", "requirement analysis:\nThe task requires developing an algorithm that can determine the minimum number of deletions needed to make a string a palindrome by removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions for palindrome creation.\n- Ensure the solution handles edge cases and large inputs effectively.\n- Provide clear output indicating the number of deletions or impossibility.\n- Optimize the algorithm for performance and accuracy.\n- Include comprehensive test cases to validate the solution.\nWe will implement a function that iterates over each character in the string and attempts to form a palindrome by removing occurrences of that character. The function will use a two-pointer technique to check if the remaining string is a palindrome after removals. If a palindrome can be formed, it will calculate the minimum number of deletions required. If no palindrome can be formed by removing any single character, it will return -1. This approach ensures efficiency and handles large inputs within constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. For example, 'kek' and 'abba' are palindromes.\n\n    'erase as few symbols as possible'\n    Explanation: The goal is to remove the minimum number of occurrences of a single chosen letter to make the string a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means finding the smallest count of deletions needed to achieve a palindrome. In code, this can be implemented by keeping track of the number of deletions for each character and selecting the minimum.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest possible number of deletions required to make the string a palindrome. In code, this involves comparing deletion counts for each character and choosing the smallest.\n\n# [code logic]\n1. For each test case, read the length of the string and the string itself.\n2. Initialize a variable to store the minimum number of deletions required, starting with a large value.\n3. For each character in the alphabet:\n   - Use a two-pointer approach to attempt forming a palindrome by removing occurrences of the current character.\n   - Count the number of deletions required.\n   - If a palindrome is formed, update the minimum deletions if the current count is smaller.\n4. If no palindrome can be formed by removing any single character, return -1 for that test case.\n5. Output the minimum number of deletions for each test case.\n\n# [edge case]\n    Test case 1: \"a\" = 0\n    Explanation: A single character is already a palindrome, so no deletions are needed.\n\n    Test case 2: \"abc\" = -1\n    Explanation: No single character can be removed to form a palindrome, so it's impossible.\n\n    Test case 3: \"aaabaaa\" = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each character and using two pointers will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions of a single character type to make a string a palindrome. The solution must efficiently handle up to 100 test cases with string lengths summing up to 200,000. The algorithm should focus on minimizing deletions and identifying when it's impossible to achieve a palindrome.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions required to make a string a palindrome.\n- Ensure the solution handles edge cases, such as already palindromic strings, correctly.\n- Optimize the solution to handle the maximum input size within time constraints.\n- Provide clear and concise output for each test case.\n- Implement additional test cases to ensure robustness of the solution.\nWe will iterate over each character in the string and attempt to make the string a palindrome by removing occurrences of that character. For each character, we will use a two-pointer technique to check if the string can be made a palindrome by removing only that character. If it is possible, we will count the number of deletions required and keep track of the minimum deletions across all characters. If no character can make the string a palindrome, we will return -1 for that test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. The requirement is to transform the given string into a palindrome by erasing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest possible occurrences of a chosen letter to make the string a palindrome. This means finding the optimal solution with the least deletions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This indicates that we need to find the smallest number of deletions required to achieve a palindrome. The implementation should focus on minimizing the count of erased symbols.\n\n# [code logic]\n    1. For each test case, iterate over each unique character in the string.\n    2. For each character, use a two-pointer approach to attempt to form a palindrome by removing occurrences of that character.\n    3. Count the number of deletions required for each character and track the minimum deletions.\n    4. If no character can make the string a palindrome, return -1 for that test case.\n    5. Output the minimum number of deletions for each test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: By removing two 'a's, either the first and last or all 'b's, we can form a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single character removal can make this string a palindrome.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and using a two-pointer approach will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a string to make it a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring the sum of lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Implement an efficient algorithm to determine the minimum number of erasures needed to form a palindrome.\n- Ensure the solution handles edge cases, such as already palindromic strings or impossible cases.\n- Optimize the solution to handle large inputs within the given constraints.\n- Provide clear output formatting as specified in the requirements.\n- Document the solution approach and edge case handling.\nWe will implement a function that iterates over each character in the string and attempts to form a palindrome by removing occurrences of that character. The function will use a two-pointer technique to check if the remaining string is a palindrome after removing the chosen character. The goal is to minimize the number of removals. If no palindrome can be formed, the function will return -1. This approach ensures efficiency by leveraging the two-pointer technique and iterating over the string only a few times.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. For example, 'kek' and 'abba' are palindromes.\n\n    'erase some occurrences'\n    Explanation: This means removing certain instances of a chosen character from the string to potentially form a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means we need to find the smallest number of characters to remove to make the string a palindrome.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to erase the fewest possible characters to achieve a palindrome.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of removals needed, starting with a large value.\n3. Iterate over each unique character in the string:\n   - Use a two-pointer approach to check if the string can be a palindrome by removing occurrences of the current character.\n   - Count the number of removals needed for this character.\n   - Update the minimum number of removals if this count is lower.\n4. If no palindrome can be formed by removing any character, return -1 for that test case.\n5. Otherwise, return the minimum number of removals found.\n\n# [edge case]\n    Test case: 1\n    Input: 1\n           a\n    Output: 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n    Test case: 2\n    Input: 2\n           aa\n    Output: 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n    Test case: 3\n    Input: 3\n           abc\n    Output: -1\n    Explanation: It is impossible to form a palindrome by removing occurrences of any single character.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and using the two-pointer technique will naturally handle these cases.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 224, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "mutate_method": "expand_one2two", "parent_index": 13}
