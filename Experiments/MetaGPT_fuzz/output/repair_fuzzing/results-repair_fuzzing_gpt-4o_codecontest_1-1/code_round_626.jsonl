{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, where each string s_i has a length of m. Andi really wants to organize the books in lexicographically ascending order, while Budi desires to sort them lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, where each string s_i has a length of m. Andi really wants to organize the books in lexicographically ascending order, while Budi desires to sort them lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, where each string s_i has a length of m. Andi has a strong preference for organizing the books in lexicographically ascending order. On the other hand, Budi desires to sort them lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books, with each book represented by the book title \u2014 a string s_i numbered from 1 to n, where each string s_i has a length of m. Andi really wants to organize the books in lexicographically ascending order, while Budi desires to sort them lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds: * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on 'asc-desc-ending' order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on 'asc-desc-ending' order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value as is\n                key.append(ord(char))\n        return key\n\n    # Generate a list of tuples (index, book_title) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the books using the custom key function\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Function call\nsorted_indices = sort_books_asc_desc(n, m, books)\n\n# Output interface\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of books sorted in asc-desc-ending order.\n    \"\"\"\n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Generates a sorting key for a book title based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the sorting key.\n        \"\"\"\n        odd_chars = tuple(title[i] for i in range(0, m, 2))\n        even_chars = tuple(title[i] for i in range(1, m, 2))\n        return (odd_chars, tuple(-ord(c) for c in even_chars))\n\n    # Create a list of tuples (index, book_title) to preserve original indices\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort indexed_books using the custom_sort_key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n\n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order, negate the character\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use the character as is\n                key.append(ord(char))\n        return tuple(key)\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on 'asc-desc-endingly' order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order, negate ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value as is\n                key.append(ord(char))\n        return key\n\n    # Create a list of tuples (index, book title)\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n\n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        return [(title[i], i % 2 == 0) for i in range(m)]\n\n    # Create a list of tuples (index, book_title) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the indexed books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        odd_chars = title[::2]  # Characters at odd indices (0-based)\n        even_chars = title[1::2]  # Characters at even indices (0-based)\n        # Odd-indexed characters sorted in ascending order\n        # Even-indexed characters sorted in descending order\n        return (odd_chars, ''.join(sorted(even_chars, reverse=True)))\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport functools\n\ndef asc_desc_sort(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order.\n\n    Args:\n        n: The number of book titles.\n        m: The length of each book title.\n        book_titles: A list of book titles.\n\n    Returns:\n        A list of indices representing the sorted order of book titles.\n    \"\"\"\n    \n    def custom_comparator(a: str, b: str) -> int:\n        \"\"\"Compares two strings based on asc-desc-ending order.\n\n        Args:\n            a: The first string to compare.\n            b: The second string to compare.\n\n        Returns:\n            -1 if a < b, 1 if a > b, 0 if a == b based on custom rules.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if (i + 1) % 2 == 1:  # Odd index (1-based)\n                    if a[i] < b[i]:\n                        return -1\n                    else:\n                        return 1\n                else:  # Even index (1-based)\n                    if a[i] > b[i]:\n                        return -1\n                    else:\n                        return 1\n        return 0\n\n    # Sort the book titles using the custom comparator\n    sorted_titles = sorted(range(n), key=functools.cmp_to_key(lambda i, j: custom_comparator(book_titles[i], book_titles[j])))\n    \n    # Convert 0-based indices to 1-based indices\n    sorted_indices = [i + 1 for i in sorted_titles]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = asc_desc_sort(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of original indices of books sorted in asc-desc-ending order.\n    \"\"\"\n    def custom_sort_key(book: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            book (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(book):\n            if i % 2 == 0:\n                # Odd-indexed positions (0-based index is even) - ascending order\n                key.append((char, True))\n            else:\n                # Even-indexed positions (0-based index is odd) - descending order\n                key.append((char, False))\n        return key\n\n    # Pair each book with its original index\n    indexed_books = [(book, index + 1) for index, book in enumerate(books)]\n\n    # Sort books using the custom key\n    sorted_books = sorted(indexed_books, key=lambda x: custom_sort_key(x[0]))\n\n    # Extract the original indices of the sorted books\n    sorted_indices = [index for _, index in sorted_books]\n\n    return sorted_indices\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n\n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n: Number of books.\n        m: Length of each book title.\n        books: List of book titles.\n\n    Returns:\n        List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title: The book title.\n\n        Returns:\n            A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value as is\n                key.append(ord(char))\n        return key\n\n    # Generate a list of tuples (index, book_title) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on custom asc-desc-ending order logic.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd-indexed characters (0-based index) are sorted ascending\n            if i % 2 == 0:\n                key.append((0, char))\n            # Even-indexed characters (0-based index) are sorted descending\n            else:\n                key.append((1, -ord(char)))\n        return key\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n"], "plans": ["requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order called 'asc-desc-ending'. This involves sorting characters at odd positions in ascending order and characters at even positions in descending order. The solution must handle up to 10^6 characters efficiently and output the indices of the sorted titles.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm.\n- Ensure the solution handles the maximum input size efficiently.\n- Output the indices of the sorted book titles.\n- Optimize for readability and maintainability of the code.\n- Include comprehensive test cases to validate the solution.\nWe will implement a custom sorting function that sorts book titles based on the 'asc-desc-ending' order. This involves comparing characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles up to 10^6 characters efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This is a custom sorting order where characters at odd indices are sorted in ascending order, and characters at even indices are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This refers to the dictionary order of strings, where strings are compared based on the alphabetical order of their characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles.\n3. Define a custom sorting key function:\n   - For each character in the title, if its index is odd, use the character as is (for ascending order).\n   - If its index is even, use the negative of the character's ASCII value (for descending order).\n4. Sort the list of book titles using this custom key.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: For the first character (odd index), 'A' < 'B', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: The first character (odd index) determines the order since they differ at the first position.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by comparing characters based on their indices.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd and even positions differently. Odd positions are sorted in ascending order, while even positions are sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output as per the format.\n- Handle edge cases such as minimum and maximum input sizes.\n- Include comments and documentation for code clarity.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd positions in ascending order and even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle up to 10^6 characters.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the n book titles.\n    3. Implement a custom sorting function:\n       - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n       - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At position 1 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           BA\n           AC\n    Output: 3 1 2\n    Explanation: At position 2 (even), 'B' comes before 'A', so AB comes after AC, and BA comes last.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to sort book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The solution must handle up to 10^6 characters efficiently and output the indices of the sorted titles.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Ensure the solution handles large input sizes efficiently\n- Optimize for performance and memory usage\n- Provide clear documentation and comments in the code\n- Include test cases to validate the sorting logic\nWe will implement a custom sorting function that sorts book titles based on the asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles large input sizes by optimizing the sorting logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending order'\n    Explanation: This is a custom sorting order where characters at odd indices are sorted in ascending order, and characters at even indices are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This refers to the dictionary order of strings, where strings are compared based on the alphabetical order of their characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each book title `m`.\n2. Read the list of book titles.\n3. Define a custom sorting key function:\n   - For each book title, create a tuple where each character at an odd index is used as is (for ascending order) and each character at an even index is negated (for descending order).\n4. Use Python's built-in `sorted()` function with the custom key to sort the book titles.\n5. Output the indices of the sorted book titles.\n\n# [edge case] \n    1 1\n    A\n    = 1\n    Explanation: With only one book, it is already sorted, so the output is its index, 1.\n\n    2 2\n    AB\n    BA\n    = 2 1\n    Explanation: For the first position (odd), 'A' comes before 'B', but for the second position (even), 'B' comes before 'A'. Thus, 'BA' should come before 'AB'.\n\n    3 3\n    ABC\n    ACB\n    BAC\n    = 1 3 2\n    Explanation: At the first position (odd), all start with 'A', so we look at the second position (even). 'C' comes before 'B', so 'ACB' is last. Between 'ABC' and 'BAC', 'A' comes before 'B' at the first position.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering both odd and even indexed character comparisons.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order called 'asc-desc-endingly'. This involves sorting odd-indexed characters in ascending order and even-indexed characters in descending order. The challenge is to implement an efficient sorting algorithm that can handle up to 10^6 characters in total, ensuring that the output is the indices of the sorted titles.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise output as per the format.\n- Optimize for readability and maintainability of the code.\n- Include comments and documentation for the sorting logic.\nWe will implement a custom sorting function that sorts book titles based on the 'asc-desc-endingly' order. This involves comparing characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles up to 10^6 characters efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting in alphabetical order (A-Z).\n    'lexicographically descending': means sorting in reverse alphabetical order (Z-A).\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles.\n3. Define a custom sorting key function:\n   - For each book title, create a tuple where:\n     - Characters at odd indices (1, 3, 5, ...) are taken as they are for ascending comparison.\n     - Characters at even indices (2, 4, 6, ...) are negated (using their ASCII values) for descending comparison.\n4. Use Python's `sorted()` function with the custom key to sort the book titles.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 1 (odd), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At index 1 (odd), 'A' comes before 'B' and 'C', so 'ABC' is first. At index 2 (even), 'B' comes after 'A', so 'BAC' is second.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing characters based on their indices and applying the appropriate order.\n", "requirement analysis:\nThe requirement involves sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified conditions for odd and even indexed characters. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across all test cases.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Optimize the algorithm for large input sizes\n- Ensure the solution passes all test cases\n- Provide clear documentation for the code\n- Enhance user interface for better experience\nWe will implement a custom sorting function that adheres to the asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending order' and 'lexicographically descending order'\n    Explanation: Lexicographical order is the order in which words or strings are arranged based on the alphabetical order of their component letters. Ascending order means from A to Z, while descending order means from Z to A.\n\n    'asc-desc-endingly'\n    Explanation: This is a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each book title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n        - Use this tuple as the key for sorting the list of book titles.\n    4. Sort the list using Python's built-in sort function with the custom key.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: Sorting by asc-desc-endingly, ABC comes first because 'A' < 'B' at odd index 1, CAB comes next because 'C' > 'B' at even index 2, and BAC comes last.\n\n    Input: 2 2\n           ZZ\n           AA\n    Output: 2 1\n    Explanation: At odd index 1, 'A' < 'Z', so AA comes before ZZ.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting with a custom key function will handle all cases, including edge cases.\n", "requirement analysis:\nThe task requires sorting a list of book titles based on a custom order where odd-indexed characters are sorted in ascending order and even-indexed characters in descending order. The solution must handle up to 10^6 characters efficiently, ensuring the output is the indices of the sorted titles.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm to handle large inputs efficiently.\n- Ensure the output format strictly follows the requirements.\n- Test the solution against multiple test cases for accuracy.\n- Document the code for maintainability and clarity.\nWe will implement a custom sorting function that sorts book titles based on the asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles up to 10^6 characters efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted normally and even-indexed characters are sorted in reverse.\n        - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: For position 1 (odd), 'A' < 'B', so 'BA' comes first. For position 2 (even), 'B' > 'A', confirming 'BA' comes first.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At position 1 (odd), 'A' < 'B' < 'C', so they are sorted as ABC, BAC, CAB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases by sorting based on the custom key function.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd positions in ascending order and characters at even positions in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution is optimized for large inputs.\n- Provide clear and concise output format.\n- Handle edge cases such as minimum and maximum input sizes.\n- Include comments and documentation for code clarity.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities. The key challenge is to define a custom comparator that handles the asc-desc-ending order efficiently. We will use the functools library to create a comparator function that compares strings based on the specified odd and even position rules.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Define a custom comparator function that:\n       - Compares characters at odd indices in ascending order.\n       - Compares characters at even indices in descending order.\n    4. Use Python's sorted function with the custom comparator to sort the list of titles.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: The sorting based on asc-desc-ending order results in this sequence.\n\n    Input: 2 2\n           AA\n           BB\n    Output: 1 2\n    Explanation: Both books have identical odd and even indexed characters, so they remain in their original order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a custom comparator will handle all cases, including edge cases, correctly.\n", "requirement analysis:\nThe requirement involves sorting a list of book titles based on a unique sorting order that combines both ascending and descending lexicographical orders depending on the character position. The challenge is to implement an efficient sorting algorithm that can handle up to 10^6 characters in total, ensuring that the sorting logic adheres to the specified odd-even character comparison rules.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm for book titles.\n- Ensure the solution is optimized for large inputs up to 10^6 characters.\n- Provide clear documentation and comments within the code.\n- Include test cases to validate the sorting logic.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting function that adheres to the specified odd-even character comparison rules. The function will iterate over each character position of the book titles, comparing them according to the rules: odd positions are sorted in ascending order, and even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending order'\n    Explanation: This means sorting strings based on the alphabetical order of their characters, from A to Z.\n\n    'lexicographically descending order'\n    Explanation: This means sorting strings based on the reverse alphabetical order of their characters, from Z to A.\n\n    'asc-desc-endingly'\n    Explanation: This is a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n# [phrase showing quantity relationship]\n    'odd-indexed': Refers to positions 1, 3, 5, etc., in a string.\n    'even-indexed': Refers to positions 2, 4, 6, etc., in a string.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of books (n) and the length of each book title (m).\n2. Store each book title along with its original index.\n3. Define a custom sorting function:\n   - For each character position in the book titles:\n     - If the position is odd, compare characters in ascending order.\n     - If the position is even, compare characters in descending order.\n4. Use Python's `sorted()` function with the custom key to sort the list of book titles.\n5. Extract and print the original indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At position 1 (odd), 'A' < 'B', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BCA\n           CAB\n    Output: 3 1 2\n    Explanation: At position 1 (odd), 'C' > 'A' > 'B', so 'CAB' comes first. At position 2 (even), 'B' > 'A', so 'ABC' comes before 'BCA'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing each character position according to the specified rules.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The solution must efficiently handle up to 10^6 characters in total, ensuring performance and correctness across multiple test cases.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm for book titles.\n- Ensure the solution handles large input sizes efficiently.\n- Provide clear documentation and comments within the code.\n- Optimize the algorithm for performance.\n- Include unit tests to verify the correctness of the sorting algorithm.\nWe will implement a custom sorting function that sorts the book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle large input sizes by leveraging Python's efficient sorting algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting in alphabetical order (A-Z).\n    'lexicographically descending': means sorting in reverse alphabetical order (Z-A).\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles.\n3. Define a custom sorting key function:\n   - For each character in the title, if its index is odd, use the character as is for comparison (ascending order).\n   - If its index is even, use the negative of the character's ASCII value for comparison (descending order).\n4. Sort the list of titles using this custom key function.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its position.\n\n    Input: 2 2\n           AA\n           AB\n    Output: 1 2\n    Explanation: Both books have the same first character, and since the second character is at an even index, 'A' comes after 'B' in descending order.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: The first character at odd index determines the order, so they remain in their input order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by applying the defined sorting rules consistently.\n", "requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified conditions for odd and even positions. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across all test cases.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Optimize performance for large input sizes\n- Ensure the solution passes all test cases\n- Provide clear documentation and comments in code\n- Consider edge cases and input validation\nWe will implement a custom sorting function that adheres to the asc-desc-ending order logic. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. The solution will handle large input sizes by leveraging Python's efficient sorting algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each pair of titles, compare characters at odd positions in ascending order.\n        - Compare characters at even positions in descending order.\n    4. Use Python's sorted function with the custom key to sort the list of titles.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At position 1 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           BA\n           AC\n    Output: 3 1 2\n    Explanation: At position 2 (even), 'B' comes before 'A', so AB comes after AC, and BA comes last.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting with a custom key function will handle all cases, including edge cases.\n"], "scores": [], "pass_results": [false, true, false, false, true, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 626, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "condense_two2one", "parent_index": 102}
