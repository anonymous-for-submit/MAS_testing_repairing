{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has got an array a consisting of n integers. We will denote k as the mathematic mean of these elements. It's important to note that k might not be an integer, meaning it could be a fractional number. The mathematic mean of an array is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has got an array a consisting of n integers, and let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). The mathematic mean of an array is the sum of elements divided by the number of these elements, and Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    if the elements on these positions are deleted, the mathematic mean of the\n    remaining elements is equal to the original mean.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # Calculate the required sum of the remaining elements\n        required_sum = mean * (n - 2)\n\n        # Dictionary to count occurrences of each element\n        count = defaultdict(int)\n        for num in a:\n            count[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through each element to find valid pairs\n        for i in range(n):\n            # Calculate the sum of the two elements to be removed\n            target_sum = total_sum - required_sum\n\n            # Check if there exists another element such that their combined removal maintains the mean\n            count[a[i]] -= 1\n            if target_sum - a[i] in count and count[target_sum - a[i]] > 0:\n                valid_pairs += count[target_sum - a[i]]\n            count[a[i]] += 1\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    elements at these positions keeps the mean of the remaining elements unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        element_count = defaultdict(int)\n        for num in a:\n            element_count[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element and find pairs\n        for i in range(n):\n            element_count[a[i]] -= 1  # Decrement count for current element\n            complement = target_sum - a[i]\n\n            # Check if the complement exists in the remaining elements\n            if complement in element_count:\n                valid_pairs += element_count[complement]\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append(a)\n\n# Output interface\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    the elements at these positions keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        required_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        element_count = defaultdict(int)\n        for num in a:\n            element_count[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through each element and check for valid pairs\n        for num in a:\n            complement = required_sum - num\n            if complement in element_count:\n                valid_pairs += element_count[complement]\n                # If num and complement are the same, we need to decrement the count\n                if complement == num:\n                    valid_pairs -= 1\n\n        # Each pair is counted twice (i, j) and (j, i), so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = mean * (n - 2)\n        \n        # Dictionary to count occurrences of each element\n        count = {}\n        for num in a:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        \n        valid_pairs = 0\n        \n        # Iterate through each element to find valid pairs\n        for i in range(n):\n            # Decrease the count of the current element\n            count[a[i]] -= 1\n            \n            # Calculate the required second element to maintain the mean\n            required = target_sum - (total_sum - a[i])\n            \n            # Check if the required element exists in the remaining array\n            if required in count and count[required] > 0:\n                valid_pairs += count[required]\n        \n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    removing the elements at these positions keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = mean * (n - 2)\n\n        # Dictionary to count occurrences of each element\n        element_count: Dict[int, int] = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            first_element = a[i]\n            # Calculate the required second element to maintain the mean\n            second_element = total_sum - target_sum - first_element\n\n            # Check if the second element exists in the dictionary\n            if second_element in element_count:\n                # If both elements are the same, we need at least two occurrences\n                if first_element == second_element:\n                    valid_pairs += element_count[second_element] - 1\n                else:\n                    valid_pairs += element_count[second_element]\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that if the elements\n    on these positions are deleted, the mean of the remaining elements is unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing\n            a tuple with the number of elements and the array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        total_sum = sum(a)\n        original_mean = total_sum / n\n\n        # Dictionary to count occurrences of each element\n        count = defaultdict(int)\n        for num in a:\n            count[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through each element to find valid pairs\n        for i in range(n):\n            # Calculate the required pair value\n            required_pair_value = 2 * original_mean - a[i]\n\n            # Check if the required pair value exists in the dictionary\n            if required_pair_value in count:\n                # If the required pair value is the same as the current element,\n                # we need to ensure there are at least two occurrences\n                if required_pair_value == a[i]:\n                    valid_pairs += count[required_pair_value] - 1\n                else:\n                    valid_pairs += count[required_pair_value]\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    the elements at these positions keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        required_sum = 2 * mean\n        \n        # Use a hashmap to count occurrences of each element\n        element_count = defaultdict(int)\n        for num in a:\n            element_count[num] += 1\n        \n        valid_pairs = 0\n        \n        # Iterate through each element and find pairs\n        for i in range(n):\n            element_count[a[i]] -= 1  # Decrement count for current element\n            target = required_sum - a[i]\n            \n            # Check if the target element exists in the hashmap\n            if target in element_count:\n                valid_pairs += element_count[target]\n        \n        results.append(valid_pairs)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append(a)\n\n# Output interface\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # Calculate the target sum for the remaining elements\n        target_sum = (n - 2) * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through each element to find valid pairs\n        for i in range(n):\n            # Calculate the required sum of the pair to be removed\n            required_sum = total_sum - target_sum\n\n            # Check if there exists a pair (a[i], a[j]) such that a[i] + a[j] = required_sum\n            count_map[a[i]] -= 1  # Temporarily remove a[i] from the count\n            if required_sum - a[i] in count_map:\n                valid_pairs += count_map[required_sum - a[i]]\n            count_map[a[i]] += 1  # Restore a[i] to the count\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of pairs of positions [i, j] such that if the elements on these positions are deleted,\n    the mathematic mean of (n - 2) remaining elements is equal to the mean of the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        required_sum = mean * (n - 2)\n        \n        count_map = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            # Calculate the target sum for the pair\n            target_sum = total_sum - required_sum - num\n            # Check if there exists a number in the map that can form a valid pair\n            valid_pairs += count_map[target_sum]\n            # Update the count map with the current number\n            count_map[num] += 1\n        \n        results.append(valid_pairs)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append(a)\n\n# Output interface\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices [i, j] such that removing these elements\n    from the array does not change the mean of the remaining elements.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n\n        # Calculate the required sum of the remaining elements after removing two elements\n        required_sum = mean * (n - 2)\n\n        # Use a hashmap to count occurrences of each element\n        element_count = defaultdict(int)\n        for num in case:\n            element_count[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through each element and calculate how many pairs can be formed\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the two elements to be removed\n                sum_of_two = case[i] + case[j]\n                # Check if removing these two elements keeps the mean unchanged\n                if total_sum - sum_of_two == required_sum:\n                    valid_pairs += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n# Read each test case\ncases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    cases.append(a)\n\n# Call the function and print results\nresults = count_valid_pairs(t, cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array while maintaining the original mean. This involves understanding the mathematical properties of means and efficiently iterating through possible pairs. The constraints suggest a need for optimized algorithms to handle large inputs.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Ensure accurate mean preservation after deletion\n- Optimize for large input sizes\n- Provide clear output format\n- Include error handling for edge cases\nWe will use a mathematical approach to determine the number of pairs that can be removed while maintaining the mean. The key observation is that the sum of the remaining elements must be equal to the sum of the original array minus the sum of the two removed elements. We will use a dictionary to count occurrences of each element and efficiently find pairs that satisfy the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by dividing the sum of its elements by the number of elements. In this problem, the mean must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': We need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial sum of the array and the mean.\n    2. For each element, calculate the required sum of the remaining elements after removing two elements.\n    3. Use a dictionary to count occurrences of each element.\n    4. Iterate through each element and check if there exists another element such that their combined removal maintains the mean.\n    5. Count valid pairs using the dictionary to ensure efficient lookup.\n\n# [edge case]\n    Input: 4, Array: [8, 8, 8, 8] = Output: 6\n    Explanation: Any pair can be removed since all elements are equal, maintaining the mean.\n\n    Input: 3, Array: [50, 20, 10] = Output: 0\n    Explanation: No pair can be removed to maintain the mean as all elements are distinct.\n\n    Input: 5, Array: [1, 4, 7, 3, 5] = Output: 2\n    Explanation: Removing elements at positions (1,3) or (4,5) maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic efficiently handles all cases by checking pairs using a dictionary for occurrences.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle up to 200,000 elements across all test cases, ensuring that the algorithm is optimized for both time and space complexity.\nrequirement pool:\n- Implement an efficient algorithm to find valid pairs of indices.\n- Ensure the solution handles edge cases, such as arrays with identical elements.\n- Optimize the solution to run within the given constraints for large inputs.\n- Provide clear and concise output for each test case.\n- Document the solution approach and edge cases considered.\nWe will use a mathematical approach to solve the problem efficiently. The key observation is that removing two elements from the array should not change the mean of the remaining elements. This implies that the sum of the two removed elements should be equal to twice the mean of the original array. We will use a hashmap to count occurrences of each element and then iterate over pairs to check if they satisfy the condition. This approach ensures that we handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean should remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'twice the mean'\n    Explanation: The sum of the two removed elements should be equal to twice the mean of the original array. This is because removing these elements should not change the mean of the remaining elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the sum of the array and the mean.\n    2. For each pair of elements, check if their sum equals twice the mean.\n    3. Use a hashmap to count occurrences of each element to efficiently find pairs.\n    4. Iterate over pairs and count those that satisfy the condition.\n    5. Return the count of valid pairs.\n\n# [edge case]\n    Input: 4, [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n    \n    Input: 3, [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged because their sum cannot equal twice the mean.\n    \n    Input: 5, [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1,3) or (4,5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic efficiently handles all cases by checking pairs against twice the mean condition.\n", "requirement analysis:\nThe task requires calculating the number of pairs of positions that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must efficiently handle up to 10,000 test cases and arrays with up to 200,000 elements in total.\nrequirement pool:\n- Implement efficient algorithm to find valid pairs\n- Ensure solution handles maximum constraints\n- Optimize for performance and memory usage\n- Provide clear documentation and examples\n- Enhance user interface for input and output\nWe will use a hashmap to count occurrences of each element in the array. The key observation is that for the mean to remain unchanged after removing two elements, the sum of the two removed elements must equal twice the mean of the array. This allows us to efficiently find pairs of elements that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. It represents the average value of the array.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This phrase describes how to calculate the mean of the array. In code, this can be implemented as `mean = sum(array) / len(array)`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial mean of the array.\n    2. Determine the required sum of the two elements to be removed, which is `2 * mean`.\n    3. Use a hashmap to count occurrences of each element in the array.\n    4. Iterate through each element and check if there exists another element such that their sum equals `2 * mean`.\n    5. Count all valid pairs and ensure each pair is unique (i < j).\n\n# [edge case]\n    Input: 4\n           8 8 8 8\n    Output: 6\n    Explanation: Any pair of elements can be removed since all are equal, and removing any two will not change the mean.\n\n    Input: 3\n           50 20 10\n    Output: 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n\n    Input: 5\n           1 4 7 3 5\n    Output: 2\n    Explanation: Possible pairs are (1, 3) and (4, 5) which keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic efficiently handles all cases by checking pairs that satisfy the condition of maintaining the mean.\n", "requirement analysis:\nThe task requires identifying pairs of elements in an array that can be removed while maintaining the original mean of the array. The solution must efficiently handle up to 10,000 test cases with arrays of size up to 200,000, ensuring the sum of all elements across test cases does not exceed 200,000. The algorithm should be optimized for performance and provide output in the specified format.\nrequirement pool:\n- Efficiently handle large input sizes and multiple test cases.\n- Correctly identify pairs of elements that can be removed to maintain the mean.\n- Optimize the algorithm to minimize computational complexity.\n- Ensure the output format is clear and correct for each test case.\n- Handle edge cases, such as arrays with all identical elements.\nWe will use a mathematical approach to determine the pairs of elements that can be removed while maintaining the mean. The key observation is that the sum of the remaining elements should be equal to the sum of the original array minus the sum of the two removed elements. We will use a dictionary to count occurrences of each element and efficiently find pairs that satisfy the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is calculated by dividing the sum of its elements by the number of elements. In this problem, the mean must remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove precisely two elements from the array.\n    'sum divided by n': This indicates the calculation of the mean, which is the sum of elements divided by the number of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial sum of the array and its mean.\n    2. Iterate through each pair of elements (i, j) in the array.\n    3. For each pair, calculate the sum of the remaining elements after removing a[i] and a[j].\n    4. Check if the mean of the remaining elements equals the original mean.\n    5. Count pairs that satisfy this condition.\n\n# [edge case]\n    Input: 4, [8, 8, 8, 8] = 6\n    Explanation: Any pair can be removed since all elements are equal, maintaining the mean.\n    \n    Input: 3, [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean because removing any two elements changes it.\n    \n    Input: 5, [1, 4, 7, 3, 5] = 2\n    Explanation: Removing positions (1,3) or (4,5) maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking all possible pairs and verifying if they maintain the mean.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of means and efficiently iterating over possible pairs to check the condition.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Ensure accurate mean calculation\n- Optimize for large input sizes\n- Handle edge cases gracefully\n- Provide detailed error messages for invalid inputs\nWe will use a mathematical approach to determine the number of pairs of elements that can be removed while maintaining the mean. The key observation is that the sum of the remaining elements must be equal to the sum of the original elements minus the sum of the two removed elements. We will use a dictionary to count occurrences of each element and iterate over possible pairs to check if they satisfy the condition. This approach ensures efficient computation even for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We are required to remove exactly two elements from the array to check if the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the initial sum of the array and its mean.\n2. For each element, calculate the required sum of the remaining elements after removing two elements.\n3. Use a dictionary to count occurrences of each element.\n4. Iterate over each element and calculate the required second element to maintain the mean.\n5. Check if this second element exists in the dictionary and count valid pairs.\n6. Ensure that pairs are counted only once by maintaining i < j.\n\n# [edge case]\n    Case 1: Input: [4, 4, 4, 4] = Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Case 2: Input: [50, 20, 10] = Output: 0\n    Explanation: No pair can be removed to maintain the mean as all elements are distinct and do not satisfy the condition.\n\n    Case 3: Input: [1, 4, 7, 3, 5] = Output: 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over pairs and checking conditions will naturally handle these cases.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must efficiently handle multiple test cases and large arrays, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently compute valid pairs for each test case\n- Ensure the solution handles large input sizes within constraints\n- Provide clear and concise output format\n- Optimize for edge cases where all elements are equal or no valid pairs exist\n- Maintain readability and simplicity in code implementation\nWe will iterate through each test case, calculate the total sum of the array, and then use a dictionary to count occurrences of each element. For each element, we will calculate the required pair that would maintain the mean and check if it exists in the dictionary. This approach ensures efficient computation by leveraging hash maps for quick lookups, which is crucial given the constraints on input size.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. It represents the average value of the array.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two'\n    Explanation: This indicates that precisely two elements must be removed from the array, no more, no less. In code, this means we need to find pairs of indices (i, j) where i < j.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, calculate the total sum of the array and the original mean.\n    2. Use a dictionary to count occurrences of each element in the array.\n    3. Iterate through each element and calculate the required pair that would maintain the mean.\n    4. Check if this pair exists in the dictionary.\n    5. Count valid pairs and output the result for each test case.\n\n# [edge case]\n    Input: 4\n           4\n           8 8 8 8\n    Output: 6\n    Explanation: Any pair of elements can be removed since all of them are equal, maintaining the mean.\n\n    Input: 3\n           3\n           50 20 10\n    Output: 0\n    Explanation: There is no way to delete two elements so that the mean doesn't change.\n\n    Input: 5\n           5\n           1 4 7 3 5\n    Output: 2\n    Explanation: It is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a dictionary to count occurrences and checking for valid pairs will naturally handle these cases.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices such that removing these elements keeps the mean unchanged. The solution must handle up to 200,000 elements efficiently, suggesting the need for an optimized algorithm, possibly involving sorting or hash maps to track element frequencies.\nrequirement pool:\n- Implement the main algorithm to find valid pairs.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases, such as all elements being the same.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to verify correctness.\nWe will use a hashmap to count the occurrences of each element in the array. The key insight is that for the mean to remain unchanged after removing two elements, the sum of the removed elements must equal twice the mean of the original array. This allows us to efficiently find pairs of elements that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean must remain unchanged after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We need to remove exactly two elements from the array to check if the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial mean of the array.\n    2. Determine the sum of the array.\n    3. For each element, calculate the required sum of two elements that need to be removed to keep the mean unchanged.\n    4. Use a hashmap to count occurrences of each element.\n    5. Iterate through pairs of elements and check if their sum equals twice the mean.\n    6. Count valid pairs and return the result.\n\n# [edge case]\n    Input: 4\n           8 8 8 8\n    Output: 6\n    Explanation: Any pair can be removed since all elements are equal, keeping the mean unchanged.\n\n    Input: 3\n           50 20 10\n    Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n    Input: 5\n           1 4 7 3 5\n    Output: 2\n    Explanation: Removing positions (1,3) or (4,5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic efficiently handles all cases by checking pairs of elements against the required sum condition.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of positions [i, j] such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle up to 10,000 test cases and arrays with up to 200,000 elements, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently calculate pairs of positions [i, j] for each test case\n- Ensure the solution handles large arrays within performance constraints\n- Provide clear output format as specified in the requirements\n- Handle edge cases such as arrays with identical elements\n- Optimize the solution for minimal computational complexity\nWe will use a mathematical approach to determine the pairs of elements that can be removed while keeping the mean unchanged. The key observation is that the sum of the remaining elements should be equal to the sum of the original array minus the sum of the two removed elements. We will use a hashmap to efficiently count pairs of elements that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. The task requires maintaining this mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove precisely two elements from the array.\n    'sum of elements divided by the number of these elements': This describes the calculation of the mean, which is a quantity relationship between the sum and count of elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial sum of the array and the mean.\n    2. For each pair of elements (i, j), check if removing them keeps the mean unchanged.\n    3. Use a hashmap to store and count pairs efficiently.\n    4. Iterate through possible pairs and check if the sum of remaining elements equals (n-2) * mean.\n    5. Return the count of valid pairs.\n\n# [edge case]\n    Input: 4, [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n    \n    Input: 3, [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged because the array is too small and diverse.\n    \n    Input: 5, [1, 4, 7, 3, 5] = 2\n    Explanation: Removing positions (1,3) or (4,5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap efficiently handles all cases by checking valid pairs based on sum conditions.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of means and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement the main algorithm to find valid pairs\n- Optimize the solution for large input sizes\n- Ensure the solution handles edge cases correctly\n- Provide clear documentation and comments in the code\n- Develop test cases to validate the solution\nWe will use a mathematical approach to determine the pairs of elements that can be removed without changing the mean of the array. The key observation is that the sum of the remaining elements must be equal to the sum of the original array minus the sum of the two removed elements. We will use a hashmap to efficiently count occurrences of required sums and iterate through the array to find valid pairs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean of an array is the sum of its elements divided by the number of elements. The task is to find pairs of elements that can be removed such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove exactly two elements from the array.\n    'sum of n over all testcases doesn't exceed 2 \u22c5 10^5': This indicates a constraint on the total number of elements across all test cases, which affects performance considerations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial sum of the array and the mean.\n    2. For each element, calculate the required sum of the remaining elements after removing two elements.\n    3. Use a hashmap to count occurrences of sums that can be formed by pairs of elements.\n    4. Iterate through the array to find pairs that satisfy the condition.\n    5. Return the count of such pairs.\n\n# [edge case]\n    Input: 4, [8, 8, 8, 8] = Output: 6\n    Explanation: Any pair of elements can be removed since all are equal, maintaining the mean.\n\n    Input: 3, [50, 20, 10] = Output: 0\n    Explanation: No pair can be removed without changing the mean.\n\n    Input: 5, [1, 4, 7, 3, 5] = Output: 2\n    Explanation: Pairs (1,3) and (4,5) can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should handle all cases correctly by checking possible pairs and their sums.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices [i, j] such that removing these elements from the array does not change the mean of the remaining elements. The solution must efficiently handle up to 10,000 test cases with a total of up to 200,000 elements across all test cases. The algorithm should be optimized for performance, considering the constraints on input size and value range.\nrequirement pool:\n- Implement the main algorithm to find valid pairs.\n- Optimize the solution for large input sizes.\n- Ensure the output format matches the specified requirements.\n- Handle edge cases such as arrays with identical elements.\n- Provide detailed comments and documentation for the code.\nWe will implement a function to calculate the number of valid pairs of indices [i, j] such that removing these elements from the array does not change the mean of the remaining elements. The approach involves calculating the total sum of the array and using a hashmap to efficiently count the required pairs. This ensures the solution is optimized for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean of an array is the sum of its elements divided by the number of elements. In this problem, it is denoted as k.\n\n    'delete exactly two elements'\n    Explanation: We need to find pairs of indices such that removing these two elements keeps the mean of the remaining elements the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': We are looking for pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the original mean k.\n2. For each element, calculate the required sum of the remaining elements after removing two elements.\n3. Use a hashmap to count occurrences of each element.\n4. Iterate through each element and calculate how many pairs can be formed with it such that the mean remains unchanged.\n5. Return the total count of valid pairs.\n\n# [edge case]\n    Input: 3\n           3\n           1 1 1\n    Output: 0\n    Explanation: With only three identical elements, removing any two will not change the mean, but since n-2 = 1, the mean cannot be calculated.\n\n    Input: 4\n           4\n           0 0 0 0\n    Output: 6\n    Explanation: Any pair can be removed since all elements are zero, and the mean remains zero.\n\n    Input: 5\n           5\n           10 10 10 10 10\n    Output: 10\n    Explanation: Any pair can be removed since all elements are equal, and the mean remains unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where all elements are equal or zero, as well as cases with minimal input size.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 179, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "parent_index": 25}
