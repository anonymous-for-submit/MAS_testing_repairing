{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n. There are n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done:   * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).   * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel between two rooms.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Preprocess the tree to find the path from u to v using DFS\n    path = []\n    visited = [False] * len(tree)\n    \n    def dfs(current: int, target: int) -> bool:\n        \"\"\"Depth First Search to find path from current to target.\"\"\"\n        if current == target:\n            path.append(current)\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target):\n                    return True\n        path.pop()\n        return False\n\n    dfs(u, v)\n\n    # Calculate the energy required for the path found\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], current: int, parent: int, path: List[int], paths: List[List[int]]) -> None:\n    \"\"\"Performs DFS to precompute paths from the root to all nodes.\"\"\"\n    path.append(current)\n    paths[current] = path[:]\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            dfs(tree, neighbor, current, path, paths)\n    path.pop()\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], paths: List[List[int]]) -> int:\n    \"\"\"Calculates the energy required to move from room u to room v.\"\"\"\n    path_u = paths[u]\n    path_v = paths[v]\n    # Find the lowest common ancestor (LCA)\n    i = 0\n    while i < len(path_u) and i < len(path_v) and path_u[i] == path_v[i]:\n        i += 1\n    # Calculate energy from u to LCA and from LCA to v\n    energy = 0\n    for j in range(i, len(path_u)):\n        energy += max(abs(illusion_rates[path_u[j - 1] - 1] + illusion_rates[path_u[j] - 1]),\n                      abs(illusion_rates[path_u[j - 1] - 1] - illusion_rates[path_u[j] - 1]))\n    for j in range(i, len(path_v)):\n        energy += max(abs(illusion_rates[path_v[j - 1] - 1] + illusion_rates[path_v[j] - 1]),\n                      abs(illusion_rates[path_v[j - 1] - 1] - illusion_rates[path_v[j] - 1]))\n    return energy\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    paths = [[] for _ in range(len(tree))]\n    dfs(tree, 1, -1, [], paths)  # Precompute paths using DFS starting from room 1\n    return calculate_energy(u, v, illusion_rates, paths)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            result = calculate_min_energy(query[1], query[2], illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Process the queries to update illusion rates and calculate minimum energy paths.\n\n    Args:\n        n (int): Number of rooms.\n        q (int): Number of queries.\n        illusion_rates (List[int]): Initial illusion rates of each room.\n        tunnels (List[Tuple[int, int]]): List of tunnels connecting rooms.\n        queries (List[Tuple[int, int, int]]): List of queries to process.\n\n    Returns:\n        List[int]: Results of type 2 queries.\n    \"\"\"\n    # Initialize adjacency list for the tree\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in tunnels:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Preprocess the tree using DFS to gather necessary information for LCA\n    parent = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n    dfs_order = []\n    \n    def dfs(node: int, par: int, dep: int):\n        parent[node] = par\n        depth[node] = dep\n        dfs_order.append(node)\n        for neighbor in adj_list[node]:\n            if neighbor != par:\n                dfs(neighbor, node, dep + 1)\n    \n    dfs(1, -1, 0)\n\n    # Implement LCA using Binary Lifting\n    LOG = 17  # log2(100000) is approximately 17\n    up = [[-1] * (LOG + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        up[i][0] = parent[i]\n    \n    for j in range(1, LOG + 1):\n        for i in range(1, n + 1):\n            if up[i][j - 1] != -1:\n                up[i][j] = up[up[i][j - 1]][j - 1]\n\n    def lca(u: int, v: int) -> int:\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        diff = depth[u] - depth[v]\n        for i in range(LOG + 1):\n            if (diff >> i) & 1:\n                u = up[u][i]\n        if u == v:\n            return u\n        for i in range(LOG, -1, -1):\n            if up[u][i] != up[v][i]:\n                u = up[u][i]\n                v = up[v][i]\n        return parent[u]\n\n    # Segment Tree for handling updates to illusion rates\n    class SegmentTree:\n        def __init__(self, data: List[int]):\n            self.n = len(data)\n            self.tree = [0] * (2 * self.n)\n            self.build(data)\n\n        def build(self, data: List[int]):\n            for i in range(self.n):\n                self.tree[self.n + i] = data[i]\n            for i in range(self.n - 1, 0, -1):\n                self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n        def update(self, pos: int, value: int):\n            pos += self.n\n            self.tree[pos] = value\n            while pos > 1:\n                pos //= 2\n                self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n\n        def query(self, l: int, r: int) -> int:\n            res = 0\n            l += self.n\n            r += self.n\n            while l <= r:\n                if l % 2 == 1:\n                    res += self.tree[l]\n                    l += 1\n                if r % 2 == 0:\n                    res += self.tree[r]\n                    r -= 1\n                l //= 2\n                r //= 2\n            return res\n\n    # Initialize Segment Tree with illusion rates\n    segment_tree = SegmentTree(illusion_rates)\n\n    # Process queries\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query: change illusion rate of room u to c\n            u, c = query[1], query[2]\n            segment_tree.update(u - 1, c)\n        elif query[0] == 2:\n            # Minimum energy query: calculate energy from room u to room v\n            u, v = query[1], query[2]\n            ancestor = lca(u, v)\n            energy = 0\n            # Calculate energy from u to ancestor\n            current = u\n            while current != ancestor:\n                parent_current = parent[current]\n                energy += max(abs(segment_tree.tree[segment_tree.n + current - 1] + segment_tree.tree[segment_tree.n + parent_current - 1]),\n                              abs(segment_tree.tree[segment_tree.n + current - 1] - segment_tree.tree[segment_tree.n + parent_current - 1]))\n                current = parent_current\n            # Calculate energy from v to ancestor\n            current = v\n            while current != ancestor:\n                parent_current = parent[current]\n                energy += max(abs(segment_tree.tree[segment_tree.n + current - 1] + segment_tree.tree[segment_tree.n + parent_current - 1]),\n                              abs(segment_tree.tree[segment_tree.n + current - 1] - segment_tree.tree[segment_tree.n + parent_current - 1]))\n                current = parent_current\n            results.append(energy)\n\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\nclass SegmentTree:\n    \"\"\"A Segment Tree to handle updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Updates the value at position pos to value.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(u: int, c: int, a: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of room u to c.\"\"\"\n    a[u - 1] = c\n    segment_tree.update(u - 1, c)\n\ndef calculate_minimum_energy(u: int, v: int, a: List[int], adjacency_list: Dict[int, List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    def dfs(node: int, parent: int, target: int, current_energy: int) -> int:\n        if node == target:\n            return current_energy\n        for neighbor in adjacency_list[node]:\n            if neighbor != parent:\n                energy_cost = max(abs(a[node - 1] + a[neighbor - 1]), abs(a[node - 1] - a[neighbor - 1]))\n                result = dfs(neighbor, node, target, current_energy + energy_cost)\n                if result != -1:\n                    return result\n        return -1\n    \n    return dfs(u, -1, v, 0)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    a = []\n    for _ in range(n):\n        a.append(int(data[index]))\n        index += 1\n    \n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for _ in range(n - 1):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    \n    segment_tree = SegmentTree(a)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        if query_type == 1:\n            u = int(data[index])\n            index += 1\n            c = int(data[index])\n            index += 1\n            update_illusion_rate(u, c, a, segment_tree)\n        elif query_type == 2:\n            u = int(data[index])\n            index += 1\n            v = int(data[index])\n            index += 1\n            result = calculate_minimum_energy(u, v, a, adjacency_list)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nfrom collections import defaultdict, deque\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    # Build the adjacency list for the tree\n    adjacency_list = defaultdict(list)\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    # Use BFS to find the path from u to v\n    def bfs_path(start: int, end: int) -> List[int]:\n        queue = deque([(start, [start])])\n        visited = set()\n        while queue:\n            current, path = queue.popleft()\n            if current == end:\n                return path\n            visited.add(current)\n            for neighbor in adjacency_list[current]:\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n        return []\n\n    path = bfs_path(u, v)\n    \n    # Calculate the total energy for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    \"\"\"Main function to handle input and process queries.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        queries.append(data[index:index + 3])\n        index += 3\n    \n    for query in queries:\n        if query[0] == '1':\n            room = int(query[1])\n            new_rate = int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates)\n        elif query[0] == '2':\n            u = int(query[1])\n            v = int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Tree:\n    def __init__(self, n: int, illusion_rates: List[int], tree: List[List[int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = tree\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.size = [0] * (n + 1)\n        self.chain_head = [-1] * (n + 1)\n        self.chain_index = [-1] * (n + 1)\n        self.pos_in_base = [-1] * (n + 1)\n        self.base_array = []\n        self.segment_tree = []\n        self.chain_count = 0\n        self.ptr = 0\n\n    def dfs(self, node: int, parent: int, depth: int):\n        self.parent[node] = parent\n        self.depth[node] = depth\n        self.size[node] = 1\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                self.size[node] += self.dfs(neighbor, node, depth + 1)\n        return self.size[node]\n\n    def hld(self, node: int, parent: int):\n        if self.chain_head[self.chain_count] == -1:\n            self.chain_head[self.chain_count] = node\n        self.chain_index[node] = self.chain_count\n        self.pos_in_base[node] = self.ptr\n        self.base_array.append(self.illusion_rates[node])\n        self.ptr += 1\n\n        special_child = -1\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                if special_child == -1 or self.size[neighbor] > self.size[special_child]:\n                    special_child = neighbor\n\n        if special_child != -1:\n            self.hld(special_child, node)\n\n        for neighbor in self.tree[node]:\n            if neighbor != parent and neighbor != special_child:\n                self.chain_count += 1\n                self.hld(neighbor, node)\n\n    def build_segment_tree(self):\n        n = len(self.base_array)\n        self.segment_tree = [0] * (4 * n)\n        self._build_segment_tree(0, n - 1, 0)\n\n    def _build_segment_tree(self, start: int, end: int, node: int):\n        if start == end:\n            self.segment_tree[node] = self.base_array[start]\n        else:\n            mid = (start + end) // 2\n            self._build_segment_tree(start, mid, 2 * node + 1)\n            self._build_segment_tree(mid + 1, end, 2 * node + 2)\n            self.segment_tree[node] = self.segment_tree[2 * node + 1] + self.segment_tree[2 * node + 2]\n\n    def update_segment_tree(self, idx: int, value: int):\n        self._update_segment_tree(0, len(self.base_array) - 1, 0, idx, value)\n\n    def _update_segment_tree(self, start: int, end: int, node: int, idx: int, value: int):\n        if start == end:\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self._update_segment_tree(start, mid, 2 * node + 1, idx, value)\n            else:\n                self._update_segment_tree(mid + 1, end, 2 * node + 2, idx, value)\n            self.segment_tree[node] = self.segment_tree[2 * node + 1] + self.segment_tree[2 * node + 2]\n\n    def query_segment_tree(self, l: int, r: int) -> int:\n        return self._query_segment_tree(0, len(self.base_array) - 1, 0, l, r)\n\n    def _query_segment_tree(self, start: int, end: int, node: int, l: int, r: int) -> int:\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.segment_tree[node]\n        mid = (start + end) // 2\n        left_query = self._query_segment_tree(start, mid, 2 * node + 1, l, r)\n        right_query = self._query_segment_tree(mid + 1, end, 2 * node + 2, l, r)\n        return left_query + right_query\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.illusion_rates[room] = new_rate\n        self.update_segment_tree(self.pos_in_base[room], new_rate)\n\n    def calculate_min_energy(self, u: int, v: int) -> int:\n        result = 0\n        while self.chain_index[u] != self.chain_index[v]:\n            if self.depth[self.chain_head[self.chain_index[u]]] < self.depth[self.chain_head[self.chain_index[v]]]:\n                u, v = v, u\n            start = self.pos_in_base[self.chain_head[self.chain_index[u]]]\n            end = self.pos_in_base[u]\n            result += self.query_segment_tree(start, end)\n            u = self.parent[self.chain_head[self.chain_index[u]]]\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u\n        start = self.pos_in_base[u]\n        end = self.pos_in_base[v]\n        result += self.query_segment_tree(start, end)\n        return result\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    maze_tree = Tree(n, illusion_rates, tree)\n    maze_tree.dfs(1, -1, 0)\n    maze_tree.hld(1, -1)\n    maze_tree.build_segment_tree()\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            maze_tree.update_illusion_rate(u, c)\n        elif query[0] == 2:\n            _, u, v = query\n            result = maze_tree.calculate_min_energy(u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tree: List[List[int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = tree\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.lca_precomputed = False\n        self.lca_ancestor = [[-1] * (n + 1) for _ in range(20)]\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int):\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.tree[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def precompute_lca(self):\n        for i in range(1, self.n + 1):\n            self.lca_ancestor[0][i] = self.parent[i]\n        for j in range(1, 20):\n            for i in range(1, self.n + 1):\n                if self.lca_ancestor[j - 1][i] != -1:\n                    self.lca_ancestor[j][i] = self.lca_ancestor[j - 1][self.lca_ancestor[j - 1][i]]\n        self.lca_precomputed = True\n\n    def find_lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        diff = self.depth[u] - self.depth[v]\n        for i in range(20):\n            if (diff >> i) & 1:\n                u = self.lca_ancestor[i][u]\n        if u == v:\n            return u\n        for i in range(19, -1, -1):\n            if self.lca_ancestor[i][u] != self.lca_ancestor[i][v]:\n                u = self.lca_ancestor[i][u]\n                v = self.lca_ancestor[i][v]\n        return self.parent[u]\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.illusion_rates[room - 1] = new_rate\n\n    def calculate_minimum_energy(self, u: int, v: int) -> int:\n        if not self.lca_precomputed:\n            self.precompute_lca()\n        lca = self.find_lca(u, v)\n        return self.calculate_energy_path(u, lca) + self.calculate_energy_path(v, lca)\n\n    def calculate_energy_path(self, start: int, end: int) -> int:\n        energy = 0\n        while start != end:\n            parent = self.parent[start]\n            energy += max(abs(self.illusion_rates[start - 1] + self.illusion_rates[parent - 1]),\n                          abs(self.illusion_rates[start - 1] - self.illusion_rates[parent - 1]))\n            start = parent\n        return energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = []\n    for _ in range(n):\n        illusion_rates.append(int(data[index]))\n        index += 1\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    maze = Maze(n, illusion_rates, tree)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        if query_type == 1:\n            u = int(data[index])\n            index += 1\n            c = int(data[index])\n            index += 1\n            maze.update_illusion_rate(u, c)\n        elif query_type == 2:\n            u = int(data[index])\n            index += 1\n            v = int(data[index])\n            index += 1\n            result = maze.calculate_minimum_energy(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\nclass Tree:\n    \"\"\"Class to represent the tree structure and handle queries.\"\"\"\n    \n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        \"\"\"Initialize the tree with nodes, illusion rates, and tunnels.\"\"\"\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.segment_tree = [0] * (4 * n)\n        \n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        \n        self._dfs(1, 0)\n        self._build_segment_tree(1, 1, n)\n    \n    def _dfs(self, node: int, parent: int):\n        \"\"\"Perform DFS to calculate depth and parent for each node.\"\"\"\n        self.parent[node] = parent\n        for neighbor in self.adj_list[node]:\n            if neighbor != parent:\n                self.depth[neighbor] = self.depth[node] + 1\n                self._dfs(neighbor, node)\n    \n    def _build_segment_tree(self, node: int, start: int, end: int):\n        \"\"\"Build the segment tree for illusion rates.\"\"\"\n        if start == end:\n            self.segment_tree[node] = self.illusion_rates[start - 1]\n        else:\n            mid = (start + end) // 2\n            self._build_segment_tree(2 * node, start, mid)\n            self._build_segment_tree(2 * node + 1, mid + 1, end)\n            self.segment_tree[node] = max(self.segment_tree[2 * node], self.segment_tree[2 * node + 1])\n    \n    def _update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int):\n        \"\"\"Update the segment tree with new illusion rate.\"\"\"\n        if start == end:\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self._update_segment_tree(2 * node, start, mid, idx, value)\n            else:\n                self._update_segment_tree(2 * node + 1, mid + 1, end, idx, value)\n            self.segment_tree[node] = max(self.segment_tree[2 * node], self.segment_tree[2 * node + 1])\n    \n    def _query_segment_tree(self, node: int, start: int, end: int, L: int, R: int) -> int:\n        \"\"\"Query the segment tree to find the maximum illusion rate in a range.\"\"\"\n        if R < start or end < L:\n            return float('-inf')\n        if L <= start and end <= R:\n            return self.segment_tree[node]\n        mid = (start + end) // 2\n        left_query = self._query_segment_tree(2 * node, start, mid, L, R)\n        right_query = self._query_segment_tree(2 * node + 1, mid + 1, end, L, R)\n        return max(left_query, right_query)\n    \n    def _lca(self, u: int, v: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n    \n    def calculate_energy(self, u: int, v: int) -> int:\n        \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n        lca = self._lca(u, v)\n        energy = 0\n        while u != lca:\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[self.parent[u] - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[self.parent[u] - 1]))\n            u = self.parent[u]\n        while v != lca:\n            energy += max(abs(self.illusion_rates[v - 1] + self.illusion_rates[self.parent[v] - 1]),\n                          abs(self.illusion_rates[v - 1] - self.illusion_rates[self.parent[v] - 1]))\n            v = self.parent[v]\n        return energy\n    \n    def update_illusion_rate(self, u: int, c: int):\n        \"\"\"Update the illusion rate of a room.\"\"\"\n        self.illusion_rates[u - 1] = c\n        self._update_segment_tree(1, 1, self.n, u, c)\n\ndef handle_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Handle the queries and return results for type 2 queries.\"\"\"\n    tree = Tree(n, illusion_rates, tunnels)\n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            # Type 1 query: Update illusion rate\n            u, c = query[1], query[2]\n            tree.update_illusion_rate(u, c)\n        elif query[0] == 2:\n            # Type 2 query: Calculate minimum energy\n            u, v = query[1], query[2]\n            energy = tree.calculate_energy(u, v)\n            results.append(energy)\n    \n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print results for type 2 queries\nresults = handle_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Build the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Update the value at index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move between two rooms.\"\"\"\n    # Construct adjacency list for the tree\n    from collections import defaultdict, deque\n    \n    adj_list = defaultdict(list)\n    for s, t in tunnels:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n    \n    # Perform BFS to find the path from u to v\n    def bfs(start: int, end: int) -> List[int]:\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in adj_list[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Reconstruct path from u to v\n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        return path[::-1]\n    \n    path = bfs(u, v)\n    \n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = []\n    for _ in range(n):\n        illusion_rates.append(int(data[index]))\n        index += 1\n    \n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        tunnels.append((s, t))\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates, segment_tree)\n        elif query_type == 2:\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tree: List[List[int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = tree\n        self.depth = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.preprocess_tree()\n\n    def preprocess_tree(self):\n        \"\"\"Preprocess the tree using DFS to prepare for LCA queries.\"\"\"\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, parent: int, depth: int):\n        \"\"\"Perform DFS to set parent and depth arrays.\"\"\"\n        self.parent[node] = parent\n        self.depth[node] = depth\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                self.dfs(neighbor, node, depth + 1)\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        \"\"\"Update the illusion rate of a specified room.\"\"\"\n        self.illusion_rates[room - 1] = new_rate\n\n    def min_energy_path(self, u: int, v: int) -> int:\n        \"\"\"Calculate the minimum energy path between two rooms using LCA.\"\"\"\n        lca = self.find_lca(u, v)\n        return self.calculate_energy(u, lca) + self.calculate_energy(v, lca)\n\n    def find_lca(self, u: int, v: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\n    def calculate_energy(self, u: int, ancestor: int) -> int:\n        \"\"\"Calculate the energy required to travel from a node to its ancestor.\"\"\"\n        energy = 0\n        while u != ancestor:\n            parent = self.parent[u]\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[parent - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[parent - 1]))\n            u = parent\n        return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    maze = Maze(n, illusion_rates, tree)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            maze.update_illusion_rate(query[1], query[2])\n        elif query[0] == 2:\n            result = maze.min_energy_path(query[1], query[2])\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on efficiently handling a large number of queries on a tree structure representing a maze. The main challenge is to ensure that updates to the illusion rates and energy calculations are performed quickly, even for the maximum constraints. The solution should be optimized for both time and space complexity.\nrequirement pool:\n- Efficiently handle up to 100,000 queries.\n- Update illusion rates in constant or logarithmic time.\n- Calculate minimum energy path efficiently.\n- Ensure the solution is scalable for large input sizes.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to quickly find the minimum energy path between any two rooms. We will also use a Segment Tree or Fenwick Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It can be changed by queries, impacting the calculation of energy.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, allowing traversal between any two rooms.\n\n    'queries'\n    Explanation: There are two types of queries: one that changes the illusion rate of a room and another that calculates the minimum energy required to travel between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates the calculation of energy required to travel between two rooms. It involves finding the maximum of the absolute values of the sum and difference of the illusion rates of two rooms.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the least amount of energy required to travel from one room to another.\n\n# [code logic]\n    1. Preprocess the tree using DFS to establish paths and calculate necessary data for LCA.\n    2. Implement LCA to efficiently find paths between any two rooms.\n    3. Use a Segment Tree or Fenwick Tree to handle updates to illusion rates efficiently.\n    4. For type 2 queries, calculate the minimum energy using preprocessed data and LCA.\n    5. For type 1 queries, update the illusion rate using the Segment Tree or Fenwick Tree.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 3 -1000000000\n           2 1 3\n    Output: 2000000000\n            2000000000\n    Explanation: The initial energy calculation involves large values, and even after changing the illusion rate, the energy remains large due to absolute value calculations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases involving large values and zero values efficiently.\n        (Implement efficient handling for large integer calculations and ensure zero values are correctly processed in energy calculations.)\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating minimum energy paths in a tree-structured maze. The solution must handle large input sizes and provide quick and accurate results for each query type.\nrequirement pool:\n- Efficient query handling for illusion rate updates\n- Accurate calculation of minimum energy paths\n- Support for large input sizes and multiple queries\n- User-friendly interface for query input and output\n- Detailed documentation of energy calculation process\nWe will use Depth First Search (DFS) to traverse the tree and calculate the minimum energy required for each query. We will utilize adjacency lists to represent the tree structure and efficiently update illusion rates using a dictionary. For path queries, we will precompute the paths using DFS and store them for quick access during queries. This approach ensures efficient handling of both types of queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of the second type of query, it refers to finding the path with the least total energy cost from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse input to construct the tree using adjacency lists.\n2. Implement DFS to precompute paths and store them for quick access.\n3. For type 1 queries, update the illusion rate in a dictionary.\n4. For type 2 queries, use precomputed paths to calculate and return the minimum energy required.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: 2 1\n              5 -5\n              1 2\n              2 1 2\n       Expected Output: 10\n       Explanation: Only one path exists, and energy is calculated as max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All rooms have zero illusion rate:\n       Input: 3 1\n              0 0 0\n              1 2\n              2 3\n              2 1 3\n       Expected Output: 0\n       Explanation: All illusion rates are zero, so energy for any path is zero.\n\n    3. Large illusion rate values:\n       Input: 3 1\n              1000000000 -1000000000 1000000000\n              1 2\n              2 3\n              2 1 3\n       Expected Output: 3000000000\n       Explanation: The path from room 1 to room 3 involves maximum energy calculations with large values.\n\n# [extra code for edge case]\n    We need extra code to handle large values efficiently due to potential integer overflow issues in some languages, but Python handles large integers natively. However, ensure that the DFS and path calculations are optimized for performance given constraints.\n", "requirement analysis:\nThe requirements focus on efficiently handling a large number of rooms and queries, ensuring that the energy calculations are accurate and quick. The system must be able to update room properties dynamically and respond to queries in real-time, even with the maximum constraints.\nrequirement pool:\n- Efficiently process up to 100,000 queries and room updates.\n- Accurately calculate the minimum energy required for any given path.\n- Provide a user-friendly interface for inputting queries and viewing results.\n- Ensure the system is robust against invalid inputs and edge cases.\n- Optimize for performance to handle the upper limits of input sizes.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary information for LCA, which will then be used to quickly compute the minimum energy path between any two rooms. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It can be changed by queries, impacting the calculation of energy.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, allowing traversal between any two rooms.\n\n    'queries'\n    Explanation: There are two types of queries: one that changes the illusion rate of a room and another that calculates the minimum energy required to travel between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy calculation for traveling between two rooms. It involves taking the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: In the context of type 2 queries, it refers to finding the least amount of energy required to travel from one room to another. This involves calculating the path with the lowest energy cost using preprocessed data structures like LCA.\n\n# [code logic]\n    1. Preprocess the tree using DFS to gather necessary information for LCA.\n    2. Implement LCA to efficiently find paths between rooms.\n    3. Use a Segment Tree to handle updates to illusion rates.\n    4. For type 2 queries, calculate the minimum energy using preprocessed data and current illusion rates.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so traveling between them requires no energy.\n\n    Input: 3 2\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n           1 2 0\n           2 1 3\n    Expected Output: 30, 20\n    Explanation: Initially, traveling from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) + max(|-10 + 10|, |-10 - 10|) = 20 + 10 = 30 energy. After updating room 2's illusion rate to 0, it requires max(|10 + 0|, |10 - 0|) + max(|0 + 10|, |0 - 10|) = 10 + 10 = 20 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will handle these cases efficiently.\n", "requirement analysis:\nThe main challenge is to efficiently handle up to 100,000 queries on a tree structure with up to 100,000 nodes. The solution must support dynamic updates to node properties and compute path costs based on these properties. The algorithm should be optimized for both time and space complexity to handle the upper limits of input size.\nrequirement pool:\n- Efficiently process type 2 queries to calculate minimum energy.\n- Implement dynamic updates for type 1 queries to change room illusion rates.\n- Optimize data structures for fast access and modification.\n- Ensure the solution is robust against edge cases and invalid inputs.\n- Provide clear and concise output for each query.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path costs efficiently. For dynamic updates, we will use a Segment Tree to handle the illusion rate changes quickly. This approach ensures that both types of queries are handled in logarithmic time complexity, making it suitable for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy cost to travel between rooms.\n\n    'energy'\n    Explanation: Energy is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute value.\n\n# [degree adverb]\n    'minimum': In the context of the query type 2, it refers to finding the path with the least sum of energy costs from room u to room v. This can be implemented using pathfinding algorithms like DFS or Dijkstra's algorithm.\n\n# [code logic]\n    1. Parse the input to construct the tree structure using adjacency lists.\n    2. Implement DFS to preprocess paths and calculate initial energy costs.\n    3. Use a Segment Tree to efficiently update illusion rates and recalculate affected paths.\n    4. For type 2 queries, use DFS or Dijkstra's algorithm to find the minimum energy path from room u to room v.\n    5. For type 1 queries, update the Segment Tree with new illusion rates.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: 10\n    Explanation: With only two rooms, the energy is calculated directly between them.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: 0\n    Explanation: Since all illusion rates are zero, the energy cost is zero.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output: Calculation based on updated rates.\n    Explanation: The change in illusion rate affects subsequent energy calculations.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to dynamic updates efficiently.\n        Implement a Segment Tree to handle updates in logarithmic time.\n        Ensure DFS or Dijkstra's algorithm accounts for updated illusion rates dynamically.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to energy calculation and illusion rate updates in a maze structured as a tree. The solution must ensure quick processing of up to 100,000 queries and handle large values for illusion rates.\nrequirement pool:\n- Efficient query handling for energy calculation\n- Accurate updates to room illusion rates\n- Clear output for each query\n- Scalable solution for large input sizes\n- User-friendly interface for input and output\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path energies efficiently. For handling updates to illusion rates, we will use a simple list update operation. The queries will be processed using DFS for path calculation and direct list updates for illusion rate changes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum sum of energy': This indicates that for type 2 queries, we need to find the path with the least total energy cost from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the given tunnels.\n3. For each query:\n   - If it's a type 1 query, update the illusion rate of the specified room.\n   - If it's a type 2 query, use DFS to find the path from room u to room v and calculate the total energy using the given formula. Return the minimum energy sum for this path.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): The simplest tree with only one tunnel.\n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected output: 10\n       Explanation: Only one path exists, and energy is max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected output: 0\n       Explanation: All energies are zero since all illusion rates are zero.\n\n    3. Large illusion rate change:\n       Input:\n       ```\n       3 2\n       1 2 3\n       1 2\n       2 3\n       1 1 1000000000\n       2 1 3\n       ```\n       Expected output: Large number (depends on calculation)\n       Explanation: The change in illusion rate significantly affects the energy calculation.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the existing logic of updating illusion rates and calculating path energies using DFS.\n", "requirement analysis:\nThe main challenge is to efficiently handle up to 100,000 queries on a tree structure with up to 100,000 nodes. The solution must support dynamic updates to node properties and calculate path energies quickly. The use of data structures like segment trees or heavy-light decomposition may be necessary to achieve the required performance.\nrequirement pool:\n- Efficiently process type 1 and type 2 queries.\n- Support dynamic updates to room illusion rates.\n- Optimize energy calculation for paths in the tree.\n- Ensure scalability for large input sizes.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Heavy-Light Decomposition (HLD) to efficiently handle path queries and updates. This approach allows us to decompose the tree into chains and use segment trees to manage updates and queries efficiently. This is suitable given the constraints of up to 100,000 nodes and queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum sum of energy': This indicates that for type 2 queries, we need to find the path with the least total energy cost from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the given connections.\n3. Implement Heavy-Light Decomposition (HLD) to decompose the tree into chains.\n4. Use segment trees to manage updates and queries efficiently on these chains.\n5. For type 1 queries, update the illusion rate of a specific room.\n6. For type 2 queries, calculate the minimum sum of energy needed to travel from room u to room v using the decomposed tree structure and segment trees.\n\n# [edge case]\n    1. Minimum number of rooms: n = 2, q = 1, with a single query to change an illusion rate.\n       Explanation: This tests the basic functionality of updating an illusion rate in a minimal tree.\n    2. All rooms have zero illusion rate initially: n = 5, q = 1, with a query to find energy from one room to another.\n       Explanation: Since all rates are zero, any path should have zero energy cost.\n    3. Maximum possible illusion rate change: n = 3, q = 1, with a query that changes an illusion rate to its maximum value.\n       Explanation: This tests handling of large numbers and ensures no overflow occurs in calculations.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to updating and querying efficiently in large trees.\n    - Implementing Heavy-Light Decomposition (HLD) and segment trees will inherently handle these edge cases by ensuring efficient updates and queries.\n    - Ensure that updates correctly propagate through the segment tree and that queries correctly aggregate results across multiple chains in HLD.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 queries and manage illusion rate updates dynamically. It should calculate the minimum energy required for treasure retrieval accurately and quickly, ensuring a seamless user experience.\nrequirement pool:\n- Efficient query handling for energy calculation\n- Dynamic update of room illusion rates\n- Accurate calculation of minimum energy required\n- Support for large datasets and queries\n- User-friendly interface for query input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in precomputing necessary information for each node, and LCA will be used to quickly find the path between any two nodes. We will also use a Segment Tree to handle dynamic updates of the illusion rates efficiently. This approach ensures that both update and query operations are handled in logarithmic time, which is suitable for the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the maze is represented as a tree with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost to travel between rooms. The illusion rate can be dynamically updated.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy cost is determined by taking the maximum of the absolute values of the sum and difference of the illusion rates of two connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum': This indicates that for type 2 queries, we need to find the minimum sum of energy required to travel from room u to room v. This involves finding the path with the least energy cost.\n\n# [code logic]\n1. Parse the input to get the number of rooms (n), number of queries (q), initial illusion rates, and the connections between rooms.\n2. Construct the tree using adjacency lists based on the given connections.\n3. Precompute necessary information using DFS for each node, such as parent and depth, to facilitate LCA queries.\n4. Implement a Segment Tree or similar data structure to handle dynamic updates of illusion rates efficiently.\n5. For type 1 queries, update the illusion rate of the specified room.\n6. For type 2 queries, use LCA to find the path between rooms u and v, and calculate the minimum energy required using precomputed information and current illusion rates.\n\n# [edge case]\n    1. Minimum number of rooms: n = 2, q = 1\n       Input: \n       ```\n       2 1\n       0 0\n       1 2\n       2 1 2\n       ```\n       Expected Output: 0\n       Explanation: With both rooms having an illusion rate of 0, the energy cost is max(|0 + 0|, |0 - 0|) = 0.\n\n    2. Maximum illusion rate change: n = 3, q = 2\n       Input:\n       ```\n       3 2\n       1000000000 -1000000000 0\n       1 2\n       2 3\n       1 1 -1000000000\n       2 1 3\n       ```\n       Expected Output: 2000000000\n       Explanation: After changing room 1's illusion rate to -1000000000, moving from room 1 to room 3 involves max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n    3. Single path with multiple queries: n = 4, q = 3\n       Input:\n       ```\n       4 3\n       1 -1 2 -2\n       1 2\n       2 3\n       3 4\n       2 1 4\n       1 3 -3\n       2 1 4\n       ```\n       Expected Output:\n       ```\n       6\n       8\n       ```\n       Explanation: Initially, moving from room 1 to room 4 costs max(|1 + (-1)|, |1 - (-1)|) + max(|-1 + 2|, |-1 - 2|) + max(|2 + (-2)|, |2 - (-2)|) = 6. After updating room 3's illusion rate to -3, the cost becomes max(|1 + (-1)|, |1 - (-1)|) + max(|-1 + (-3)|, |-1 - (-3)|) + max(|-3 + (-2)|, |-3 - (-2)|) = 8.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of using DFS for precomputation and LCA for pathfinding. The Segment Tree or similar data structure will efficiently manage updates and queries within the constraints.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates to the illusion rates and calculate the minimum energy required for traversal in a tree structure. The solution must be optimized for large input sizes and frequent queries.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Calculate minimum energy required for traversal between rooms.\n- Optimize for large input sizes and frequent queries.\n- Ensure the solution is scalable and responsive.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to find the minimum energy path between two nodes. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A data structure consisting of nodes, where each node has zero or more child nodes, and there is exactly one path between any two nodes.\n    'illusion rate': A numerical value associated with each room that affects the energy calculation when moving between rooms.\n    'query': An operation that either updates the illusion rate of a room or calculates the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'minimum': Refers to finding the smallest possible sum of energies needed to move from one room to another. This can be implemented using algorithms that efficiently calculate paths, such as DFS combined with LCA.\n\n# [code logic]\n    1. Preprocess the tree using DFS to calculate necessary paths and store information for LCA.\n    2. Implement LCA to find the path between two nodes efficiently.\n    3. Use a Segment Tree to handle updates to the illusion rates efficiently.\n    4. For type 2 queries, calculate the minimum energy required using the preprocessed data and LCA.\n\n# [edge case]\n    Case 1: When all rooms have an illusion rate of zero, moving between any rooms should result in zero energy.\n    Case 2: When there is only one query and it is a type 1 query, no output should be generated since type 1 queries do not require output.\n    Case 3: When all rooms are connected in a straight line, ensure that the path calculation correctly handles linear connections.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to zero illusion rates and linear connections.\n        if all(illusion_rate == 0 for illusion_rate in a):\n            return 0 for type 2 queries\n        Ensure DFS and LCA handle linear connections correctly without additional complexity.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 queries and accurately calculate the energy required for treasure retrieval. It should allow for quick updates to room illusion rates and provide results in a timely manner.\nrequirement pool:\n- Efficient query handling for up to 100,000 queries\n- Accurate energy calculation for treasure retrieval\n- Quick update mechanism for room illusion rates\n- Seamless user experience for query processing\n- Scalable solution for larger mazes\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate paths, while Segment Tree will allow us to update and query the illusion rates efficiently. This approach ensures that both types of queries are handled in logarithmic time, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n    'illusion rate': This is a numerical value associated with each room that affects the energy calculation when moving between rooms.\n    'query': There are two types of queries: updating the illusion rate of a room and calculating the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'minimum': This indicates that for type 2 queries, we need to find the path with the least energy cost between two rooms. This can be implemented using algorithms that find minimum paths, such as Dijkstra's algorithm or BFS/DFS with appropriate conditions.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on the tunnel connections.\n    3. Implement DFS to traverse the tree and calculate paths.\n    4. Use a Segment Tree to efficiently update and query illusion rates.\n    5. For type 1 queries, update the illusion rate of the specified room.\n    6. For type 2 queries, calculate the minimum energy required using DFS/BFS from the starting room to the target room, considering updated illusion rates.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2) with maximum illusion rates.\n    Input: \n    ```\n    2 1\n    1000000000 -1000000000\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    2000000000\n    ```\n    Explanation: The energy required is max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000.\n\n    Case 2: All rooms have zero illusion rate.\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: The energy required is max(|0 + 0|, |0 - 0|) = 0 for all paths.\n\n    Case 3: Single query to update illusion rate to maximum value.\n    Input:\n    ```\n    3 2\n    1 -1 2\n    1 2\n    2 3\n    1 1 1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    1000000003\n    ```\n    Explanation: After updating room 1's illusion rate to maximum, calculate energy from room 1 to room 3.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to updating and querying efficiently due to large constraints.\n    \n```python\ndef update_illusion_rate(segment_tree, index, value):\n    # Update logic for segment tree\n\ndef query_minimum_energy(tree, start, end):\n    # DFS/BFS logic to find minimum energy path\n\n# Additional logic for handling large values and ensuring efficient updates/queries\n```\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to energy calculations and illusion rate updates in a tree-structured maze. The solution must ensure quick processing and accurate results, especially for type 2 queries that calculate the minimum energy path.\nrequirement pool:\n- Efficient query handling for energy calculations\n- Accurate updates to room illusion rates\n- Immediate feedback for query results\n- Scalable solution for large input sizes\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to quickly find the minimum energy path between any two rooms. We will also use a Segment Tree or Fenwick Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented as `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb] \n    'minimum': In the context of the query, it refers to finding the minimum sum of energy needed to travel from one room to another. This involves finding the path with the least energy cost.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and connections between rooms.\n2. Construct the tree using adjacency lists based on the given connections.\n3. Preprocess the tree using DFS to prepare for LCA queries.\n4. For each query:\n   - If it's a type 1 query, update the illusion rate of the specified room.\n   - If it's a type 2 query, use LCA to find the path between the two rooms and calculate the minimum energy required using the preprocessed data.\n5. Output the result for each type 2 query.\n\n# [edge case] \n    1. Minimum number of rooms (n=2): \n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: 10\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output: 0\n       Explanation: Since all illusion rates are zero, any path will have zero energy cost.\n\n    3. Large illusion rate change:\n       Input:\n       ```\n       3 2\n       1 2 3\n       1 2\n       2 3\n       1 1 1000000000\n       2 1 3\n       ```\n       Expected Output: A large number based on updated rates.\n       Explanation: The update changes the illusion rate significantly, affecting energy calculations.\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently.\n    - Implement a Segment Tree or Fenwick Tree to handle updates to illusion rates efficiently.\n    - Ensure that DFS and LCA preprocessing can handle edge cases like minimum nodes or large updates without performance issues.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 598, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "add_1_sentence_at_end", "parent_index": 2}
