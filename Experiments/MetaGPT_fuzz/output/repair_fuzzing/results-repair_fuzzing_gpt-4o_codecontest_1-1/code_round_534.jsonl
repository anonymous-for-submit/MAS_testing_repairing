{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized. The challenge is to develop an efficient algorithm that can determine this minimum k value based on the given attack sequence and the dragon's hit points.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized. The challenge is to develop an efficient algorithm that can determine this minimum k value based on the given attack sequence and the dragon's hit points.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds. During this time, Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle. The i-th attack is executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon. This poison effect deals 1 damage during each of the next k seconds. It is important to note that the poison effect begins with the same second when the dragon was stabbed by the dagger. However, if the dragon has previously been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle. Therefore, he wants to identify the smallest possible value of k (the number of seconds the poison effect lasts) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized. The challenge is to develop an efficient algorithm that can determine this minimum k value based on the given attack sequence and the dragon's hit points.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is playing yet another computer game, where his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. Each attack by Monocarp occurs at specific seconds during the battle, with the i-th attack executed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon that deals 1 damage during each of the next k seconds. The poison effect begins with the same second when the dragon was stabbed by the dagger, but if the dragon has previously been poisoned, the dagger updates the poison effect (i.e., cancels the current poison effect and applies a new one). For example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4, and 10; the poison effect is applied at the start of the 2-nd second, dealing 1 damage during the 2-nd and 3-rd seconds, and reapplied at the beginning of the 4-th second, dealing exactly 1 damage during the seconds 4, 5, 6, and 7, then re-applied during the 10th second, dealing 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon receives 10 damage. Monocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to identify the smallest possible value of k (the poison effect duration) that is sufficient to deal at least h damage to the dragon. Consider the sequence and behavior of Monocarp's stabbing pattern carefully to ensure the poison effect application is maximized; the challenge is to develop an efficient algorithm that can determine this minimum k value based on the given attack sequence and the dragon's hit points.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1  # Try smaller k\n            else:\n                low = mid + 1  # Increase k\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to slay the dragon.\n            - attacks: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, 10**18  # Maximum possible k based on constraints\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = calculate_damage(n, attacks, mid)\n\n            if total_damage >= h:\n                high = mid - 1  # Try smaller k\n            else:\n                low = mid + 1  # Increase k\n\n        results.append(low)\n\n    return results\n\ndef calculate_damage(n: int, attacks: List[int], k: int) -> int:\n    \"\"\"Calculate the total damage for a given k.\n\n    Args:\n        n: Number of attacks.\n        attacks: List of attack times.\n        k: Duration of poison effect.\n\n    Returns:\n        Total damage dealt to the dragon.\n    \"\"\"\n    total_damage = 0\n\n    for i in range(n):\n        if i == n - 1:\n            # Last attack, poison lasts for k seconds\n            total_damage += k\n        else:\n            # Calculate damage for overlapping poison effects\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n\n    return total_damage\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, 10**18  # Set a large upper bound for k\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage with current mid as k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().strip().split())\n        attacks = list(map(int, input().strip().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Dragon's hit points.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, a[i + 1] - a[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1  # Try smaller k\n            else:\n                low = mid + 1  # Increase k\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Required damage to slay the dragon.\n            - attack_times: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search boundaries based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        result = h\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                result = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(result)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        low, high = 1, 10**18\n        answer = high\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate the total damage for poison duration k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            if total_damage >= h:\n                answer = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n\n        results.append(answer)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to ensure at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        low, high = 1, attacks[-1] - attacks[0] + 1\n        \n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_poison_duration(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum k value for each test case to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to slay the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, 10**18  # High is set to a large number to ensure we cover all possible k values\n\n        while low <= high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    # Last attack, poison lasts for k seconds\n                    total_damage += mid\n                else:\n                    # Poison lasts until the next attack or k seconds, whichever is smaller\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Check if the total damage is sufficient\n            if total_damage >= h:\n                high = mid - 1  # Try smaller k\n            else:\n                low = mid + 1  # Try larger k\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) that will ensure the dragon receives at least h damage. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring up to 10^18 damage. The algorithm should consider the sequence of attacks and the overlapping nature of the poison effect.\nrequirement pool:\n- Develop an algorithm to calculate the minimum k value.\n- Ensure the algorithm handles large input sizes efficiently.\n- Optimize the solution for performance and accuracy.\n- Provide clear documentation and examples for understanding.\n- Consider edge cases and validate the solution thoroughly.\nWe will use a binary search algorithm to efficiently determine the minimum k value. The binary search will help us find the smallest k such that the total damage dealt is at least h. We will calculate the damage for each k by iterating over the attack sequence and considering the overlapping poison effects.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison effect that lasts for k seconds, dealing 1 damage per second. If a new attack occurs before the current poison effect ends, the effect is reset.\n\n    'minimum k'\n    Explanation: The task is to find the smallest duration k for which the total damage dealt by the poison effect is at least h, ensuring the dragon is slain.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'smallest': This indicates that we need to find the minimum value of k that satisfies the condition. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries: low = 1, high = maximum possible k.\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Calculate total damage for k = mid using the attack sequence.\n        c. If total damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (increase k).\n    3. The result is stored in low after exiting the loop.\n\n# [edge case]\n    Case 1: Single attack with h = 1\n    Input: 1 1\n           1\n    Expected Output: 1\n    Explanation: With one attack and h = 1, k must be at least 1 to deal enough damage.\n\n    Case 2: Multiple attacks with large h\n    Input: 3 1000000000000000000\n           1 1000000000 2000000000\n    Expected Output: Large k value needed\n    Explanation: The attacks are far apart, requiring a large k to accumulate enough damage.\n\n    Case 3: Attacks at consecutive seconds\n    Input: 5 5\n           1 2 3 4 5\n    Expected Output: 1\n    Explanation: With consecutive attacks, k = 1 is sufficient to deal damage in each second.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) that will ensure the dragon receives at least h damage. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring up to 10^18 damage. The algorithm should consider the sequence of attacks and the overlapping nature of the poison effect.\nrequirement pool:\n- Develop an algorithm to calculate the minimum k value.\n- Ensure the algorithm handles large input sizes efficiently.\n- Optimize the solution for overlapping poison effects.\n- Provide clear and correct output for each test case.\n- Consider edge cases with maximum input values.\nWe will use a binary search algorithm to efficiently determine the minimum k value. The binary search will help us find the smallest k such that the total damage is at least h. We will calculate the damage for each k by iterating through the attack sequence and considering the overlapping poison effects. This approach ensures that we handle large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison effect that lasts for k seconds, dealing 1 damage per second. If a new attack occurs before the current poison effect ends, the poison effect is reset.\n\n    'minimum k'\n    Explanation: The task is to find the smallest duration k for which the total damage dealt by the poison effect is at least h, the dragon's hit points.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means that the total damage dealt must be greater than or equal to h.\n    Implementation: Ensure that the calculated damage for each k meets or exceeds h.\n\n# [degree adverb]\n    'smallest': means finding the minimum value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries: low = 1, high = maximum possible k.\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Calculate total damage for k = mid using the attack sequence.\n        c. If total damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (increase k).\n    3. Return low as the minimum k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a_1 = 1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal enough damage.\n\n    Case 2: n = 100, h = 10^18, a_i = i (for i in range 1 to 100)\n    Expected output: A large value of k\n    Explanation: With maximum h and sequential attacks, k must be large enough to accumulate sufficient damage.\n\n    Case 3: n = 2, h = 10, a_1 = 1, a_2 = 10\n    Expected output: 5\n    Explanation: The poison effect must last long enough to cover gaps between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe problem requires determining the minimum duration of a poison effect that ensures the dragon receives at least h damage. The solution must efficiently handle up to 1000 test cases, with each test case involving up to 100 attacks and requiring up to 10^18 damage. The algorithm should consider the sequence of attacks and the overlapping nature of poison effects.\nrequirement pool:\n- Develop an algorithm to calculate the minimum k value.\n- Ensure the solution is efficient for large input sizes.\n- Provide clear and concise output for each test case.\n- Handle edge cases where attacks are closely spaced.\n- Optimize for readability and maintainability of the code.\nWe will use a binary search approach to efficiently determine the minimum k value. The key observation is that the damage dealt by the poison effect is cumulative and can be calculated by iterating over the attack times and checking the overlap of poison effects. By using binary search on k, we can find the smallest k that results in at least h damage. This approach is efficient and handles the large input sizes specified in the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage for each of the next k seconds, starting from the second of the attack. If a new attack occurs before the previous poison effect ends, the poison effect is reset.\n\n    'minimum k'\n    Explanation: The smallest number of seconds the poison effect must last to ensure that the total damage is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: Ensure that the cumulative damage from all attacks is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Use binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k, calculate the total damage:\n     - Iterate over attack times and calculate damage considering overlapping poison effects.\n   - Adjust binary search bounds based on whether total damage is >= h.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal enough damage.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack must deal at least 1 damage independently.\n\n    Test case 3: n = 3, h = 10, a = [1, 2, 3] => k = 4\n    Explanation: Overlapping attacks require k to be large enough to accumulate sufficient damage over consecutive seconds.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting k based on cumulative damage calculations.\n", "requirement analysis:\nThe requirement is to find the minimum k value that ensures Monocarp deals at least h damage to the dragon. The algorithm must efficiently handle up to 1000 test cases with large input sizes, ensuring accurate results for each scenario.\nrequirement pool:\n- Develop an efficient algorithm to calculate minimum k\n- Ensure the algorithm handles large input sizes\n- Provide clear output format for test cases\n- Optimize for speed and accuracy\n- Consider edge cases and input constraints\nWe will use a binary search approach to efficiently determine the minimum k value. The key observation is that the damage dealt by the poison effect is cumulative and can be calculated by iterating over the attack times and checking the overlap of poison effects. By using binary search on k, we can find the smallest k that results in at least h damage. This approach is efficient and handles large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. Each attack applies a poison effect that lasts for k seconds, dealing 1 damage per second. If a new attack occurs before the previous poison effect ends, the poison effect is reset.\n\n    'minimum k'\n    Explanation: The task is to find the smallest duration k for which the cumulative damage from all attacks is at least h, the dragon's hit points.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the cumulative damage is >= h.\n\n# [degree adverb]\n    'smallest': This indicates that we need to find the minimum value of k that satisfies the condition of dealing at least h damage. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries: low = 1, high = maximum possible k (e.g., h).\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Calculate total damage for k = mid using the attack sequence.\n        c. If total damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (increase k).\n    3. The result is stored in low after the loop ends.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal enough damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value close to h/100\n    Explanation: With maximum attacks and maximum h, k needs to be large enough to accumulate sufficient damage.\n\n    Case 3: n = 2, h = 10^9, a = [1, 10^9]\n    Expected output: 10^9\n    Explanation: With two attacks far apart, k must be large enough to cover the gap between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on cumulative damage calculations.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect (k) needed to deal at least h damage to the dragon, given a sequence of attack times. The solution must efficiently handle large numbers and provide accurate results for multiple test cases.\nrequirement pool:\n- Develop the main algorithm to calculate minimum k\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for speed and accuracy\n- Provide clear output format for test cases\n- Include comprehensive test coverage\nWe will implement a binary search algorithm to efficiently determine the minimum k value. The key challenge is to handle large input sizes and ensure the solution is optimized for speed and accuracy. We will use Python's built-in capabilities to manage large integers and perform efficient calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon, dealing 1 damage per second for k seconds. If a new attack occurs, the poison effect is reset and starts again from that second.\n\n    'minimum k'\n    Explanation: The smallest number of seconds the poison effect lasts such that the total damage dealt is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage must be greater than or equal to h.\n    Implementation: Ensure the sum of damage over the battle period is >= h.\n\n# [degree adverb]\n    'smallest': means finding the minimum value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k (e.g., low = 1, high = maximum possible k).\n    2. For each test case, perform binary search:\n        - Calculate the total damage for a given k.\n        - If total damage >= h, adjust high boundary.\n        - If total damage < h, adjust low boundary.\n    3. Return the minimum k found for each test case.\n\n# [edge case]\n    Test case with minimum attacks and minimum h:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With one attack at second 1, k=1 is sufficient to deal at least 1 damage.\n\n    Test case with maximum h and sparse attacks:\n    2 10^18\n    1 10^9\n    Expected output: Large k value (close to 10^9)\n    Explanation: Sparse attacks require a large k to accumulate enough damage.\n\n    Test case with consecutive attacks:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Consecutive attacks mean k=1 is sufficient to deal at least 3 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting boundaries based on damage calculations.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) such that the total damage dealt to the dragon is at least h. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring up to 10^18 damage. The algorithm should consider the sequence of attacks and ensure the poison effect is maximized.\nrequirement pool:\n- Develop an efficient algorithm to calculate minimum k.\n- Ensure the solution handles large input sizes effectively.\n- Provide clear and correct output for each test case.\n- Optimize the algorithm for performance.\n- Document the solution for maintainability.\nWe will use a binary search approach to efficiently determine the minimum k value. The key observation is that the damage dealt by the poison effect is cumulative and can be calculated by iterating over the attack times. By using binary search on k, we can find the smallest k that results in at least h damage. This approach is efficient and can handle the large input sizes specified in the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon. It deals 1 damage for each of the next k seconds, starting from the second of the attack. If another attack occurs before the current poison effect ends, the poison effect is reset.\n\n    'minimum k'\n    Explanation: The smallest number of seconds the poison effect must last to ensure that the total damage is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: Use a loop to calculate cumulative damage and check if it meets or exceeds h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find this minimum value.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Initialize binary search bounds for k (e.g., low = 1, high = maximum possible k).\n4. Perform binary search:\n   - Calculate the total damage for a mid value of k.\n   - If total damage >= h, adjust high to mid.\n   - Otherwise, adjust low to mid + 1.\n5. Output the smallest k found for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, the minimum k is 1 since one second of poison is enough.\n\n    Test case 2: n = 2, h = 2, a = [1, 3] => k = 1\n    Explanation: Each attack deals 1 damage for 1 second, totaling 2 damage which meets h.\n\n    Test case 3: n = 3, h = 10^18, a = [1, 10^9, 2*10^9] => k = 10^18\n    Explanation: With very large h and spaced attacks, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on cumulative damage calculations.\n", "requirement analysis:\nThe main requirement is to develop an algorithm that efficiently calculates the minimum poison duration (k) needed to deal at least h damage to the dragon. The algorithm must handle up to 1000 test cases, with each test case having up to 100 attacks and requiring up to 10^18 damage. The solution should be optimized for performance given the constraints on input size and value ranges.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum poison duration.\n- Ensure the solution handles large input sizes effectively.\n- Provide clear and correct output for each test case.\n- Optimize the algorithm for performance given the constraints.\n- Consider edge cases and ensure robustness of the solution.\nWe will use a binary search approach to efficiently determine the minimum poison duration k. The key observation is that the total damage dealt by the poison can be calculated by iterating over the attack times and summing up the effective poison duration for each attack. By using binary search on k, we can find the smallest k that results in at least h damage. This approach is efficient and works well within the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect duration'\n    Explanation: This refers to the number of seconds during which the poison deals damage after each attack. The goal is to find the minimum duration that results in at least h damage to the dragon.\n\n    'binary search'\n    Explanation: A search algorithm that efficiently finds the minimum k by repeatedly dividing the search interval in half.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage dealt must be greater than or equal to h.\n    Implementation: Ensure the sum of damage over all attack intervals is >= h.\n\n# [degree adverb]\n    'smallest': means we need to find the minimum value of k that satisfies the condition.\n    Implementation: Use binary search to find the smallest k.\n\n# [code logic]\n    1. Initialize low and high bounds for binary search on k.\n    2. While low <= high:\n        a. Calculate mid as (low + high) // 2.\n        b. Calculate total damage for current mid value.\n        c. If total damage >= h, update result and set high = mid - 1.\n        d. Else, set low = mid + 1.\n    3. Return the result as the minimum k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to deal any damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large k value\n    Explanation: The dragon has extremely high hit points, requiring a large k to accumulate enough damage.\n\n    Case 3: n = 2, h = 5, a = [1, 10]\n    Expected output: 5\n    Explanation: The attacks are far apart, requiring k to cover the gap and deal sufficient damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe problem requires determining the minimum duration of poison effect (k) such that the total damage dealt is at least h. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring up to 10^18 damage. The attacks are given in increasing order of time, and the poison effect can be reapplied, resetting its duration.\nrequirement pool:\n- Develop an efficient algorithm to calculate minimum k.\n- Ensure the solution handles large input sizes and high damage requirements.\n- Optimize the algorithm for both small and large test cases.\n- Provide clear documentation and examples for understanding the solution.\n- Consider edge cases and ensure robustness of the solution.\nWe will use a binary search approach to efficiently determine the minimum poison duration k. The key observation is that if a certain k is sufficient to deal at least h damage, then any larger k will also be sufficient. This allows us to use binary search over the possible values of k. For each test case, we will simulate the damage dealt for a given k and check if it meets or exceeds the required damage h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect duration'\n    Explanation: This refers to the number of seconds during which the poison deals damage after each attack. The goal is to find the minimum duration that ensures the total damage is at least h.\n\n    'binary search'\n    Explanation: A search algorithm that efficiently finds the minimum k by checking midpoints and adjusting the search range based on whether the current k is sufficient.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'smallest': This indicates that we need to find the minimum value of k that satisfies the condition. In code, this is achieved by narrowing down the search range using binary search.\n\n# [code logic]\n1. Initialize variables for binary search: low = 1, high = maximum possible k (e.g., 10^9).\n2. While low <= high:\n   - Calculate mid = (low + high) // 2.\n   - Simulate the damage dealt with poison duration k = mid.\n   - If the damage is at least h, update high = mid - 1 and store mid as a potential answer.\n   - Otherwise, update low = mid + 1.\n3. Return the stored answer as the minimum k.\n\n# [edge case]\n    Test case with minimum attacks:\n    Input: 1 1\n           1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k = 1 is sufficient.\n\n    Test case with maximum h:\n    Input: 1 10^18\n           1\n    Expected output: 10^18\n    Explanation: With only one attack, k must be equal to h to deal enough damage.\n\n    Test case with consecutive attacks:\n    Input: 3 3\n           1 2 3\n    Expected output: 1\n    Explanation: Each attack occurs consecutively, so k = 1 is sufficient to deal damage in each second.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the search range based on damage calculations.\n", "requirement analysis:\nThe problem requires determining the minimum duration of the poison effect (k) such that the total damage dealt to the dragon is at least h. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring damage calculations for very large h values.\nrequirement pool:\n- Develop an algorithm to calculate the minimum k for each test case.\n- Ensure the solution is optimized for large input sizes.\n- Provide detailed documentation and examples for understanding the solution.\n- Implement error handling for edge cases.\n- Optimize the algorithm for speed and memory usage.\nWe will use a binary search algorithm to efficiently determine the minimum k value. The key idea is to simulate the damage dealt by the poison effect for different k values and check if it meets or exceeds the required damage h. This approach is efficient for large input sizes due to the logarithmic nature of binary search.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is applied when Monocarp attacks the dragon, dealing 1 damage per second for the next k seconds. If another attack occurs before the current poison effect ends, the poison effect is reset.\n\n    'minimum k'\n    Explanation: The smallest duration of the poison effect that ensures the total damage dealt to the dragon is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage dealt must be greater than or equal to h.\n    Implementation: Check if the accumulated damage is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n, h, and the attack times.\n3. Use binary search to find the minimum k:\n   - Set low = 1 and high = a_n - a_1 + 1 (maximum possible k).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Simulate the damage for k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage interval and accumulate total_damage.\n       - If total_damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n4. Output low as the minimum k for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal enough damage.\n\n    Test case 2: n = 2, h = 2, a = [1, 1000000000] => k = 1\n    Explanation: The attacks are far apart, so each attack must deal at least 1 damage.\n\n    Test case 3: n = 3, h = 3, a = [1, 2, 3] => k = 1\n    Explanation: Each attack can deal exactly 1 damage with k = 1, totaling to h.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the accumulated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum k value that ensures Monocarp deals at least h damage to the dragon. The solution must efficiently handle large input sizes and provide accurate results for each test case. The algorithm should consider the sequence of attacks and optimize the poison effect application.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum k value\n- Ensure the solution handles large input sizes effectively\n- Provide clear and accurate output for each test case\n- Optimize the algorithm for edge cases\n- Verify the solution against multiple test cases\nWe will use a binary search algorithm to efficiently determine the minimum k value. The binary search will help us find the smallest k that allows Monocarp to deal at least h damage to the dragon. We will calculate the total damage for each k by iterating through the attack sequence and applying the poison effect, ensuring that the poison is reapplied correctly when a new attack occurs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which Monocarp deals damage to the dragon. It lasts for k seconds and is reapplied with each attack, canceling any previous poison effects.\n\n    'minimum k'\n    Explanation: The smallest duration of the poison effect that allows Monocarp to deal at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage dealt must be greater than or equal to h.\n    Implementation: Ensure the total damage calculated for a given k meets or exceeds h.\n\n# [degree adverb]\n    'smallest': means finding the minimum value of k that satisfies the condition.\n    Implementation: Use binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k (e.g., low = 1, high = maximum possible k).\n    2. While low <= high:\n        a. Calculate mid = (low + high) // 2.\n        b. Calculate total damage for current mid value of k:\n            - Initialize total_damage = 0.\n            - Iterate through attack sequence:\n                - For each attack, calculate the damage dealt by poison effect lasting mid seconds.\n                - Ensure poison effect is reapplied correctly.\n        c. If total_damage >= h, update high = mid - 1 (try smaller k).\n        d. Else, update low = mid + 1 (try larger k).\n    3. Return low as the minimum k.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal enough damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large value of k is needed since h is extremely large.\n\n    Case 3: n = 2, h = 5, a = [1, 10]\n    Expected output: 5\n    Explanation: The attacks are far apart, requiring a longer poison duration to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying values of n and h efficiently.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 534, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "add_1_sentence_at_end", "parent_index": 343}
