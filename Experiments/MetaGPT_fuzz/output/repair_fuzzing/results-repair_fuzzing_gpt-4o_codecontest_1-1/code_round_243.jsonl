{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem carries a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n). All problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Note that the selection should adhere strictly to the given conditions to ensure diverse exposure to distinct topics and challenges for the students.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem carries a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n). All problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Note that the selection should adhere strictly to the given conditions to ensure diverse exposure to distinct topics and challenges for the students.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem carries a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n). Every problem is unique and no problem shares both topic and difficulty with another problem. All problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Note that the selection should adhere strictly to the given conditions to ensure diverse exposure to distinct topics and challenges for the students.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp, a coach at Berland State University, decided to create a problemset for a team training session. Monocarp has n problems that none of his students have seen yet and the i-th problem carries a topic a_i (an integer ranging from 1 to n) and a difficulty b_i (an integer ranging from 1 to n). All problems are unique, meaning that no two tasks possess identical topic and difficulty simultaneously. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\nYour task is to determine the number of ways to select three problems for the problemset. Note that the selection should adhere strictly to the given conditions to ensure diverse exposure to distinct topics and challenges for the students.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import Counter\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid ways to select three problems from each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of topic and difficulty.\n\n    Returns:\n        A list of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of selecting 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Count occurrences of each topic and difficulty\n        topic_counter = Counter(problem[0] for problem in problems)\n        difficulty_counter = Counter(problem[1] for problem in problems)\n\n        # Calculate invalid combinations where all three problems have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topic_counter.values() if count >= 3)\n\n        # Calculate invalid combinations where all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulty_counter.values() if count >= 3)\n\n        # Calculate valid combinations by subtracting invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing the number of problems and a list of tuples\n                    representing the topic and difficulty of each problem.\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate invalid combinations where all topics are the same\n        invalid_topic_combinations = sum(comb(count, 3) for count in topic_count.values() if count >= 3)\n\n        # Calculate invalid combinations where all difficulties are the same\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulty_count.values() if count >= 3)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print the results\n    results = count_valid_problem_sets(test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where topics are not all different\n        invalid_topic_combinations = sum(comb(count, 2) * (n - count) for count in topic_count.values() if count >= 2)\n\n        # Calculate invalid combinations where difficulties are not all different\n        invalid_difficulty_combinations = sum(comb(count, 2) * (n - count) for count in difficulty_count.values() if count >= 2)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Subtract 1 to exclude the current problem itself\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid ways to select three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid ways to select three problems.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where all three problems have the same topic\n        invalid_same_topic = sum(comb(count, 3) for count in topic_count.values() if count >= 3)\n\n        # Calculate invalid combinations where all three problems have the same difficulty\n        invalid_same_difficulty = sum(comb(count, 3) for count in difficulty_count.values() if count >= 3)\n\n        # Calculate invalid combinations where all three problems have the same topic and difficulty\n        # This is zero because no two problems have the same topic and difficulty simultaneously\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_same_topic - invalid_same_difficulty\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_selections(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid ways to select three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid selections.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize hash maps to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count the frequency of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting any 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where topics or difficulties are not distinct\n        invalid_combinations = 0\n\n        # Subtract combinations where topics are not distinct\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Subtract combinations where difficulties are not distinct\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += comb(count, 2) * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print the results\n    results = count_valid_selections(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import Counter\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid sets of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_counter = Counter(problem[0] for problem in problems)\n        difficulty_counter = Counter(problem[1] for problem in problems)\n\n        # Total combinations of choosing 3 problems from n\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where topics are not all different\n        invalid_topic_combinations = sum(comb(count, 2) * (n - count) for count in topic_counter.values())\n\n        # Calculate invalid combinations where difficulties are not all different\n        invalid_difficulty_combinations = sum(comb(count, 2) * (n - count) for count in difficulty_counter.values())\n\n        # Calculate combinations that were subtracted twice (where both topics and difficulties are not all different)\n        double_counted_combinations = sum(comb(count, 3) for count in topic_counter.values()) + \\\n                                      sum(comb(count, 3) for count in difficulty_counter.values())\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + double_counted_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of topic and difficulty.\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Calculate the number of ways to choose 2 more problems with the same topic or difficulty\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        problems = []\n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            problems.append((a_i, b_i))\n            index += 2\n        test_cases.append((n, problems))\n    \n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize hash maps to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Populate the hash maps\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate the total number of ways to select any three problems\n        total_combinations = comb(n, 3)\n\n        # Calculate invalid combinations where neither topics nor difficulties are all different\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # For each problem, calculate the number of invalid combinations it contributes to\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid sets of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid sets of three problems for each test case.\n    \"\"\"\n    def combination(n: int, k: int) -> int:\n        \"\"\"Calculate the number of combinations of n items taken k at a time.\"\"\"\n        if n < k:\n            return 0\n        if k == 0:\n            return 1\n        return n * (n - 1) * (n - 2) // 6\n\n    results = []\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n        \n        # Calculate total combinations of choosing any 3 problems\n        total_combinations = combination(n, 3)\n        \n        # Calculate invalid combinations where all three problems have the same topic\n        invalid_topic_combinations = sum(combination(count, 3) for count in topic_count.values())\n        \n        # Calculate invalid combinations where all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(combination(count, 3) for count in difficulty_count.values())\n        \n        # Calculate combinations that were subtracted twice (where both topics and difficulties are the same)\n        double_counted_combinations = sum(combination(topic_count[topic], 2) * combination(difficulty_count[difficulty], 1)\n                                          for topic, difficulty in problems)\n        \n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations + double_counted_combinations\n        \n        results.append(valid_combinations)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to select three problems from a given set such that they either have different topics or different difficulties. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate and diverse problem selection.\nrequirement pool:\n- Implement efficient algorithm to select problems based on given conditions\n- Ensure solution handles maximum input constraints effectively\n- Provide clear output format for easy verification\n- Optimize for performance to handle large datasets\n- Include comprehensive test cases to validate solution\nWe will use combinatorial counting to efficiently determine the number of valid selections. The key is to count combinations where either topics or difficulties are distinct. We will utilize collections.Counter from the Python standard library to count occurrences of topics and difficulties, and then calculate the number of valid combinations using combinatorial mathematics.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics of all three selected problems are different'\n    Explanation: This means that when selecting three problems, each problem must have a unique topic number.\n\n    'difficulties of all three selected problems are different'\n    Explanation: This means that when selecting three problems, each problem must have a unique difficulty level.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that we need to select precisely three problems from the list.\n    'at least one of two conditions': This means that the selection must satisfy at least one of the two given conditions (different topics or different difficulties).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems `n`.\n2. For each problem, store its topic and difficulty in a list.\n3. Use combinatorial counting to calculate the total number of ways to choose 3 problems from `n` (using combinations formula C(n, 3)).\n4. Count the occurrences of each topic and each difficulty using `collections.Counter`.\n5. For each topic, calculate the number of invalid combinations where all three problems have the same topic.\n6. For each difficulty, calculate the number of invalid combinations where all three problems have the same difficulty.\n7. Subtract these invalid combinations from the total combinations to get the valid combinations.\n8. Output the result for each test case.\n\n# [edge case]\n    Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select all three problems, and they satisfy both conditions.\n\n    Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected output: 4\n    Explanation: All combinations of three problems satisfy at least one condition.\n\n    Case 3: n = 5, problems = [(1, 1), (1, 2), (1, 3), (2, 1), (3, 1)]\n    Expected output: 10\n    Explanation: All combinations satisfy at least one condition due to unique topics or difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and subtracting invalid cases will handle these scenarios correctly.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that they meet at least one of the two conditions: all topics are different or all difficulties are different. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Efficiently handle large datasets\n- Ensure diverse selection of problems\n- Provide accurate output for all test cases\n- Optimize for speed and performance\n- Maintain simplicity in implementation\nWe will use a combinatorial approach to efficiently count the number of valid problem sets. The key is to count the total number of ways to choose 3 problems and then subtract the invalid combinations where either all topics or all difficulties are the same. We will use dictionaries to count occurrences of each topic and difficulty, which allows us to quickly calculate the number of invalid combinations. This approach ensures that we handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no duplicates in terms of both attributes.\n\n    'select exactly 3 problems'\n    Explanation: The requirement is to choose a subset of three problems from the given list, adhering to specified conditions.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems from the list.\n    'different': means that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the number of problems and their respective topics and difficulties.\n    2. Calculate the total number of ways to choose 3 problems from n using combinatorial formula C(n, 3).\n    3. Use dictionaries to count occurrences of each topic and difficulty.\n    4. Calculate invalid combinations where all topics are the same or all difficulties are the same using combinatorial formula C(count, 3) for each topic and difficulty.\n    5. Subtract invalid combinations from the total combinations to get valid combinations.\n    6. Output the result for each test case.\n\n# [edge case]\n    Input: \n    3\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one valid combination exists where all topics and difficulties are different.\n\n    Input: \n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    Output: \n    0\n    Explanation: All problems have the same topic, so no valid combination exists.\n\n    Input: \n    5\n    1 1\n    2 2\n    3 3\n    4 4\n    5 5\n    Output: \n    10\n    Explanation: All combinations are valid as all topics and difficulties are different.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of subtracting invalid combinations from total combinations inherently handles edge cases.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the constraints are respected and the output is accurate.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm to minimize computational complexity.\n- Include comments and documentation for code clarity.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count combinations where either all topics or all difficulties are different. We will utilize collections from Python's standard library to count occurrences and calculate combinations using combinatorial mathematics.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no duplicates in terms of both attributes.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specific conditions.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must have either all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems for each valid set.\n    'different': implies that the topics or difficulties must be distinct among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the details of each problem.\n    2. For each test case, store the problems with their topics and difficulties.\n    3. Use combinatorial counting to determine valid sets of three problems:\n        - Count combinations where all topics are different.\n        - Count combinations where all difficulties are different.\n    4. Ensure no double-counting by considering sets that meet both conditions.\n    5. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Test case with minimum n:\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one set can be formed with all different topics and difficulties.\n\n    Test case with maximum n:\n    Input:\n    1\n    200000\n    (problems with unique topic and difficulty pairs)\n    Output: \n    (Expected output based on combinatorial counting)\n    Explanation: The output should reflect the maximum number of combinations possible given the constraints.\n\n    Test case with identical topics or difficulties:\n    Input:\n    1\n    4\n    1 1\n    1 2\n    1 3\n    2 4\n    Output:\n    (Expected output based on valid combinations)\n    Explanation: Only sets meeting the condition of different difficulties can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting will naturally account for these scenarios.\n", "requirement analysis:\nThe task requires selecting three problems from a set such that they meet at least one of the two conditions: all topics are different or all difficulties are different. The solution must efficiently handle up to 200,000 problems across multiple test cases.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and correct output for each test case.\n- Optimize the solution for both time and space complexity.\n- Include comments and documentation for maintainability.\nWe will use a combination of combinatorial mathematics and hash maps to efficiently count the number of valid problem sets. The key challenge is to ensure that the solution can handle large inputs efficiently, so we will leverage Python's collections library to manage counts of topics and difficulties.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of three problems from the given set of problems.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a different topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a different difficulty level.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must consist of precisely three problems.\n    \n    'different': This implies that the topics or difficulties must not repeat among the selected problems.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use combinatorial mathematics to calculate the total number of ways to choose 3 problems from n (n choose 3).\n4. Use hash maps to count occurrences of each topic and difficulty.\n5. Calculate the number of invalid combinations where either topics or difficulties are not unique.\n6. Subtract invalid combinations from the total combinations to get valid combinations.\n7. Output the result for each test case.\n\n# [edge case] \n    Test case with minimum n (n=3) = 1\n    Explanation: With only three problems, there is exactly one way to select them, and they will automatically satisfy at least one condition.\n\n    Test case with all topics and difficulties being unique = n choose 3\n    Explanation: If all topics and difficulties are unique, every combination of three problems will satisfy both conditions.\n\n    Test case with all topics or all difficulties being the same = 0\n    Explanation: If all topics or all difficulties are the same, no valid combination can be formed as neither condition can be satisfied.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by calculating valid combinations based on topic and difficulty uniqueness.\n", "requirement analysis:\nThe requirement is to develop a solution that efficiently selects three problems from a set of n problems, ensuring that the selected problems have either distinct topics or distinct difficulties. The solution must handle multiple test cases and large input sizes efficiently, adhering to the constraints provided.\nrequirement pool:\n- Efficiently handle up to 50000 test cases with a total of 200000 problems.\n- Ensure the selected problems meet the criteria of distinct topics or difficulties.\n- Provide clear and concise output for each test case.\n- Optimize the solution for performance and scalability.\n- Maintain code readability and ease of maintenance.\nWe will use a combinatorial approach to solve this problem efficiently. The key is to count the number of ways to select three problems such that they satisfy the given conditions. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations. This approach ensures that we handle large inputs efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of three problems from the given set.\n\n    'topics of all three selected problems are different'\n    Explanation: The three chosen problems must each have a unique topic.\n\n    'difficulties of all three selected problems are different'\n    Explanation: The three chosen problems must each have a unique difficulty.\n\n# [phrase showing quantity relationship]\n    'exactly 3': This indicates that the selection must consist of precisely three problems.\n    \n    'at least one': This means that the selection must satisfy at least one of the two conditions (different topics or different difficulties).\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the number of problems and their respective topics and difficulties.\n3. Use dictionaries to count the occurrences of each topic and each difficulty.\n4. Calculate the total number of ways to choose any 3 problems from n (using combinations).\n5. Subtract invalid combinations where neither condition is satisfied:\n   - Calculate invalid combinations where all three problems have the same topic.\n   - Calculate invalid combinations where all three problems have the same difficulty.\n6. Add back combinations that were subtracted twice (where both topic and difficulty are the same for all three).\n7. Output the result for each test case.\n\n# [edge case] \n    Test case with minimum n:\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one way to select all three problems, satisfying both conditions.\n\n    Test case with all topics and difficulties the same:\n    3\n    1 1\n    1 1\n    1 1\n    = 0\n    Explanation: No valid way to select three problems as they do not satisfy either condition.\n\n    Test case with maximum n:\n    Consider a test case with n = 200000, where topics and difficulties are distinct for each problem.\n    = Large number (calculated based on combinations)\n    Explanation: The number of ways will be large due to many possible combinations satisfying at least one condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and adjustments for invalid cases will handle these scenarios effectively.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring that the constraints are respected and the output is correct for each test case.\nrequirement pool:\n- Implement an efficient algorithm to select problems based on the given conditions.\n- Ensure the solution can handle the maximum input size within time limits.\n- Provide clear and formatted output for each test case.\n- Optimize the algorithm for performance and scalability.\n- Include comments and documentation for maintainability.\nWe will use a combination of combinatorial counting and hash maps to efficiently determine the number of valid selections. The key idea is to count the number of ways to select three problems such that either all topics or all difficulties are different. We will utilize hash maps to keep track of the frequency of each topic and difficulty, allowing us to quickly compute the number of valid combinations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The requirement is to choose a subset of three problems from the given set, adhering to specified conditions.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must either have all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that the selection must consist of precisely three problems.\n    'different': implies that the topics or difficulties must be distinct among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the details of each problem.\n2. For each test case, initialize hash maps to count occurrences of each topic and difficulty.\n3. Calculate the total number of ways to select any three problems using combinatorial counting (n choose 3).\n4. Subtract invalid combinations where topics or difficulties are not distinct using the hash maps.\n5. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum n = 3:\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one way to select three problems, all topics and difficulties are different.\n\n    Test case with all topics or difficulties the same:\n    Input: \n    1\n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    Output: \n    0\n    Explanation: No valid selection as all topics are the same.\n\n    Test case with mixed topics and difficulties:\n    Input: \n    1\n    5\n    1 2\n    2 3\n    3 4\n    4 5\n    5 1\n    Output: \n    10\n    Explanation: Multiple valid selections as both topics and difficulties vary.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and hash maps will naturally account for these scenarios.\n", "requirement analysis:\nThe problem requires selecting three problems from a set such that they meet at least one of the two conditions: all topics are different or all difficulties are different. The solution must efficiently handle up to 200,000 problems across multiple test cases.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets.\n- Ensure the solution handles edge cases with minimum and maximum constraints.\n- Optimize for performance given the large input size.\n- Provide clear and understandable output for each test case.\n- Maintain code readability and modularity.\nWe will use combinatorial counting to efficiently determine the number of valid sets of three problems. The key is to count combinations where either all topics or all difficulties are different. We will utilize collections.Counter to count occurrences of topics and difficulties, and then calculate the number of valid combinations using these counts.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing a subset of three problems from the given list, adhering to specific conditions.\n\n# [phrase showing quantity relationship]\n    'at least one of two conditions'\n    Explanation: The selection must satisfy either the condition of having all different topics or all different difficulties, or both. This implies a logical OR relationship between the conditions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the list of problems for each test case.\n    2. For each test case, count the occurrences of each topic and difficulty using collections.Counter.\n    3. Calculate the total number of ways to select any three problems using combinatorial counting (n choose 3).\n    4. Subtract combinations that do not meet either condition:\n        - Calculate invalid combinations where topics are not all different.\n        - Calculate invalid combinations where difficulties are not all different.\n    5. Add back combinations that were subtracted twice (where both topics and difficulties are not all different).\n    6. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Input: \n    3\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one combination (all three problems) satisfies both conditions as all topics and difficulties are different.\n\n    Input: \n    4\n    1 1\n    1 2\n    2 1\n    2 2\n    Output: \n    0\n    Explanation: No combination of three problems can satisfy either condition as there are only two unique topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting and subtraction of invalid combinations inherently handles these scenarios.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either the topics or the difficulties are all different. The solution must efficiently handle up to 50000 test cases with a total of 200000 problems across all test cases.\nrequirement pool:\n- Efficiently handle large input sizes.\n- Ensure diverse selection of topics and difficulties.\n- Provide accurate results for all test cases.\n- Optimize for speed and performance.\n- User-friendly output format.\nWe will use a combinatorial approach to efficiently count the number of valid problem sets. The key is to count the total number of ways to choose 3 problems and then subtract the invalid combinations where neither topics nor difficulties are all different. We will use dictionaries to count occurrences of each topic and difficulty, and then apply combinatorial mathematics to calculate the number of valid sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task is to choose a subset of three problems from the given list, adhering to specified conditions.\n\n# [phrase showing quantity relationship]\n    'at least one of two conditions'\n    Explanation: The selection must satisfy either the condition of having different topics or different difficulties, or both.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the number of problems and their respective topics and difficulties.\n    2. Use dictionaries to count occurrences of each topic and difficulty.\n    3. Calculate the total number of ways to choose 3 problems using combinatorial mathematics (n choose 3).\n    4. Subtract invalid combinations where neither topics nor difficulties are all different.\n    5. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Input: 3\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one valid combination exists where all topics and difficulties are different.\n\n    Input: 4\n           4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No valid combination exists as neither condition is satisfied for any set of three problems.\n\n    Input: 5\n           5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations are valid as both conditions are satisfied for any set of three problems.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires selecting three problems from a set such that they meet at least one of the two conditions: all topics are different or all difficulties are different. The solution must efficiently handle up to 50000 test cases with a total of up to 200000 problems across all test cases. This requires an algorithm that can quickly determine valid combinations without checking each possible triplet individually.\nrequirement pool:\n- Implement an efficient algorithm to count valid problem sets.\n- Ensure the solution handles the maximum constraints effectively.\n- Optimize the solution for performance to handle large inputs.\n- Provide clear and concise output for each test case.\n- Include comments and documentation for maintainability.\nWe will use a combination of combinatorial counting and hash maps to efficiently determine the number of valid problem sets. The key is to count the number of ways to select three problems such that either all topics are different or all difficulties are different. We will use hash maps to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations without iterating over all possible triplets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique problems'\n    Explanation: Each problem has a distinct combination of topic and difficulty, ensuring no two problems are identical in both aspects.\n\n    'select exactly 3 problems'\n    Explanation: The task requires choosing three problems from the given set, adhering to specific conditions.\n\n    'different topics or difficulties'\n    Explanation: The selected problems must have either all different topics or all different difficulties, or both.\n\n# [phrase showing quantity relationship]\n    'exactly 3': means that we need to select precisely three problems from the list.\n    'different': implies that the topics or difficulties must be distinct among the selected problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize hash maps to count occurrences of each topic and difficulty.\n    2. For each test case, iterate through the list of problems to populate the hash maps.\n    3. Calculate the total number of ways to select any three problems using combinatorial counting.\n    4. Subtract invalid combinations where neither topics nor difficulties are all different.\n    5. Use the hash maps to efficiently count and subtract these invalid combinations.\n    6. Return the number of valid combinations for each test case.\n\n# [edge case]\n    Case 1: n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select three problems, and they satisfy both conditions.\n\n    Case 2: n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected output: 0\n    Explanation: No way to select three problems that satisfy either condition.\n\n    Case 3: n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected output: 10\n    Explanation: All combinations of three problems satisfy both conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hash maps and combinatorial counting efficiently handles all cases by ensuring only valid combinations are counted.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems.\n- Ensure the selected problems meet the diversity criteria in topics or difficulties.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance and speed.\n- Include detailed comments and documentation for maintainability.\nWe will use combinatorial counting to efficiently determine the number of valid sets of three problems. The key is to count combinations where either all topics or all difficulties are different. We will utilize Python's collections library to count occurrences and calculate combinations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics': Refers to the distinct subject or category each problem belongs to.\n    'difficulties': Refers to the level of challenge each problem presents.\n    'combinatorial counting': A mathematical approach to count the number of ways to choose items from a set, considering specific conditions.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': We need to select precisely three problems from the given set.\n    'different': Implies that the selected problems must have distinct topics or difficulties.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of problems, n.\n2. Initialize data structures to count occurrences of each topic and difficulty.\n3. For each problem, update the counts for its topic and difficulty.\n4. Calculate the total number of ways to choose any 3 problems from n using combinatorial formula C(n, 3).\n5. Subtract invalid combinations where topics or difficulties are not distinct:\n   - For each topic, calculate invalid combinations where all three problems have the same topic.\n   - For each difficulty, calculate invalid combinations where all three problems have the same difficulty.\n6. Add back combinations that were subtracted twice (where both topics and difficulties are the same).\n7. Output the valid combinations for each test case.\n\n# [edge case] \n    Test case 1: \n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select all three problems since they all have different topics and difficulties.\n\n    Test case 2:\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 4\n    Explanation: All combinations of selecting three problems will satisfy at least one condition.\n\n    Test case 3:\n    Input: 5\n           1 1\n           1 2\n           1 3\n           2 1\n           3 1\n    Output: 10\n    Explanation: Multiple combinations exist where either topics or difficulties are distinct.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations and subtracting invalid ones will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, false, true, false, false, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 243, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "add_1_sentence_at_end", "parent_index": 160}
