{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending. He prefers the order where the book titles are arranged in alphabetical order from A to Z, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly. They will have the odd-indexed characters compared ascendingly. Whereas, the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books, and each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, having the odd-indexed characters compared ascendingly and the even-indexed characters compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of the book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order\n                key.append(ord(char))\n        return key\n\n    # Pair each book title with its index\n    indexed_books = [(i + 1, book) for i, book in enumerate(books)]\n\n    # Sort the books using the custom sort key\n    sorted_books = sorted(indexed_books, key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in sorted_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on the asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list of tuples representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Odd-indexed positions (0-based index) - ascending order\n                key.append((char, True))\n            else:\n                # Even-indexed positions (0-based index) - descending order\n                key.append((char, False))\n        return key\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value as is\n                key.append(ord(char))\n        return key\n\n    # Create a list of tuples (index, book) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value as is\n                key.append(ord(char))\n        return key\n\n    # Sort books using the custom key function\n    sorted_books = sorted(enumerate(books, start=1), key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in sorted_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of the book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value as is\n                key.append(ord(char))\n        return key\n\n    # Generate a list of tuples (index, title) to keep track of original indices\n    indexed_titles = list(enumerate(titles, start=1))\n    \n    # Sort the indexed titles using the custom sort key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: sort descendingly, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: sort ascendingly, use ASCII value\n                key.append(ord(char))\n        return key\n\n    # Pair each book with its index, sort by custom key, and extract sorted indices\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    sorted_indices = [index for index, _ in indexed_books]\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on the asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of the book titles.\n    \"\"\"\n    def sort_key(book: str) -> tuple:\n        \"\"\"Generates a sorting key for a book title based on asc-desc-ending order.\n\n        Args:\n            book (str): Book title.\n\n        Returns:\n            tuple: A tuple representing the sorting order.\n        \"\"\"\n        return tuple(\n            (ord(book[i]) if i % 2 == 1 else -ord(book[i]))\n            for i in range(m)\n        )\n\n    # Sort books using the key function\n    sorted_books = sorted(range(n), key=lambda i: sort_key(books[i]))\n    \n    # Return the sorted indices (1-based)\n    return [index + 1 for index in sorted_books]\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        odd_chars = [title[i] for i in range(m) if i % 2 == 0]\n        even_chars = [title[i] for i in range(m) if i % 2 == 1]\n        return (odd_chars, [-ord(c) for c in even_chars])\n\n    # Create a list of tuples (index, book_title) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\nresult = sort_books_asc_desc(n, m, books)\n\n# Output interface\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in the custom order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list of tuples representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: sort descending, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: sort ascending, use ASCII value\n                key.append(ord(char))\n        return key\n\n    # Create a list of tuples (original_index, book_title)\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    sorted_books = sorted(indexed_books, key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the original indices of the sorted books\n    sorted_indices = [index for index, _ in sorted_books]\n    \n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom 'asc-desc-ending' order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in the custom order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value\n                key.append(ord(char))\n        return key\n\n    # Pair each book with its original index\n    indexed_books = [(i + 1, book) for i, book in enumerate(books)]\n    \n    # Sort books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the original indices of the sorted books\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n"], "plans": ["requirement analysis:\nThe requirements focus on sorting strings based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified character comparison rules for odd and even positions. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across all test cases.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Optimize for performance and memory usage\n- Validate the output format against multiple test cases\n- Consider edge cases with minimum and maximum input values\nWe will implement a custom sorting function that adheres to the asc-desc-ending order rules. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles large input sizes by optimizing the sorting logic.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of books (n) and the length of each title (m).\n    2. Store each book title along with its index.\n    3. Implement a custom sorting function:\n        - For each pair of titles, compare characters at odd positions in ascending order.\n        - Compare characters at even positions in descending order.\n    4. Use Python's sorted function with the custom key to sort the titles.\n    5. Extract and print the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At the first position, 'B' > 'A' (even position), so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           AC\n           AD\n    Output: 1 2 3\n    Explanation: All books have different second characters, sorted by odd position first.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting with a custom key function will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to sort book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The solution must efficiently handle up to 10^6 characters in total, ensuring performance and correctness across multiple test cases.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm for performance with large inputs.\n- Ensure the solution handles edge cases, such as minimum and maximum input sizes.\n- Provide clear documentation and comments within the code.\n- Develop test cases to validate the sorting logic.\nWe will implement a custom sorting function that compares book titles based on the asc-desc-ending order. The function will iterate through each character of the strings, checking odd and even positions to determine the correct order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Define a custom sorting function that:\n       - Iterates through each character of the book titles.\n       - Compares characters at odd positions in ascending order.\n       - Compares characters at even positions in descending order.\n    4. Use Python's sorted function with the custom key to sort the book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At position 1 (odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           AC\n           AD\n    Output: 3 2 1\n    Explanation: At position 2 (even), 'D' comes before 'C' and 'B', so AD comes first, followed by AC, then AB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The solution must handle up to 10^6 characters efficiently and output the indices of the sorted titles.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases like minimum and maximum input sizes.\n- Provide clear documentation and comments within the code.\n- Develop test cases to validate the sorting logic.\nWe will implement a custom sorting function that sorts book titles based on the asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending order'\n    Explanation: This is a custom sorting order where characters at odd indices are sorted in ascending order, and characters at even indices are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This refers to the dictionary order of strings, where strings are compared based on the alphabetical order of their characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each book title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the book title, if its index is odd, use the character as is for comparison (ascending order).\n   - If its index is even, use the negative ASCII value of the character for comparison (descending order).\n4. Use Python's `sorted()` function with the custom key to sort the book titles.\n5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 0 (odd), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 2 1 3\n    Explanation: At index 0 (odd), 'B' comes before 'A', so 'BAC' comes first. Then 'ABC' and 'CAB' are compared at index 1 (even), where 'B' comes after 'A'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by comparing characters based on their indices and applying the appropriate order.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd and even positions differently. Odd positions are sorted in ascending order, while even positions are sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Optimize the algorithm to handle large inputs efficiently.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd positions in ascending order and even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle up to 10^6 characters.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to a custom sorting order where characters at odd indices are sorted in ascending order, and characters at even indices are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of the characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles.\n3. Define a custom sorting key function:\n   - For each character in the title, if its index is odd, use it as is for ascending comparison.\n   - If its index is even, use the negative of its ASCII value for descending comparison.\n4. Use Python's `sorted()` function with the custom key to sort the titles.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    1 1\n    A\n    = 1\n    Explanation: With only one book, it remains in its position.\n\n    2 2\n    AB\n    BA\n    = 2 1\n    Explanation: For index 1 (odd), 'A' < 'B', and for index 2 (even), 'B' > 'A', so \"BA\" comes before \"AB\".\n\n    3 3\n    ABC\n    ACB\n    BAC\n    = 2 1 3\n    Explanation: At index 1 (odd), all have 'A', so move to index 2 (even), where 'C' > 'B', so \"ACB\" comes first, then \"ABC\", and finally \"BAC\".\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing each character based on its index position.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom lexicographical order. The sorting rule is a combination of ascending and descending order based on character positions. Odd-indexed characters are sorted in ascending order, while even-indexed characters are sorted in descending order. The solution must handle up to 10^6 characters efficiently.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Optimize the algorithm to handle large inputs efficiently.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting algorithm that sorts book titles based on the specified asc-desc-ending order. The algorithm will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will be optimized to handle up to 10^6 characters using efficient string operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Define a custom key function for sorting:\n        - For each character in the title, if its index is odd, use the character as is for comparison (ascending).\n        - If its index is even, use the negative of its ASCII value for comparison (descending).\n    4. Sort the list of titles using this custom key function.\n    5. Output the indices of the sorted titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At the first position, 'B' comes after 'A' in descending order, so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 3 2 1\n    Explanation: At the first position, 'C' comes after 'B' and 'A', so 'CAB' comes first. At the second position, 'A' comes before 'B', so 'BAC' comes next.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering both odd and even positions as specified.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom lexicographical order. The sorting rule combines ascending order for odd-indexed characters and descending order for even-indexed characters. The solution must efficiently handle up to 10^6 characters in total, ensuring performance and correctness.\nrequirement pool:\n- Implement the sorting algorithm based on asc-desc-ending order.\n- Ensure the solution handles large input sizes efficiently.\n- Optimize the code for readability and maintainability.\n- Include comprehensive test cases to validate the sorting logic.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting function that sorts the book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting in alphabetical order from A to Z.\n    'lexicographically descending': means sorting in reverse alphabetical order from Z to A.\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each book title (m).\n    2. Read the n book titles into a list.\n    3. Define a custom sorting key function:\n        - For each character in the book title, if the index is odd, use the character as is for comparison (ascending order).\n        - If the index is even, use the negative ASCII value of the character for comparison (descending order).\n    4. Sort the list of book titles using this custom key function.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: For the first character (odd index), A < B, so AB comes before BA. For the second character (even index), B > A, so BA comes before AB.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: The first differing position is odd for all comparisons, so we sort based on ascending order of the first character.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by applying the specified sorting rules consistently.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input size constraint is significant, with n * m up to 10^6, which suggests the need for an efficient sorting algorithm. The output should be the indices of the books in the sorted order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Optimize the sorting algorithm to handle large inputs efficiently.\n- Ensure the output format strictly follows the requirements.\n- Test the algorithm with various edge cases.\n- Document the code for maintainability.\nWe will implement a custom sorting algorithm using a comparator function that sorts book titles based on the specified asc-desc-ending order. The sorting will be efficient enough to handle large inputs, leveraging Python's built-in sorting capabilities with a custom key function.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Define a custom comparator function that compares two strings based on the asc-desc-ending order:\n        - For each character position, check if it is odd or even.\n        - If odd, compare characters in ascending order.\n        - If even, compare characters in descending order.\n    4. Use Python's sorted function with the custom comparator to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: The first position is odd, so ABC comes before BAC. CAB comes last because at the second position (even), C is later than A and B.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At the first position (odd), B comes after A, so BA comes before AB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a custom comparator function will handle all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The solution must efficiently handle up to 10^6 characters in total, ensuring performance and correctness across multiple test cases.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Optimize the algorithm for large input sizes\n- Ensure the solution passes all test cases\n- Provide clear documentation and comments in the code\n- Consider edge cases and input validation\nWe will implement a custom sorting algorithm that compares characters at odd indices in ascending order and characters at even indices in descending order. The algorithm will efficiently handle large input sizes by leveraging Python's built-in sorting capabilities with a custom key function.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Define a custom sorting key function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n    4. Use Python's built-in sort function with the custom key to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 3 2\n    Explanation: Sorting by asc-desc-endingly, ABC comes first because 'A' < 'B' at odd index 1, CAB comes next because 'C' > 'B' at even index 2, and BAC is last.\n\n    Input: 2 2\n           AA\n           AB\n    Output: 1 2\n    Explanation: At odd index 1, 'A' < 'B', so AA comes before AB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing characters at odd and even indices according to the specified rules.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd and even positions differently. Odd-indexed characters are compared in ascending order, while even-indexed characters are compared in descending order. The solution must handle up to 10^6 characters in total, ensuring efficiency in both time and space complexity.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Optimize the algorithm to handle large inputs efficiently.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear and concise documentation for the code.\n- Implement additional features like user interface for input and output.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution is optimized for handling up to 10^6 characters.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting in alphabetical order (A-Z).\n    'lexicographically descending': means sorting in reverse alphabetical order (Z-A).\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships in the requirement.\n\n# [degree adverb]\n    No degree adverbs present in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the title, if its index is odd, use the character as is for ascending order.\n   - If its index is even, use the negative of the character's ASCII value for descending order.\n4. Use Python's `sorted()` function with the custom key to sort the list of titles.\n5. Output the indices of the sorted titles based on their original positions.\n\n# [edge case]\n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: For position 1 (odd), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At position 1 (odd), 'A' < 'B' < 'C', so they remain in their original order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by applying the specified sorting rules consistently.\n", "requirement analysis:\nThe requirement involves sorting strings based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The challenge is to efficiently implement this sorting mechanism given the constraints on the number of books and the length of each title.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Optimize the algorithm for large inputs\n- Ensure the solution handles edge cases like minimum and maximum input sizes\n- Provide clear documentation and comments within the code\n- Develop test cases to validate the sorting logic\nWe will implement a custom sorting function that sorts the book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending order'\n    Explanation: This refers to a custom sorting order where characters at odd indices are sorted in ascending order, and characters at even indices are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of the characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each book title `m`.\n2. Store each book title along with its original index.\n3. Define a custom sorting key function:\n   - For each character in the book title, if the index is odd, use the character as is (for ascending order).\n   - If the index is even, use the negative ASCII value of the character (for descending order).\n4. Sort the list of book titles using this custom key.\n5. Extract and print the original indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 1 (even), 'B' > 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At index 1 (odd), 'A' < 'B' < 'C', so they remain in their original order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by considering both odd and even indexed character comparisons.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 166, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "expand_one2two", "parent_index": 0}
