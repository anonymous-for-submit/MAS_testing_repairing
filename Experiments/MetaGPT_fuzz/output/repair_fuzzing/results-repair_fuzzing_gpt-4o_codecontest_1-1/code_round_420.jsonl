{"name": "1582_C. Grandma Capa Knits a Scarf", "description": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "tags": ["brute force", "data structures", "greedy", "strings", "two pointers"], "difficulty": 9, "id": 1582, "sample_io": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}], "test_list": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["3\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhhyhhyyky\n", "output": ["-1\n-1\n1\n3\n3\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyzxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabcaacba\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhkhhhy\n", "output": ["-1\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nxkhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxzxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrpparlar\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxxzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyyxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nyyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcbacaa\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabbaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabca\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyzyhhhhky\n", "output": ["2\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhhyky\n", "output": ["2\n1\n1\n3\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxzzxyy\n4\nbaba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwxz\n4\nbaba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n1\n1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyx\n4\nacbb\n8\nsakparpr\n10\nkyyyhhhhky\n", "output": ["2\n1\n-1\n-1\n4\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["-1\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\naabb\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n2\n-1\n4\n"]}, {"input": "5\n8\nabcaacba\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["0\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbcaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n-1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyx\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbabca\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzzyx\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n0\n0\n-1\n-1\n"]}, {"input": "5\n8\naacaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["-1\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["3\n1\n1\n3\n2\n"]}, {"input": "5\n8\naccabcaa\n6\nxyzxyy\n4\nabbc\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["3\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nacba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nbbcaacbb\n6\nzyxzyx\n4\nabba\n8\nroqarlap\n10\nykhxhhyyhk\n", "output": ["0\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyhyhyhhky\n", "output": ["2\n1\n1\n-1\n3\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhiyyhk\n", "output": ["-1\n2\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzxx\n4\nabbb\n8\nqprarlap\n10\nkhhyyhyhky\n", "output": ["2\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nbabb\n8\nrpqapkas\n10\njyyyhhhhky\n", "output": ["2\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nzzzxyx\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyxzyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhhyky\n", "output": ["3\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkgyyhhyhky\n", "output": ["3\n1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcabcba\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbabaadba\n6\nxyyxxy\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n3\n-1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nyzywyz\n4\nacda\n8\napqrrlap\n10\nykhxhhyyhk\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbabaadba\n6\nyxxxyx\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n1\n-1\n-1\n-1\n"]}, {"input": "5\n8\ncbabacbb\n6\nyyzyxx\n4\naabb\n8\nrpqarlap\n10\nkyyyhhhhkx\n", "output": ["3\n-1\n2\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhghhyyyk\n", "output": ["2\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n0\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyyhyhhk\n", "output": ["-1\n-1\n2\n-1\n3\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaslap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqpr\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbbaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nacba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrplarqap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\ncaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrpsarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlbp\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\npalraqps\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpparlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naaba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxghyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\njhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrpraqlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\naaba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbbcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nylhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykgk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyxxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\naaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nzxxzyw\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxzxxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\ncbcaaaab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqlraap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqaralp\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaaa\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqor\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabbb\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzzx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\npalrarpr\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nzywzxx\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nacba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nzyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nyhkyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqaalrp\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacba\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}], "task_id": "codecontest/30", "prompt": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters, and Grandpa Sher wrote a string s of length n. Grandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, yet she doesn't want to offend him in any way. Thus, to avoid upsetting him, she will pick one lowercase English letter and remove some (at her choice, possibly none or all) occurrences of that letter in string s. She also wants to minimize the number of erased symbols from the pattern, so please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose. A string is a palindrome if it reads the same forwards and backwards. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not. You need to consider all possibilities for the letter choice and find the optimal solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "repair_prompt": ["Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters, and Grandpa Sher wrote a string s of length n. Grandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, yet she doesn't want to offend him in any way. Thus, to avoid upsetting him, she will pick one lowercase English letter and remove some (at her choice, possibly none or all) occurrences of that letter in string s. She also wants to minimize the number of erased symbols from the pattern, so please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose. A string is a palindrome if it reads the same forwards and backwards. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not. You need to consider all possibilities for the letter choice and find the optimal solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n. Grandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, yet she doesn't want to offend him in any way. Thus, to avoid upsetting him, she will pick one lowercase English letter. She will then remove some (at her choice, possibly none or all) occurrences of that letter in string s. She also wants to minimize the number of erased symbols from the pattern, so please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose. A string is a palindrome if it reads the same forwards and backwards. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not. You need to consider all possibilities for the letter choice and find the optimal solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters, and Grandpa Sher wrote a string s of length n. Grandma Capa wants to knit a beautiful scarf, which can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher yet doesn't want to offend him, so to avoid upsetting him, she will pick one lowercase English letter and remove occurrences of that letter in string s. She also wants to minimize the number of erased symbols from the pattern, so please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose. A string is a palindrome if it reads the same forwards and backwards. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not. You need to consider all possibilities for the letter choice and find the optimal solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import Counter\n\ndef min_erased_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erased symbols required to make the string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum number of erased symbols for each test case, or -1 if impossible.\n    \"\"\"\n    def can_form_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Check if the string can be a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to check.\n            char_to_remove (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals needed, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n\n    for n, s in test_cases:\n        if s == s[::-1]:  # Already a palindrome\n            results.append(0)\n            continue\n\n        min_removals = float('inf')\n        unique_chars = set(s)\n\n        for char in unique_chars:\n            removals = can_form_palindrome(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append((n, s))\n\n    # Call the function and print results\n    results = min_erased_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum deletions required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                deletions += 1\n            elif s[right] == char:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')  # Impossible to form a palindrome by removing this character\n\n        return deletions\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = min_deletions_for_char(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        if min_deletions == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_deletions)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_deletions_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum deletions required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Calculate the minimum number of removals to make a string a palindrome by removing a specific character.\n\n        Args:\n            s (str): The original string.\n            char_to_remove (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals, or -1 if impossible.\n        \"\"\"\n        filtered_s = [c for c in s if c != char_to_remove]\n        if is_palindrome(filtered_s):\n            return len(s) - len(filtered_s)\n        return -1\n\n    results = []\n    for n, s in test_cases:\n        unique_chars = set(s)\n        min_removals = float('inf')\n        for char in unique_chars:\n            removals = min_removals_for_palindrome(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n        \n        results.append(min_removals if min_removals != float('inf') else -1)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_deletions_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make a palindrome by removing this character\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append((n, s))\n\n    # Call the function and get results\n    results = min_removals_to_palindrome(t, test_cases)\n\n    # Output interface\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals needed to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals, or float('inf') if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings to be processed.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome using two-pointer technique.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing a specific character.\n\n        Args:\n            s (str): The original string.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals, or a large number if impossible.\n        \"\"\"\n        filtered_s = [c for c in s if c != char]\n        if is_palindrome(filtered_s):\n            return len(s) - len(filtered_s)\n        return float('inf')\n\n    results = []\n    for s in test_cases:\n        unique_chars = set(s)\n        min_removals = float('inf')\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n        \n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals, or float('inf') if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')\n        \n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of character removals required to make each string a palindrome.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[str]): A list of strings, each representing a test case.\n\n    Returns:\n        List[int]: A list of integers where each integer represents the minimum number of removals\n                   required for the corresponding test case to become a palindrome, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a given string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum number of removals required to make the string a palindrome\n        by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: The number of removals required, or a large number if not possible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make it a palindrome by removing this char\n\n        return removals\n\n    results = []\n\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output results\n    results = min_removals_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erased_symbols(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of symbols to erase to make a string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum number of erased symbols for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make a string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append((n, s))\n\n    # Output interface\n    results = min_erased_symbols(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a string to make it a palindrome, considering all possible choices of a single character to erase. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring the sum of lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Implement efficient palindrome checking algorithm\n- Optimize for large input sizes\n- Ensure consistent output format\n- Handle edge cases effectively\n- Provide clear documentation and examples\nWe will implement a function that iterates over each character in the string and attempts to make the string a palindrome by removing occurrences of that character. The function will use a two-pointer technique to check if the string can be a palindrome after removing certain characters. We will use the collections library to count occurrences of each character efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The task is to make the string a palindrome by removing occurrences of one chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means we need to find the least number of characters to remove to achieve a palindrome. In code, this can be implemented by iterating over possible characters to remove and calculating the number of removals needed for each.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest number of removals required to make the string a palindrome. This involves checking all possible characters and choosing the one that results in the fewest removals.\n\n# [code logic]\n    1. For each test case, iterate over each unique character in the string.\n    2. Use a two-pointer approach to check if the string can be a palindrome by removing occurrences of the current character.\n    3. Count the number of removals needed for each character.\n    4. Track the minimum number of removals across all characters.\n    5. If no character can result in a palindrome, return -1 for that test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Removing two 'a's (first and last) results in 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single character removal can make this string a palindrome.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and using a two-pointer approach will naturally handle these cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of deletions of a single character type to make a string a palindrome. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000. The algorithm should consider all possible character choices and determine the optimal solution or declare it impossible.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions required.\n- Ensure the solution handles edge cases, such as already palindromic strings.\n- Optimize the solution for large input sizes within the given constraints.\n- Provide clear and concise output for each test case.\n- Consider user feedback for further optimization and improvements.\nWe will iterate over each character in the string and attempt to remove all occurrences of that character to check if the resulting string can be a palindrome. We will use a two-pointer technique to verify if a string is a palindrome after removing certain characters. The solution will be efficient enough to handle the constraints by iterating over each character and using a linear check for palindrome validation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The requirement is to transform the given string into a palindrome by removing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest possible symbols to achieve a palindrome. This means finding the optimal letter to remove such that the remaining string is a palindrome with the least number of deletions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest number of deletions required to make the string a palindrome, if possible.\n\n# [code logic]\n    1. For each test case, read the integer n and the string s.\n    2. Initialize a variable to store the minimum number of deletions required, starting with infinity.\n    3. Iterate over each unique character in the string s.\n    4. For each character, use a two-pointer approach to attempt to form a palindrome by removing occurrences of that character.\n    5. If a palindrome can be formed, update the minimum deletions required.\n    6. If no palindrome can be formed for any character, return -1 for that test case.\n    7. Print the minimum number of deletions for each test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: By removing two 'a's (first and last), we can form the palindrome 'bcaacb'.\n    \n    xyzxyz = -1\n    Explanation: It is impossible to form a palindrome by removing occurrences of any single letter.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and using a two-pointer approach will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions of a single character type to make a string a palindrome. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000. The algorithm should consider all possible character choices and determine the optimal one for each test case.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions required.\n- Ensure the solution handles edge cases, such as already palindromic strings.\n- Optimize the solution to handle the maximum input size within time limits.\n- Provide clear output format as specified in the requirements.\n- Consider user experience by providing informative error messages if needed.\nWe will use a two-pointer technique to check if a string can be converted into a palindrome by removing occurrences of a single character. For each character in the string, we will simulate removing all occurrences of that character and check if the remaining string can be a palindrome. This approach ensures we efficiently handle large inputs by minimizing unnecessary operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The requirement is to transform the given string into a palindrome by removing occurrences of a single character.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means we need to find the least number of characters to remove to achieve a palindrome. In code, this can be implemented by iterating through possible characters to remove and calculating the number of removals needed for each.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest number of removals required to make the string a palindrome. This involves checking all possible single character removals and selecting the one with the least removals.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of removals needed, starting with a large value.\n3. Iterate over each unique character in the string s.\n4. Use a two-pointer approach to simulate removing all occurrences of the current character.\n5. Check if the remaining string can be a palindrome.\n6. If it can, update the minimum number of removals if the current number is less.\n7. If no palindrome can be formed, return -1 for that test case.\n8. Output the minimum number of removals for each test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Removing two 'a's (first and last) results in 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single character removal can make this string a palindrome.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each character removal and verifying palindrome formation inherently handles edge cases.\n", "requirement analysis:\nThe requirement is to transform a given string into a palindrome by removing occurrences of a single chosen letter, minimizing the number of removals. The solution must efficiently handle multiple test cases and large input sizes, ensuring the output is clear and concise.\nrequirement pool:\n- Efficiently handle large input sizes\n- Minimize the number of symbol removals\n- Provide clear output indicating impossibility\n- Optimize for multiple test cases\n- Handle edge cases effectively\nWe will implement a function that iterates over each possible letter choice and attempts to make the string a palindrome by removing occurrences of that letter. The function will use a two-pointer technique to check if the string can be transformed into a palindrome and count the number of removals required. If a palindrome is possible, it will return the minimum number of removals; otherwise, it will return -1. We will use Python's built-in capabilities for string manipulation and list operations to ensure efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The task is to transform the given string into a palindrome by removing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols': This means we need to find the smallest number of deletions required to make the string a palindrome.\n    'possibly none or all': This indicates that we can choose to remove no occurrences or all occurrences of the chosen letter.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible number of deletions to achieve the goal.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of deletions required, starting with a large value.\n3. Iterate over each unique character in the string s as the potential character to remove.\n4. For each character, use a two-pointer approach:\n   - Initialize two pointers, one at the start and one at the end of the string.\n   - Move the pointers towards each other, skipping over occurrences of the chosen character.\n   - Count how many characters need to be removed to make the remaining string a palindrome.\n5. If a palindrome is possible with the current character choice, update the minimum deletions if this is a better solution.\n6. If no palindrome can be formed with any character choice, return -1 for that test case.\n7. Output the minimum number of deletions for each test case.\n\n# [edge case]\n    Test case: \"a\" = 0\n    Explanation: A single character is already a palindrome, so no deletions are needed.\n\n    Test case: \"abcba\" = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n    Test case: \"abccba\" = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic will naturally handle strings that are already palindromes by recognizing that no deletions are necessary.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to remove from a string to make it a palindrome by only removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring the sum of lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Efficiently handle large input sizes\n- Determine if a palindrome is possible\n- Minimize the number of removals\n- Provide clear output format\n- Handle edge cases effectively\nWe will implement a function that iterates over each possible character choice and attempts to make the string a palindrome by removing occurrences of that character. The function will use a two-pointer technique to check if the string can be a palindrome after removals. We will use the collections library to efficiently count occurrences of each character.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The task is to make the given string a palindrome by removing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means we need to find the least number of occurrences of a chosen letter to remove in order to make the string a palindrome.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to minimize the number of symbols erased to achieve a palindrome.\n\n# [code logic]\n    1. For each test case, iterate over each unique character in the string.\n    2. For each character, use a two-pointer approach to check if the string can be made a palindrome by removing occurrences of that character.\n    3. Count the number of removals needed for each character choice.\n    4. Track the minimum number of removals across all character choices.\n    5. If no character choice can result in a palindrome, return -1 for that test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Choose 'a' and remove its first and last occurrences to get 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single letter removal can make this string a palindrome.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and using two-pointer technique inherently handles edge cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of characters to erase from a string to make it a palindrome by only removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000. The algorithm should consider all possible characters for removal and determine the optimal solution or declare it impossible.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum number of erasures needed.\n- Ensure the solution handles edge cases and large inputs within constraints.\n- Provide clear output format as specified in the requirements.\n- Optimize the algorithm for performance and accuracy.\n- Include comprehensive test cases to validate the solution.\nWe will implement a function that iterates over each possible character choice for removal and checks if the string can be transformed into a palindrome by removing occurrences of that character. The function will use a two-pointer technique to efficiently check for palindromes and count the number of removals needed. If a palindrome can be formed, it will return the minimum number of removals; otherwise, it will return -1. The solution will handle multiple test cases and ensure performance within the constraints using efficient string manipulation techniques.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The requirement is to transform the given string into a palindrome by removing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means we need to find the least number of occurrences of a chosen letter to remove in order to make the string a palindrome.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to minimize the number of symbols erased to achieve a palindrome. This requires checking all possible letters and choosing the one that results in the fewest removals.\n\n# [code logic]\n    1. For each test case, iterate over each unique character in the string.\n    2. For each character, use a two-pointer approach to check if the string can be made into a palindrome by removing occurrences of that character.\n    3. Count the number of removals needed for each character choice.\n    4. Track the minimum number of removals across all character choices.\n    5. If no palindrome can be formed, return -1 for that test case.\n    6. Output the minimum number of removals for each test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Choose 'a' and remove its first and last occurrences to get 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single letter removal can transform this string into a palindrome.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and checking for palindrome formation inherently handles edge cases.\n", "requirement analysis:\nThe task requires developing an algorithm that can efficiently determine the minimum number of characters to remove from a string to make it a palindrome. The solution must handle up to 100 test cases with a total character count of up to 200,000. The algorithm should consider all possible single-character removals and find the optimal solution or determine if it's impossible.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum number of characters to remove to form a palindrome.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm to minimize computational complexity.\n- Provide clear and concise output for each test case.\n- Consider edge cases and ensure robustness of the solution.\nWe will implement a function that iterates over each possible character that can be removed from the string. For each character, we will attempt to form a palindrome by removing all occurrences of that character and checking if the resulting string is a palindrome. We will use a two-pointer technique to efficiently check for palindromes. The solution will be optimized to handle up to 100 test cases with a total character count of up to 200,000.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. For example, 'kek', 'abacaba', and 'r' are palindromes, while 'abb' and 'iq' are not.\n\n    'minimize the number of erased symbols'\n    Explanation: The goal is to remove the fewest number of occurrences of a single character to make the string a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means we need to find the smallest number of characters that can be removed to achieve a palindrome.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest possible number of characters to remove to achieve the desired result.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of removals needed, starting with a large value.\n3. Iterate over each unique character in the string s.\n4. For each character, simulate removing all its occurrences and check if the resulting string can be a palindrome using a two-pointer technique.\n5. If it can be a palindrome, calculate the number of removals and update the minimum if this is smaller.\n6. If no character removal results in a palindrome, return -1 for that test case.\n7. Output the minimum number of removals for each test case.\n\n# [edge case]\n    Test case 1: \"a\" = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n    Test case 2: \"abc\" = -1\n    Explanation: No single character removal can make this string a palindrome.\n\n    Test case 3: \"abccba\" = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each character removal and verifying if the resulting string is a palindrome will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a string to make it a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle multiple test cases and large input sizes, ensuring that the output is accurate and follows the specified format.\nrequirement pool:\n- Implement the main algorithm to find the minimum number of erased symbols\n- Ensure the solution handles edge cases and large inputs efficiently\n- Optimize the algorithm for computational complexity\n- Provide clear and consistent output format\n- Include detailed comments and documentation for the code\nWe will implement a function that iterates over each possible letter choice, removing occurrences of that letter and checking if the resulting string can be a palindrome. We will use a two-pointer technique to efficiently check for palindromes and calculate the minimum number of removals required. The solution will handle multiple test cases and large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. For example, 'kek', 'abacaba', and 'r' are palindromes, while 'abb' and 'iq' are not.\n\n    'minimize the number of erased symbols'\n    Explanation: The goal is to remove the fewest number of occurrences of a single chosen letter to make the string a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols': This means we need to find the smallest number of deletions required to achieve a palindrome.\n    Implementation: Track the number of deletions for each letter choice and select the minimum.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible number of deletions.\n    Implementation: Use a variable to keep track of the minimum deletions found across all letter choices.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of deletions, starting with a large value.\n3. Iterate over each unique character in the string s.\n4. For each character, use a two-pointer approach to check if removing all occurrences of that character can result in a palindrome:\n   - Initialize two pointers, one at the start and one at the end of the string.\n   - Move the pointers towards each other, skipping over occurrences of the chosen character.\n   - If the characters at both pointers match, continue; otherwise, break.\n5. If a palindrome is formed, calculate the number of deletions and update the minimum if it's lower than the current minimum.\n6. If no palindrome can be formed for any character choice, return -1 for that test case.\n7. Output the minimum number of deletions for each test case.\n\n# [edge case]\n    Test case 1: \"a\" = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n    Test case 2: \"abc\" = -1\n    Explanation: No single character removal can make this string a palindrome.\n\n    Test case 3: \"aabb\" = 2\n    Explanation: Removing both 'a's or both 'b's results in \"bb\" or \"aa\", which are palindromes.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers all possible single character removals and checks for palindrome formation.\n", "requirement analysis:\nThe requirement involves processing multiple test cases to determine the minimum number of characters to erase from a string to make it a palindrome. The solution must efficiently handle strings of length up to 10^5 and ensure the sum of lengths across all test cases does not exceed 2 \u22c5 10^5. The algorithm should consider all possible single-letter removals and find the optimal solution or determine if it's impossible.\nrequirement pool:\n- Implement the main algorithm to find the minimum number of erased symbols.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm to reduce computational complexity.\n- Provide clear and accurate output for each test case.\n- Document the solution and explain the logic used.\nWe will iterate over each test case and for each string, try removing all occurrences of each character one by one. For each character removal, we will check if the resulting string is a palindrome. We will keep track of the minimum number of removals required to achieve a palindrome. If no palindrome can be formed, we will return -1 for that test case. The solution will efficiently handle large inputs by leveraging the two-pointer technique to check for palindromes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. For example, 'kek', 'abacaba', and 'r' are palindromes.\n\n    'minimize the number of erased symbols'\n    Explanation: The goal is to remove the fewest number of characters from the string to make it a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means finding the smallest count of characters that need to be removed to achieve a palindrome.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of removals needed, starting with a large value.\n3. Iterate over each unique character in the string s.\n4. For each character, remove all its occurrences and check if the resulting string is a palindrome using a two-pointer technique.\n5. If it is a palindrome, update the minimum number of removals if the current count is less than the stored value.\n6. If no palindrome can be formed after checking all characters, return -1 for that test case.\n7. Output the minimum number of removals for each test case.\n\n# [edge case] \n    Test case 1: \"a\" = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n    Test case 2: \"abc\" = -1\n    Explanation: No single character removal can make this string a palindrome.\n\n    Test case 3: \"aaabaaa\" = 1\n    Explanation: Removing one 'b' makes the string \"aaaaaa\", which is a palindrome.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and checking for palindromes will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a string to make it a palindrome, considering only one type of character can be erased. The solution must efficiently handle up to 100 test cases with strings of length up to 100,000, ensuring the sum of lengths does not exceed 200,000. The output must be consistent with the format specified.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum erasures needed for palindrome formation\n- Ensure the solution handles edge cases and large inputs effectively\n- Optimize the algorithm to reduce computational complexity\n- Provide clear and consistent output format\n- Document the solution approach and edge case handling\nWe will use a two-pointer technique to check if a string can be converted into a palindrome by removing occurrences of a single character. For each character in the string, we will simulate the removal of all occurrences of that character and check if the remaining string can be a palindrome. This approach ensures that we efficiently handle large inputs by minimizing unnecessary computations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The task is to make the string a palindrome by removing occurrences of a single character.\n\n    'minimize the number of erased symbols'\n    Explanation: The goal is to remove the fewest possible characters to achieve a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols': This means we need to find the least number of characters to remove to make the string a palindrome.\n    Implementation: Track the number of removals for each character and choose the minimum.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest number of removals required.\n    Implementation: Compare the number of removals for each character and select the smallest.\n\n# [code logic]\n1. For each test case, read the integer n and string s.\n2. Initialize a variable to store the minimum number of removals, starting with a large value.\n3. Iterate over each unique character in the string s.\n4. Use a two-pointer approach to simulate removing all occurrences of the current character.\n5. Check if the remaining string can be a palindrome.\n6. If it can, update the minimum number of removals if the current count is smaller.\n7. If no palindrome can be formed, return -1 for that test case.\n8. Output the minimum number of removals for each test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Removing two 'a's (first and last) results in 'bcaacb', which is a palindrome.\n\n    xyzxyz = -1\n    Explanation: No single character removal can make this string a palindrome.\n\n    abba = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of simulating removal for each character and checking for palindrome suffices.\n"], "scores": [], "pass_results": [true, false, true, true, true, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 420, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "mutate_method": "rephrase_one", "parent_index": 279}
