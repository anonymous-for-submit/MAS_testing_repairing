{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, and it is possible to travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies. Constraints ensure that n and q can be large, so optimize your solution for time complexity.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, and it is possible to travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies. Constraints ensure that n and q can be large, so optimize your solution for time complexity.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. It is possible to travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\nHelp them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies. Constraints ensure that n and q can be large, so optimize your solution for time complexity.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, where it is possible to travel between each pair of rooms through several tunnels, and the i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, taking max(|a_x + a_y|, |a_x - a_y|) energy; |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries of two types: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Your task is to efficiently handle the queries and determine the required sums of energies; constraints ensure that n and q can be large, so optimize your solution for time complexity.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum sum of energy needed to travel from room u to room v.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representation of the tree.\n\n    Returns:\n        int: The minimum sum of energy required.\n    \"\"\"\n    # Preprocess the tree to find the path from u to v using DFS\n    path = []\n    visited = [False] * len(tree)\n    \n    def dfs(current: int, target: int, path: List[int]) -> bool:\n        \"\"\"Depth First Search to find path from current to target.\"\"\"\n        if current == target:\n            path.append(current)\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target, path):\n                    return True\n        path.pop()\n        return False\n\n    dfs(u, v, path)\n\n    # Calculate the energy required for the path found\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, tree: List[List[int]], parent_list: List[int], depth_list: List[int]) -> None:\n    \"\"\"Perform a Depth-First Search to populate parent and depth information.\n\n    Args:\n        node (int): The current node being visited.\n        parent (int): The parent of the current node.\n        depth (int): The depth of the current node.\n        tree (List[List[int]]): The adjacency list representation of the tree.\n        parent_list (List[int]): The list to store parent information for each node.\n        depth_list (List[int]): The list to store depth information for each node.\n    \"\"\"\n    parent_list[node] = parent\n    depth_list[node] = depth\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, tree, parent_list, depth_list)\n\ndef lca(u: int, v: int, parent_list: List[int], depth_list: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\n\n    Args:\n        u (int): The first node.\n        v (int): The second node.\n        parent_list (List[int]): The list of parent information for each node.\n        depth_list (List[int]): The list of depth information for each node.\n\n    Returns:\n        int: The LCA of the two nodes.\n    \"\"\"\n    if depth_list[u] < depth_list[v]:\n        u, v = v, u\n    while depth_list[u] > depth_list[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(a: int, b: int, illusion_rates: List[int]) -> int:\n    \"\"\"Calculate the energy required to move between two rooms.\n\n    Args:\n        a (int): The first room.\n        b (int): The second room.\n        illusion_rates (List[int]): The list of illusion rates for all rooms.\n\n    Returns:\n        int: The energy required to move between the two rooms.\n    \"\"\"\n    return max(abs(illusion_rates[a] + illusion_rates[b]), abs(illusion_rates[a] - illusion_rates[b]))\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        u (int): The starting room.\n        v (int): The destination room.\n        illusion_rates (List[int]): The list of illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representation of the tree.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    n = len(illusion_rates)\n    parent_list = [-1] * (n + 1)\n    depth_list = [0] * (n + 1)\n    dfs(1, -1, 0, tree, parent_list, depth_list)\n    \n    ancestor = lca(u, v, parent_list, depth_list)\n    energy = 0\n    \n    # Calculate energy from u to ancestor\n    current = u\n    while current != ancestor:\n        energy += calculate_energy(current - 1, parent_list[current] - 1, illusion_rates)\n        current = parent_list[current]\n    \n    # Calculate energy from v to ancestor\n    current = v\n    while current != ancestor:\n        energy += calculate_energy(current - 1, parent_list[current] - 1, illusion_rates)\n        current = parent_list[current]\n    \n    return energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to efficiently update and query illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at a specific index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], current: int, parent: int, path: List[int]):\n    \"\"\"Performs DFS to find the path from the root to the current node.\"\"\"\n    path.append(current)\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            dfs(tree, neighbor, current, path)\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(start_room: int, end_room: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from one room to another.\"\"\"\n    n = len(illusion_rates)\n    tree = [[] for _ in range(n)]\n    for u, v in tunnels:\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n    \n    path = []\n    dfs(tree, start_room - 1, -1, path)\n    \n    energy = 0\n    for i in range(len(path) - 1):\n        u, v = path[i], path[i + 1]\n        energy += max(abs(illusion_rates[u] + illusion_rates[v]), abs(illusion_rates[u] - illusion_rates[v]))\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            update_illusion_rate(int(query[1]), int(query[2]), illusion_rates, segment_tree)\n        elif query[0] == '2':\n            result = calculate_min_energy(int(query[1]), int(query[2]), illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Helper function to perform DFS and find the path from u to v\n    def dfs(current: int, target: int, parent: int, path: List[int]) -> bool:\n        if current == target:\n            path.append(current)\n            return True\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                if dfs(neighbor, target, current, path):\n                    path.append(current)\n                    return True\n        return False\n\n    # Find the path from u to v using DFS\n    path = []\n    dfs(u, v, -1, path)\n    path.reverse()\n\n    # Calculate the total energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]) -> None:\n    \"\"\"Perform Depth First Search to calculate depth and parent of each node.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(tree, neighbor, node, depth, parent_list)\n\ndef calculate_energy(a_x: int, a_y: int) -> int:\n    \"\"\"Calculate the energy required to move between two rooms.\"\"\"\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum sum of energy needed to travel from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    depth = [0] * (n + 1)\n    parent_list = [-1] * (n + 1)\n    \n    # Initialize DFS from node 1 (assuming 1 is the root)\n    dfs(tree, 1, -1, depth, parent_list)\n    \n    # Find the path from u to v using parent_list\n    path_u = []\n    path_v = []\n    \n    # Trace path from u to root\n    while u != -1:\n        path_u.append(u)\n        u = parent_list[u]\n    \n    # Trace path from v to root\n    while v != -1:\n        path_v.append(v)\n        v = parent_list[v]\n    \n    # Find the lowest common ancestor (LCA)\n    path_u.reverse()\n    path_v.reverse()\n    \n    lca_index = 0\n    while lca_index < min(len(path_u), len(path_v)) and path_u[lca_index] == path_v[lca_index]:\n        lca_index += 1\n    \n    # Calculate energy from u to LCA and from LCA to v\n    total_energy = 0\n    for i in range(lca_index, len(path_u)):\n        total_energy += calculate_energy(illusion_rates[path_u[i] - 1], illusion_rates[parent_list[path_u[i]] - 1])\n    \n    for i in range(lca_index, len(path_v)):\n        total_energy += calculate_energy(illusion_rates[path_v[i] - 1], illusion_rates[parent_list[path_v[i]] - 1])\n    \n    return total_energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            result = calculate_min_energy(query[1], query[2], illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(tree: List[List[int]], current: int, parent: int, depth: List[int], parent_list: List[int]) -> None:\n    \"\"\"Perform Depth First Search to preprocess the tree.\"\"\"\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            depth[neighbor] = depth[current] + 1\n            parent_list[neighbor] = current\n            dfs(tree, neighbor, current, depth, parent_list)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    depth = [0] * (n + 1)\n    parent_list = [-1] * (n + 1)\n    \n    # Preprocess the tree using DFS\n    dfs(tree, 1, -1, depth, parent_list)\n    \n    # Find the path from u to v using parent_list\n    path_u = []\n    path_v = []\n    \n    while u != -1:\n        path_u.append(u)\n        u = parent_list[u]\n    \n    while v != -1:\n        path_v.append(v)\n        v = parent_list[v]\n    \n    # Find the lowest common ancestor (LCA)\n    path_u.reverse()\n    path_v.reverse()\n    \n    lca_index = 0\n    while lca_index < min(len(path_u), len(path_v)) and path_u[lca_index] == path_v[lca_index]:\n        lca_index += 1\n    \n    lca_index -= 1\n    \n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(lca_index, len(path_u) - 1):\n        a_x = illusion_rates[path_u[i] - 1]\n        a_y = illusion_rates[path_u[i + 1] - 1]\n        total_energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    \n    for i in range(lca_index, len(path_v) - 1):\n        a_x = illusion_rates[path_v[i] - 1]\n        a_y = illusion_rates[path_v[i + 1] - 1]\n        total_energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    \n    return total_energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates)\n        elif query[0] == 2:\n            result = calculate_min_energy(query[1], query[2], illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass TreeProcessor:\n    def __init__(self, n: int, tree: List[List[int]]):\n        self.n = n\n        self.tree = tree\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.preprocess_tree()\n\n    def preprocess_tree(self):\n        \"\"\"Preprocess the tree using DFS to establish parent-child relationships and calculate initial paths.\"\"\"\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, parent: int, depth: int):\n        \"\"\"Depth First Search to set parent and depth for each node.\"\"\"\n        self.parent[node] = parent\n        self.depth[node] = depth\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                self.dfs(neighbor, node, depth + 1)\n\n    def find_lca(self, u: int, v: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\"\"\"\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\nclass SegmentTree:\n    def __init__(self, illusion_rates: List[int]):\n        self.n = len(illusion_rates)\n        self.tree = [0] * (2 * self.n)\n        self.build(illusion_rates)\n\n    def build(self, illusion_rates: List[int]):\n        \"\"\"Build the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = illusion_rates[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, pos: int, value: int):\n        \"\"\"Update the illusion rate at a specific position.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n\n    def query(self, l: int, r: int) -> int:\n        \"\"\"Query the sum of values in a range.\"\"\"\n        res = 0\n        l += self.n\n        r += self.n\n        while l <= r:\n            if l % 2 == 1:\n                res += self.tree[l]\n                l += 1\n            if r % 2 == 0:\n                res += self.tree[r]\n                r -= 1\n            l //= 2\n            r //= 2\n        return res\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree_processor: TreeProcessor) -> int:\n    \"\"\"Calculate the minimum sum of energy needed to travel from room u to room v.\"\"\"\n    lca = tree_processor.find_lca(u, v)\n    energy = 0\n    current = u\n    while current != lca:\n        parent = tree_processor.parent[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[parent - 1]),\n                      abs(illusion_rates[current - 1] - illusion_rates[parent - 1]))\n        current = parent\n    current = v\n    while current != lca:\n        parent = tree_processor.parent[current]\n        energy += max(abs(illusion_rates[current - 1] + illusion_rates[parent - 1]),\n                      abs(illusion_rates[current - 1] - illusion_rates[parent - 1]))\n        current = parent\n    return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    tree_processor = TreeProcessor(n, tree)\n    segment_tree = SegmentTree(illusion_rates)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == 2:\n            _, u, v = query\n            result = calculate_minimum_energy(u, v, illusion_rates, tree_processor)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tree: List[List[int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = tree\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.segment_tree = [0] * (4 * n)\n        self.build_tree()\n        self.dfs(1, -1, 0)\n        self.build_segment_tree(1, 1, n)\n\n    def build_tree(self):\n        # Initialize tree structure\n        pass\n\n    def dfs(self, node: int, parent: int, depth: int):\n        self.parent[node] = parent\n        self.depth[node] = depth\n        for neighbor in self.tree[node]:\n            if neighbor != parent:\n                self.dfs(neighbor, node, depth + 1)\n\n    def build_segment_tree(self, node: int, start: int, end: int):\n        if start == end:\n            self.segment_tree[node] = self.illusion_rates[start - 1]\n        else:\n            mid = (start + end) // 2\n            self.build_segment_tree(2 * node, start, mid)\n            self.build_segment_tree(2 * node + 1, mid + 1, end)\n            self.segment_tree[node] = max(self.segment_tree[2 * node], self.segment_tree[2 * node + 1])\n\n    def update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int):\n        if start == end:\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update_segment_tree(2 * node, start, mid, idx, value)\n            else:\n                self.update_segment_tree(2 * node + 1, mid + 1, end, idx, value)\n            self.segment_tree[node] = max(self.segment_tree[2 * node], self.segment_tree[2 * node + 1])\n\n    def query_segment_tree(self, node: int, start: int, end: int, L: int, R: int) -> int:\n        if R < start or end < L:\n            return float('-inf')\n        if L <= start and end <= R:\n            return self.segment_tree[node]\n        mid = (start + end) // 2\n        left_query = self.query_segment_tree(2 * node, start, mid, L, R)\n        right_query = self.query_segment_tree(2 * node + 1, mid + 1, end, L, R)\n        return max(left_query, right_query)\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        self.illusion_rates[room - 1] = new_rate\n        self.update_segment_tree(1, 1, self.n, room, new_rate)\n\n    def calculate_minimum_energy(self, u: int, v: int) -> int:\n        # Find LCA and calculate energy\n        path = self.find_path(u, v)\n        energy = 0\n        for i in range(len(path) - 1):\n            a_x = self.illusion_rates[path[i] - 1]\n            a_y = self.illusion_rates[path[i + 1] - 1]\n            energy += max(abs(a_x + a_y), abs(a_x - a_y))\n        return energy\n\n    def find_path(self, u: int, v: int) -> List[int]:\n        # Find path from u to v using parent information\n        path_u = self.get_path_to_root(u)\n        path_v = self.get_path_to_root(v)\n        lca = self.find_lca(path_u, path_v)\n        path = path_u[:path_u.index(lca) + 1] + path_v[path_v.index(lca) + 1:][::-1]\n        return path\n\n    def get_path_to_root(self, node: int) -> List[int]:\n        path = []\n        while node != -1:\n            path.append(node)\n            node = self.parent[node]\n        return path\n\n    def find_lca(self, path_u: List[int], path_v: List[int]) -> int:\n        # Find Lowest Common Ancestor\n        set_u = set(path_u)\n        for node in path_v:\n            if node in set_u:\n                return node\n        return -1\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    maze = Maze(n, illusion_rates, tree)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            maze.update_illusion_rate(query[1], query[2])\n        elif query[0] == 2:\n            result = maze.calculate_minimum_energy(query[1], query[2])\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle updates efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at the given index.\"\"\"\n        pos = index + self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_info: List[int]):\n    \"\"\"Performs DFS to precompute depth and parent information.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_info[neighbor] = node\n            dfs(tree, neighbor, node, depth, parent_info)\n\ndef lca(u: int, v: int, depth: List[int], parent_info: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor (LCA) of nodes u and v.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent_info[u]\n    while u != v:\n        u = parent_info[u]\n        v = parent_info[v]\n    return u\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], parent_info: List[int], depth: List[int]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    ancestor = lca(u, v, depth, parent_info)\n    energy = 0\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u] + illusion_rates[parent_info[u]]), abs(illusion_rates[u] - illusion_rates[parent_info[u]]))\n        u = parent_info[u]\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v] + illusion_rates[parent_info[v]]), abs(illusion_rates[v] - illusion_rates[parent_info[v]]))\n        v = parent_info[v]\n    return energy\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a room.\"\"\"\n    illusion_rates[room] = new_rate\n    segment_tree.update(room, new_rate)\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    # Precompute depth and parent information using DFS\n    depth = [0] * (n + 1)\n    parent_info = [-1] * (n + 1)\n    dfs(tree, 1, -1, depth, parent_info)\n    \n    # Initialize Segment Tree\n    segment_tree = SegmentTree(illusion_rates)\n    \n    # Process queries\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == 2:\n            _, u, v = query\n            result = calculate_minimum_energy(u, v, illusion_rates, tree, parent_info, depth)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle range queries and updates efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Updates the value at position pos.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\nclass HeavyLightDecomposition:\n    \"\"\"Heavy-Light Decomposition to handle path queries on trees.\"\"\"\n    \n    def __init__(self, n: int, tree: List[List[int]], illusion_rates: List[int]):\n        self.n = n\n        self.tree = tree\n        self.illusion_rates = illusion_rates\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.size = [0] * (n + 1)\n        self.chain_head = [-1] * (n + 1)\n        self.chain_index = [-1] * (n + 1)\n        self.pos_in_base = [-1] * (n + 1)\n        self.base_array = []\n        self.segment_tree = None\n        self.chain_count = 0\n        self.dfs(1, -1)\n        self.hld(1, -1)\n        self.segment_tree = SegmentTree(self.base_array)\n    \n    def dfs(self, node: int, parent: int):\n        \"\"\"Performs DFS to calculate size and depth of each node.\"\"\"\n        self.parent[node] = parent\n        self.size[node] = 1\n        for neighbor in self.tree[node]:\n            if neighbor == parent:\n                continue\n            self.depth[neighbor] = self.depth[node] + 1\n            self.dfs(neighbor, node)\n            self.size[node] += self.size[neighbor]\n    \n    def hld(self, node: int, parent: int):\n        \"\"\"Performs Heavy-Light Decomposition.\"\"\"\n        if self.chain_head[self.chain_count] == -1:\n            self.chain_head[self.chain_count] = node\n        self.chain_index[node] = self.chain_count\n        self.pos_in_base[node] = len(self.base_array)\n        self.base_array.append(self.illusion_rates[node - 1])\n        \n        # Find the special child (heavy child)\n        special_child = -1\n        max_size = -1\n        for neighbor in self.tree[node]:\n            if neighbor != parent and self.size[neighbor] > max_size:\n                max_size = self.size[neighbor]\n                special_child = neighbor\n        \n        if special_child != -1:\n            self.hld(special_child, node)\n        \n        # Decompose the light edges\n        for neighbor in self.tree[node]:\n            if neighbor != parent and neighbor != special_child:\n                self.chain_count += 1\n                self.hld(neighbor, node)\n    \n    def update_illusion_rate(self, room: int, new_rate: int):\n        \"\"\"Updates the illusion rate of a specified room.\"\"\"\n        pos = self.pos_in_base[room]\n        self.segment_tree.update(pos, new_rate)\n    \n    def min_energy_path(self, u: int, v: int) -> int:\n        \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n        result = 0\n        while self.chain_index[u] != self.chain_index[v]:\n            if self.depth[self.chain_head[self.chain_index[u]]] < self.depth[self.chain_head[self.chain_index[v]]]:\n                u, v = v, u\n            chain_head_u = self.chain_head[self.chain_index[u]]\n            result += self.segment_tree.query(self.pos_in_base[chain_head_u], self.pos_in_base[u] + 1)\n            u = self.parent[chain_head_u]\n        \n        if self.depth[u] > self.depth[v]:\n            u, v = v, u\n        result += self.segment_tree.query(self.pos_in_base[u], self.pos_in_base[v] + 1)\n        return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = []\n    for _ in range(n):\n        illusion_rates.append(int(data[index]))\n        index += 1\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    hld = HeavyLightDecomposition(n, tree, illusion_rates)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        if query_type == 1:\n            u = int(data[index])\n            index += 1\n            c = int(data[index])\n            index += 1\n            hld.update_illusion_rate(u, c)\n        elif query_type == 2:\n            u = int(data[index])\n            index += 1\n            v = int(data[index])\n            index += 1\n            result = hld.min_energy_path(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on efficiently handling queries related to illusion rate updates and energy calculations in a tree-structured maze. The solution must be optimized for large input sizes, ensuring quick response times and accurate results.\nrequirement pool:\n- Efficient query handling for illusion rate updates\n- Accurate calculation of minimum energy required\n- Optimization for large input sizes\n- Ensure seamless navigation through the maze\n- User-friendly interface for query input\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to quickly find the path between any two nodes. We will also use a Segment Tree to handle the updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'minimum': In the context of the type 2 query, it refers to finding the minimum sum of energy needed to travel from one room to another. This involves finding the shortest path in terms of energy cost.\n\n# [code logic]\n    1. Preprocess the tree using DFS to calculate necessary paths and prepare for LCA queries.\n    2. Use LCA to efficiently find paths between any two nodes for type 2 queries.\n    3. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    4. For type 1 queries, update the illusion rate of a specified room.\n    5. For type 2 queries, calculate the minimum sum of energy needed using preprocessed data and LCA.\n\n# [edge case]\n    Edge Case 1: When n = 2, q = 1, and both rooms have the same illusion rate.\n    Input: \n    ```\n    2 1\n    5 5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: The energy required is max(|5 + 5|, |5 - 5|) = 10.\n\n    Edge Case 2: When all rooms have an illusion rate of zero.\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: The energy required is max(|0 + 0|, |0 - 0|) = 0 for all paths.\n\n    Edge Case 3: When there is only one query and it is a type 1 query.\n    Input:\n    ```\n    3 1\n    1 -1 2\n    1 2\n    2 3\n    1 1 -5\n    ```\n    Expected Output:\n    No output since it's a type 1 query.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic using DFS, LCA, and Segment Tree will handle these scenarios efficiently.\n", "requirement analysis:\nThe main challenge is to efficiently handle up to 100,000 queries on a tree structure with up to 100,000 nodes. The solution must support dynamic updates to node attributes and compute path energies quickly. This requires a combination of data structures for fast updates and path queries, likely involving techniques such as heavy-light decomposition or segment trees.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Accurately compute the minimum energy required for type 2 queries.\n- Optimize the solution to handle the maximum constraints smoothly.\n- Ensure the solution is scalable and maintainable.\n- Provide clear and concise output for each query.\nWe will use a combination of data structures to efficiently handle the queries. For the tree structure, we will use adjacency lists to represent the rooms and tunnels. To handle the dynamic updates and path queries efficiently, we will employ techniques such as Heavy-Light Decomposition (HLD) or Segment Trees. These techniques allow us to decompose the tree into manageable segments, enabling fast updates and queries. We will also use Depth-First Search (DFS) to preprocess the tree for LCA (Lowest Common Ancestor) calculations, which are crucial for determining paths in the tree.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected graph with no cycles. This structure allows traversal between any two rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the maximum of the absolute values of the sum and difference of their illusion rates.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the greater of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function with `abs` for absolute values.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from room u to room v. This involves calculating the path with the least energy consumption.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Preprocess the tree using DFS to prepare for LCA calculations.\n3. Implement Heavy-Light Decomposition or Segment Trees to efficiently handle updates and queries.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, calculate the minimum energy required using preprocessed data and path calculations.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires 0 energy.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n    Expected Output: 2000000000\n    Explanation: The path from room 1 to room 3 involves high illusion rates, resulting in maximum energy consumption.\n\n    Input: 4 3\n           -5 -5 -5 -5\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Expected Output: 15\n    Explanation: The illusion rates are negative but equal, resulting in consistent energy calculations across the path.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic for calculating energy based on illusion rates and tree traversal will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing illusion rates and calculating minimum energy needed for treasure retrieval. The solution must be optimized for large inputs and ensure accurate energy calculations.\nrequirement pool:\n- Efficiently handle type 1 queries to change illusion rates.\n- Accurately calculate minimum energy for type 2 queries.\n- Optimize solution for large input sizes.\n- Ensure solution reliability and accuracy.\n- Provide clear documentation of energy calculation process.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate paths, while Segment Tree will allow us to update and query the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, forming a connected graph with no cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to travel between two rooms is determined by the maximum of the absolute sum or difference of their illusion rates.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute value of the sum or difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves calculating the path with the least energy cost.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to traverse the tree and calculate paths between rooms.\n    4. Use a Segment Tree to efficiently update and query illusion rates.\n    5. For type 1 queries, update the illusion rate of a specified room.\n    6. For type 2 queries, calculate the minimum energy required to travel from one room to another using DFS and Segment Tree.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy calculation is straightforward using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, the energy required is zero.\n\n    Case 3: Large illusion rates\n    Input:\n    ```\n    3 1\n    1000000000 -1000000000 1000000000\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    3000000000\n    ```\n    Explanation: The large values test the handling of maximum integer values in calculations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will handle these cases efficiently.\n", "requirement analysis:\nThe main challenge is to efficiently handle both types of queries given the constraints on n and q. The solution must be optimized for time complexity, likely involving data structures that support fast updates and queries, such as segment trees or binary indexed trees. Additionally, the solution should be robust to handle the maximum constraints without performance issues.\nrequirement pool:\n- Efficiently process type 1 queries to update illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy.\n- Ensure the solution is scalable to handle maximum constraints.\n- Provide clear and concise output for each query.\n- Optimize memory usage to handle large datasets.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. For the type 1 query, we will update the illusion rate of a room in constant time. For the type 2 query, we will use LCA to find the path between two rooms and calculate the minimum energy required using precomputed values. This approach ensures that both types of queries are handled in logarithmic time complexity, which is optimal given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, it represents the maze structure with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: This is a property of each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n    'query'\n    Explanation: There are two types of queries: updating the illusion rate of a room and calculating the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function with `abs`.\n\n# [degree adverb] \n    'minimum': In the context of type 2 queries, it refers to finding the least sum of energies required to travel from one room to another. This can be implemented by calculating the path energy and selecting the smallest possible value.\n\n# [code logic]\n1. Parse input to construct the tree and store initial illusion rates.\n2. For type 1 queries, update the illusion rate of the specified room.\n3. For type 2 queries:\n   - Use LCA to find the path between two rooms.\n   - Calculate the energy for each segment of the path using max(|a_x + a_y|, |a_x - a_y|).\n   - Sum these energies to get the total energy required for the path.\n4. Output the result for each type 2 query.\n\n# [edge case] \n    1. Minimum number of rooms (n=2): Ensure that the code handles the smallest tree correctly.\n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: \n       ```\n       10\n       ```\n       Explanation: The only path is from room 1 to room 2, with energy max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All rooms have zero illusion rate:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output:\n       ```\n       0\n       ```\n       Explanation: All energies are zero since all illusion rates are zero.\n\n    3. Large illusion rate change:\n       Input:\n       ```\n       3 2\n       1000000000 -1000000000 0\n       1 2\n       2 3\n       1 1 -1000000000\n       2 1 3\n       ```\n       Expected Output:\n       ```\n       2000000000\n       ```\n       Explanation: After changing room 1's rate, moving from room 1 to room 3 involves max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic should handle them correctly by ensuring that updates and calculations are performed accurately based on input constraints and conditions.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates to the illusion rates and calculate the minimum energy path in a tree structure. The solution must be optimized for large input sizes, ensuring quick response times for both types of queries. The use of data structures like segment trees or heavy-light decomposition may be necessary to achieve the desired performance.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Calculate minimum energy path between any two rooms.\n- Optimize for large input sizes and query counts.\n- Ensure accurate and reliable energy calculations.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Heavy-Light Decomposition (HLD) to efficiently handle the queries. DFS will help in traversing the tree structure, while HLD will allow us to manage path queries and updates efficiently. This approach is optimal for handling large input sizes and query counts, ensuring quick response times.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'minimum sum of energy': This means finding the smallest possible total energy required to travel from one room to another. In code, this involves calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Implement DFS to calculate initial paths and prepare for Heavy-Light Decomposition (HLD).\n3. Use HLD to decompose the tree into chains for efficient path queries.\n4. For type 1 queries, update the illusion rate of a room.\n5. For type 2 queries, calculate the minimum energy required using precomputed paths and HLD.\n6. Output the result for each type 2 query.\n\n# [edge case] \n    1. Minimum number of rooms (n=2): The simplest tree with only one tunnel.\n       Explanation: The energy calculation is straightforward as there is only one path.\n    2. All rooms have zero illusion rate: The energy for any path should be zero.\n       Explanation: Since all illusion rates are zero, max(|0 + 0|, |0 - 0|) = 0 for any path.\n    3. Maximum number of rooms (n=100000) with maximum queries (q=100000): Test efficiency and performance.\n       Explanation: Ensures that the algorithm handles large input sizes within time limits.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of DFS and HLD. The algorithm's efficiency ensures it can handle large inputs within constraints.\n", "requirement analysis:\nThe solution must efficiently handle up to 100,000 queries and room changes, ensuring that energy calculations are optimized for time complexity. The tree structure of the maze should be leveraged to minimize computational overhead.\nrequirement pool:\n- Efficient query handling for room rate changes\n- Optimized energy calculation between rooms\n- Scalability to handle large datasets\n- Accurate output for all test cases\n- User-friendly interface for input and output\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path between any two rooms efficiently. We will utilize Segment Trees to handle updates to the illusion rates and efficiently calculate the minimum energy required for queries. This approach leverages the tree structure and ensures optimal time complexity for both updates and queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: The illusion rate is a value associated with each room that affects the energy cost to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented as `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb] \n    'minimum': This indicates that for type 2 queries, we need to find the minimum sum of energy required to travel from room u to room v. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Use Depth First Search (DFS) to preprocess the tree and calculate paths between rooms.\n3. Implement a Segment Tree or Binary Indexed Tree to handle updates to illusion rates efficiently.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, calculate the minimum energy required using preprocessed path information and current illusion rates.\n\n# [edge case] \n    1. Query with u = v: The expected output is 0 because no energy is needed to stay in the same room.\n    Explanation: Since no movement is required, the energy cost is zero.\n\n    2. All rooms have zero illusion rate: The expected output for any path is 0.\n    Explanation: If all illusion rates are zero, then max(|0 + 0|, |0 - 0|) = 0 for any path.\n\n    3. Maximum possible illusion rate change: Test with maximum allowed values for c (10^9) and verify correct handling.\n    Explanation: Ensure that the code handles large numbers without overflow and correctly updates and calculates energy.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to updates and queries efficiently.\n    \n```python\ndef handle_query_type_1(u, c):\n    # Update the illusion rate of room u to c\n    # Update segment tree or data structure used for efficient updates\n\ndef handle_query_type_2(u, v):\n    # Calculate minimum energy from room u to v using preprocessed paths\n    # Use current illusion rates from data structure\n```\n\nThis approach ensures that both types of queries are handled efficiently, even for large input sizes.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates to the illusion rates and calculate the minimum energy required for paths in a large tree structure. The solution must be optimized for both time and space complexity to handle up to 100,000 rooms and queries.\nrequirement pool:\n- Efficiently process type 1 queries to update illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy.\n- Optimize data structures for fast query handling.\n- Ensure the solution scales with large input sizes.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to quickly find the path between any two nodes. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. This structure is crucial for efficiently finding paths and handling updates.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy calculation when moving between rooms. It can be updated dynamically, which requires efficient handling.\n\n    'energy'\n    Explanation: Energy is calculated using the formula max(|a_x + a_y|, |a_x - a_y|) when moving between rooms x and y. This is the core calculation for determining the cost of moving through the maze.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This requires efficient pathfinding and energy calculation.\n\n# [code logic]\n1. Preprocess the tree using DFS to establish parent-child relationships and calculate initial paths.\n2. Use LCA to quickly find paths between any two nodes for type 2 queries.\n3. Implement a Segment Tree to handle updates to illusion rates efficiently.\n4. For type 2 queries, calculate the energy required using the preprocessed paths and updated illusion rates.\n\n# [edge case]\n    Edge Case 1: n = 2, q = 1, a = [0, 0], queries = [(2, 1, 2)]\n    Expected Output: 0\n    Explanation: With only two rooms and zero illusion rates, the energy required is zero.\n\n    Edge Case 2: n = 3, q = 2, a = [10^9, -10^9, 0], queries = [(2, 1, 3), (1, 2, 10^9)]\n    Expected Output: 10^9\n    Explanation: Initially, moving from room 1 to room 3 through room 2 requires max(|10^9 + (-10^9)|, |10^9 - (-10^9)|) = 10^9 energy.\n\n    Edge Case 3: n = 4, q = 3, a = [1, -1, 1, -1], queries = [(2, 1, 4), (1, 3, -1), (2, 1, 4)]\n    Expected Output: 4\n    Explanation: The path from room 1 to room 4 initially requires max(|1 + (-1)|, |1 - (-1)|) = 2 energy twice.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA with Segment Tree updates will efficiently handle all cases including edge cases.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates to the illusion rates and calculate the minimum energy required for traversal in a tree structure. The solution must be optimized for large input sizes and frequent queries.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Calculate minimum energy for room traversal accurately.\n- Optimize the solution for large datasets.\n- Ensure the solution is scalable with increasing queries.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to quickly find the path between any two nodes. We will also use a Segment Tree to handle the updates to the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it has n rooms and n-1 tunnels, forming a connected graph with no cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'queries'\n    Explanation: There are two types of queries: one that updates the illusion rate of a room and another that calculates the minimum energy required to travel between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the energy calculation between two rooms, where the energy is the maximum of the absolute sum or difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves finding the shortest path in terms of energy consumption.\n\n# [code logic]\n    1. Preprocess the tree using DFS to establish parent-child relationships and calculate paths.\n    2. Use LCA to efficiently find paths between any two nodes for type 2 queries.\n    3. Implement a Segment Tree to handle updates to illusion rates for type 1 queries.\n    4. For type 2 queries, calculate the energy using the formula max(|a_x + a_y|, |a_x - a_y|) for each segment of the path.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: Direct calculation between two rooms with given illusion rates.\n\n    Case 2: All rooms have zero illusion rate\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, no energy is required.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After changing the illusion rate, calculate the energy with maximum values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will efficiently handle these scenarios.\n", "requirement analysis:\nThe main challenge is to efficiently handle updates to the illusion rates and calculate the minimum energy required for paths in a tree structure. The solution must be optimized for large input sizes, ensuring quick response times for both types of queries.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Calculate minimum energy required for paths quickly.\n- Optimize the solution for large input sizes.\n- Ensure the solution is scalable and maintainable.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in precomputing necessary data for quick LCA queries, which will allow us to determine the path between any two nodes in the tree. We will also use a Segment Tree to handle updates to the illusion rates efficiently. This approach ensures that both update and query operations are optimized for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A data structure consisting of nodes, where each node has zero or more child nodes, and there is exactly one path between any two nodes.\n    'illusion rate': A numerical value associated with each room that affects the energy calculation when moving between rooms.\n    'query': An operation that either updates the illusion rate of a room or calculates the minimum energy required to move between two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates the calculation of energy required to move between two rooms, where the energy is the maximum of the absolute sum or difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': Refers to finding the least possible sum of energies required to move from one room to another. This can be implemented by calculating the path using LCA and summing up the energies along the path.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Use DFS to precompute data for LCA queries, such as parent and depth information.\n    3. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    4. For type 2 queries, use LCA to find the path between two rooms and calculate the total energy using the precomputed data and current illusion rates.\n    5. For type 1 queries, update the Segment Tree with the new illusion rate.\n\n# [edge case]\n    1. Input: 2 1\n       Illusion rates: 0 0\n       Tunnel: 1 2\n       Query: 2 1 2\n       Expected output: 0\n       Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n       \n    2. Input: 3 1\n       Illusion rates: 10 -10 10\n       Tunnels: 1 2, 2 3\n       Query: 2 1 3\n       Expected output: 30\n       Explanation: The path is 1 \u2192 2 \u2192 3, with energies max(|10 + (-10)|, |10 - (-10)|) = 20 and max(|-10 + 10|, |-10 - 10|) = 10.\n\n    3. Input: 4 1\n       Illusion rates: -5 -5 -5 -5\n       Tunnels: 1 2, 2 3, 3 4\n       Query: 2 1 4\n       Expected output: 30\n       Explanation: The path is 1 \u2192 2 \u2192 3 \u2192 4, with each step requiring max(|-5 + (-5)|, |-5 - (-5)|) = 10 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will handle these cases correctly by ensuring that all paths and updates are processed efficiently.\n", "requirement analysis:\nThe main challenge is to efficiently handle up to 100,000 queries on a tree structure with up to 100,000 nodes. The solution must support dynamic updates to node attributes and compute the minimum energy path between any two nodes. This requires a combination of data structures for fast updates and path queries, such as segment trees or heavy-light decomposition.\nrequirement pool:\n- Efficiently handle up to 100,000 queries.\n- Support dynamic updates to room illusion rates.\n- Calculate minimum energy path between any two rooms.\n- Optimize for large input sizes to ensure quick response times.\n- Ensure accuracy in energy calculations for user trust.\nWe will use a combination of data structures to efficiently handle the queries. For dynamic updates and path queries on a tree, we can use Heavy-Light Decomposition (HLD) along with Segment Trees. HLD will help in breaking down the tree into manageable paths, and Segment Trees will allow us to efficiently update and query the illusion rates. This approach is optimal for handling large input sizes and ensuring quick response times.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, it represents the maze with rooms as nodes and tunnels as edges.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy cost to travel between rooms.\n\n    'energy'\n    Explanation: The energy required to travel between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented using Python's built-in `max` and `abs` functions.\n\n# [degree adverb]\n    'minimum': In the context of query type 2, it refers to finding the minimum sum of energy needed to travel from room u to room v. This requires efficiently calculating the path with the least energy cost.\n\n# [code logic]\n1. Parse input to construct the tree using adjacency lists.\n2. Implement Heavy-Light Decomposition (HLD) to break down the tree into paths.\n3. Use Segment Trees to manage and update illusion rates efficiently.\n4. For query type 1 (update), update the illusion rate of a specified room.\n5. For query type 2 (path query), calculate the minimum energy required using HLD and Segment Trees to traverse from room u to room v.\n\n# [edge case]\n    1. Minimum number of rooms (n=2): \n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: 10\n       Explanation: Only one path exists, and energy is calculated as max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All rooms have zero illusion rate:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output: 0\n       Explanation: All illusion rates are zero, so any path will have zero energy cost.\n\n    3. Large illusion rate change:\n       Input:\n       ```\n       3 2\n       1000000000 -1000000000 0\n       1 2\n       2 3\n       1 1 -1000000000\n       2 1 3\n       ```\n       Expected Output: 2000000000\n       Explanation: After updating room 1's illusion rate, the path from room 1 to room 3 has an energy cost of max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using HLD and Segment Trees will efficiently manage updates and queries, including edge cases.\n"], "scores": [], "pass_results": [true, false, true, false, true, false, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 726, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "add_1_sentence_at_end", "parent_index": 403}
