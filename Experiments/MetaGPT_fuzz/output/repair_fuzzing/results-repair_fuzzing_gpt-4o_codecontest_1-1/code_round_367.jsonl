{"name": "1591_C. Minimize Distance", "description": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "tags": ["greedy", "math"], "difficulty": 9, "id": 1591, "sample_io": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}], "test_list": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["30\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 1 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["21\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n41\n7\n3000010100\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["13\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n7\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n12\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n51\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n44\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 9 3\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n10\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n37\n7\n3000000000\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["13\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n45\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["27\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010000000\n", "output": ["16\n44\n8\n3010000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["25\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n46\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 4 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1010000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3010000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n39\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n11\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 4 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["29\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["16\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 4\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n6\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n34\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 5 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["31\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 8 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["20\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n40\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 3 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 7\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["27\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 4 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 4 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 1\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n7000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n1 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n23\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n48\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 1 3 4 3\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 0 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 9 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n48\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["18\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 0\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["30\n41\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 6 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -23 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n49\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 4\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 16 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["38\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000001 1000000000\n", "output": ["25\n44\n9\n3000000001\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 3 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n-1 2 3 4 5\n9 3\n-5 -10 -15 9 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 10 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n28\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 0\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["18\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 5\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 1 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["14\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 3 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n49\n7\n3000010100\n"]}, {"input": "4\n5 2\n2 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["15\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n2 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["31\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 0000000000 1000110000\n", "output": ["30\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n1 2 3 2 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["17\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 0 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n19\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n4 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n43\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 6\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 14 8 3 7 0\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 0 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n42\n10\n3000000001\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1001000000 1000010000\n", "output": ["13\n39\n8\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -9 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n32\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 5\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1000010000\n", "output": ["25\n63\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1001000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3001000000\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["30\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 4 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1010010000\n", "output": ["25\n57\n27\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 8 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["32\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 6 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["26\n40\n27\n3000010000\n"]}, {"input": "4\n5 2\n1 2 4 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["15\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 8 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n12\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 2\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n15\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 6\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["26\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1010110000\n", "output": ["30\n43\n13\n3010110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 8\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n43\n9\n7000100000\n"]}, {"input": "4\n5 1\n1 2 3 7 2\n9 3\n-14 -18 -13 6 5 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000100000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000100000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 1 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n44\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 4\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n1001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -6 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n35\n8\n3010100000\n"]}, {"input": "4\n5 2\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["7\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n73\n8\n3000010100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -18 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1000010000\n", "output": ["25\n57\n32\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -26 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n54\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["18\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -14 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n11\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["13\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 1 8 3 7 4\n5 4\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n37\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n1 0 3 5 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n19\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n32\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000100001 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000100001\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-7 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n139\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n0 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["28\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -6 -15 10 5 8 4 0 0\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n35\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 0\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -20 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["25\n140\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000000100\n", "output": ["30\n40\n8\n3000000100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-2 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n129\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000111000\n", "output": ["27\n43\n13\n1000111000\n"]}, {"input": "4\n5 2\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["11\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -4 -15 10 3 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 1\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 5 4\n5 3\n2 2 5 3 3\n4 2\n1000001000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000001000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 3 8 0 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["20\n41\n10\n3000010000\n"]}], "task_id": "codecontest/47", "prompt": "A total of n depots are positioned on a number line. Depot i is located at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots, and both you and the n bags are initially at the origin 0, and you can carry up to k bags at a time. You must pick up the necessary number of goods from the origin, take them to the respective depots, and then return to the origin to gather your next batch of goods.\n\nFind the shortest distance you need to travel to deliver every bag of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "repair_prompt": ["A total of n depots are positioned on a number line. Depot i is located at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots, and both you and the n bags are initially at the origin 0, and you can carry up to k bags at a time. You must pick up the necessary number of goods from the origin, take them to the respective depots, and then return to the origin to gather your next batch of goods.\n\nFind the shortest distance you need to travel to deliver every bag of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "A total of n depots are positioned on a number line. Depot i is located at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots, and both you and the n bags are initially at the origin 0, and you can carry up to k bags at a time. You must pick up the necessary number of goods from the origin, take them to the respective depots, and then return to the origin to gather your next batch of goods. This process of returning to the origin is crucial for picking up the next set of goods. It ensures that you can continue the delivery process smoothly.\n\nFind the shortest distance you need to travel to deliver every bag of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "A total of n depots are positioned on a number line. Depot i is located at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots, and both you and the n bags are initially at the origin 0, and you can carry up to k bags at a time, and you must pick up the necessary number of goods from the origin, take them to the respective depots, and then return to the origin to gather your next batch of goods.\n\nFind the shortest distance you need to travel to deliver every bag of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for delivering goods to depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - positions (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, positions in test_cases:\n        # Separate positions into positive and negative lists\n        positive_positions = [pos for pos in positions if pos > 0]\n        negative_positions = [-pos for pos in positions if pos < 0]\n\n        # Sort both lists in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n\n        # Calculate total distance for positive positions\n        positive_distance = 0\n        for i in range(0, len(positive_positions), k):\n            positive_distance += 2 * positive_positions[i]\n\n        # Calculate total distance for negative positions\n        negative_distance = 0\n        for i in range(0, len(negative_positions), k):\n            negative_distance += 2 * negative_positions[i]\n\n        # The last trip in either direction does not require a return to origin\n        if positive_positions:\n            positive_distance -= positive_positions[0]\n        if negative_positions:\n            negative_distance -= negative_positions[0]\n\n        # Sum the distances for both positive and negative trips\n        total_distance = positive_distance + negative_distance\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        positions = list(map(int, input().split()))\n        test_cases.append((n, k, positions))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for delivering goods to depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at a time.\n            - depots (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = [x for x in depots if x > 0]\n        negative_depots = [-x for x in depots if x < 0]\n\n        # Sort both lists in descending order\n        positive_depots.sort(reverse=True)\n        negative_depots.sort(reverse=True)\n\n        # Calculate the minimum distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Subtract the farthest trip as we don't need to return to origin\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried in one trip.\n            - depots (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: Minimum travel distance for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative coordinates\n        positive_depots = sorted([x for x in depots if x > 0], reverse=True)\n        negative_depots = sorted([-x for x in depots if x < 0], reverse=True)\n\n        # Function to calculate distance for a list of depots\n        def calculate_distance(depots: List[int]) -> int:\n            distance = 0\n            for i in range(0, len(depots), k):\n                # Only add the distance to the farthest point in each batch\n                distance += 2 * depots[i]\n            return distance\n\n        # Calculate total minimum distance\n        total_distance = calculate_distance(positive_depots) + calculate_distance(negative_depots)\n\n        # Adjust for the last trip not needing to return to the origin\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        depots = list(map(int, input().strip().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_positions = [x for x in depots if x > 0]\n        negative_positions = [-x for x in depots if x < 0]\n\n        # Sort positions in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n\n        # Calculate total distance\n        total_distance = 0\n\n        # Process positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n\n        # Process negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n\n        # Subtract the distance of the farthest trip (no need to return)\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        depots = list(map(int, input().strip().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at a time.\n            - depots (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = [x for x in depots if x > 0]\n        negative_depots = [-x for x in depots if x < 0]\n\n        # Sort both lists in descending order\n        positive_depots.sort(reverse=True)\n        negative_depots.sort(reverse=True)\n\n        # Calculate the total distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Subtract the farthest trip as we don't need to return to origin after last delivery\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        depots = list(map(int, input().strip().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimal_travel_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimal travel distance for delivering goods to depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried in one trip.\n            - depots (List[int]): Positions of the depots on the number line.\n\n    Returns:\n        List[int]: List of minimal travel distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = [x for x in depots if x > 0]\n        negative_depots = [-x for x in depots if x < 0]\n\n        # Sort both lists in descending order\n        positive_depots.sort(reverse=True)\n        negative_depots.sort(reverse=True)\n\n        # Calculate total distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Subtract the last trip's return to origin\n        if positive_depots or negative_depots:\n            last_trip_distance = max(\n                positive_depots[0] if positive_depots else 0,\n                negative_depots[0] if negative_depots else 0\n            )\n            total_distance -= last_trip_distance\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = minimal_travel_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance to deliver goods to depots for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): Positions of the depots on the number line.\n\n    Returns:\n        List[int]: Minimum distance for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = [x for x in depots if x > 0]\n        negative_depots = [-x for x in depots if x < 0]\n\n        # Sort both lists in descending order\n        positive_depots.sort(reverse=True)\n        negative_depots.sort(reverse=True)\n\n        # Calculate total distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Adjust for the last trip which doesn't require returning to origin\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        depots = list(map(int, input().strip().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for delivering goods to depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): Positions of depots on the number line.\n\n    Returns:\n        List[int]: Minimum travel distance for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative lists\n        positive_depots = [x for x in depots if x > 0]\n        negative_depots = [-x for x in depots if x < 0]\n\n        # Sort both lists in descending order\n        positive_depots.sort(reverse=True)\n        negative_depots.sort(reverse=True)\n\n        # Calculate the total distance\n        total_distance = 0\n\n        # Calculate distance for positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Calculate distance for negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Subtract the distance for the farthest depot in each direction\n        if positive_depots:\n            total_distance -= positive_depots[0]\n        if negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance needed to deliver goods to depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = [x for x in depots if x > 0]\n        negative_depots = [-x for x in depots if x < 0]\n\n        # Sort depots in descending order of absolute values\n        positive_depots.sort(reverse=True)\n        negative_depots.sort(reverse=True)\n\n        total_distance = 0\n\n        # Calculate distance for positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Calculate distance for negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Subtract the farthest one-way trip (last trip doesn't return to origin)\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_travel_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - positions (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, positions in test_cases:\n        # Separate positive and negative positions\n        positive_positions = [x for x in positions if x > 0]\n        negative_positions = [-x for x in positions if x < 0]\n\n        # Sort positions in descending order\n        positive_positions.sort(reverse=True)\n        negative_positions.sort(reverse=True)\n\n        # Calculate total distance\n        total_distance = 0\n\n        # Process positive positions\n        for i in range(0, len(positive_positions), k):\n            total_distance += 2 * positive_positions[i]\n\n        # Process negative positions\n        for i in range(0, len(negative_positions), k):\n            total_distance += 2 * negative_positions[i]\n\n        # Subtract the farthest one-way trip (no need to return to origin)\n        if positive_positions and negative_positions:\n            total_distance -= max(positive_positions[0], negative_positions[0])\n        elif positive_positions:\n            total_distance -= positive_positions[0]\n        elif negative_positions:\n            total_distance -= negative_positions[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        positions = list(map(int, input().split()))\n        test_cases.append((n, k, positions))\n\n    # Output interface\n    results = minimum_travel_distance(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the minimum travel distance for delivering goods to depots on a number line. The constraints involve handling multiple test cases with potentially large input sizes, ensuring the solution is both efficient and scalable. The solution must account for carrying capacity and optimize the route to minimize travel distance.\nrequirement pool:\n- Implement the main algorithm to calculate minimum travel distance.\n- Ensure the solution handles up to 10,500 test cases efficiently.\n- Optimize the algorithm for large input sizes up to 2 \u22c5 10^5 depots.\n- Provide clear and formatted output for each test case.\n- Include edge case handling for depots with the same position.\nWe will implement a function to calculate the minimum travel distance using a greedy approach. The depots will be split into positive and negative positions, and we will deliver goods to the farthest depots first, minimizing the number of trips. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on a number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman and goods are initially located.\n    'shortest distance': The minimum total distance the salesman needs to travel to deliver all goods.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags in one trip.\n    '1 \u2264 i \u2264 n': Indicates that depot indices range from 1 to n.\n    '1 \u2264 k \u2264 n': The number of bags that can be carried at once is between 1 and n.\n    'sum of n over all test cases does not exceed 2 \u22c5 10^5': Ensures that the total number of depots across all test cases is manageable within computational limits.\n\n# [degree adverb]\n    'shortest': Refers to the minimum possible distance that needs to be traveled.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k, and then the list of depot positions.\n3. Separate depot positions into positive and negative lists.\n4. Sort both lists in descending order of absolute values.\n5. Calculate the total distance by making trips to the farthest depots first, carrying up to k bags per trip.\n6. For each trip, add twice the distance to the farthest depot in that trip (except for the last trip in each direction, which doesn't require a return to origin).\n7. Sum the distances for both positive and negative trips to get the total minimum distance for each test case.\n\n# [edge case]\n    Test case: 1 1\n    Input: 0\n    Output: 0\n    Explanation: No travel is needed as there are no depots.\n\n    Test case: 2 1\n    Input: -1000000000 1000000000\n    Output: 4000000000\n    Explanation: The salesman must travel to both extremes, resulting in a large distance.\n\n    Test case: 3 3\n    Input: -1 -1 -1\n    Output: 2\n    Explanation: All depots are at the same position, so only one trip is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and grouping by positive and negative positions inherently handles these scenarios.\n", "requirement analysis:\nThe problem requires calculating the minimum travel distance for delivering goods to depots positioned on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle multiple test cases and large input sizes, ensuring optimal performance and scalability.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum travel distance\n- Ensure solution handles up to 10,500 test cases\n- Optimize for large input sizes up to 2 \u22c5 10^5 depots\n- Provide clear and concise output format\n- Consider edge cases with overlapping depot positions\nWe will implement an efficient algorithm to calculate the minimum travel distance using a greedy approach. The key idea is to sort the depot positions and then group them into batches of size k, considering both positive and negative positions separately. This allows us to minimize the number of trips by always delivering the farthest depots in each batch. We will use Python's built-in sorting and list manipulation capabilities to handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot', 'origin', 'bags', 'distance'\n    Explanation: \n    - 'depot': A location on the number line where goods need to be delivered.\n    - 'origin': The starting point (0) where the salesman begins and returns to pick up goods.\n    - 'bags': The goods that need to be delivered, with each depot receiving one bag.\n    - 'distance': The total travel distance required to deliver all bags to the depots.\n\n# [phrase showing quantity relationship]\n    'up to k bags at a time': This indicates the maximum number of bags that can be carried in one trip. In code, this can be implemented by grouping depot positions into batches of size k.\n    'minimum distance': This indicates the goal is to find the shortest possible travel distance. In code, this can be implemented by optimizing the delivery sequence using sorting and grouping strategies.\n\n# [degree adverb]\n    'shortest': This indicates the need to minimize the travel distance. In code, this can be implemented by ensuring that each trip covers the maximum possible distance efficiently, using a greedy approach.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k, and then read the depot positions.\n3. Separate depot positions into positive and negative lists.\n4. Sort both lists in descending order of absolute values.\n5. Calculate the minimum distance by grouping depots into batches of size k, always delivering the farthest depots first.\n6. Sum up the distances for all trips, ensuring not to return to origin after the last delivery.\n\n# [edge case]\n    Test case with all depots at the same position:\n    Input: 3 2\n           5 5 5\n    Expected output: 10\n    Explanation: The salesman makes two trips: 0 \u2192 5 \u2192 0 \u2192 5 \u2192 0 \u2192 5, totaling 10 units.\n\n    Test case with depots at both positive and negative positions:\n    Input: 4 2\n           -3 -3 3 3\n    Expected output: 12\n    Explanation: The salesman makes two trips: 0 \u2192 (-3) \u2192 (-3) \u2192 0 \u2192 3 \u2192 3, totaling 12 units.\n\n    Test case with maximum possible depot position:\n    Input: 2 1\n           -1000000000 1000000000\n    Expected output: 3000000000\n    Explanation: The salesman makes two trips: 0 \u2192 (-1000000000) \u2192 0 \u2192 1000000000, totaling 3000000000 units.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and grouping handles these scenarios effectively.\n", "requirement analysis:\nThe problem requires calculating the minimum travel distance for delivering goods to depots positioned on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and provide accurate results for each test case.\nrequirement pool:\n- Implement an algorithm to calculate the minimum travel distance.\n- Ensure the solution handles up to 200,000 depots efficiently.\n- Optimize the algorithm for speed and accuracy.\n- Test the solution against a variety of test cases for reliability.\n- Consider edge cases such as overlapping depot positions.\nWe will implement an algorithm to calculate the minimum travel distance using a greedy approach. The algorithm will sort the depot positions, split them into positive and negative coordinates, and then calculate the distance by grouping depots into batches of size k. This approach ensures efficient handling of large input sizes and provides accurate results. We will use Python's built-in sorting and list manipulation capabilities to achieve this.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on the number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman begins and returns to pick up goods.\n    'bags of goods': The items that need to be delivered to each depot.\n    'carry up to k bags': The maximum number of bags the salesman can carry in one trip.\n\n# [phrase showing quantity relationship]\n    'up to k bags': Indicates the maximum number of bags that can be carried in one trip. In code, this means grouping the depots into batches of size k for delivery.\n    'minimum distance': The shortest possible travel distance required to deliver all goods. In code, this involves optimizing the travel path to reduce total distance.\n\n# [degree adverb]\n    'shortest': Refers to the minimum possible travel distance. In code, this requires calculating the optimal path that minimizes the total distance traveled.\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and details for each test case.\n    2. For each test case, separate depot positions into positive and negative coordinates.\n    3. Sort both positive and negative coordinates.\n    4. Calculate the travel distance by grouping depots into batches of size k, starting from the farthest depot and moving towards the origin.\n    5. Sum the distances traveled for each batch, ensuring not to return to the origin after delivering all bags.\n    6. Output the minimum distance for each test case.\n\n# [edge case]\n    Test case with all depots at the same position: \n    Input: 4 2\n           1000000000 1000000000 1000000000 1000000000\n    Expected output: 3000000000\n    Explanation: Since all depots are at the same position, the salesman only needs to make two trips carrying two bags each time.\n\n    Test case with depots at both positive and negative positions:\n    Input: 3 1\n           -5 -10 5\n    Expected output: 30\n    Explanation: The salesman needs to make separate trips for positive and negative positions, optimizing the path to minimize total distance.\n\n    Test case with k equal to n:\n    Input: 5 5\n           1 2 3 4 5\n    Expected output: 10\n    Explanation: The salesman can carry all bags in one trip directly to the farthest depot and return once.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batching depots based on their positions inherently handles these scenarios efficiently.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle up to 200,000 depots across multiple test cases, ensuring optimal performance and correct output.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum travel distance.\n- Ensure the solution handles up to 200,000 depots efficiently.\n- Optimize the algorithm for both positive and negative depot positions.\n- Provide clear and concise output for each test case.\n- Consider edge cases such as all depots at the same position.\nWe will implement an algorithm that sorts the depot positions and calculates the minimum travel distance by grouping the depots into batches of size k. The algorithm will handle both positive and negative positions separately to optimize the travel distance. We will use Python's built-in sorting and list manipulation capabilities to efficiently manage the large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on a number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman and goods begin.\n    'shortest distance': The minimum total distance the salesman needs to travel to deliver all goods.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags at a time. This means the number of bags carried in one trip cannot exceed k.\n    '1 \u2264 i \u2264 n': Indicates that the depots are indexed from 1 to n, inclusive.\n\n# [degree adverb]\n    'shortest': Refers to the minimum possible distance that needs to be traveled. In code, this involves calculating the least total distance by optimizing the trips.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k.\n3. Read the depot positions and separate them into positive and negative positions.\n4. Sort both lists of positions.\n5. Calculate the total distance by making trips to the farthest depots first, carrying up to k bags per trip.\n6. For each trip, add twice the distance to the farthest depot in that batch (since you return to origin after each trip).\n7. Subtract the distance of the last trip from the total since you don't need to return after delivering all bags.\n8. Output the calculated shortest distance for each test case.\n\n# [edge case]\n    Test case 1: n = 1, k = 1, x = [0] = 0\n    Explanation: The depot is at the origin, so no travel is needed.\n\n    Test case 2: n = 3, k = 2, x = [-5, -10, 10] = 30\n    Explanation: Deliver to -10 and -5 in one trip (20 units), return (20 units), then deliver to 10 (10 units). Total = 50 - 20 = 30.\n\n    Test case 3: n = 5, k = 3, x = [-1, -2, -3, 4, 5] = 18\n    Explanation: Deliver to -3, -2, -1 in one trip (6 units), return (6 units), then deliver to 4 and 5 in one trip (10 units). Total = 22 - 4 = 18.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batching handles these scenarios effectively.\n", "requirement analysis:\nThe problem requires calculating the minimum travel distance for delivering goods to depots positioned on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and multiple test cases, ensuring optimal performance and accuracy.\nrequirement pool:\n- Implement the main algorithm to calculate minimum travel distance.\n- Ensure the solution handles up to 200,000 depots efficiently.\n- Optimize the algorithm for both positive and negative depot positions.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to validate the solution.\nWe will implement an algorithm that efficiently calculates the minimum travel distance by considering both positive and negative depot positions separately. The algorithm will sort the depot positions, group them into batches of size k, and calculate the travel distance for each batch. The use of sorting and batch processing ensures that the solution is both optimal and scalable for large input sizes. We will use Python's built-in sorting and list manipulation capabilities to achieve this.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot', 'origin', 'bags', 'distance'\n    Explanation: \n    - 'depot': A location on the number line where goods need to be delivered.\n    - 'origin': The starting point (0) where the salesman begins and returns to pick up goods.\n    - 'bags': The items that need to be delivered to each depot.\n    - 'distance': The total travel distance required to deliver all bags to the depots.\n\n# [phrase showing quantity relationship]\n    'up to k bags at a time': This indicates the maximum number of bags that can be carried in one trip. In code, this means grouping the depots into batches of size k for delivery.\n    'minimum distance': This indicates the need to find the shortest possible travel distance. In code, this involves optimizing the delivery sequence.\n\n# [degree adverb]\n    'shortest': This means finding the least possible travel distance. In code, this involves calculating and comparing different delivery sequences to find the optimal one.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k, and then read the depot positions.\n3. Separate depot positions into positive and negative lists.\n4. Sort both lists in descending order of absolute value.\n5. Calculate the travel distance for each batch of k depots, considering both positive and negative directions separately.\n6. Sum up the distances for all batches, ensuring not to return to origin after the last delivery.\n7. Output the total minimum distance for each test case.\n\n# [edge case]\n    Test case with all depots at the same position:\n    Input: 3 2\n           5 5 5\n    Expected output: 10\n    Explanation: The salesman can carry two bags at a time, so he makes two trips: 0 \u2192 5 \u2192 0 \u2192 5, totaling 10 units of distance.\n\n    Test case with depots at maximum positive position:\n    Input: 2 1\n           1000000000 1000000000\n    Expected output: 2000000000\n    Explanation: Each trip is from 0 \u2192 1000000000 \u2192 0, repeated twice.\n\n    Test case with depots at maximum negative position:\n    Input: 2 1\n           -1000000000 -1000000000\n    Expected output: 2000000000\n    Explanation: Each trip is from 0 \u2192 -1000000000 \u2192 0, repeated twice.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batch processing will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires calculating the minimal travel distance for delivering goods to depots positioned on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and multiple test cases, ensuring optimal performance and clear output.\nrequirement pool:\n- Implement the main algorithm to calculate minimal travel distance.\n- Ensure the solution handles up to 2 \u22c5 10^5 depots efficiently.\n- Optimize the algorithm for both positive and negative depot positions.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to validate the solution.\nWe will implement a function to calculate the minimal travel distance using a greedy approach. The key is to sort the depot positions and handle positive and negative positions separately. We will deliver the goods in batches of size k, always choosing the farthest depots first to minimize the number of trips. This approach ensures that we handle large input sizes efficiently by leveraging sorting and batch processing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot', 'origin', 'distance', 'bags', 'carry'\n    Explanation: \n    - 'depot': A location on the number line where goods need to be delivered.\n    - 'origin': The starting point (0) where the salesman begins and returns to pick up goods.\n    - 'distance': The total travel distance required to deliver all goods.\n    - 'bags': The units of goods to be delivered, one per depot.\n    - 'carry': The maximum number of bags the salesman can transport in one trip.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags in one trip.\n    Explanation: This means that the salesman can make multiple trips, each carrying k or fewer bags, until all bags are delivered.\n\n# [degree adverb]\n    'shortest': The minimum possible distance the salesman needs to travel to deliver all goods.\n    Explanation: This requires optimizing the travel path to minimize the total distance covered.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and details for each test case.\n    2. For each test case, separate depot positions into positive and negative lists.\n    3. Sort both lists in descending order of absolute values.\n    4. Calculate the total distance by making trips to the farthest depots first, carrying up to k bags per trip.\n    5. Sum the distances for all trips, ensuring not to return to the origin after the final delivery.\n\n# [edge case]\n    Test case with all depots at the same position:\n    Input: 4 2\n           5 5 5 5\n    Expected output: 10\n    Explanation: The salesman makes two trips, each carrying two bags to position 5, resulting in a total distance of 10.\n\n    Test case with depots at both positive and negative positions:\n    Input: 6 3\n           -3 -3 -3 3 3 3\n    Expected output: 18\n    Explanation: The salesman makes two trips, one to -3 and one to 3, each carrying three bags, resulting in a total distance of 18.\n\n    Test case with maximum possible depot position:\n    Input: 2 1\n           1000000000 -1000000000\n    Expected output: 3000000000\n    Explanation: The salesman makes two trips, one to each extreme position, resulting in a total distance of 3000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and batch processing handles these scenarios efficiently.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots positioned on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large inputs and provide accurate results.\nrequirement pool:\n- Implement efficient algorithm for route optimization\n- Ensure solution scalability for large datasets\n- Provide clear documentation for code maintenance\n- Optimize code for performance\n- Develop user-friendly interface for input/output\nWe will implement an efficient algorithm to optimize the delivery route using a greedy approach. The algorithm will sort the depot positions and calculate the minimum travel distance by grouping depots into batches based on the maximum number of bags that can be carried at once. We will use Python's built-in sorting and list manipulation capabilities to handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on a number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman and goods begin.\n    'shortest distance': The minimum total distance traveled to deliver all goods.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags at a time.\n    '1 \u2264 i \u2264 n': Each depot is indexed from 1 to n.\n    '1 \u2264 k \u2264 n': The number of bags that can be carried at once is between 1 and n.\n    'sum of n over all test cases does not exceed 2 \u22c5 10^5': The total number of depots across all test cases is limited to 200,000.\n\n# [degree adverb]\n    'shortest': Refers to the minimum possible distance that needs to be traveled.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k.\n3. Read the positions of the depots.\n4. Separate the depot positions into positive and negative lists.\n5. Sort both lists in descending order of absolute values.\n6. Calculate the total distance by:\n   - Grouping depots into batches of size k.\n   - For each batch, calculate the round trip distance (except for the last trip which doesn't require returning to origin).\n7. Sum up the distances for both positive and negative sides.\n8. Output the total minimum distance for each test case.\n\n# [edge case]\n    Test case: 1 1\n    Input: 0\n    Expected output: 0\n    Explanation: No travel is needed as there are no depots.\n\n    Test case: 2 2\n    Input: -1000000000 1000000000\n    Expected output: 2000000000\n    Explanation: The salesman can carry both bags in one trip, traveling to -1000000000 and then to 1000000000 without returning.\n\n    Test case: 3 1\n    Input: -1 -1 -1\n    Expected output: 6\n    Explanation: Each bag must be delivered individually, requiring a round trip for each.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and grouping handles these scenarios effectively.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots positioned on a number line. The key challenge is optimizing the delivery route considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle large input sizes and both positive and negative depot positions.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum travel distance.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles both positive and negative depot positions.\n- Provide detailed comments and documentation for the code.\n- Implement additional test cases to validate the solution.\nWe will implement a function to calculate the minimum travel distance using a greedy approach. The algorithm will sort the depot positions, split them into positive and negative groups, and calculate the distance for each group separately. We will use the Python standard library for sorting and basic list operations to ensure efficiency and simplicity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on the number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman and goods begin.\n    'shortest distance': The minimum total distance traveled to deliver all goods.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags at a time.\n    '1 \u2264 i \u2264 n': Each depot is indexed from 1 to n.\n    '1 \u2264 k \u2264 n': The number of bags that can be carried at once is between 1 and n.\n    'sum of n over all test cases does not exceed 2 \u22c5 10^5': The total number of depots across all test cases is limited to 200,000.\n\n# [degree adverb]\n    'shortest': Refers to the minimum possible distance that needs to be traveled.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k.\n3. Separate depot positions into positive and negative lists.\n4. Sort both lists in descending order of absolute values.\n5. Calculate the total distance by:\n   - Grouping depots into batches of size k.\n   - For each batch, calculate the round trip distance (except for the last trip in each direction).\n6. Add the distance for the farthest depot in each direction (positive and negative) only once, as you don't need to return to the origin after the last delivery.\n7. Sum up the distances for both positive and negative directions to get the total minimum distance.\n\n# [edge case]\n    Case 1: n = 1, k = 1, x = [0] = 0\n    Explanation: No travel is needed as the depot is at the origin.\n\n    Case 2: n = 2, k = 2, x = [-1000000000, 1000000000] = 2000000000\n    Explanation: Deliver both bags in one trip, covering the distance to the farthest point only once.\n\n    Case 3: n = 3, k = 1, x = [-1, 0, 1] = 3\n    Explanation: Deliver one bag at a time, visiting each depot separately.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and grouping handles these scenarios effectively.\n", "requirement analysis:\nThe problem requires calculating the minimum travel distance for delivering goods to depots positioned on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and provide accurate results.\nrequirement pool:\n- Implement efficient algorithm for route optimization\n- Ensure solution handles maximum input constraints\n- Provide clear documentation for code maintenance\n- Optimize code for performance\n- Include test cases for edge scenarios\nWe will implement an efficient algorithm to optimize the delivery route using sorting and grouping techniques. The algorithm will handle large input sizes by processing each test case independently and using a greedy approach to minimize travel distance. We will utilize Python's built-in sorting capabilities to efficiently manage depot positions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on a number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman and goods are initially located.\n    'shortest distance': The minimum total distance the salesman needs to travel to deliver all goods.\n\n# [phrase showing quantity relationship]\n    'up to k bags': The salesman can carry a maximum of k bags at a time. This means the number of bags carried in one trip should not exceed k.\n    '1 \u2264 i \u2264 n': Indicates that the depots are indexed from 1 to n.\n    '1 \u2264 k \u2264 n': The number of bags that can be carried at once (k) is at least 1 and at most n.\n    'sum of n over all test cases does not exceed 2 \u22c5 10^5': Ensures that the total number of depots across all test cases is within a manageable limit for processing.\n\n# [degree adverb]\n    'shortest': Refers to the minimum possible distance that needs to be traveled. This requires optimizing the route to minimize back-and-forth travel.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k, and then the list of depot positions.\n3. Separate depot positions into positive and negative lists.\n4. Sort both lists in descending order of absolute values.\n5. Calculate the total distance by making trips carrying up to k bags at a time:\n   - For each group of k depots, calculate the round trip distance (2 * farthest depot).\n   - Add the one-way distance for the last trip (farthest depot) since you don't need to return to the origin after the last delivery.\n6. Sum up the distances for both positive and negative depot trips.\n7. Output the total minimum distance for each test case.\n\n# [edge case]\n    Test case: 1 1\n    Input: 0\n    Output: 0\n    Explanation: No travel is needed as there are no depots.\n\n    Test case: 2 1\n    Input: -1 1\n    Output: 2\n    Explanation: Deliver to -1 and return, then deliver to 1. Total distance is 2.\n\n    Test case: 3 3\n    Input: -1000000000 -1000000000 -1000000000\n    Output: 1000000000\n    Explanation: All depots are at the same position, so only one trip is needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers trips based on depot positions and handles cases where depots are at the same position or when no depots exist.\n", "requirement analysis:\nThe problem requires calculating the minimum travel distance for delivering goods to depots positioned on a number line. The solution must efficiently handle up to 200,000 depots across multiple test cases, considering both positive and negative positions. The key challenge is optimizing the route to minimize the total distance traveled while adhering to the carrying capacity constraint.\nrequirement pool:\n- Implement an efficient algorithm to calculate the minimum travel distance.\n- Ensure the solution can handle the maximum input size within time limits.\n- Optimize the algorithm for both positive and negative depot positions.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will implement an efficient algorithm to calculate the minimum travel distance by considering both positive and negative depot positions separately. The algorithm will sort the positions and then group them based on the carrying capacity k. We will use a greedy approach to minimize the distance by always delivering the farthest depots first in each direction. This approach ensures that we minimize the number of trips needed, thus reducing the total distance traveled. We will use Python's built-in sorting and list manipulation capabilities to handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'depot': A location on the number line where goods need to be delivered.\n    'origin': The starting point (0) where the salesman and goods begin.\n    'shortest distance': The minimum total distance traveled to deliver all goods.\n\n# [phrase showing quantity relationship]\n    'up to k bags': This means the salesman can carry a maximum of k bags in one trip.\n    '1 \u2264 i \u2264 n': This indicates that the depots are indexed from 1 to n.\n    '1 \u2264 k \u2264 n': This means k is at least 1 and at most n, ensuring the salesman can carry at least one bag and at most all bags in one trip.\n\n# [degree adverb]\n    'shortest': This indicates the need to minimize the total travel distance. In code, this can be implemented by calculating the total distance for different strategies and selecting the minimum.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k, and then read the positions of the depots.\n3. Separate the depot positions into positive and negative lists.\n4. Sort both lists in descending order of absolute values.\n5. Calculate the total distance by grouping depots based on k and always delivering to the farthest depots first.\n6. For each group, calculate the round trip distance (except for the last trip in each direction).\n7. Sum up the distances for both positive and negative directions.\n8. Output the total minimum distance for each test case.\n\n# [edge case]\n    Case 1: n = 1, k = 1, x = [0] = 0\n    Explanation: No travel is needed as the depot is at the origin.\n    \n    Case 2: n = 3, k = 3, x = [-1, 0, 1] = 2\n    Explanation: All depots can be delivered in one trip without returning to origin after delivery.\n    \n    Case 3: n = 5, k = 2, x = [-10^9, -10^9, 10^9, 10^9, 0] = 4 * 10^9\n    Explanation: The farthest depots are delivered first in two trips for each direction.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic of sorting and grouping based on k will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 367, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "mutate_method": "condense_two2one", "parent_index": 240}
