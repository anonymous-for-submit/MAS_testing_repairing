{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n, with the example of n = 4 number 17 being special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, whereas the number 9 is not considered special because it cannot be represented in such a way.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Consider that edge cases might involve very large k or n values, requiring efficient computation.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n, with the example of n = 4 number 17 being special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, whereas the number 9 is not considered special because it cannot be represented in such a way.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Consider that edge cases might involve very large k or n values, requiring efficient computation.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4, number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17. However, the number 9 is not considered special because it cannot be represented in such a way.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Consider that edge cases might involve very large k or n values, requiring efficient computation.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, with n = 4, number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17, whereas the number 9 is not considered special because it cannot be represented in such a way. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. Consider that edge cases might involve very large k or n values, requiring efficient computation.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = calculate_special_number(n, k)\n        results.append(special_number)\n    return results\n\ndef calculate_special_number(n: int, k: int) -> int:\n    \"\"\"Calculate the k-th special number for given n.\n\n    Args:\n        n: The base number for powers.\n        k: The position in the sequence of special numbers.\n\n    Returns:\n        The k-th special number modulo 10^9+7.\n    \"\"\"\n    special_number = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            special_number = (special_number + power) % MODULO\n        power = (power * n) % MODULO\n        k //= 2\n    return special_number\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Priority queue to store special numbers\n        min_heap = []\n        # Set to track already generated numbers to avoid duplicates\n        seen = set()\n        \n        # Start with the smallest power of n, which is n^0 = 1\n        heapq.heappush(min_heap, 1)\n        seen.add(1)\n        \n        # Variable to store the k-th special number\n        kth_special_number = 0\n        \n        for _ in range(k):\n            # Extract the smallest number from the priority queue\n            kth_special_number = heapq.heappop(min_heap)\n            \n            # Generate new special numbers by adding distinct powers of n\n            current = kth_special_number\n            power = 1\n            while True:\n                new_special_number = current * n\n                if new_special_number > kth_special_number and new_special_number not in seen:\n                    heapq.heappush(min_heap, new_special_number)\n                    seen.add(new_special_number)\n                # Break if the new number is too large to prevent overflow\n                if new_special_number > 10**18:\n                    break\n                current = new_special_number\n        \n        # Apply modulo operation\n        results.append(kth_special_number % MODULO)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport heapq\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = calculate_kth_special_number(n, k)\n        results.append(special_number)\n    return results\n\ndef calculate_kth_special_number(n: int, k: int) -> int:\n    \"\"\"Calculate the k-th special number for given n.\n\n    Args:\n        n: The base number for powers.\n        k: The position of the special number in the sequence.\n\n    Returns:\n        The k-th special number modulo 10^9+7.\n    \"\"\"\n    # Use a min-heap to efficiently find the k-th smallest special number\n    min_heap = []\n    heapq.heappush(min_heap, 1)  # Start with the smallest special number, n^0 = 1\n    visited = set(min_heap)\n\n    for _ in range(k):\n        current = heapq.heappop(min_heap)\n        next_power = current * n\n        if next_power not in visited:\n            heapq.heappush(min_heap, next_power)\n            visited.add(next_power)\n\n    return current % MODULO\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Use a priority queue to efficiently generate and sort special numbers\n        heap = []\n        heapq.heappush(heap, 1)\n        seen = {1}\n        \n        current = 0\n        for _ in range(k):\n            current = heapq.heappop(heap)\n            for i in range(32):  # Assuming we won't need more than 32 bits for practical purposes\n                next_special = current * n**i\n                if next_special not in seen:\n                    seen.add(next_special)\n                    heapq.heappush(heap, next_special)\n        \n        results.append(current % MOD)\n    \n    return results\n\n# Input interface\ndef main():\n    input_data = input().strip().split('\\n')\n    t = int(input_data[0])\n    test_cases = [tuple(map(int, line.split())) for line in input_data[1:t+1]]\n    \n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport sys\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Compute the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        result = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                result = (result + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(result)\n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        test_cases.append((n, k))\n        index += 2\n\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains\n            two integers n and k.\n\n    Returns:\n        List[int]: List of integers representing the k-th special number for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Use a priority queue to efficiently find the k-th smallest special number\n        heap = []\n        heapq.heappush(heap, 1)  # Start with the smallest special number, which is always 1\n        seen = set()\n        seen.add(1)\n        \n        # Generate up to the k-th special number\n        for _ in range(k):\n            value = heapq.heappop(heap)\n            \n            # Generate new special numbers by adding powers of n\n            next_value = value * n\n            if next_value not in seen:\n                seen.add(next_value)\n                heapq.heappush(heap, next_value)\n        \n        results.append(value % MOD)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_numbers = []\n        # Generate special numbers using binary representation\n        i = 0\n        while len(special_numbers) < k:\n            special_number = 0\n            power = 0\n            num = i\n            while num > 0:\n                if num & 1:\n                    special_number += pow(n, power, MODULO)\n                    special_number %= MODULO\n                num >>= 1\n                power += 1\n            special_numbers.append(special_number)\n            i += 1\n        results.append(special_numbers[k-1])\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples containing n and k for each test case.\n\n    Returns:\n        List[int]: List of k-th special numbers modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Use a priority queue to efficiently find the k-th smallest special number\n        heap = []\n        heapq.heappush(heap, 1)\n        seen = {1}\n        \n        current = 0\n        for _ in range(k):\n            current = heapq.heappop(heap)\n            for i in range(60):  # Assuming we won't need more than 60 powers for practical purposes\n                next_special = current * n**i\n                if next_special not in seen:\n                    seen.add(next_special)\n                    heapq.heappush(heap, next_special)\n                if next_special > MOD:\n                    break\n        \n        results.append(current % MOD)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement involves computing the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The challenge is to efficiently compute this for large values of n and k, ensuring results are accurate and within the modulo constraint.\nrequirement pool:\n- Efficient computation of special numbers\n- Handling large values of n and k\n- Accurate modulo operation\n- Correct input/output formatting\n- Graceful handling of edge cases\nWe will use a mathematical approach to generate special numbers efficiently. The key is to understand that each special number can be represented as a sum of distinct powers of n. We will use a binary representation to determine which powers of n to include in the sum. For large values of n and k, we will leverage Python's built-in capabilities for handling large integers and perform modulo operations to ensure results fit within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, such as n^0, n^1, n^2, etc., without repeating any power.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use a binary representation to determine which powers of n to include in the sum for the k-th special number.\n3. Convert k to its binary form and use each bit to decide whether to include the corresponding power of n in the sum.\n4. Calculate the sum of these selected powers of n.\n5. Apply modulo 10^9+7 to the result to ensure it fits within the constraints.\n6. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: A large number modulo 10^9+7\n    Explanation: This tests the efficiency and correctness of handling very large k values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using binary representation and modulo operation will handle all cases efficiently.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large values of n and k efficiently, and output the result modulo 10^9+7. The challenge lies in efficiently generating and sorting these numbers to find the k-th one.\nrequirement pool:\n- Efficient algorithm to compute special numbers for large n and k.\n- Implement modulo operation to handle large outputs.\n- Optimize the solution for performance with high input values.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide clear and formatted output as per requirements.\nWe will use a mathematical approach to generate special numbers efficiently. The key is to understand that a special number can be represented as a sum of distinct powers of n. We will use a priority queue (min-heap) to keep track of the smallest special numbers and generate them in increasing order. This allows us to efficiently find the k-th special number. The modulo operation will be applied to handle large outputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th smallest special number when all special numbers are sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The special numbers need to be sorted from smallest to largest.\n\n# [code logic]\n1. Initialize a priority queue (min-heap) to store special numbers.\n2. Start with the smallest power of n, which is n^0 = 1.\n3. Use a loop to generate special numbers by adding distinct powers of n.\n4. For each generated number, add it to the priority queue if it hasn't been added before.\n5. Extract the smallest number from the priority queue until you reach the k-th special number.\n6. Apply modulo 10^9+7 to the k-th special number before outputting it.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1 = 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1 = 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Explanation: This tests the efficiency of the algorithm for large k values. The expected output would be the 10^9-th special number modulo 10^9+7.\n\n# [extra code for edge case]\n    We need extra code to handle large values of k efficiently.\n    - Use a set to track already generated numbers to avoid duplicates.\n    - Implement an efficient way to generate and store large numbers using a priority queue.\n    - Ensure that all operations are performed modulo 10^9+7 to handle large outputs.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large values of n and k efficiently, ensuring results are computed modulo 10^9+7. The challenge lies in efficiently generating and sorting these numbers for large inputs.\nrequirement pool:\n- Efficient computation of special numbers for large n and k\n- Output results modulo 10^9+7\n- Handle multiple test cases efficiently\n- Ensure correct and formatted output\n- Optimize for edge cases with very large inputs\nWe will use a mathematical approach to generate special numbers efficiently. The key is to understand that each special number can be represented as a sum of distinct powers of n. We will leverage the properties of binary numbers to generate these sums efficiently. For large values of n and k, we will use a combination of bit manipulation and modular arithmetic to ensure the solution is both efficient and scalable. Python's built-in capabilities for handling large integers and the 'pow' function for modular exponentiation will be utilized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of n.\n\n    'modulo 10^9+7'\n    Explanation: This is a common modulus used in competitive programming to ensure numbers don't become too large, and it helps in managing overflow issues.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding together different powers of n, where each power is non-negative (i.e., 0, 1, 2, ...).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The special numbers are sorted in ascending order, meaning each subsequent number is greater than or equal to the previous one.\n\n# [code logic]\n    - Parse the number of test cases.\n    - For each test case, read n and k.\n    - Generate special numbers using binary representation:\n        - Each binary number represents a unique combination of powers of n.\n        - Convert binary numbers to special numbers by summing the corresponding powers of n.\n    - Sort the special numbers and find the k-th one.\n    - Return the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Input: 2 1\n    Output: 1\n    Explanation: The smallest special number for any n is always 1 (n^0).\n\n    Input: 10^9 1\n    Output: 1\n    Explanation: Even for very large n, the smallest special number remains 1.\n\n    Input: 2 10^9\n    Output: (calculated value modulo 10^9+7)\n    Explanation: For very large k, efficient computation is required to find the k-th special number.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently due to large values of n and k.\n        - Use bit manipulation to generate combinations of powers.\n        - Use modular arithmetic to keep numbers manageable.\n        - Implement efficient sorting and selection algorithms to handle large k values.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n efficiently, considering large values for both n and k. The solution must handle multiple test cases and provide results modulo 10^9+7. Edge cases with large inputs need special attention to ensure performance and correctness.\nrequirement pool:\n- Efficient computation of special numbers for large n and k\n- Output results modulo 10^9+7\n- Handle multiple test cases efficiently\n- Ensure correct output format\n- Optimize for edge cases with large inputs\nWe will use a combination of mathematical insights and efficient algorithms to compute the k-th special number. The key observation is that special numbers can be represented as sums of distinct powers of n. We will leverage binary representation to efficiently generate these numbers, as each bit in a binary number can represent whether a particular power of n is included in the sum. This approach allows us to efficiently compute the k-th special number even for large values of n and k. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure correctness and performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use binary representation to determine which powers of n to include in the sum to form special numbers.\n3. Generate special numbers by iterating through possible combinations of powers of n.\n4. Sort these numbers in increasing order.\n5. Retrieve the k-th special number from the sorted list.\n6. Output the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: (a large number modulo 10^9+7)\n    Explanation: This tests the efficiency and correctness of the algorithm for large k values.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently due to potentially large values of n and k.\n    \n```python\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n, k):\n    # Use a priority queue or similar structure to efficiently generate and sort special numbers\n    import heapq\n    heap = []\n    heapq.heappush(heap, 1)\n    seen = {1}\n    \n    for _ in range(k):\n        current = heapq.heappop(heap)\n        for i in range(32):  # Assuming we won't need more than 32 bits for practical purposes\n            next_special = current * n**i\n            if next_special not in seen:\n                seen.add(next_special)\n                heapq.heappush(heap, next_special)\n    \n    return current % MOD\n\n# Example usage:\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(find_kth_special_number(n, k))\n```\n\nThis code efficiently handles large values of n and k by using a priority queue to generate and sort special numbers.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle large values of n and k efficiently, and output results modulo 10^9+7. The challenge lies in efficiently generating and sorting these special numbers to find the k-th one.\nrequirement pool:\n- Efficiently generate special numbers for large n and k\n- Implement modulo operation to handle large outputs\n- Optimize algorithm for performance with large test cases\n- Ensure correct input/output format handling\n- Provide clear documentation and comments in code\nWe will use a combination of mathematical insights and efficient algorithms to generate special numbers. The key observation is that special numbers can be represented as sums of distinct powers of n, which is similar to representing numbers in a base-n numeral system. We will leverage this property to efficiently compute the k-th special number using combinatorial generation techniques. Python's built-in libraries will be used for handling large integers and performing modulo operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. Parse the input to get the number of test cases, t.\n2. For each test case, read the values of n and k.\n3. Use a combinatorial approach to generate the k-th special number:\n   - Represent numbers in a base-n numeral system to find combinations of powers of n.\n   - Use bit manipulation or combinatorial generation to efficiently compute the k-th special number.\n4. Apply modulo 10^9+7 to the result to handle large numbers.\n5. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1 = 1\n    Explanation: The first special number for n = 2 is 1 (2^0).\n\n    Edge Case 2: n = 10^9, k = 1 = 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 2, k = 10^9\n    Explanation: This tests the efficiency of the algorithm for large k values. The expected output would be a large number modulo 10^9+7.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently due to large values of n and k.\n    \n```python\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n, k):\n    result = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            result = (result + power) % MOD\n        power = (power * n) % MOD\n        k //= 2\n    return result\n\nt = int(input().strip())\nfor _ in range(t):\n    n, k = map(int, input().strip().split())\n    print(find_kth_special_number(n, k))\n```\n\nThis code efficiently computes the k-th special number using bit manipulation and modular arithmetic to handle large numbers and ensure performance within constraints.\n", "requirement analysis:\nThe problem requires finding the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large values of n and k efficiently, ensuring results are computed modulo 10^9+7. The challenge lies in efficiently generating and sorting these numbers to find the k-th one.\nrequirement pool:\n- Efficiently compute the k-th special number for large n and k.\n- Implement modulo operation to handle large numbers.\n- Optimize the algorithm for performance with large test cases.\n- Ensure the solution is scalable for up to 10^4 test cases.\n- Provide clear and concise output for each test case.\nWe will use a combination of bit manipulation and mathematical properties to efficiently generate special numbers. The key insight is that each special number can be represented as a sum of distinct powers of n, which corresponds to binary representation of numbers. We will use Python's built-in capabilities to handle large integers and perform modulo operations efficiently. The itertools library can be used to generate combinations of powers of n.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th smallest special number when all special numbers are sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The special numbers need to be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use bit manipulation to generate numbers that can be expressed as sums of distinct powers of n.\n3. For each integer i, interpret its binary representation as a selection of powers of n to sum.\n4. Calculate the sum for each valid combination and store it.\n5. Sort the list of sums to find the k-th smallest special number.\n6. Return the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The smallest special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The smallest special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: (a large number modulo 10^9+7)\n    Explanation: This tests the efficiency and correctness of the algorithm for large k.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently due to potentially large values of k and n.\n    \n```python\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n, k):\n    # Use a priority queue or similar structure to efficiently find the k-th smallest special number\n    import heapq\n    \n    # Initialize a min-heap with the first special number\n    heap = []\n    heapq.heappush(heap, (1, 0)) # (value, index)\n    \n    seen = set()\n    seen.add(1)\n    \n    # Generate up to the k-th special number\n    for _ in range(k):\n        value, index = heapq.heappop(heap)\n        \n        # Generate new special numbers by adding powers of n\n        next_value = value * n\n        if next_value not in seen:\n            seen.add(next_value)\n            heapq.heappush(heap, (next_value, index + 1))\n    \n    return value % MOD\n\n# Example usage:\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(find_kth_special_number(n, k))\n```\n\nThis code efficiently handles large values of k and n by using a min-heap to track the smallest unprocessed special numbers and ensures that we only compute up to the k-th special number.\n", "requirement analysis:\nThe problem requires finding the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large values of n and k efficiently, ensuring results are computed modulo 10^9+7. The algorithm should be optimized for performance given the constraints.\nrequirement pool:\n- Efficient computation of k-th special number\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for performance and scalability\nWe will use a mathematical approach to generate special numbers by considering the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will use Python's built-in capabilities to handle large integers and modular arithmetic efficiently. The algorithm will iterate over possible combinations of powers of n to find the k-th special number, ensuring results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, with n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use a loop to generate special numbers by considering the binary representation of numbers. Each bit in the binary representation indicates whether a particular power of n is included in the sum.\n3. Calculate the sum of powers of n based on the binary representation.\n4. Keep track of the count of special numbers generated.\n5. Once the k-th special number is found, compute it modulo 10^9+7 and store the result.\n6. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: Computation should be efficient enough to handle large k values without timeouts or memory issues.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using binary representation and modular arithmetic efficiently handles large values of n and k.\n", "requirement analysis:\nThe requirement involves computing the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The challenge is to efficiently compute this for large values of n and k, ensuring results are accurate and performance is optimized. The output must be modulo 10^9+7 to handle large numbers.\nrequirement pool:\n- Efficient computation of special numbers\n- Handling large values of n and k\n- Output results modulo 10^9+7\n- Ensure accuracy for edge cases\n- Optimize performance for high input values\nWe will use a combination of mathematical properties and efficient algorithms to compute the k-th special number. The key is to generate numbers that can be expressed as sums of distinct powers of n. We will leverage Python's built-in capabilities for handling large integers and use modular arithmetic to ensure results are within the required range. The algorithm will focus on generating combinations of powers of n efficiently, using bit manipulation to represent combinations of powers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, with n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This means that a special number is formed by adding distinct powers of n, such as n^0, n^1, etc., without repeating any power.\n\n# [degree adverb]\n    'increasing order': This indicates that the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use bit manipulation to generate combinations of powers of n. Each bit in a binary number can represent whether a particular power of n is included in the sum.\n3. Calculate the sum for each combination and store it in a list.\n4. Sort the list of sums to get the sequence of special numbers in increasing order.\n5. Retrieve the k-th special number from the sorted list.\n6. Return the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: (n=2, k=1) = 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Edge Case 2: (n=10^9, k=1) = 1\n    Explanation: The first special number for any n is always 1, as it is represented by n^0.\n\n    Edge Case 3: (n=2, k=10^9) = (very large number modulo 10^9+7)\n    Explanation: This tests the efficiency and correctness of handling very large k values.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently due to potentially large values of k and n.\n    \n```python\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n, k):\n    # Use a priority queue to efficiently find the k-th smallest special number\n    import heapq\n    heap = []\n    heapq.heappush(heap, 1)\n    seen = {1}\n    \n    for _ in range(k):\n        current = heapq.heappop(heap)\n        for i in range(60):  # Assuming we won't need more than 60 powers for practical purposes\n            next_special = current * n**i\n            if next_special not in seen:\n                seen.add(next_special)\n                heapq.heappush(heap, next_special)\n            if next_special > MOD:\n                break\n    \n    return current % MOD\n\n# Example usage:\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(find_kth_special_number(n, k))\n```\n\nThis code efficiently handles large values by using a priority queue to generate and sort special numbers on-the-fly, ensuring that we only compute what is necessary to find the k-th special number.\n", "requirement analysis:\nThe requirement involves computing the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle large values of n and k efficiently, ensuring results are accurate and within the constraints of modulo 10^9+7.\nrequirement pool:\n- Efficient computation of special numbers for large n and k\n- Accurate output modulo 10^9+7\n- Handle up to 10^4 test cases efficiently\n- Ensure the solution is scalable for competitive programming\n- Optimize algorithm for performance\nWe will use a mathematical approach to generate special numbers efficiently. The key is to understand that each special number can be represented as a sum of distinct powers of n. We will use a combination of bit manipulation and mathematical properties to generate these numbers. Python's built-in libraries will be sufficient for this task, especially considering the constraints of modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, with n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This means that a special number is formed by adding distinct powers of n, such as n^0, n^1, etc., without repeating any power.\n\n# [degree adverb] \n    'increasing order': This indicates that the sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use bit manipulation to generate the k-th special number:\n   - Each bit in the binary representation of k can be used to determine which powers of n are included in the sum.\n   - For example, if k = 4 (binary 100), it corresponds to n^2.\n3. Calculate the k-th special number by summing the appropriate powers of n.\n4. Apply modulo 10^9+7 to the result to handle large numbers.\n5. Output the result for each test case.\n\n# [edge case] \n    Edge Case 1: n = 2, k = 1 = 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1 = 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Explanation: This tests the efficiency of the algorithm with large k. The expected output is calculated using bit manipulation and modulo operation.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using bit manipulation and modulo operation efficiently handles large values of k and n.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n and k values efficiently. The solution must handle large values and edge cases, ensuring the output is modulo 10^9+7. The algorithm should be optimized for performance given the constraints.\nrequirement pool:\n- Efficient computation of special numbers for large n and k\n- Output results modulo 10^9+7\n- Handle multiple test cases efficiently\n- Ensure correct output format\n- Optimize for edge cases and large inputs\nWe will use a mathematical approach to generate special numbers efficiently. The key is to understand that a special number can be represented as a sum of distinct powers of n. We will use a combination of bit manipulation and mathematical properties to generate these numbers in increasing order. The challenge is to efficiently compute the k-th special number for large values of n and k, ensuring the result is modulo 10^9+7. Python's built-in capabilities for handling large integers and efficient computation will be leveraged.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb] \n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use bit manipulation to generate the k-th special number:\n   - Each bit in the binary representation of k corresponds to a power of n.\n   - If a bit is set (1), include the corresponding power of n in the sum.\n3. Calculate the sum of these powers to get the k-th special number.\n4. Return the result modulo 10^9+7 to handle large numbers.\n\n# [edge case] \n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always n^0 = 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: A large number modulo 10^9+7\n    Explanation: This tests the efficiency and correctness of handling very large k values.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic using bit manipulation inherently handles all cases, including very large values of n and k, by leveraging Python's ability to manage large integers and efficient computation.\n"], "scores": [], "pass_results": [false, true, false, true, true, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 789, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "add_1_sentence_at_end", "parent_index": 496}
