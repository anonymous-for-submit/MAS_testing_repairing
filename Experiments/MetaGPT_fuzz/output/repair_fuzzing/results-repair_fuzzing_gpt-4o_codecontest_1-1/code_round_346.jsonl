{"name": "1622_B. Berland Music", "description": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\n\n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "tags": ["data structures", "greedy", "math", "sortings"], "difficulty": 8, "id": 1622, "sample_io": [{"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}], "test_list": [{"input": "1\n7\n1 2 3 4 5 6 7\n0101010\n", "output": ["1 5 2 6 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n10101010101010101010101010101010101010101010101010\n", "output": ["26 1 27 2 28 3 29 4 30 5 31 6 32 7 33 8 34 9 35 10 36 11 37 12 38 13 39 14 40 15 41 16 42 17 43 18 44 19 45 20 46 21 47 22 48 23 49 24 50 25\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 4 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n3 1 2\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["2 1\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101010\n", "output": ["4 5 1 6 2 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 1 2\n1 6 5 8 2 7 4 3\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101000\n", "output": ["5 6 1 7 2 3 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n3 1 2\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n1 2 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 2 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 1 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 7 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["2 1\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01100100\n", "output": ["2 1\n3 2 1\n1 7 6 5 2 8 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n1 2 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 5 2 6 3 4 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 1 6 2 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 1 2 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n1 2 3\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 4 2 5 6 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 7 4 5 6\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111011\n", "output": ["2 1\n1 6 2 7 3 4 5\n3 4 2 8 5 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 2 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 5 6 7 2 3 4\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 6 7 1 2 3\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110100\n", "output": ["2 1\n3 2 1\n5 6 4 8 1 7 3 2\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n2 3 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1001000\n", "output": ["6 1 2 7 3 4 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00100001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 7 6 4 3 5 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n2 3 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 3 2 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n3 2 1\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n1 5 6 7 2 3 4\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010010\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 6 1 8 3 2 7 4\n"]}, {"input": "3\n2\n2 1\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 4 5 6 1 7 2\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 7 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 4 3 8 2 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111101\n", "output": ["2 1\n3 2 1\n1 4 3 8 6 5 2 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n2 3 4 5 6 1 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0110000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 7 2 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n2 1 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 6 4 7 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 3 1\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110110\n", "output": ["2 1\n3 2 1\n1 5 4 8 2 6 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n10010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 2 1 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 2 1\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 2 1\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 2 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 5 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1100010\n", "output": ["5 6 1 2 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110111\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 4 8 3 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n4 5 6 7 1 2 3\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 4 2 5 3 6 7\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 4 1 5 6 7 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110110\n", "output": ["2 1\n3 2 1\n4 5 3 8 1 6 7 2\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["1 2\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n3 4 5 6 7 1 2\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01100001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 7 6 5 3 2 4 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 7 2 3 4 5 6\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11011011\n", "output": ["2 1\n1 5 2 6 3 4 7\n3 4 1 8 5 2 7 6\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}], "task_id": "codecontest/155", "prompt": "Berland Music is a music streaming service built specifically to support Berland local artists, providing a platform for local artists to showcase their talent. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n, and the i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n, and every integer from 1 to n appears exactly once; in other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button, let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "repair_prompt": ["Berland Music is a music streaming service built specifically to support Berland local artists, providing a platform for local artists to showcase their talent. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n, and the i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n, and every integer from 1 to n appears exactly once; in other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button, let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "Berland Music is a music streaming service built specifically to support Berland local artists. It provides a platform for local artists to showcase their talent. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n, and the i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n, and every integer from 1 to n appears exactly once; in other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button, let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "Berland Music is a music streaming service built specifically to support Berland local artists, offering a platform for local artists to showcase their talent, and its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n, and the i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n, and every integer from 1 to n appears exactly once; in other words, p is a permutation. After listening to each of them, Monocarp pressed either a like or a dislike button, let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it. \n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings, a permutation of numbers from 1 to n.\n            - s (str): String of likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate songs into liked and disliked based on the string s\n        liked = []\n        disliked = []\n\n        for i in range(n):\n            if s[i] == '1':\n                liked.append((p[i], i))\n            else:\n                disliked.append((p[i], i))\n\n        # Sort liked songs in descending order and disliked songs in ascending order\n        liked.sort(reverse=True)\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        current_rating = n\n\n        # Assign highest ratings to liked songs\n        for _, index in liked:\n            q[index] = current_rating\n            current_rating -= 1\n\n        # Assign remaining ratings to disliked songs\n        for _, index in disliked:\n            q[index] = current_rating\n            current_rating -= 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        p = list(map(int, data[index:index + n]))\n        index += n\n        s = data[index]\n        index += 1\n        test_cases.append((n, p, s))\n    \n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback using a greedy approach.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Permutation of predicted ratings.\n            - s (str): String representing user feedback (likes/dislikes).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort liked indices in descending order and disliked indices in ascending order\n        liked_indices.sort(key=lambda x: p[x], reverse=True)\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign ratings\n        q = [0] * n\n        current_rating = n\n\n        # Assign highest ratings to liked songs\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating -= 1\n\n        # Assign lowest ratings to disliked songs\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating -= 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string indicating likes (1) and dislikes (0).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort(reverse=True)\n        disliked.sort(reverse=True)\n\n        # Assign new ratings\n        q = [0] * n\n        liked_index = 0\n        disliked_index = 0\n\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                q[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Original permutation of predicted ratings.\n            - s (str): String representing user feedback (likes and dislikes).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the original ratings\n        sorted_p = sorted(p)\n\n        # Assign ratings to liked and disliked songs\n        q = [0] * n\n        liked_ratings = sorted_p[-len(liked_indices):]\n        disliked_ratings = sorted_p[:len(disliked_indices)]\n\n        # Fill the permutation q\n        for idx, rating in zip(liked_indices, liked_ratings):\n            q[idx] = rating\n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            q[idx] = rating\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings, a permutation of numbers from 1 to n.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: Re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings\n        sorted_p = sorted(p)\n\n        # Assign the highest ratings to liked songs and lowest to disliked songs\n        q = [0] * n\n        liked_count = len(liked_indices)\n        disliked_count = len(disliked_indices)\n\n        # Assign ratings to disliked songs\n        for i, index in enumerate(disliked_indices):\n            q[index] = sorted_p[i]\n\n        # Assign ratings to liked songs\n        for i, index in enumerate(liked_indices):\n            q[index] = sorted_p[disliked_count + i]\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        p = list(map(int, input().strip().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef adjust_song_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjust song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings\n        sorted_p = sorted(p)\n\n        # Assign highest ratings to liked songs and lowest to disliked songs\n        liked_ratings = sorted_p[-len(liked_indices):]\n        disliked_ratings = sorted_p[:len(disliked_indices)]\n\n        # Create a new ratings list initialized with zeros\n        q = [0] * n\n\n        # Assign ratings to liked songs\n        for idx, rating in zip(liked_indices, liked_ratings):\n            q[idx] = rating\n\n        # Assign ratings to disliked songs\n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            q[idx] = rating\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = adjust_song_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback using permutation approach.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign lowest ratings to disliked songs\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign highest ratings to liked songs\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Original permutation of ratings.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated permutations for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort liked indices by their original ratings in descending order\n        liked_indices.sort(key=lambda x: p[x], reverse=True)\n        # Sort disliked indices by their original ratings in ascending order\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Create a new permutation q\n        q = [0] * n\n        # Assign highest available ratings to liked songs\n        current_rating = n\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        # Assign lowest available ratings to disliked songs\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback while maintaining a permutation of ratings.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Permutation of predicted ratings.\n            - s (str): String representing user feedback (likes/dislikes).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n    \n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n        \n        # Sort the original ratings\n        sorted_ratings = sorted(p)\n        \n        # Assign higher ratings to liked songs and lower ratings to disliked songs\n        liked_ratings = sorted_ratings[-len(liked_indices):]\n        disliked_ratings = sorted_ratings[:len(disliked_indices)]\n        \n        # Create a new permutation based on the liked and disliked indices\n        new_permutation = [0] * n\n        for idx, rating in zip(liked_indices, liked_ratings):\n            new_permutation[idx] = rating\n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            new_permutation[idx] = rating\n        \n        results.append(new_permutation)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n    \n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings permutations for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign new ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the predicted ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation algorithm to re-evaluate ratings.\n- Ensure the algorithm handles up to 10,000 test cases efficiently.\n- Optimize the algorithm to minimize the sum of absolute differences.\n- Develop a user interface for liking/disliking songs.\n- Integrate the recommendation module with the existing music platform.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and assign new ratings such that liked songs have higher ratings than disliked ones. The approach will ensure that the sum of absolute differences between the predicted and new ratings is minimized. We will use Python's built-in sorting capabilities to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to calculate the difference between predicted and new ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs. In code, this can be implemented by sorting liked songs to have higher indices than disliked ones.\n\n# [degree adverb]\n    'smallest': This refers to minimizing the sum of absolute differences between predicted and new ratings. In code, this can be achieved by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n    - Parse the number of test cases.\n    - For each test case:\n      - Parse the number of songs and their predicted ratings.\n      - Parse the like/dislike string.\n      - Separate songs into liked and disliked based on the string.\n      - Sort liked songs in descending order and disliked songs in ascending order.\n      - Assign ratings such that liked songs have higher ratings than disliked ones.\n      - Ensure the permutation condition is met.\n      - Calculate the sum of absolute differences and print the permutation.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (4, 2) should have higher ratings than disliked ones (3, 1).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes/dislikes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the predicted ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation algorithm to re-evaluate ratings based on user feedback.\n- Optimize the algorithm to handle up to 200,000 songs efficiently.\n- Ensure the solution minimizes the sum of absolute differences between predicted and re-evaluated ratings.\n- Provide a user interface for users to like or dislike songs.\n- Integrate the recommendation module with the existing music streaming platform.\nWe will implement a function to re-evaluate song ratings based on user feedback using a greedy approach. The function will sort the songs into liked and disliked categories, assign the highest available ratings to liked songs, and the lowest to disliked songs, ensuring the permutation constraint is maintained. This approach efficiently minimizes the sum of absolute differences between predicted and re-evaluated ratings.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings must be rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs.\n    'minimum possible': This means we need to find a permutation that minimizes the sum of absolute differences between predicted and re-evaluated ratings.\n\n# [degree adverb]\n    'smallest': Refers to finding the permutation with the smallest sum of absolute differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, the permutation p, and the string s.\n3. Separate the indices of liked and disliked songs based on s.\n4. Sort the indices of liked songs in descending order and disliked songs in ascending order.\n5. Assign the highest available ratings to liked songs and lowest to disliked songs while maintaining permutation constraints.\n6. Calculate the sum of absolute differences between p and q.\n7. Print the permutation q for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but using p minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but using p minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (indices 0 and 2) get higher ratings than disliked songs (indices 1 and 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases by sorting liked and disliked indices separately and assigning ratings accordingly.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation re-evaluation algorithm.\n- Optimize the algorithm for handling large input sizes efficiently.\n- Ensure the system supports multiple test cases as per the input format.\n- Enhance the user interface for liking and disliking songs.\n- Integrate analytics to track user engagement and feedback.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and assign new ratings such that liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this efficiently. The algorithm will ensure that the sum of absolute differences between predicted and re-evaluated ratings is minimized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this requirement, it means that the ratings must be rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs. In code, this can be implemented by sorting liked songs to have higher indices than disliked ones.\n\n# [degree adverb]\n    'smallest': This refers to minimizing the sum of absolute differences between predicted and re-evaluated ratings. In code, this can be achieved by sorting the permutation in a way that closely matches the original predicted ratings.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case:\n        - Parse the number of songs and their predicted ratings.\n        - Parse the feedback string indicating likes and dislikes.\n        - Separate songs into liked and disliked based on feedback.\n        - Sort liked songs to have higher ratings than disliked ones.\n        - Assign new ratings such that the permutation condition is satisfied.\n        - Ensure the sum of absolute differences is minimized.\n    3. Output the new permutation for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (4, 2) should have higher ratings than disliked ones (3, 1).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting based on feedback and ensuring permutation conditions will handle these cases naturally.\n", "requirement analysis:\nThe main requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation algorithm to re-evaluate ratings.\n- Optimize the algorithm for handling large input sizes efficiently.\n- Ensure the system supports multiple test cases as per the input format.\n- Develop a user-friendly interface for liking/disliking songs.\n- Integrate analytics to track user satisfaction and recommendation accuracy.\nWe will implement a function that processes multiple test cases to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while minimizing the absolute difference from the original predicted ratings. We will use Python's built-in sorting and list manipulation capabilities to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to calculate the difference between the original and new ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs. In code, this can be implemented by ensuring that indices corresponding to liked songs have higher values than those corresponding to disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation with the minimum possible sum of absolute differences between original and new ratings. In code, this can be implemented by sorting and rearranging the ratings to minimize the difference.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, the permutation p, and the string s.\n3. Separate indices of liked and disliked songs based on s.\n4. Sort the original ratings p.\n5. Assign the highest available ratings to liked songs and the lowest to disliked songs to ensure q is a permutation.\n6. Calculate the permutation q such that the sum of absolute differences is minimized.\n7. Print the permutation q for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but using the original permutation minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but using the original permutation minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (indices 1 and 3) get higher ratings than disliked ones (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes will handle these cases efficiently.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the predicted ratings.\nrequirement pool:\n- Implement the song recommendation algorithm.\n- Ensure the algorithm maintains permutation properties.\n- Optimize the algorithm for large datasets.\n- Integrate user feedback into the recommendation system.\n- Enhance the UI for better user interaction.\nWe will implement a function that processes multiple test cases to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while maintaining permutation properties. We will use sorting and list manipulation techniques to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this requirement, both the predicted ratings and the re-evaluated ratings must be permutations, meaning each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. In this requirement, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs. In code, this can be implemented by ensuring that indices corresponding to liked songs have higher values than those corresponding to disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between predicted and re-evaluated ratings. In code, this can be implemented by sorting and assigning values in a way that minimizes these differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Read the number of songs, predicted ratings, and feedback string.\n   - Separate indices of liked and disliked songs.\n   - Sort the predicted ratings.\n   - Assign the highest ratings to liked songs and lowest to disliked songs while maintaining permutation properties.\n   - Calculate the permutation that minimizes the sum of absolute differences.\n3. Output the re-evaluated ratings for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (indices 1 and 3) get higher ratings than disliked ones (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on feedback will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement focuses on adjusting song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, with minimal deviation from predicted ratings.\nrequirement pool:\n- Implement song rating adjustment algorithm\n- Develop user interface for song feedback\n- Integrate recommendation system with local artist support\n- Optimize performance for large datasets\n- Enhance user experience with intuitive design\nWe will implement a function that processes each test case independently. For each test case, we will separate the songs into two groups based on Monocarp's feedback: liked and disliked. We will then assign the highest available ratings to the liked songs and the lowest available ratings to the disliked songs, ensuring that the permutation condition is maintained. This approach minimizes the deviation from the predicted ratings while satisfying the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to measure the deviation between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs.\n    Implementation: Ensure that for indices i and j, if s_i=1 and s_j=0, then q_i > q_j.\n\n# [degree adverb]\n    'smallest': This refers to minimizing the sum of absolute differences between predicted and re-evaluated ratings.\n    Implementation: Arrange the ratings such that the sum \u2211_{i=1}^n |p_i-q_i| is minimized.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case:\n       - Separate songs into liked and disliked based on the string s.\n       - Sort the predicted ratings p.\n       - Assign the highest available ratings to liked songs and lowest to disliked songs.\n       - Ensure the permutation condition is maintained.\n    3. Output the re-evaluated ratings for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 1 2 3, 111\n    Output: 1 2 3\n    Explanation: All songs are liked, so the original order is optimal.\n\n    Test case with all songs disliked:\n    Input: 3, 3 2 1, 000\n    Output: 1 2 3\n    Explanation: All songs are disliked, so assigning lowest ratings in ascending order minimizes deviation.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 3 4 1 2\n    Explanation: Liked songs (indices 1 and 3) get higher ratings than disliked ones (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. The solution must handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation algorithm ensuring liked songs have higher ratings than disliked ones.\n- Optimize the algorithm to handle up to 10^4 test cases efficiently.\n- Develop a responsive UI for the recommendation module.\n- Integrate local artist promotion within the recommendation system.\n- Enhance the personalization of recommendations based on user feedback.\nWe will implement a function to re-evaluate song ratings based on user feedback using a permutation approach. The function will ensure liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. We will use efficient sorting and permutation techniques to handle up to 10^4 test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are a sequence of numbers from 1 to n, each appearing exactly once.\n\n    'liked' and 'disliked'\n    Explanation: These terms refer to Monocarp's feedback on the songs. A 'liked' song should have a higher rating than any 'disliked' song in the new permutation.\n\n# [phrase showing quantity relationship]\n    'greater than'\n    Explanation: This indicates that the new rating for liked songs should be higher than the ratings for disliked songs. In code, this can be implemented by ensuring that all indices corresponding to '1' in the string s have higher values in the permutation q than those corresponding to '0'.\n\n# [degree adverb]\n    'smallest'\n    Explanation: The goal is to find a permutation that minimizes the sum of absolute differences between the predicted and new ratings. This can be implemented by sorting and assigning values in a way that minimizes these differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, the permutation p, and the string s.\n3. Separate the indices of liked and disliked songs based on s.\n4. Sort the liked and disliked indices based on their predicted ratings.\n5. Assign the highest available ratings to liked songs and the lowest to disliked songs to minimize the absolute difference.\n6. Construct the new permutation q and print it.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: All songs are liked, so they can retain their original order.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: All songs are disliked, so they can retain their original order.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (indices 1 and 3) get higher ratings than disliked ones (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation module with efficient re-evaluation of ratings.\n- Ensure the solution handles up to 10,000 test cases efficiently.\n- Optimize the algorithm to minimize the sum of absolute differences between predicted and re-evaluated ratings.\n- Support scalability for future expansion of the music streaming service.\n- Enhance user interface for better user engagement.\nWe will implement a function that processes multiple test cases efficiently. For each test case, we will separate the songs into liked and disliked categories based on the input string. We will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring that the permutation constraint is maintained. The solution will be optimized to handle the maximum constraints using sorting and efficient data manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are a sequence of numbers from 1 to n, each appearing exactly once.\n\n    'liked' and 'disliked'\n    Explanation: These terms refer to Monocarp's feedback on the songs. A 'liked' song should have a higher rating than any 'disliked' song in the new permutation.\n\n# [phrase showing quantity relationship]\n    'greater than'\n    Explanation: For every song that Monocarp liked, its new rating should be greater than the rating of any song he disliked. This can be implemented by assigning higher numbers from the permutation to liked songs and lower numbers to disliked songs.\n\n# [degree adverb]\n    'smallest'\n    Explanation: Among all valid permutations, we need to find one that minimizes the sum of absolute differences between the original and new ratings. This involves minimizing the total change in ratings.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case:\n   - Read n, the permutation p, and the string s.\n   - Separate indices of liked and disliked songs based on s.\n   - Sort the indices of liked songs by their original ratings in descending order.\n   - Sort the indices of disliked songs by their original ratings in ascending order.\n   - Assign the highest available ratings to liked songs and the lowest to disliked songs.\n   - Construct the new permutation q and ensure it is a valid permutation.\n3. Output the permutation q for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: All songs are liked, so the permutation with minimum cost is the original permutation itself.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: All songs are disliked, so they can be assigned any permutation. The simplest is the sorted order.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (1st and 3rd) get higher ratings than disliked (2nd and 4th).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of sorting liked and disliked songs separately and assigning ratings accordingly handles all edge cases inherently.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge is to ensure liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback.\n- Ensure permutation of song ratings is maintained.\n- Optimize for minimum sum of absolute differences in ratings.\n- Develop responsive UI for music streaming.\n- Integrate local artist discovery features.\nWe will implement a function to re-evaluate song ratings based on user feedback while maintaining a permutation of ratings. The function will ensure liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between original and new ratings. We will use Python's built-in sorting capabilities to efficiently handle the permutation and rating adjustments.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings must be rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. Here, it is used to calculate the difference between original and new ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs. In code, this can be implemented by ensuring that the indices of liked songs have higher values than those of disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between original and new ratings. In code, this can be implemented by sorting and rearranging the ratings to achieve minimal difference.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, the permutation p, and the string s.\n    3. Separate indices of liked and disliked songs based on s.\n    4. Assign higher ratings to liked songs and lower ratings to disliked songs.\n    5. Sort the ratings to minimize the sum of absolute differences.\n    6. Output the new permutation for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: \n    3\n    3\n    1 2 3\n    111\n    Output: \n    1 2 3\n    Explanation: Since all songs are liked, any permutation works, but the original permutation minimizes the sum of differences.\n\n    Test case with all songs disliked:\n    Input: \n    3\n    3\n    1 2 3\n    000\n    Output: \n    1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but the original permutation minimizes the sum of differences.\n\n    Test case with alternating likes and dislikes:\n    Input: \n    4\n    1 2 3 4\n    1010\n    Output: \n    3 1 4 2\n    Explanation: Liked songs (1 and 3) get higher ratings (3 and 4), disliked songs (2 and 4) get lower ratings (1 and 2).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes/dislikes will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system should ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution must handle multiple test cases efficiently due to the large input size constraints.\nrequirement pool:\n- Implement the song recommendation algorithm to re-evaluate ratings.\n- Ensure the algorithm handles up to 200,000 songs efficiently.\n- Develop a user interface for liking and disliking songs.\n- Integrate the recommendation module with the existing music platform.\n- Provide analytics on user preferences and song performance.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust the ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this efficiently. The approach will minimize the sum of absolute differences between predicted and re-evaluated ratings by carefully assigning new ratings based on sorted feedback.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings are rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. Here, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have a higher rating than disliked songs. In code, this can be implemented by ensuring that indices corresponding to liked songs have higher values than those corresponding to disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation with the minimum sum of absolute differences between predicted and re-evaluated ratings. In code, this can be achieved by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Read the number of songs, predicted ratings, and feedback string.\n   - Separate the indices of liked and disliked songs.\n   - Sort the liked and disliked indices based on their predicted ratings.\n   - Assign new ratings such that liked songs have higher ratings than disliked ones.\n   - Ensure the permutation minimizes the sum of absolute differences.\n3. Output the new permutation for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Expected output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Expected output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Expected output: 4 1 3 2\n    Explanation: Liked songs (indices 1 and 3) should have higher ratings than disliked ones (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on feedback will naturally handle these scenarios.\n"], "scores": [], "pass_results": [false, false, false, true, false, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 346, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "mutate_method": "condense_two2one", "parent_index": 225}
