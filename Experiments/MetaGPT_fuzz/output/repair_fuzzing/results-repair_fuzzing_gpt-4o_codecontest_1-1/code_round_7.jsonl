{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white. Let us denote the cell with coordinates i vertically and j horizontally by (i, j), where the upper left cell will be referred to as (1, 1) and the lower right cell as (n, m). Casimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted, which means a tick consists of 2d + 1 black cells.\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white. Let us denote the cell with coordinates i vertically and j horizontally by (i, j), where the upper left cell will be referred to as (1, 1) and the lower right cell as (n, m). Casimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted, which means a tick consists of 2d + 1 black cells.\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white. Let us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1). The lower right cell will be referred to as (n, m). Casimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted, which means a tick consists of 2d + 1 black cells.\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m, where initially all cells of the field are white and the cell with coordinates i vertically and j horizontally is denoted by (i, j), with the upper left cell referred to as (1, 1) and the lower right cell as (n, m). Casimir draws ticks of different sizes on the field, and a tick of size d (d > 0) with its center in cell (i, j) is drawn as follows:\n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted, which means a tick consists of 2d + 1 black cells.\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m, and Casimir claims that this field came about after he drew some (possibly 0) ticks on it. Determine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given field can be formed by drawing ticks of size d \u2265 k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" if the field can be formed by ticks, otherwise \"NO\".\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, k, field = case\n        possible = True\n\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the field\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if this can be the center of a tick of size >= k\n                    if i >= k and j >= k and j < m - k:\n                        valid_tick = True\n                        for h in range(1, k + 1):\n                            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            # Mark the cells of the tick\n                            for h in range(k + 1):\n                                marked[i - h][j - h] = True\n                                marked[i - h][j + h] = True\n\n        # Check if all '*' cells are part of a valid tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    possible = False\n                    break\n            if not possible:\n                break\n\n        results.append(\"YES\" if possible else \"NO\")\n\n    return results\n\n# Example usage:\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given field can be obtained by drawing ticks of at least the given size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a grid to mark cells that can be part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if this cell can be the center of a tick of size at least k\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells as part of a tick\n                    if size >= k:\n                        for h in range(size):\n                            marked[i - h][j - h] = True\n                            marked[i - h][j + h] = True\n\n        # Check if all '*' cells are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nnumber_of_test_cases = int(input())\ntest_cases = []\nfor _ in range(number_of_test_cases):\n    n, m, k = map(int, input().split())\n    field = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, field))\n\n# Output interface\nresults = can_form_ticks(number_of_test_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given fields can be obtained by drawing ticks of at least the given size.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - k: Minimum size of the ticks.\n            - field: A list of strings representing the grid.\n\n    Returns:\n        A list of strings, each being \"YES\" or \"NO\" for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Function to check if a cell can be the center of a tick of size at least k\n        def is_valid_tick_center(i: int, j: int) -> bool:\n            # Check top-left diagonal\n            for h in range(1, k + 1):\n                if i - h < 0 or j - h < 0 or field[i - h][j - h] != '*':\n                    return False\n            # Check top-right diagonal\n            for h in range(1, k + 1):\n                if i - h < 0 or j + h >= m or field[i - h][j + h] != '*':\n                    return False\n            return True\n\n        # Mark all valid tick centers\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and is_valid_tick_center(i, j):\n                    # Mark the cells of the tick\n                    for h in range(k + 1):\n                        marked[i - h][j - h] = True\n                        marked[i - h][j + h] = True\n\n        # Check if all '*' are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Example usage:\n# t = int(input())\n# test_cases = []\n# for _ in range(t):\n#     n, m, k = map(int, input().split())\n#     field = [input().strip() for _ in range(n)]\n#     test_cases.append((n, m, k, field))\n# results = can_form_ticks(t, test_cases)\n# for result in results:\n#     print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the checkered field can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): Grid representation with '*' for painted cells and '.' for unpainted cells.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" if the grid can be formed by ticks of size at least k, otherwise \"NO\".\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n, m, k, grid = case\n        # Create a copy of the grid to mark visited cells\n        visited = [[False] * m for _ in range(n)]\n        \n        def is_valid_tick(i: int, j: int, d: int) -> bool:\n            \"\"\"Check if a tick of size d can be centered at (i, j).\"\"\"\n            for h in range(d + 1):\n                if i - h < 0 or j - h < 0 or j + h >= m:\n                    return False\n                if grid[i - h][j - h] != '*' or grid[i - h][j + h] != '*':\n                    return False\n            return True\n        \n        def mark_tick(i: int, j: int, d: int) -> None:\n            \"\"\"Mark the cells of a valid tick as visited.\"\"\"\n            for h in range(d + 1):\n                visited[i - h][j - h] = True\n                visited[i - h][j + h] = True\n        \n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not visited[i][j]:\n                    # Try to find the largest possible tick centered at (i, j)\n                    d = k\n                    while is_valid_tick(i, j, d):\n                        d += 1\n                    d -= 1\n                    if d < k:\n                        possible = False\n                        break\n                    mark_tick(i, j, d)\n            if not possible:\n                break\n        \n        # Check if all '*' are part of valid ticks\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not visited[i][j]:\n                    possible = False\n                    break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Call the function and print results\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given field can be obtained by drawing ticks of at least the given size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): Grid representation with '*' for black cells and '.' for white cells.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" if the field can be obtained by drawing ticks, \"NO\" otherwise.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n, m, k, grid = case\n        possible = True\n        marked = [[False] * m for _ in range(n)]\n        \n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if this can be the center of a tick of size at least k\n                    if i >= k and j >= k and j < m - k:\n                        # Check diagonals for tick formation\n                        valid_tick = True\n                        for d in range(1, k + 1):\n                            if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            # Mark the cells as part of a tick\n                            for d in range(k + 1):\n                                marked[i - d][j - d] = True\n                                marked[i - d][j + d] = True\n                    else:\n                        possible = False\n                        break\n            if not possible:\n                break\n        \n        # Check if all '*' are part of valid ticks\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    possible = False\n                    break\n            if not possible:\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n    \n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given fields can be obtained by drawing ticks of at least the given size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" if the field can be obtained by drawing\n                   ticks of at least the given size, otherwise \"NO\".\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, k, field = case\n        possible = True\n\n        # Create a copy of the field to mark visited cells\n        visited = [[False] * m for _ in range(n)]\n\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not visited[i][j]:\n                    # Check if this can be the center of a tick of size at least k\n                    if i >= k and j >= k and j + k < m:\n                        valid_tick = True\n                        for h in range(k + 1):\n                            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            # Mark these cells as visited\n                            for h in range(k + 1):\n                                visited[i - h][j - h] = True\n                                visited[i - h][j + h] = True\n                        else:\n                            possible = False\n                            break\n                    else:\n                        possible = False\n                        break\n\n        # Check if all black cells are part of valid ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not visited[i][j]:\n                    possible = False\n                    break\n            if not possible:\n                break\n\n        results.append(\"YES\" if possible else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a given checkered field can be obtained by drawing ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): The grid representation with '*' for painted cells and '.' for unpainted cells.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" if the field can be obtained by drawing ticks, \"NO\" otherwise.\n    \"\"\"\n    def is_valid_tick_center(i: int, j: int, n: int, m: int, k: int, grid: List[str]) -> bool:\n        \"\"\"Check if a tick of size at least k can be centered at (i, j).\n\n        Args:\n            i (int): Row index of the center cell.\n            j (int): Column index of the center cell.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the ticks.\n            grid (List[str]): The grid representation.\n\n        Returns:\n            bool: True if a valid tick can be formed, False otherwise.\n        \"\"\"\n        d = 0\n        while True:\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                break\n            if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                break\n            d += 1\n        return d > k\n\n    results = []\n\n    for case in test_cases:\n        n, m, k, grid = case\n        possible = True\n        painted_cells = set()\n\n        # Collect all painted cells\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    painted_cells.add((i, j))\n\n        # Check if each painted cell can be part of a valid tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    if not is_valid_tick_center(i, j, n, m, k, grid):\n                        possible = False\n                        break\n            if not possible:\n                break\n\n        results.append(\"YES\" if possible else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the checkered field can be obtained by drawing ticks of at least a specified size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): Grid representation with '*' for painted cells and '.' for unpainted cells.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" if the field can be obtained by drawing ticks, \"NO\" otherwise.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a grid to mark cells that can be part of a tick\n        tick_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size at least k can be formed\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells as part of a tick\n                    if size >= k:\n                        for h in range(size):\n                            tick_grid[i - h][j - h] = True\n                            tick_grid[i - h][j + h] = True\n\n        # Check if all '*' in the field can be part of a tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_grid[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each checkered field can be obtained by drawing ticks of at least size k.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - k: Minimum size of the ticks.\n            - grid: List of strings representing the grid.\n\n    Returns:\n        A list of strings, each being \"YES\" or \"NO\" for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Initialize a matrix to track valid tick centers\n        valid_tick_centers = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check for valid tick centers\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if this cell can be the center of a tick of size k\n                    is_valid_center = True\n                    for d in range(1, k + 1):\n                        if i - d < 0 or j - d < 0 or j + d >= m:\n                            is_valid_center = False\n                            break\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            is_valid_center = False\n                            break\n                    if is_valid_center:\n                        valid_tick_centers[i][j] = True\n\n        # Check if all '*' can be part of valid ticks\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not valid_tick_centers[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given grid can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing grid dimensions, minimum tick size, and the grid itself.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a copy of the grid to mark visited cells\n        visited = [[False] * m for _ in range(n)]\n\n        def is_valid_tick_center(i: int, j: int) -> bool:\n            \"\"\"Check if a cell can be the center of a tick of size at least k.\n\n            Args:\n                i (int): Row index of the cell.\n                j (int): Column index of the cell.\n\n            Returns:\n                bool: True if the cell can be the center of a valid tick, False otherwise.\n            \"\"\"\n            if grid[i][j] != '*':\n                return False\n            # Check diagonals for size k\n            for d in range(1, k + 1):\n                if i - d < 0 or j - d < 0 or j + d >= m:\n                    return False\n                if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                    return False\n            return True\n\n        # Mark all valid ticks\n        for i in range(n):\n            for j in range(m):\n                if is_valid_tick_center(i, j):\n                    # Mark the center and diagonals as visited\n                    for d in range(k + 1):\n                        visited[i - d][j - d] = True\n                        visited[i - d][j + d] = True\n\n        # Check if all '*' are part of a valid tick\n        all_covered = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not visited[i][j]:\n                    all_covered = False\n                    break\n            if not all_covered:\n                break\n\n        results.append(\"YES\" if all_covered else \"NO\")\n\n    return results\n\n# Input interface\nnum_test_cases = int(input())\ntest_cases = []\nfor _ in range(num_test_cases):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Output interface\nresults = can_form_ticks(num_test_cases, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining if a given field can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, considering the constraints on field size and tick size. The output should be a simple YES or NO for each test case.\nrequirement pool:\n- Implement the main logic to determine if the field can be formed by ticks of size d \u2265 k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is robust against edge cases.\n- Provide clear and concise output formatting.\n- Maintain code readability and simplicity for future maintenance.\nWe will implement a function to determine if the given field can be formed by drawing ticks of size d \u2265 k. The function will iterate over each cell in the field, checking if it can be the center of a tick of the required size. We will use a simple nested loop to traverse the field and check the conditions for forming a tick. The solution will be optimized to handle the constraints efficiently by ensuring that each cell is checked only once.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick is determined by the number of cells extending diagonally from the center.\n\n    'size d \u2265 k'\n    Explanation: The size of each tick must be at least k, meaning the tick must extend at least k cells diagonally from its center.\n\n# [phrase showing quantity relationship]\n    'at least': means that the size of each tick must be greater than or equal to k.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Iterate over each cell in the field.\n    2. For each cell that is '*', check if it can be the center of a tick of size d \u2265 k.\n    3. To check if a cell can be the center of a tick, verify that there are at least k cells diagonally in both directions that are also '*'.\n    4. If a cell can be the center of a tick, mark those cells as part of a tick.\n    5. If all '*' cells can be part of ticks of size d \u2265 k, return \"YES\". Otherwise, return \"NO\".\n\n# [edge case]\n    Case 1: A field with no '*' cells.\n    Input: 3 3 1\n           ...\n           ...\n           ...\n    Expected Output: YES\n    Explanation: Since there are no '*' cells, no ticks are needed, and the field can be considered as formed by zero ticks.\n\n    Case 2: A field with '*' cells that cannot form any valid tick.\n    Input: 3 3 2\n           *..\n           ...\n           ...\n    Expected Output: NO\n    Explanation: The single '*' cannot form a tick of size 2, so the field cannot be formed by valid ticks.\n\n    Case 3: A field with '*' cells forming a valid tick.\n    Input: 3 3 1\n           *.*\n           .*.\n           ...\n    Expected Output: YES\n    Explanation: The '*' cells form a valid tick of size 1 centered at (2,2).\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no '*' cells exist or where isolated '*' cells cannot form valid ticks.\n    \n```python\ndef can_form_ticks(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, k, field = case\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if this can be the center of a tick of size >= k\n                    if i >= k and j >= k and j < m - k:\n                        valid_tick = True\n                        for h in range(1, k + 1):\n                            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if not valid_tick:\n                            possible = False\n                            break\n                    else:\n                        possible = False\n                        break\n            if not possible:\n                break\n        results.append(\"YES\" if possible else \"NO\")\n    return results\n\n# Example usage:\ntest_cases = [\n    (3, 3, 1, [\"...\", \"...\", \"...\"]),\n    (3, 3, 2, [\"*..\", \"...\", \"...\"]),\n    (3, 3, 1, [\"*.*\", \".*.\", \"...\"])\n]\nprint(can_form_ticks(3, test_cases))\n```\n", "requirement analysis:\nThe main requirement is to determine if a given field can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases with varying field sizes and configurations. The output should be a simple YES or NO for each test case, indicating whether the field configuration is possible under the given constraints.\nrequirement pool:\n- Implement the core algorithm to detect valid tick configurations.\n- Optimize the algorithm for performance with large input sizes.\n- Ensure the solution handles edge cases correctly.\n- Provide detailed comments and documentation for the code.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine if a given field can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid and check if it can be the center of a valid tick of size at least k. We will use simple loops and condition checks to ensure the solution is efficient and handles edge cases correctly. The function will return YES or NO for each test case based on the validity of the tick configuration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick determines how many cells are painted diagonally from the center.\n\n    'minimum size k'\n    Explanation: The smallest size a tick can be, meaning the tick must have at least k cells extending diagonally from the center.\n\n# [phrase showing quantity relationship]\n    'at least k'\n    Explanation: The size of each tick must be greater than or equal to k. In code, this means checking if the tick size is >= k.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Iterate over each cell in the grid.\n    2. For each cell marked '*', check if it can be the center of a tick of size at least k.\n    3. To check for a valid tick, ensure there are d cells diagonally in both directions from the center.\n    4. If a valid tick is found, mark those cells as part of a tick.\n    5. If all '*' can be part of valid ticks, return YES; otherwise, return NO.\n\n# [edge case]\n    Case 1: A grid with no '*' cells.\n    Input: 3 3 1\n           ...\n           ...\n           ...\n    Expected Output: YES\n    Explanation: No ticks are needed as there are no '*' cells.\n\n    Case 2: A grid with '*' cells that cannot form a valid tick.\n    Input: 3 3 2\n           *..\n           ...\n           ...\n    Expected Output: NO\n    Explanation: The single '*' cannot form a tick of size 2.\n\n    Case 3: A grid where all '*' can form valid ticks.\n    Input: 3 3 1\n           ***\n           ***\n           ***\n    Expected Output: YES\n    Explanation: Each '*' can be part of a tick of size 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if there are any '*' cells in the grid initially.\n        - Implement logic to verify if each '*' can be part of a valid tick based on its position and surrounding cells.\n", "requirement analysis:\nThe requirements focus on determining if a given field can be obtained by drawing ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as fields with no ticks or fields with ticks smaller than the minimum size, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case handling\n- Ensure output clarity and correctness\n- Handle edge cases effectively\n- Improve performance for larger fields\nWe will implement a function to determine if a given field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use a simple nested loop to traverse the grid and check the conditions for each potential tick center. The solution will be optimized for handling multiple test cases by processing each test case independently and efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick': A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick determines how many cells are painted diagonally from the center.\n    'size d': The size of the tick, which dictates the number of cells painted diagonally from the center. A tick of size d consists of 2d + 1 black cells.\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of the tick must be greater than zero, meaning no tick can have a size of zero.\n    '2d + 1': Represents the total number of black cells in a tick, including the center cell and the diagonally painted cells.\n\n# [degree adverb]\n    'at least k': Specifies that the minimum size of any tick must be k or greater. This means any tick drawn must have a size equal to or larger than k.\n\n# [code logic]\n    1. Iterate over each cell in the grid.\n    2. For each cell, check if it can be the center of a tick of size at least k.\n    3. Verify if there are enough cells diagonally in both directions to form a tick of size k.\n    4. If a valid tick is found, mark those cells as part of a tick.\n    5. If all '*' can be part of valid ticks, return \"YES\"; otherwise, return \"NO\".\n\n# [edge case]\n    Case 1: A grid with no '*' at all.\n    Explanation: If there are no '*' in the grid, it can trivially be obtained by drawing zero ticks. Expected output: YES.\n\n    Case 2: A grid with '*' only in one row or column.\n    Explanation: If '*' are only in one row or column, they cannot form valid ticks as they require diagonal extensions. Expected output: NO.\n\n    Case 3: A grid where '*' are isolated and cannot form ticks of size k.\n    Explanation: If '*' are isolated such that they cannot form ticks of size k, the field cannot be obtained by drawing valid ticks. Expected output: NO.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where '*' are isolated or insufficient to form valid ticks.\n    \n```python\ndef can_form_ticks(grid, n, m, k):\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                # Check if it can be the center of a tick of size at least k\n                if not is_valid_tick_center(grid, i, j, n, m, k):\n                    return \"NO\"\n    return \"YES\"\n\ndef is_valid_tick_center(grid, i, j, n, m, k):\n    # Check top-left diagonal\n    for h in range(1, k + 1):\n        if i - h < 0 or j - h < 0 or grid[i - h][j - h] != '*':\n            return False\n    # Check top-right diagonal\n    for h in range(1, k + 1):\n        if i - h < 0 or j + h >= m or grid[i - h][j + h] != '*':\n            return False\n    return True\n```\n", "requirement analysis:\nThe task requires determining if a given checkered field can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases, each with a grid size of up to 10x19. The main challenge is to accurately identify valid tick patterns and ensure that all black cells can be explained by these patterns.\nrequirement pool:\n- Implement the main algorithm to detect valid tick patterns.\n- Optimize the solution for performance with large inputs.\n- Ensure the solution handles edge cases correctly.\n- Provide clear and concise output for each test case.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine if a given checkered field can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. If a valid tick is found, it will mark the cells as part of a tick and continue. The solution will handle multiple test cases efficiently by processing each grid independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered field'\n    Explanation: A grid-like structure where each cell can either be painted (denoted by '*') or unpainted (denoted by '.'). The task is to determine if the painted cells can form ticks of a certain minimum size.\n\n    'tick'\n    Explanation: A pattern formed by a center cell and diagonally adjacent cells. The size of a tick is determined by the number of cells diagonally adjacent to the center.\n\n    'minimum size k'\n    Explanation: The smallest allowable size for a tick. A tick of size d must have d cells on each diagonal from the center.\n\n# [phrase showing quantity relationship]\n    'at least k': The size of each tick must be greater than or equal to k. In code, this means checking if the tick size d satisfies d >= k.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the dimensions n, m, and the minimum tick size k.\n2. Parse the grid of n rows and m columns.\n3. Iterate over each cell in the grid:\n   - If the cell is '*', check if it can be the center of a tick of size at least k.\n   - For a valid tick, ensure there are d cells diagonally on both top-left and top-right.\n4. If a valid tick is found, mark these cells as part of a tick.\n5. After processing all cells, verify if all '*' cells are part of valid ticks.\n6. Output \"YES\" if the grid can be formed by ticks of size at least k, otherwise \"NO\".\n\n# [edge case]\n    1. Edge case: A grid with no '*' cells.\n       Input: 1 1 1\n              .\n       Expected output: YES\n       Explanation: An empty grid can trivially be formed by zero ticks.\n\n    2. Edge case: A grid with '*' cells that cannot form any valid tick.\n       Input: 2 2 1\n              *.\n              .*\n       Expected output: NO\n       Explanation: The '*' cells are isolated and cannot form a tick of any size.\n\n    3. Edge case: A grid where all '*' cells form a single valid tick.\n       Input: 3 3 1\n              .*.\n              ***\n              .*.\n       Expected output: YES\n       Explanation: The center cell (2,2) with its diagonals forms a valid tick of size 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where isolated '*' cells exist or when no '*' cells are present.\n    \n```python\ndef can_form_ticks(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, k, grid = case\n        # Create a copy of the grid to mark visited cells\n        visited = [[False] * m for _ in range(n)]\n        \n        def is_valid_tick(i, j, d):\n            # Check if a tick of size d can be centered at (i, j)\n            for h in range(d + 1):\n                if i - h < 0 or j - h < 0 or j + h >= m:\n                    return False\n                if grid[i - h][j - h] != '*' or grid[i - h][j + h] != '*':\n                    return False\n            return True\n        \n        def mark_tick(i, j, d):\n            # Mark the cells of a valid tick as visited\n            for h in range(d + 1):\n                visited[i - h][j - h] = True\n                visited[i - h][j + h] = True\n        \n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not visited[i][j]:\n                    # Try to find the largest possible tick centered at (i, j)\n                    d = k\n                    while is_valid_tick(i, j, d):\n                        d += 1\n                    d -= 1\n                    if d < k:\n                        possible = False\n                        break\n                    mark_tick(i, j, d)\n            if not possible:\n                break\n        \n        # Check if all '*' are part of valid ticks\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not visited[i][j]:\n                    possible = False\n                    break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Example usage:\nt = 8\ntest_cases = [\n    (2, 3, 1, [\"*.*\", \"...\"]),\n    (4, 9, 2, [\"*.*.*...*\", \".*.*...*.\", \"..*.*.*..\", \".....*...\"]),\n    (4, 4, 1, [\"*.*.\", \"****\", \".**.\", \"....\"]),\n    (5, 5, 1, [\".....\", \"*...*\", \".*.*.\", \"..*.*\", \"...*.\"]),\n    (5, 5, 2, [\".....\", \"*...*\", \".*.*.\", \"..*.*\", \"...*.\"]),\n    (4, 7, 1, [\"*.....*\", \".....*.\", \"..*.*..\", \"...*...\"]),\n    (3, 3, 1, [\"***\", \"***\", \"***\"]),\n    (3, 5, 1, [\"*...*\", \".***.\", \".**..\"])\n]\n\nprint(can_form_ticks(t, test_cases))\n```\n\n", "requirement analysis:\nThe requirements focus on determining if a given field can be obtained by drawing ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide accurate results. Edge cases, such as fields with no ticks or fields with ticks smaller than the minimum size, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test cases\n- Handle edge cases gracefully\n- Ensure output clarity\n- Improve performance for large fields\nWe will implement a function to determine if a given field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use a simple nested loop to traverse the grid and check the conditions for tick formation. The solution will be optimized for multiple test cases by processing each test case independently and efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick determines how many cells are painted diagonally from the center.\n\n    'minimum size'\n    Explanation: The smallest size a tick can be, which is defined by the variable k. All ticks must be of size d \u2265 k.\n\n# [phrase showing quantity relationship]\n    'at least': means that the size of each tick must be greater than or equal to k.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Iterate over each cell in the grid.\n    2. For each cell that is '*', check if it can be the center of a tick of size at least k.\n    3. To check for a valid tick, ensure there are d cells diagonally on both sides from the center.\n    4. If a valid tick is found, mark the cells as part of a tick.\n    5. If all '*' can be part of valid ticks, return \"YES\"; otherwise, return \"NO\".\n\n# [edge case]\n    Case 1: A grid with no '*' characters.\n    Input: 3 3 1\n           ...\n           ...\n           ...\n    Expected Output: YES\n    Explanation: Since there are no '*' characters, no ticks are needed, and the condition is trivially satisfied.\n\n    Case 2: A grid with '*' characters that cannot form any valid tick.\n    Input: 3 3 2\n           *..\n           ...\n           ..*\n    Expected Output: NO\n    Explanation: The '*' characters are isolated and cannot form ticks of size 2.\n\n    Case 3: A grid where all '*' characters can form valid ticks.\n    Input: 3 3 1\n           ***\n           ***\n           ***\n    Expected Output: YES\n    Explanation: Each '*' can be part of a tick of size 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no '*' characters exist or isolated '*' cannot form valid ticks.\n    \n```python\ndef can_form_ticks(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, m, k, grid = case\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if this can be the center of a tick of size at least k\n                    if not (i >= k and j >= k and j < m - k):\n                        possible = False\n                        break\n                    # Check diagonals for tick formation\n                    for d in range(1, k + 1):\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            possible = False\n                            break\n            if not possible:\n                break\n        results.append(\"YES\" if possible else \"NO\")\n    return results\n\n# Example usage:\ntest_cases = [\n    (3, 3, 1, [\"...\", \"...\", \"...\"]),\n    (3, 3, 2, [\"*..\", \"...\", \"..*\"]),\n    (3, 3, 1, [\"***\", \"***\", \"***\"])\n]\nprint(can_form_ticks(3, test_cases))\n```\n", "requirement analysis:\nThe requirements focus on determining if a given field can be obtained by drawing ticks of a specified minimum size. The solution must handle multiple test cases efficiently, ensuring accurate results for each. Edge cases, such as fields with no ticks or fields with ticks smaller than the minimum size, must be addressed. The output should be clear and concise, providing a YES or NO answer for each test case.\nrequirement pool:\n- Implement the main algorithm to check tick validity\n- Optimize performance for handling up to 100 test cases\n- Ensure accurate representation of ticks on the field\n- Handle edge cases effectively\n- Provide clear and concise output\nWe will implement a function to determine if a given field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use simple loops and condition checks to ensure performance optimization for handling up to 100 test cases. The solution will handle edge cases such as fields with no ticks or fields with ticks smaller than the minimum size by checking the constraints on tick formation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick is determined by the number of cells painted diagonally from the center.\n\n    'minimum size k'\n    Explanation: The smallest size a tick can be, meaning the tick must have at least k cells extending diagonally from its center.\n\n# [phrase showing quantity relationship]\n    'at least k': means that the size of each tick must be greater than or equal to k.\n    Implementation: Ensure that any tick considered has a size d such that d >= k.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Iterate over each cell in the grid.\n    2. For each cell, check if it can be the center of a tick of size at least k.\n    3. For a cell to be the center of a tick, verify that there are k cells diagonally in both directions that are painted black.\n    4. If a cell can be the center of a valid tick, mark those cells as part of a tick.\n    5. After processing all cells, check if all black cells are part of valid ticks.\n    6. Return \"YES\" if all black cells can be part of ticks of size at least k, otherwise return \"NO\".\n\n# [edge case]\n    Case 1: A field with no black cells.\n    Input: \n    ```\n    1\n    3 3 1\n    ...\n    ...\n    ...\n    ```\n    Expected Output: YES\n    Explanation: Since there are no black cells, the field can trivially be obtained without any ticks.\n\n    Case 2: A field with isolated black cells that cannot form ticks.\n    Input:\n    ```\n    1\n    3 3 1\n    *..\n    ...\n    ..*\n    ```\n    Expected Output: NO\n    Explanation: The isolated black cells cannot form ticks of size at least 1.\n\n    Case 3: A field with exactly one valid tick.\n    Input:\n    ```\n    1\n    3 3 1\n    .*.\n    ***\n    .*.\n    ```\n    Expected Output: YES\n    Explanation: The central cell (2,2) forms a valid tick of size 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where isolated black cells exist or when there are no black cells.\n    \n```python\ndef can_form_ticks(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, field = case\n        possible = True\n        \n        # Create a copy of the field to mark visited cells\n        visited = [[False] * m for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not visited[i][j]:\n                    # Check if this can be the center of a tick of size at least k\n                    if i >= k and j >= k and j + k < m:\n                        valid_tick = True\n                        for h in range(k + 1):\n                            if field[i - h][j - h] != '*' or field[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            # Mark these cells as visited\n                            for h in range(k + 1):\n                                visited[i - h][j - h] = True\n                                visited[i - h][j + h] = True\n                        else:\n                            possible = False\n                            break\n                    else:\n                        possible = False\n                        break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Example usage:\ntest_cases = [\n    (3, 3, 1, [\"...\", \"...\", \"...\"]),\n    (3, 3, 1, [\"*..\", \"...\", \"..*\"]),\n    (3, 3, 1, [\".*.\", \"***\", \".*.\"])\n]\n\nprint(can_form_ticks(3, test_cases))\n```\n", "requirement analysis:\nThe requirements focus on determining if a given checkered field can be obtained by drawing ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as fields with no ticks or fields with overlapping ticks, must be considered. The output should be clear and concise, indicating whether the field configuration is possible or not.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case processing\n- Handle edge cases gracefully\n- Ensure clear output format\n- Provide detailed error messages for invalid inputs\nWe will implement a function to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use a simple nested loop to traverse the grid and a helper function to verify if a tick can be formed at a given position. The solution will be optimized for multiple test cases by processing each test case independently and efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick': A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick determines how many cells are painted diagonally from the center.\n    'checkered field': A grid of cells where each cell can be either painted (black) or unpainted (white).\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of the tick must be greater than zero, meaning no tick can have a size of zero.\n    '2d + 1': Represents the total number of black cells in a tick, including the center cell and the diagonally painted cells.\n\n# [degree adverb]\n    'at least': Refers to the minimum size requirement for ticks, meaning ticks must be of size k or larger.\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and details for each test case.\n    2. For each test case, iterate over each cell in the grid.\n    3. For each cell, check if it can be the center of a tick of size at least k.\n    4. Use a helper function to verify if a tick can be formed at a given position by checking diagonal cells.\n    5. If all painted cells can be part of valid ticks, return \"YES\"; otherwise, return \"NO\".\n\n# [edge case]\n    Case 1: A grid with no painted cells (all '.')\n    Expected output: YES\n    Explanation: Since there are no painted cells, no ticks are needed, and the condition is trivially satisfied.\n\n    Case 2: A grid with a single painted cell ('*') and k > 0\n    Expected output: NO\n    Explanation: A single painted cell cannot form a tick of size greater than zero.\n\n    Case 3: A grid where all cells are painted ('*') and k = 1\n    Expected output: YES\n    Explanation: Each cell can be the center of a tick of size 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where there are no painted cells or isolated painted cells that cannot form valid ticks.\n    \n```python\ndef can_form_ticks(t, test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, m, k, grid = case\n        possible = True\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    if not is_valid_tick_center(i, j, n, m, k, grid):\n                        possible = False\n                        break\n            if not possible:\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\ndef is_valid_tick_center(i, j, n, m, k, grid):\n    # Check if a tick of size at least k can be centered at (i, j)\n    for d in range(k):\n        if i - d < 0 or j - d < 0 or j + d >= m:\n            return False\n        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n            return False\n    return True\n\n# Example usage:\ntest_cases = [\n    (2, 3, 1, ['*.*', '...']),\n    (4, 9, 2, ['*.*.*...*', '.*.*...*.', '..*.*.*..', '.....*...']),\n    # Add more test cases as needed\n]\n\nprint(can_form_ticks(8, test_cases))\n```\n", "requirement analysis:\nThe requirements focus on determining if a given checkered field can be obtained by drawing ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide accurate results for each. Edge cases, such as fields with no ticks or fields with ticks smaller than the minimum size, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case handling\n- Ensure accurate output for edge cases\n- Provide clear and concise output format\n- Enhance performance for large inputs\nWe will implement a function to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. If a valid tick is found, it will mark the cells as part of a tick. The function will handle multiple test cases efficiently by processing each test case independently. We will use simple list operations and loops to achieve this, ensuring the solution is both accurate and optimized for speed.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells centered at a specific cell, extending diagonally in both directions. The size of the tick determines how many cells are painted diagonally from the center.\n\n    'checkered field'\n    Explanation: A grid of cells where each cell can be either painted (black) or unpainted (white).\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of the tick must be greater than zero, meaning no tick can have a size of zero.\n    \n    '2d + 1': Represents the total number of cells painted for a tick of size d, including the center cell and the diagonal cells.\n\n# [degree adverb]\n    'at least': Indicates that the tick size must be greater than or equal to a specified minimum size k.\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and details for each test case.\n    2. For each test case, iterate over each cell in the grid.\n    3. Check if the current cell can be the center of a tick of size at least k.\n    4. If a valid tick is found, mark the cells as part of a tick.\n    5. If all asterisks can be part of valid ticks, return \"YES\"; otherwise, return \"NO\".\n\n# [edge case]\n    Case 1: A grid with no asterisks (all cells are '.')\n    Input: \n    1 1 1\n    .\n    Expected Output: YES\n    Explanation: No ticks are needed, so the field is valid.\n\n    Case 2: A grid with isolated asterisks that cannot form valid ticks\n    Input:\n    3 3 2\n    *..\n    ...\n    ..*\n    Expected Output: NO\n    Explanation: The asterisks cannot form ticks of size 2.\n\n    Case 3: A grid with a single row or column\n    Input:\n    1 5 1\n    *.*.*\n    Expected Output: NO\n    Explanation: Ticks cannot be formed as there is no space for diagonal extension.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if all(cell == '.' for row in grid for cell in row):\n            return \"YES\"\n        # Additional logic to check isolated asterisks and single row/column scenarios\n        # Implement checks for isolated asterisks and insufficient space for ticks in single row/column grids\n", "requirement analysis:\nThe requirement is to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide a clear YES or NO output for each case. The constraints on field size and tick size are manageable, allowing for straightforward implementation.\nrequirement pool:\n- Implement the main algorithm to detect valid tick patterns.\n- Optimize the solution for performance with multiple test cases.\n- Ensure the output format is consistent and clear.\n- Handle edge cases where no ticks are present.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use simple loops and condition checks to verify the tick pattern. Given the constraints, the solution will be efficient for the provided input size. We will use standard Python libraries for input and output handling.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'checkered field'\n    Explanation: A grid-like structure where each cell can be either painted (denoted by '*') or unpainted (denoted by '.'). The task involves determining if the painted pattern can be formed by drawing ticks of a certain size.\n\n    'tick'\n    Explanation: A pattern formed by painting a center cell and diagonally adjacent cells. The size of the tick determines how many cells are painted diagonally from the center.\n\n# [phrase showing quantity relationship]\n    'd > 0': Indicates that the size of the tick must be greater than zero, meaning no tick can have a size of zero.\n    \n    '2d + 1': Represents the total number of cells painted for a tick of size d, including the center cell and the diagonally adjacent cells.\n\n# [degree adverb]\n    'at least': Refers to the minimum size requirement for ticks, meaning any tick drawn must be of size k or larger.\n\n# [code logic]\n1. Parse the input to get the number of test cases and details for each test case.\n2. For each test case, iterate over each cell in the grid.\n3. Check if a cell can be the center of a tick of size at least k by verifying the diagonal cells.\n4. If all required cells for a tick are painted, mark them as part of a valid tick.\n5. After checking all cells, determine if all painted cells can be part of valid ticks.\n6. Return \"YES\" if the field can be obtained by drawing ticks of at least size k, otherwise return \"NO\".\n\n# [edge case]\n    Case 1: A grid with no painted cells (all '.')\n    Expected output: YES\n    Explanation: Since there are no painted cells, it is trivially possible to have zero ticks.\n\n    Case 2: A grid with a single '*' not forming a valid tick\n    Expected output: NO\n    Explanation: A single '*' cannot form a tick of size k \u2265 1.\n\n    Case 3: A grid where all '*' are isolated and cannot form ticks\n    Expected output: NO\n    Explanation: If all '*' are isolated and cannot form valid ticks, the output should be NO.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        def can_form_ticks(grid, n, m, k):\n            # Initialize a matrix to track valid tick centers\n            valid_tick_centers = [[False] * m for _ in range(n)]\n            \n            # Iterate over each cell to check for valid tick centers\n            for i in range(n):\n                for j in range(m):\n                    if grid[i][j] == '*':\n                        # Check if this cell can be the center of a tick of size k\n                        is_valid_center = True\n                        for d in range(1, k + 1):\n                            if i - d < 0 or j - d < 0 or j + d >= m:\n                                is_valid_center = False\n                                break\n                            if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                                is_valid_center = False\n                                break\n                        if is_valid_center:\n                            valid_tick_centers[i][j] = True\n            \n            # Check if all '*' can be part of valid ticks\n            for i in range(n):\n                for j in range(m):\n                    if grid[i][j] == '*' and not valid_tick_centers[i][j]:\n                        return \"NO\"\n            return \"YES\"\n\n        # Main function to process multiple test cases\n        def process_test_cases(test_cases):\n            results = []\n            for n, m, k, grid in test_cases:\n                results.append(can_form_ticks(grid, n, m, k))\n            return results\n", "requirement analysis:\nThe task requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases with grid sizes up to 10x19. The main challenge is ensuring that all black cells can be part of valid ticks, considering the constraints on tick size and placement.\nrequirement pool:\n- Implement the main algorithm to detect valid tick formations.\n- Optimize the solution for performance with large input sizes.\n- Ensure the output format is consistent and easy to understand.\n- Handle edge cases where ticks overlap or are minimal in size.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. We will use a nested loop to verify the tick formation by checking the diagonals from the center cell. If all black cells can be part of valid ticks, the function will return 'YES', otherwise 'NO'. The solution will be optimized to handle up to 100 test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tick'\n    Explanation: A tick is a pattern of black cells on the grid, centered at a specific cell, and extending diagonally in both directions. The size of the tick is determined by how many cells extend diagonally from the center.\n\n    'minimum size k'\n    Explanation: The smallest size a tick can be, meaning the tick must have at least k cells extending diagonally from the center.\n\n# [phrase showing quantity relationship]\n    'at least k': means that the size of each tick must be greater than or equal to k.\n    Implementation: Ensure that any tick considered has a size d where d >= k.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read the grid dimensions (n, m) and minimum tick size (k).\n3. For each cell in the grid, check if it can be the center of a tick of size at least k:\n   - Check diagonally upwards to ensure there are at least k cells in both directions.\n   - If a valid tick is found, mark these cells as part of a tick.\n4. After processing all potential centers, verify if all '*' cells are part of a valid tick.\n5. If all '*' cells are covered by ticks, return 'YES'; otherwise, return 'NO'.\n\n# [edge case] \n    Case 1: A grid with no '*' cells.\n    Input: 3 3 1\n           ...\n           ...\n           ...\n    Expected Output: YES\n    Explanation: No ticks are needed as there are no black cells.\n\n    Case 2: A grid with '*' cells that cannot form a valid tick.\n    Input: 3 3 2\n           *..\n           ...\n           ...\n    Expected Output: NO\n    Explanation: The single '*' cannot form a tick of size 2.\n\n    Case 3: A grid where all '*' can form valid ticks.\n    Input: 3 3 1\n           *.*\n           .*.\n           *.*\n    Expected Output: YES\n    Explanation: Each '*' can be the center of a tick of size 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    \n```python\ndef can_form_ticks(grid, n, m, k):\n    # Create a copy of the grid to mark visited cells\n    visited = [[False] * m for _ in range(n)]\n    \n    # Function to check if a cell can be the center of a tick of size at least k\n    def is_valid_tick_center(i, j):\n        if grid[i][j] != '*':\n            return False\n        # Check diagonals for size k\n        for d in range(1, k + 1):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                return False\n        return True\n    \n    # Mark all valid ticks\n    for i in range(n):\n        for j in range(m):\n            if is_valid_tick_center(i, j):\n                # Mark the center and diagonals as visited\n                for d in range(k + 1):\n                    visited[i - d][j - d] = True\n                    visited[i - d][j + d] = True\n    \n    # Check if all '*' are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*' and not visited[i][j]:\n                return \"NO\"\n    \n    return \"YES\"\n\ndef process_test_cases(test_cases):\n    results = []\n    for n, m, k, grid in test_cases:\n        results.append(can_form_ticks(grid, n, m, k))\n    return results\n\n# Example usage:\ntest_cases = [\n    (2, 3, 1, [\"*.*\", \"...\"]),\n    (4, 9, 2, [\"*.*.*...*\", \".*.*...*.\", \"..*.*.*..\", \".....*...\"]),\n    (4, 4, 1, [\"*.*.\", \"****\", \".**.\", \"....\"]),\n    (5, 5, 1, [\".....\", \"*...*\", \".*.*.\", \"..*.*\", \"...*.\"]),\n    (5, 5, 2, [\".....\", \"*...*\", \".*.*.\", \"..*.*\", \"...*.\"]),\n    (4, 7, 1, [\"*.....*\", \".....*.\", \"..*.*..\", \"...*...\"]),\n    (3, 3, 1, [\"***\", \"***\", \"***\"]),\n    (3, 5, 1, [\"*...*\", \".***.\", \".**..\"])\n]\n\nprint(process_test_cases(test_cases))\n```\n\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 7, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "condense_two2one", "parent_index": 7}
