{"name": "1586_B. Omkar and Heavenly Tree", "description": "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible. \n\nA tree with n nodes is an connected undirected graph with n nodes and n-1 edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree: \n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c. \n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "tags": ["brute force", "constructive algorithms", "trees"], "difficulty": 8, "id": 1586, "sample_io": [{"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}], "test_list": [{"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n10 3\n2 2 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 4\n8 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 12\n6 5 4\n6 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n8 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n7 3\n1 2 -1\n3 3 4\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n"]}, {"input": "2\n12 4\n1 2 3\n3 1 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n6 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 1\n7 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 3 7\n5 5 4\n4 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n"]}, {"input": "2\n7 4\n1 1 3\n3 2 5\n6 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 0\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n8 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 7 4\n13 0\n1 1 -1\n2 3 4\n3 7 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 2\n5 7 10\n4 5 4\n6 0\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 1 4\n3 6 0\n5 5 7\n5 5 4\n8 3\n2 2 -1\n6 2 4\n3 4 10\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n7 4\n0 1 2\n10 2 5\n6 6 7\n6 5 4\n5 3\n1 1 0\n0 3 4\n3 3 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 2\n6 2 10\n7 2 20\n6 3 4\n9 0\n0 1 1\n4 3 4\n2 4 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n"]}, {"input": "2\n11 4\n-1 4 1\n3 7 5\n5 2 22\n2 5 1\n10 1\n2 2 1\n5 1 3\n4 2 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n26 4\n1 3 3\n4 4 5\n5 6 17\n4 9 4\n6 0\n1 3 0\n2 1 4\n7 0 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 25\n1 26\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n11 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n23 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 0\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n13 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n1 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n24 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 3\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n2 1\n2 3\n2 4\n"]}, {"input": "2\n21 4\n1 2 3\n4 1 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 13\n3 14\n3 15\n3 16\n3 17\n3 18\n3 19\n3 20\n3 21\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n4 3\n1 2 1\n2 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n"]}, {"input": "2\n9 4\n2 2 6\n3 4 10\n-1 6 7\n6 5 4\n8 3\n1 4 0\n1 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n7 4\n0 2 1\n3 1 5\n5 6 12\n3 5 4\n6 3\n2 1 0\n4 1 3\n4 2 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n9 4\n1 4 3\n3 4 17\n5 6 12\n8 5 8\n9 3\n1 1 0\n3 3 4\n3 5 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n"]}, {"input": "2\n9 4\n1 4 3\n3 1 17\n5 6 12\n8 5 15\n5 3\n1 1 0\n3 3 7\n3 5 7\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 1 1\n3 7 5\n5 6 12\n3 5 4\n6 3\n2 1 0\n4 1 3\n4 2 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n27 4\n1 3 3\n4 2 2\n5 7 10\n4 9 4\n6 0\n1 2 -1\n2 6 4\n4 1 8\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 25\n1 26\n1 27\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n-1 4 1\n3 7 5\n5 2 22\n2 1 4\n10 1\n2 2 0\n4 1 3\n4 2 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n-1 4 1\n3 7 5\n5 1 22\n2 5 1\n10 1\n2 2 0\n4 1 3\n4 2 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n9 4\n-1 4 1\n0 7 9\n5 2 22\n2 5 1\n10 1\n4 2 1\n5 1 3\n4 1 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n26 4\n1 3 3\n4 4 7\n5 1 17\n4 9 4\n6 0\n1 3 0\n2 1 4\n7 -1 12\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n2 13\n2 14\n2 15\n2 16\n2 17\n2 18\n2 19\n2 20\n2 21\n2 22\n2 23\n2 24\n2 25\n2 26\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n11 4\n0 4 2\n1 10 9\n5 2 22\n2 5 1\n19 1\n4 2 1\n5 1 3\n4 1 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n"]}, {"input": "2\n24 4\n1 4 3\n1 4 7\n5 6 17\n1 13 4\n6 0\n1 3 0\n2 1 4\n7 -1 21\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n7 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n4 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 3\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n5 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 3\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 12\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 6\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n5 4 10\n5 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n2 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n4 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 -1\n3 3 4\n0 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 12\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 2\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 10\n5 6 7\n6 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n4 4 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 12\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n4 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 4 0\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 7\n8 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n4 6 3\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n12 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 6 3\n3 4 2\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 1\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 4 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 3 3\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n4 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 5\n5 5 4\n5 3\n2 2 0\n4 4 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 7\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n10 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n4 6 7\n5 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n4 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 1\n8 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n8 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 1\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n4 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 4 10\n5 6 7\n5 4 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 3 4\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 12\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 3 7\n5 5 4\n10 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 10\n7 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n5 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n6 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n0 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 3 3\n4 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n5 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n8 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n1 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 1\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 1\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 3\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 3\n3 1 8\n5 6 10\n6 5 1\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 5 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 20\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n5 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 0\n4 1 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 10\n5 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n10 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n5 5 4\n5 3\n0 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n4 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 5 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 1\n2 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 1\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 -1\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 0\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 7 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n12 4\n1 2 6\n3 1 8\n5 6 10\n6 5 1\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 5 7\n5 5 4\n5 3\n2 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n6 2 10\n7 6 20\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n12 5 4\n5 3\n0 1 0\n5 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 1\n4 1 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 18\n5 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n10 5 4\n5 3\n4 3 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}], "task_id": "codecontest/37", "prompt": "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible.\n\nA tree with n nodes is a connected undirected graph with n nodes. This tree has precisely n-1 edges that join the nodes. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c.\n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "repair_prompt": ["Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible.\n\nA tree with n nodes is a connected undirected graph with n nodes. This tree has precisely n-1 edges that join the nodes. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c.\n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible.\n\nA tree with n nodes is a connected undirected graph with n nodes. This tree has precisely n-1 edges. These edges join the nodes in a way that maintains the properties of a tree. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c.\n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree, while ensuring m (1 \u2264 m < n) restrictions to make the tree as heavenly as possible.\n\nA tree with n nodes is a connected undirected graph with n nodes and precisely n-1 edges that join the nodes. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree:\n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n), signifying that node b cannot lie on the simple path between node a and node c.\n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_heavenly_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a heavenly tree for each test case based on given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree for a test case.\n    \"\"\"\n    results = []\n    \n    for n, m, restrictions in test_cases:\n        # Select a root node, here we choose node 1\n        root_node = 1\n        edges = []\n        \n        # Connect all other nodes directly to the root node\n        for node in range(2, n + 1):\n            edges.append((root_node, node))\n        \n        results.append(edges)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n    \n    results = construct_heavenly_tree(t, test_cases)\n    \n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c).\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Initialize the adjacency list for the tree\n        adjacency_list = [[] for _ in range(n + 1)]\n        \n        # Start by connecting nodes in a linear fashion\n        for i in range(1, n):\n            adjacency_list[i].append(i + 1)\n            adjacency_list[i + 1].append(i)\n        \n        # Adjust connections to satisfy restrictions\n        for a, b, c in restrictions:\n            # Ensure node b is not on the path between nodes a and c\n            # This can be done by ensuring b is not directly connected to either a or c\n            if b in adjacency_list[a]:\n                adjacency_list[a].remove(b)\n                adjacency_list[b].remove(a)\n                adjacency_list[a].append(c)\n                adjacency_list[c].append(a)\n            elif b in adjacency_list[c]:\n                adjacency_list[c].remove(b)\n                adjacency_list[b].remove(c)\n                adjacency_list[c].append(a)\n                adjacency_list[a].append(c)\n        \n        # Collect the edges from the adjacency list\n        edges = []\n        for i in range(1, n + 1):\n            for j in adjacency_list[i]:\n                if i < j:  # To avoid duplicate edges\n                    edges.append((i, j))\n        \n        results.append(edges)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n    test_cases.append((n, m, restrictions))\n\n# Output interface\nresult = construct_tree(t, test_cases)\nfor edges in result:\n    for u, v in edges:\n        print(u, v)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_heavenly_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"\n    Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Determine nodes involved in restrictions\n        restricted_nodes = set()\n        for a, b, c in restrictions:\n            restricted_nodes.add(b)\n\n        # Find a node that is not involved in any restriction\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n\n        # Construct the tree by connecting the root to all other nodes\n        edges = [(root, node) for node in range(1, n + 1) if node != root]\n        results.append(edges)\n\n    return results\n\ndef main():\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n\n    # Process each test case\n    results = construct_heavenly_tree(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport typing\nimport networkx as nx\n\ndef construct_tree(t: int, test_cases: typing.List[typing.Tuple[int, int, typing.List[typing.Tuple[int, int, int]]]]) -> typing.List[typing.List[typing.Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case while respecting the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the constructed tree.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Initialize a graph with n nodes\n        graph = nx.Graph()\n        graph.add_nodes_from(range(1, n + 1))\n\n        # Use a union-find data structure to manage connected components\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n\n        # Choose a root node that is not involved in any restriction as node b\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n\n        # Connect all nodes to the root initially\n        for node in range(1, n + 1):\n            if node != root:\n                union(root, node)\n\n        # Adjust connections to ensure no restricted paths are formed\n        for a, b, c in restrictions:\n            # Ensure b is not on the path between a and c\n            if find(a) == find(b):\n                union(c, b)\n            elif find(c) == find(b):\n                union(a, b)\n\n        # Collect the edges of the constructed tree\n        tree_edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                if find(node) != find(root):\n                    tree_edges.append((root, node))\n                    union(root, node)\n                else:\n                    for other in range(1, n + 1):\n                        if find(node) != find(other):\n                            tree_edges.append((node, other))\n                            union(node, other)\n                            break\n\n        results.append(tree_edges)\n\n    return results\n\n# Input interface\nnum_test_cases = int(input())\ntest_cases = []\nfor _ in range(num_test_cases):\n    n, m = map(int, input().split())\n    restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n    test_cases.append((n, m, restrictions))\n\n# Call the function and print the result\nresults = construct_tree(num_test_cases, test_cases)\nfor result in results:\n    for edge in result:\n        print(edge[0], edge[1])\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: The number of nodes in the tree.\n            - m: The number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree for a test case.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Select a root node, here we choose node 1\n        root = 1\n        # Create the edges by connecting all nodes to the root node\n        edges = [(root, i) for i in range(2, n + 1)]\n        results.append(edges)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        index += 1\n        restrictions = []\n        for _ in range(m):\n            a, b, c = map(int, data[index].split())\n            restrictions.append((a, b, c))\n            index += 1\n        test_cases.append((n, m, restrictions))\n\n    results = construct_tree(t, test_cases)\n\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case based on the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c).\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree.\n    \"\"\"\n    results = []\n    for n, m, restrictions in test_cases:\n        # Choose node 1 as the root and connect all other nodes directly to it\n        edges = [(1, i) for i in range(2, n + 1)]\n        results.append(edges)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n    \n    results = construct_tree(t, test_cases)\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_heavenly_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"\n    Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the constructed tree.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Initialize an empty list for edges\n        edges = []\n\n        # To satisfy the restrictions, we can choose a node that is not 'b' in any restriction as the root\n        # Create a set of all nodes that are 'b' in any restriction\n        restricted_nodes = set(b for _, b, _ in restrictions)\n\n        # Find a node that is not in restricted_nodes to use as the root\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n\n        # Connect all other nodes to the root\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n\n        # Append the constructed edges for this test case to the results\n        results.append(edges)\n\n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        test_cases.append((n, m, restrictions))\n    \n    # Call the function\n    result = construct_heavenly_tree(t, test_cases)\n    \n    # Output interface\n    for edges in result:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_heavenly_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"\n    Constructs a tree for each test case that satisfies the given restrictions.\n    \n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n    \n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, restrictions in test_cases:\n        # Initialize a set to track restricted nodes\n        restricted_nodes = set()\n        \n        # Process each restriction to mark restricted nodes\n        for a, b, c in restrictions:\n            restricted_nodes.add(b)\n        \n        # Find a root node that is not restricted\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = []\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n        \n        results.append(edges)\n    \n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        restrictions = []\n        \n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        test_cases.append((n, m, restrictions))\n    \n    # Output interface\n    results = construct_heavenly_tree(t, test_cases)\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport networkx as nx\n\nclass UnionFind:\n    \"\"\"Union-Find data structure to manage connected components.\"\"\"\n    \n    def __init__(self, size: int):\n        \"\"\"Initialize the Union-Find structure.\"\"\"\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, u: int) -> int:\n        \"\"\"Find the root of the component containing u.\"\"\"\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u: int, v: int):\n        \"\"\"Union the components containing u and v.\"\"\"\n        rootU = self.find(u)\n        rootV = self.find(v)\n        if rootU != rootV:\n            if self.rank[rootU] > self.rank[rootV]:\n                self.parent[rootV] = rootU\n            elif self.rank[rootU] < self.rank[rootV]:\n                self.parent[rootU] = rootV\n            else:\n                self.parent[rootV] = rootU\n                self.rank[rootU] += 1\n\ndef construct_heavenly_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Construct heavenly trees for multiple test cases.\"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        uf = UnionFind(n + 1)\n        edges = []\n        \n        # Determine a node that is not restricted as a middle node\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = next(i for i in range(1, n + 1) if i not in restricted_nodes)\n        \n        # Connect all other nodes to the root\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n\n    # Call the function\n    result = construct_heavenly_tree(t, test_cases)\n\n    # Output interface\n    for edges in result:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef construct_heavenly_tree(t: int, test_cases: list) -> list:\n    \"\"\"Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): A list of tuples, each containing:\n            - n (int): Number of nodes in the tree.\n            - m (int): Number of restrictions.\n            - restrictions (list of tuples): Each tuple contains three integers (a, b, c) representing a restriction.\n\n    Returns:\n        list: A list of lists, where each inner list contains tuples representing the edges of the tree for a test case.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # We will use node 1 as the root and connect all other nodes to it.\n        edges = []\n        for node in range(2, n + 1):\n            edges.append((1, node))\n        \n        results.append(edges)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n    \n    result = construct_heavenly_tree(t, test_cases)\n    \n    for edges in result:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires constructing a tree that satisfies specific path restrictions between nodes. The solution must handle multiple test cases efficiently and ensure the output format is correct. Given the constraints, the algorithm should be optimized for performance, especially considering the large possible input sizes.\nrequirement pool:\n- Construct a tree that satisfies all restrictions\n- Handle multiple test cases efficiently\n- Ensure output format is correct and easy to understand\n- Optimize algorithm for large input sizes\n- Provide clear documentation for the solution\nWe will use a simple approach to construct the tree by selecting a root node and connecting all other nodes to it. This ensures that no node lies on the path between any two other nodes, thus satisfying all restrictions. This approach is efficient and works within the constraints provided. We will use basic data structures and avoid complex algorithms to ensure performance and simplicity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a particular node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges': This indicates that the tree must have exactly n-1 edges to connect n nodes.\n    Implementation: Ensure the output contains n-1 edges for each test case.\n\n# [degree adverb]\n    'heavenly': This implies the tree must satisfy all given restrictions.\n    Implementation: Construct the tree such that no node lies on the path between any two other nodes as per restrictions.\n\n# [code logic]\n    1. For each test case, select a root node (e.g., node 1).\n    2. Connect all other nodes directly to this root node.\n    3. This ensures no node lies on the path between any two other nodes, satisfying all restrictions.\n    4. Output the n-1 edges for each test case.\n\n# [edge case]\n    Case 1: Minimum nodes and restrictions\n    Input: 3 1\n           1 2 3\n    Expected Output: \n           1 2\n           1 3\n    Explanation: With only three nodes, connecting them directly to a root node satisfies the restriction.\n\n    Case 2: Maximum nodes with minimum restrictions\n    Input: 100000 1\n           1 2 3\n    Expected Output: \n           (Output n-1 edges connecting all nodes to node 1)\n    Explanation: Even with maximum nodes, connecting all to a single root node satisfies the restriction.\n\n    Case 3: Multiple restrictions with overlapping nodes\n    Input: 5 3\n           1 2 3\n           2 3 4\n           3 4 5\n    Expected Output:\n           1 2\n           1 3\n           1 4\n           1 5\n    Explanation: Connecting all nodes to a single root node ensures no node lies on the path between any two others.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of connecting all nodes to a single root node inherently satisfies all restrictions.\n", "requirement analysis:\nThe requirements focus on constructing a tree that adheres to specific path restrictions. The solution must efficiently handle large input sizes and multiple test cases, ensuring the output format is correct for verification.\nrequirement pool:\n- Construct a tree that satisfies all restrictions\n- Handle multiple test cases efficiently\n- Optimize performance for large input sizes\n- Ensure output format is correct\n- Provide clear documentation for the solution\nWe will use a greedy approach to construct the tree by ensuring that each restriction is satisfied. We will start by connecting nodes in a linear fashion and then adjust the connections to meet the restrictions. This approach will leverage efficient data structures like adjacency lists to represent the graph and ensure quick access and modification of paths.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, ensuring there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a particular node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges'\n    Explanation: The tree must have exactly n-1 edges to connect n nodes, ensuring it remains a tree structure.\n    Implementation: Ensure the output contains n-1 edges for each test case.\n\n# [degree adverb]\n    'heavenly'\n    Explanation: The tree must satisfy all given restrictions to be considered heavenly.\n    Implementation: Ensure that no node specified in a restriction lies on the path between the other two nodes.\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases.\n    2. For each test case, initialize a list to store the edges of the tree.\n    3. Start by connecting nodes in a linear fashion (e.g., 1 to 2, 2 to 3, etc.).\n    4. Adjust connections to ensure each restriction is satisfied:\n        - For each restriction (a, b, c), ensure node b is not on the path between nodes a and c.\n        - Use adjacency lists to efficiently manage and modify connections.\n    5. Output the edges for each test case.\n\n# [edge case]\n    Test case with minimum nodes and restrictions:\n    Input: 3 1\n           1 2 3\n    Output: \n           1 3\n           3 2\n    Explanation: With only three nodes, the restriction ensures node 2 is not on the path between nodes 1 and 3.\n\n    Test case with maximum nodes and no restrictions:\n    Input: 100000 0\n    Output: \n           (Linear connection from node 1 to node 100000)\n    Explanation: Without restrictions, a simple linear connection suffices.\n\n    Test case with multiple restrictions affecting the same node:\n    Input: 5 3\n           1 2 3\n           2 3 4\n           3 4 5\n    Output:\n           (Adjust connections to ensure node specified in each restriction is not on the path between the other two)\n    Explanation: Each restriction must be individually satisfied.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement logic to check and adjust paths based on restrictions.\n        - Use adjacency lists or similar data structures for efficient path management.\n        - Ensure output format adheres to n-1 edges per test case.\n", "requirement analysis:\nThe requirements focus on constructing a tree with specific restrictions, ensuring the tree is connected, undirected, and has n-1 edges. The solution must handle multiple test cases efficiently and output the tree edges in the correct format.\nrequirement pool:\n- Efficiently construct a tree with n nodes and n-1 edges\n- Ensure the tree meets all given restrictions\n- Handle multiple test cases efficiently\n- Output the tree edges in the correct format\n- Optimize the algorithm for large values of n\nWe will use a greedy approach to construct the tree. The key idea is to select a root node and connect it to all other nodes, ensuring that the restrictions are satisfied. By choosing a node that is not involved in any restriction as the root, we can easily construct the tree by connecting this root to all other nodes, which guarantees that no restricted node lies on any path between two other nodes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges': This means the tree must have exactly n-1 edges to connect n nodes.\n    'exactly one simple path': This means there should be only one path between any two nodes without repeating any node.\n\n# [degree adverb]\n    'most trusted': This implies the highest level of trust, but it doesn't directly affect the code logic.\n    'heavenly': This is a qualitative description and doesn't affect the code logic.\n\n# [code logic]\n1. For each test case, read the number of nodes (n) and restrictions (m).\n2. Identify a node that is not involved in any restriction as the root.\n3. Connect this root node to all other nodes to form the tree.\n4. Ensure that the constructed tree satisfies all given restrictions by checking that no restricted node lies on any path between two other nodes.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = (1, 2, 3)\n    Expected output: 1 3, 3 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, so we connect 1 to 3 and then 3 to 2.\n\n    Case 2: n = 4, m = 0\n    Expected output: 1 2, 1 3, 1 4\n    Explanation: With no restrictions, we can connect all nodes directly to node 1.\n\n    Case 3: n = 5, m = 4, restrictions = (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 1)\n    Expected output: 5 1, 5 2, 5 3, 5 4\n    Explanation: Node 5 is not involved in any restriction directly, so it can be used as the root.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of selecting a root node not involved in any restriction and connecting it to all other nodes inherently handles these cases.\n", "requirement analysis:\nThe requirements focus on constructing a tree with specific path restrictions. The solution must efficiently handle multiple test cases and ensure the tree meets all restrictions. The output format is crucial for validation.\nrequirement pool:\n- Implement efficient tree construction algorithm\n- Ensure all path restrictions are met\n- Optimize for large input sizes\n- Provide clear output format\n- Test against multiple test cases\nWe will use a graph-based approach to construct the tree while ensuring all restrictions are met. The key idea is to leverage the properties of a tree and use a depth-first search (DFS) or breadth-first search (BFS) to ensure that the restrictions are respected. We will use the NetworkX library to handle graph operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges. It has the property that there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a particular node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges': This indicates that the tree must have exactly n-1 edges to maintain its properties.\n    Implementation: Ensure the output contains n-1 edges for each test case.\n\n# [degree adverb]\n    'heavenly': This implies that the tree must meet all given restrictions to be considered valid.\n    Implementation: Ensure that all restrictions are respected when constructing the tree.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n and m, and then read the m restrictions.\n    3. Initialize a graph with n nodes.\n    4. Use a strategy to construct the tree while ensuring no restriction is violated. This can be done by:\n       - Selecting a root node and connecting it to all other nodes initially.\n       - Iteratively adjust connections to ensure no restricted paths are formed.\n    5. Output the edges of the constructed tree for each test case.\n\n# [edge case]\n    Case 1: Minimum nodes and restrictions\n    Input: 3 1\n           1 2 3\n    Expected Output: \n           1 3\n           3 2\n    Explanation: With only three nodes, the simplest tree that respects the restriction is connecting node 1 to node 3 and node 3 to node 2.\n\n    Case 2: Maximum nodes with no restrictions\n    Input: 100000 0\n    Expected Output: \n           (Output n-1 edges connecting all nodes sequentially)\n    Explanation: With no restrictions, a simple sequential connection from node 1 to node n will suffice.\n\n    Case 3: All nodes have restrictions\n    Input: 4 3\n           1 2 3\n           2 3 4\n           3 4 1\n    Expected Output:\n           (A valid tree structure that respects all restrictions)\n    Explanation: The output must ensure no restricted paths are formed between any specified nodes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement logic to check and adjust connections based on restrictions.\n        - Use a graph traversal method (DFS/BFS) to ensure all nodes are connected without violating restrictions.\n        - Consider using a union-find data structure to efficiently manage connected components and ensure valid tree construction.\n", "requirement analysis:\nThe requirements focus on constructing a tree that adheres to specific path restrictions. The solution must efficiently handle large input sizes and multiple test cases, ensuring that the output format is correct and easy to interpret.\nrequirement pool:\n- Construct a tree that satisfies all restrictions\n- Handle multiple test cases efficiently\n- Optimize performance for large input sizes\n- Ensure output format is correct\n- Provide clear documentation for the solution\nWe will use a simple approach to construct the tree by selecting a root node and connecting all other nodes to it. This ensures that no node lies on the path between any two other nodes, thus satisfying all restrictions. This approach is efficient and works within the constraints provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a particular node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges'\n    Explanation: The tree must have exactly n-1 edges to maintain its properties. In code, this means ensuring the output contains n-1 pairs of nodes representing edges.\n\n# [degree adverb]\n    'heavenly'\n    Explanation: The term 'heavenly' implies that the tree must satisfy all given restrictions. In code, this means constructing the tree such that no node lies on the restricted paths.\n\n# [code logic]\n    1. For each test case, select a root node (e.g., node 1).\n    2. Connect all other nodes directly to the root node.\n    3. This ensures that no node lies on the path between any two other nodes, satisfying all restrictions.\n    4. Output the n-1 edges for each test case.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = (1, 2, 3)\n    Expected output: \n    1 3\n    1 2\n    Explanation: Node 2 cannot be on the path between nodes 1 and 3. Connecting both nodes directly to node 1 satisfies this restriction.\n\n    Case 2: n = 4, m = 2, restrictions = (1, 2, 3), (3, 4, 2)\n    Expected output:\n    1 3\n    1 4\n    1 2\n    Explanation: Node 2 cannot be on the path between nodes 1 and 3, and node 4 cannot be on the path between nodes 3 and 2. Connecting all nodes to node 1 satisfies these restrictions.\n\n    Case 3: n = 5, m = 3, restrictions = (1, 2, 3), (3, 4, 5), (5, 2, 4)\n    Expected output:\n    1 3\n    1 4\n    1 5\n    1 2\n    Explanation: Each restriction is satisfied by connecting all nodes directly to node 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of connecting all nodes to a single root node inherently satisfies all restrictions.\n", "requirement analysis:\nThe problem requires constructing a tree that satisfies a set of restrictions for multiple test cases. Each restriction specifies that a particular node cannot be on the path between two other nodes. The solution must efficiently handle up to 10^5 nodes and restrictions across all test cases, ensuring that the output format is strictly followed.\nrequirement pool:\n- Develop an efficient algorithm to construct the tree\n- Ensure all restrictions are satisfied in the constructed tree\n- Optimize the solution for large input sizes\n- Maintain correct output format for all test cases\n- Provide detailed documentation and comments in the code\nWe will use a simple approach to construct the tree by selecting a root node and connecting all other nodes directly to it. This ensures that no node lies on the path between any two other nodes, thus satisfying all restrictions. This approach is efficient and works within the constraints provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges, where there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction specifies that a particular node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'n-1 edges': This means the tree must have exactly n-1 edges to maintain its properties.\n    '1 \u2264 m < n': This indicates the number of restrictions is at least 1 and less than the number of nodes.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. For each test case, read the number of nodes (n) and restrictions (m).\n    2. Choose a root node (e.g., node 1) and connect all other nodes directly to it.\n    3. This ensures that no node lies on the path between any two other nodes, satisfying all restrictions.\n    4. Output the edges for each test case.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restriction = (1, 2, 3)\n    Expected output: \n    1 3\n    1 2\n    Explanation: Connect node 3 and node 2 directly to node 1. The path between nodes 1 and 3 does not include node 2.\n\n    Case 2: n = 4, m = 2, restrictions = (1, 2, 3), (2, 3, 4)\n    Expected output:\n    1 2\n    1 3\n    1 4\n    Explanation: Connect nodes 2, 3, and 4 directly to node 1. The paths do not violate any restrictions.\n\n    Case 3: n = 5, m = 4, restrictions = (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 1)\n    Expected output:\n    1 2\n    1 3\n    1 4\n    1 5\n    Explanation: Connect all nodes directly to node 1. This satisfies all restrictions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of connecting all nodes directly to a root node inherently satisfies all restrictions.\n", "requirement analysis:\nThe requirements focus on constructing a tree with n nodes while adhering to m restrictions. The tree must be a connected undirected graph with n-1 edges, ensuring no node b lies on the simple path between nodes a and c for each restriction. The solution must handle multiple test cases efficiently, with the sum of n across all test cases not exceeding 10^5.\nrequirement pool:\n- Efficiently construct a tree with n nodes and n-1 edges\n- Ensure the tree meets all m restrictions\n- Handle multiple test cases seamlessly\n- Provide correct output format for each test case\n- Optimize for large values of n\nWe will use a graph-based approach to construct the tree while ensuring the restrictions are met. The key challenge is efficiently checking and applying restrictions to ensure node b does not lie on the path between nodes a and c. We will leverage the NetworkX library for graph operations, which provides efficient methods for path checking and graph construction.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and exactly n-1 edges. It ensures there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges'\n    Explanation: This means the tree must have exactly n-1 edges to connect n nodes, which is a fundamental property of trees.\n\n# [degree adverb]\n    'most trusted'\n    Explanation: This is more of a narrative element and does not directly impact the coding logic.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n and m.\n3. Initialize a list to store the edges of the tree.\n4. Use a strategy to construct the tree while ensuring that no node b lies on the path between nodes a and c for each restriction.\n5. One approach is to select a root node and connect all other nodes directly to it, ensuring no restrictions are violated.\n6. Output the constructed edges for each test case.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between 1 and 3. Directly connecting 1 to 3 and 3 to 2 satisfies this.\n\n    Case 2: n = 4, m = 0\n    Expected output: 1 2, 2 3, 3 4\n    Explanation: With no restrictions, any valid tree structure is acceptable.\n\n    Case 3: n = 5, m = 4, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 1)]\n    Expected output: A valid tree structure that satisfies all restrictions.\n    Explanation: This case tests the ability to handle multiple restrictions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement a function to check if adding an edge violates any restrictions.\n    - Use a graph traversal method to ensure no restricted paths are created when adding edges.\n    \n```python\ndef construct_tree(n, m, restrictions):\n    # Initialize an empty list for edges\n    edges = []\n    \n    # Choose a root node (e.g., node 1)\n    root = 1\n    \n    # Connect all other nodes to the root\n    for i in range(2, n + 1):\n        edges.append((root, i))\n    \n    # Check restrictions and adjust if necessary\n    # This part requires additional logic to ensure no restriction is violated\n    \n    return edges\n\n# Example usage:\n# For each test case, call construct_tree with appropriate parameters\n```\n", "requirement analysis:\nThe requirements focus on constructing a tree with n nodes while adhering to m restrictions. The tree must be a connected undirected graph with n-1 edges, ensuring no node b lies on the simple path between nodes a and c for each restriction. The solution must handle multiple test cases efficiently, with the sum of n across all test cases not exceeding 10^5.\nrequirement pool:\n- Efficiently construct a tree with n nodes and n-1 edges\n- Ensure the tree meets all m restrictions\n- Handle multiple test cases with consistent output format\n- Optimize for large values of n up to 10^5\n- Provide clear documentation and examples\nWe will use a greedy approach to construct the tree. The key idea is to select a root node and connect it to all other nodes, ensuring that the restrictions are satisfied. This approach leverages the fact that a tree with n nodes can be constructed by connecting a single node to all others, forming a star-like structure. We will iterate over the restrictions to ensure that the selected root node does not violate any restriction. This method is efficient and works well within the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A connected undirected graph with n nodes and exactly n-1 edges.\n    'simple path': A path between two nodes that does not contain any node more than once.\n    'restriction': A condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges': This means the tree must have exactly n-1 edges to connect n nodes.\n    'at least': Not applicable in this context as the restrictions are absolute.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, read the number of nodes (n) and restrictions (m).\n2. Initialize an array to keep track of which nodes are restricted from being on paths.\n3. For each restriction, mark the node b as restricted for the path between a and c.\n4. Choose a root node that is not restricted in any of the given restrictions.\n5. Connect this root node to all other nodes to form a star-like tree structure.\n6. Output the edges of the tree.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: Node 2 cannot be on the path between 1 and 3, so we connect 1 to 3 and then 3 to 2.\n\n    Case 2: n = 4, m = 0\n    Expected output: 1 2, 1 3, 1 4\n    Explanation: With no restrictions, we can choose any node as the root and connect it to all others.\n\n    Case 3: n = 5, m = 4, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 1)]\n    Expected output: A valid tree that satisfies all restrictions.\n    Explanation: The specific output will depend on the chosen root and connections but must satisfy all restrictions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of selecting a root node that is not restricted and connecting it to all other nodes inherently handles these cases.\n", "requirement analysis:\nThe requirements focus on constructing a tree that adheres to specific restrictions. The challenge lies in efficiently handling up to 10^5 nodes and ensuring the tree structure is valid for multiple test cases. The solution must be scalable and provide correct outputs for all test cases.\nrequirement pool:\n- Develop an efficient algorithm to construct the tree\n- Ensure the tree meets all restrictions\n- Optimize for performance with large input sizes\n- Provide clear output format for each test case\n- Include error handling for invalid inputs\nWe will use a graph theory approach to construct the tree while ensuring it meets all restrictions. The key challenge is efficiently handling up to 10^5 nodes and multiple test cases. We will utilize the NetworkX library, which provides efficient graph manipulation capabilities and is suitable for large-scale problems. The algorithm will focus on constructing a valid tree by iteratively adding edges while checking restrictions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and exactly n-1 edges. It has no cycles, and there is exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges': This means the tree must have exactly n-1 edges to connect n nodes.\n    \n    'at least': This phrase is not explicitly in the requirement but is implied in the context of restrictions, where a node cannot be on the path between two others.\n\n# [degree adverb]\n    'most trusted': This implies achieving the best possible solution that satisfies all restrictions.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n and m.\n3. Initialize a list to store the edges of the tree.\n4. Use a disjoint set (union-find) to manage connected components.\n5. Iterate over each restriction and ensure that the restricted node is not on the path by managing components.\n6. Construct the tree by adding edges while ensuring no restriction is violated.\n7. Output the edges for each test case.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected output: 1 3, 3 2\n    Explanation: The only restriction is that node 2 cannot be on the path between nodes 1 and 3. The tree can be constructed as 1-3-2.\n\n    Case 2: n = 4, m = 0\n    Expected output: Any valid tree with 4 nodes, e.g., 1 2, 2 3, 3 4\n    Explanation: With no restrictions, any valid tree structure is acceptable.\n\n    Case 3: n = 5, m = 4, restrictions = [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 1)]\n    Expected output: A valid tree that satisfies all restrictions, e.g., 1 3, 3 5, 5 4, 4 2\n    Explanation: Each restriction must be considered to ensure no restricted node lies on the path between specified nodes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement a union-find data structure to efficiently manage connected components.\n    - Ensure that when adding an edge, it does not violate any restrictions by checking component membership.\n    \n```python\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v):\n        rootU = self.find(u)\n        rootV = self.find(v)\n        if rootU != rootV:\n            if self.rank[rootU] > self.rank[rootV]:\n                self.parent[rootV] = rootU\n            elif self.rank[rootU] < self.rank[rootV]:\n                self.parent[rootU] = rootV\n            else:\n                self.parent[rootV] = rootU\n                self.rank[rootU] += 1\n\ndef construct_tree(n, restrictions):\n    uf = UnionFind(n + 1)\n    edges = []\n    \n    # Add edges while respecting restrictions\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if not any((a == i and c == j) or (a == j and c == i) for a, b, c in restrictions):\n                if uf.find(i) != uf.find(j):\n                    uf.union(i, j)\n                    edges.append((i, j))\n                    if len(edges) == n - 1:\n                        return edges\n    return edges\n```\n", "requirement analysis:\nThe main requirement is to construct a tree with n nodes that satisfies m restrictions, where each restriction specifies that a particular node cannot be on the path between two other nodes. The solution must handle multiple test cases efficiently, given the constraints on n and m.\nrequirement pool:\n- Develop an efficient algorithm to construct the tree with n nodes and m restrictions.\n- Ensure the algorithm satisfies all given restrictions for each test case.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Provide a clear and concise output format for the constructed tree.\n- Document the code for better understanding and future maintenance.\nWe will use a simple approach to construct the tree by selecting a root node and connecting all other nodes to it. This ensures that no node lies on the path between any two other nodes, thus satisfying all restrictions. This approach is efficient and works within the constraints provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected undirected graph with n nodes and n-1 edges. It has exactly one simple path between any two nodes.\n\n    'restriction'\n    Explanation: A restriction is a condition where a specific node cannot lie on the simple path between two other nodes.\n\n# [phrase showing quantity relationship]\n    'precisely n-1 edges': This means the tree must have exactly n-1 edges to connect n nodes.\n    'exactly one simple path': This means there is only one path between any two nodes without repeating any node.\n\n# [degree adverb]\n    'most trusted': This implies the highest level of trust, but it doesn't directly affect the code logic.\n    'heavenly': This is a qualitative description and doesn't affect the code logic.\n\n# [code logic]\n1. For each test case, read the number of nodes (n) and restrictions (m).\n2. Select a root node (e.g., node 1) to connect all other nodes.\n3. For each node from 2 to n, create an edge from the root node to the current node.\n4. This ensures that no node lies on the path between any two other nodes, satisfying all restrictions.\n\n# [edge case]\n    Case 1: n = 3, m = 1, restrictions = [(1, 2, 3)]\n    Expected output: \n    1 2\n    1 3\n    Explanation: The tree has 3 nodes and 2 edges. Node 2 is not on the path between nodes 1 and 3.\n\n    Case 2: n = 4, m = 2, restrictions = [(1, 2, 3), (3, 4, 1)]\n    Expected output:\n    1 2\n    1 3\n    1 4\n    Explanation: The tree has 4 nodes and 3 edges. Node 2 is not on the path between nodes 1 and 3, and node 4 is not on the path between nodes 3 and 1.\n\n    Case 3: n = 5, m = 0\n    Expected output:\n    1 2\n    1 3\n    1 4\n    1 5\n    Explanation: The tree has no restrictions, so any valid tree structure with n-1 edges is acceptable.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of connecting all nodes to a single root node inherently satisfies all restrictions by ensuring no intermediate nodes on paths between any two other nodes.\n"], "scores": [], "pass_results": [true, true, false, false, false, false, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 987, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "mutate_method": "rephrase_one", "parent_index": 87}
