{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is engaged in yet another computer game. In this game, his character must defeat a dragon. The combat with the dragon spans 100^{500} seconds. Within this duration, Monocarp attacks the dragon using a poisoned dagger. Each of Monocarp's attacks happens at specified seconds during the fight. The i-th strike occurs at the commencement of the a_i-th second from the battle's start. The dagger itself does not inflict damage. Nonetheless, it introduces a poison effect on the dragon, which is crucial for causing harm. This poison effect inflicts 1 damage during each of the subsequent k seconds. The poison effect begins at the moment the dragon is struck by the dagger. However, if the dragon had previously been affected by poison, then the dagger refreshes the poison effect (i.e. it cancels the current poison effect and activates a new one).\n\nFor instance, let k = 4, and Monocarp strikes the dragon during the seconds 2, 4, and 10. Consequently, the poison effect is initiated at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; then, at the start of the 4-th second, the poison effect is refreshed, dealing 1 damage exactly during the seconds 4, 5, 6, and 7; subsequently, at the 10-th second, the poison effect is activated once more, delivering 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon incurs 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts a minimum of h damage to the dragon during the skirmish \u2014 he kills the dragon. Monocarp has not yet made up his mind about the potency of the poison he will utilize during the battle. Thus, he wishes to determine the smallest feasible value of k (the number of seconds the poison effect endures) that is adequate to deliver at least h damage to the dragon. Observe Monocarp's stabbing sequence and approach meticulously to guarantee the maximization of the poison effect application.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is engaged in yet another computer game. In this game, his character must defeat a dragon. The combat with the dragon spans 100^{500} seconds. Within this duration, Monocarp attacks the dragon using a poisoned dagger. Each of Monocarp's attacks happens at specified seconds during the fight. The i-th strike occurs at the commencement of the a_i-th second from the battle's start. The dagger itself does not inflict damage. Nonetheless, it introduces a poison effect on the dragon, which is crucial for causing harm. This poison effect inflicts 1 damage during each of the subsequent k seconds. The poison effect begins at the moment the dragon is struck by the dagger. However, if the dragon had previously been affected by poison, then the dagger refreshes the poison effect (i.e. it cancels the current poison effect and activates a new one).\n\nFor instance, let k = 4, and Monocarp strikes the dragon during the seconds 2, 4, and 10. Consequently, the poison effect is initiated at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; then, at the start of the 4-th second, the poison effect is refreshed, dealing 1 damage exactly during the seconds 4, 5, 6, and 7; subsequently, at the 10-th second, the poison effect is activated once more, delivering 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon incurs 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts a minimum of h damage to the dragon during the skirmish \u2014 he kills the dragon. Monocarp has not yet made up his mind about the potency of the poison he will utilize during the battle. Thus, he wishes to determine the smallest feasible value of k (the number of seconds the poison effect endures) that is adequate to deliver at least h damage to the dragon. Observe Monocarp's stabbing sequence and approach meticulously to guarantee the maximization of the poison effect application.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in yet another computer game. In this game, his character must defeat a dragon. The combat with the dragon spans 100^{500} seconds. Within this duration, Monocarp attacks the dragon using a poisoned dagger. Each of Monocarp's attacks happens at specified seconds during the fight. The i-th strike occurs at the commencement of the a_i-th second from the battle's start. The dagger itself does not inflict damage. Nonetheless, it introduces a poison effect on the dragon, which is crucial for causing harm. Upon striking the dragon, the poison effect begins immediately at that moment. This poison effect inflicts 1 damage during each of the subsequent k seconds. However, if the dragon had previously been affected by poison, then the dagger refreshes the poison effect (i.e. it cancels the current poison effect and activates a new one).\n\nFor instance, let k = 4, and Monocarp strikes the dragon during the seconds 2, 4, and 10. Consequently, the poison effect is initiated at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; then, at the start of the 4-th second, the poison effect is refreshed, dealing 1 damage exactly during the seconds 4, 5, 6, and 7; subsequently, at the 10-th second, the poison effect is activated once more, delivering 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon incurs 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts a minimum of h damage to the dragon during the skirmish \u2014 he kills the dragon. Monocarp has not yet made up his mind about the potency of the poison he will utilize during the battle. Thus, he wishes to determine the smallest feasible value of k (the number of seconds the poison effect endures) that is adequate to deliver at least h damage to the dragon. Observe Monocarp's stabbing sequence and approach meticulously to guarantee the maximization of the poison effect application.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is engaged in yet another computer game. In this game, his character must defeat a dragon. The combat with the dragon spans 100^{500} seconds, and within this duration, Monocarp attacks the dragon using a poisoned dagger. Each of Monocarp's attacks happens at specified seconds during the fight, with the i-th strike occurring at the commencement of the a_i-th second from the battle's start. The dagger itself does not inflict damage; nonetheless, it introduces a poison effect on the dragon, which is crucial for causing harm. This poison effect inflicts 1 damage during each of the subsequent k seconds, and the poison effect begins at the moment the dragon is struck by the dagger. However, if the dragon had previously been affected by poison, then the dagger refreshes the poison effect (i.e. it cancels the current poison effect and activates a new one).\n\nFor instance, let k = 4, and Monocarp strikes the dragon during the seconds 2, 4, and 10. Consequently, the poison effect is initiated at the start of the 2-nd second and inflicts 1 damage during the 2-nd and 3-rd seconds; then, at the start of the 4-th second, the poison effect is refreshed, dealing 1 damage exactly during the seconds 4, 5, 6, and 7; subsequently, at the 10-th second, the poison effect is activated once more, delivering 1 damage during the seconds 10, 11, 12, and 13. In total, the dragon incurs 10 damage.\n\nMonocarp is aware that the dragon possesses h hit points, and if he inflicts a minimum of h damage to the dragon during the skirmish \u2014 he kills the dragon. Monocarp has not yet made up his mind about the potency of the poison he will utilize during the battle, thus he wishes to determine the smallest feasible value of k (the number of seconds the poison effect endures) that is adequate to deliver at least h damage to the dragon. Observe Monocarp's stabbing sequence and approach meticulously to guarantee the maximization of the poison effect application.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # Initial bounds for k\n        while left < right:\n            mid = (left + right) // 2\n            if can_inflict_damage(n, h, attack_times, mid):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef can_inflict_damage(n: int, h: int, attack_times: List[int], k: int) -> bool:\n    \"\"\"Check if a given k can inflict at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage to defeat the dragon.\n        attack_times (List[int]): List of attack times.\n        k (int): Duration of the poison effect.\n\n    Returns:\n        bool: True if the total damage is at least h, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attack_times[i + 1] - attack_times[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to be inflicted.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, 10**18  # Set a large upper bound for k\n        while left < right:\n            mid = (left + right) // 2\n            if can_inflict_damage(n, h, attacks, mid):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef can_inflict_damage(n: int, h: int, attacks: List[int], k: int) -> bool:\n    \"\"\"Check if a given poison duration k can inflict at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage to be inflicted.\n        attacks (List[int]): List of attack times.\n        k (int): Duration of the poison effect.\n\n    Returns:\n        bool: True if k can inflict at least h damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        # Calculate damage for each interval between attacks\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n        if total_damage >= h:\n            return True\n    # Add damage for the last attack\n    total_damage += k\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to inflict at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum poison durations for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Hit points of the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    def calculate_damage(n: int, k: int, attack_times: List[int]) -> int:\n        \"\"\"Calculate the total damage inflicted with a given poison duration k.\n\n        Args:\n            n (int): Number of attacks.\n            k (int): Poison duration.\n            attack_times (List[int]): List of attack times.\n\n        Returns:\n            int: Total damage inflicted.\n        \"\"\"\n        total_damage = 0\n        for i in range(n):\n            if i == n - 1:\n                total_damage += k\n            else:\n                total_damage += min(k, attack_times[i + 1] - attack_times[i])\n        return total_damage\n\n    results = []\n    for n, h, attack_times in test_cases:\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(n, mid, attack_times) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, h = map(int, input().split())\n    attack_times = list(map(int, input().split()))\n    test_cases.append((n, h, attack_times))\n\n# Output interface\nresult = minimum_poison_duration(t, test_cases)\nfor res in result:\n    print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum duration of the poison effect needed to inflict at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to inflict at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum poison durations for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search boundaries based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum k for each test case to inflict at least h damage.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of attacks.\n            - h: Hit points of the dragon.\n            - attacks: List of attack times.\n\n    Returns:\n        A list of integers representing the minimum k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search boundaries\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n - 1):\n                total_damage += min(mid, attacks[i + 1] - attacks[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search boundaries based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to defeat the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum value of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h  # Initial bounds for k\n        while left < right:\n            mid = (left + right) // 2\n            if can_inflict_damage(n, h, attack_times, mid):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef can_inflict_damage(n: int, h: int, attack_times: List[int], k: int) -> bool:\n    \"\"\"Check if a given k can inflict at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage to defeat the dragon.\n        attack_times (List[int]): List of attack times.\n        k (int): Duration of the poison effect.\n\n    Returns:\n        bool: True if k can inflict at least h damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attack_times[i + 1] - attack_times[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum duration of poison effect needed to inflict at least h damage on the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum duration of the poison effect required to inflict at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    for n, h, attack_times in test_cases:\n        low, high = 1, 10**18  # Set high to a large number as the maximum possible k\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum duration k for which the poison effect must last to inflict at least h damage on the dragon. The solution must efficiently handle up to 1000 test cases, with each test case involving up to 100 attacks and requiring damage calculations for potentially very large values of h.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case.\n- Ensure the solution handles large input sizes and edge cases efficiently.\n- Optimize the algorithm for performance and scalability.\n- Provide clear and concise output for each test case.\n- Include comprehensive test coverage for various scenarios.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will be used to find the smallest k such that the total damage inflicted is at least h. This approach is efficient and suitable for handling the large constraints given in the problem. We will iterate over the attack times and calculate the damage for a given k, adjusting k using binary search until the minimum valid k is found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is inflicted on the dragon. It lasts for k seconds after each attack, refreshing with each new attack.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration k for which the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'smallest feasible value of k'\n    Explanation: We need to find the minimum k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search for k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - Calculate the total damage for a given k by iterating over attack times and summing up the damage.\n        - Adjust the bounds based on whether the total damage is at least h.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1]\n    Expected output: 1\n    Explanation: With only one attack, k must be at least 1 to inflict any damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100]\n    Expected output: A large number (close to h/n)\n    Explanation: With maximum constraints, k needs to be large enough to accumulate sufficient damage.\n\n    Case 3: n = 2, h = 10, a = [1, 1000000000]\n    Expected output: 5\n    Explanation: The attacks are far apart, so k must be large enough to cover the gap and accumulate damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the accumulated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) needed to inflict at least h damage to the dragon. The challenge lies in efficiently calculating this for potentially large input sizes, ensuring the solution is both correct and performant.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k\n- Optimize the algorithm for large input sizes\n- Ensure the solution is accurate and handles edge cases\n- Provide clear documentation and examples\n- Enhance user engagement with feedback on damage dealt\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will be applied on the range of possible k values, and for each k, we will simulate the damage calculation to check if it meets or exceeds the required damage h. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is inflicted on the dragon. It lasts for k seconds after each attack, refreshing with each new attack.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration of the poison effect that results in at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'smallest feasible value'\n    Explanation: We need to find the minimum k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search on k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - For each k in the binary search, simulate the damage calculation:\n            - Initialize total damage to 0.\n            - Iterate over attack times and calculate damage intervals.\n            - Accumulate damage based on poison effect duration k.\n        - Check if total damage is at least h.\n        - Adjust binary search bounds based on whether the condition is met.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with attacks at consecutive seconds:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h=1, k=1 is sufficient to inflict the required damage.\n\n    Test case with maximum h:\n    2 10^18\n    1 10^9\n    Expected output: Large k value\n    Explanation: Requires a large k to meet the high damage requirement.\n\n    Test case with attacks spaced far apart:\n    3 5\n    1 1000 2000\n    Expected output: 5\n    Explanation: Requires k=5 to accumulate enough damage over widely spaced attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles varying attack intervals and large values of h efficiently.\n", "requirement analysis:\nThe requirement involves calculating the minimum duration of poison effect needed to inflict at least h damage to the dragon. The challenge lies in efficiently handling large numbers and ensuring the accuracy of calculations.\nrequirement pool:\n- Implement the main algorithm to calculate minimum poison duration\n- Optimize the code for handling large input sizes\n- Ensure the output format matches the requirements\n- Test the algorithm against multiple test cases\n- Improve user interface for better understanding\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) required to inflict at least h damage to the dragon. The binary search will be applied over the possible values of k, leveraging the sorted nature of the attack times to calculate the total damage for a given k. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is inflicted on the dragon. Each attack refreshes the poison effect, causing damage over a specified number of seconds (k).\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'smallest': We need to find the minimum value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, h, and the list of attack times.\n3. Implement a binary search on k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k, calculate the total damage:\n     - Initialize total damage to 0.\n     - Iterate over attack times and calculate damage for each segment.\n     - If the next attack time is within the current poison duration, extend the damage calculation.\n     - Otherwise, add full k seconds of damage.\n   - If total damage >= h, adjust the upper bound of k.\n   - Otherwise, adjust the lower bound.\n4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] = 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Case 2: n = 2, h = 10^18, a = [1, 10^9] = 10^18\n    Explanation: With a large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n    Case 3: n = 100, h = 100, a = [1, 2, ..., 100] = 1\n    Explanation: With attacks every second and needing only 100 damage, k = 1 is sufficient as each attack refreshes the poison.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) that will ensure the dragon receives at least h damage. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attacks and requiring up to 10^18 damage. The attacks are given in increasing order of time, and the poison effect refreshes with each attack.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case\n- Ensure the solution handles large input sizes efficiently\n- Optimize the code for performance and readability\n- Provide clear documentation and comments within the code\n- Include additional test cases to cover edge scenarios\nWe will implement a function to calculate the minimum poison duration k for each test case. The approach involves iterating over the attack times and calculating the damage inflicted by the poison effect. We will use binary search to efficiently find the minimum k that satisfies the damage requirement. This ensures optimal performance even for large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism through which damage is inflicted on the dragon. It lasts for k seconds after each attack, refreshing with each new attack.\n\n    'minimum value of k'\n    Explanation: The smallest duration for which the poison effect must last to ensure that the total damage inflicted meets or exceeds the dragon's hit points.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted by the poison effect must be greater than or equal to h, the dragon's hit points. This can be implemented by ensuring the sum of damage over all affected seconds is >= h.\n\n# [degree adverb]\n    'smallest feasible value of k'\n    Explanation: We need to find the minimum k such that the total damage inflicted is at least h. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n (number of attacks) and h (hit points).\n    3. Read the attack times into a list.\n    4. Use binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - For each mid value in binary search, calculate total damage:\n            - Iterate over attack times and calculate damage for each attack.\n            - Refresh poison effect if a new attack occurs before the previous poison duration ends.\n        - Check if total damage >= h.\n        - Adjust binary search bounds based on whether current mid satisfies the condition.\n    5. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k = 1 is sufficient to inflict at least 1 damage.\n\n    Test case with attacks spaced far apart:\n    2 2\n    1 1000000000\n    Expected output: 1\n    Explanation: Each attack can independently inflict 1 damage with k = 1, totaling 2 damage.\n\n    Test case with large h:\n    3 1000000000000000000\n    1 2 3\n    Expected output: Large value (depends on implementation)\n    Explanation: Requires a large k to accumulate enough damage over few attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles varying input sizes and conditions efficiently.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect needed to inflict at least h damage to the dragon. The challenge lies in efficiently handling large numbers and ensuring the poison effect is maximized by refreshing it at the right moments.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum poison duration\n- Ensure accurate handling of large input sizes\n- Optimize code for performance\n- Provide clear output format\n- Include detailed comments and documentation\nWe will implement a function to determine the minimum duration of the poison effect needed to inflict at least h damage to the dragon. The approach involves iterating over the attack times and calculating the damage inflicted by each attack, considering the refresh of the poison effect. We will use binary search to efficiently find the minimum k that satisfies the condition. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is inflicted on the dragon. Each attack refreshes the poison effect, causing it to last for k seconds and inflict 1 damage per second.\n\n    'refreshes the poison effect'\n    Explanation: When an attack occurs, any ongoing poison effect is reset, and a new poison effect begins, lasting for k seconds.\n\n    'smallest feasible value of k'\n    Explanation: The goal is to find the minimum duration k such that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'smallest'\n    Explanation: We need to find the minimum value of k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Initialize a binary search range for k, starting from 1 to a large number (e.g., h).\n2. For each test case, perform a binary search:\n   - Calculate the total damage for a given k by iterating over attack times.\n   - For each attack, calculate the damage inflicted by considering the overlap and refresh of poison effects.\n   - If the total damage is at least h, adjust the binary search range to find a smaller k.\n3. Return the smallest k found for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and needing only 1 damage, k = 1 is sufficient.\n\n    Case 2: n = 100, h = 1000, a = [1, 2, ..., 100] => k = 10\n    Explanation: Each attack refreshes the poison effect, and with 100 attacks, k = 10 ensures at least 1000 damage.\n\n    Case 3: n = 2, h = 10^18, a = [1, 10^9] => k = 10^18\n    Explanation: With very large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe requirement focuses on calculating the minimum duration of poison effect needed to inflict sufficient damage to the dragon. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Implement the main algorithm to calculate minimum poison duration\n- Optimize the solution for large input sizes\n- Ensure the solution handles multiple test cases efficiently\n- Provide clear and concise output for each test case\n- Test the solution against edge cases and large numbers\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) required to inflict at least h damage to the dragon. The binary search will be applied over the possible values of k, leveraging the sorted nature of attack times to calculate the total damage for a given k. This approach ensures that we handle large input sizes and multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism through which damage is inflicted on the dragon. It lasts for k seconds after each attack and can be refreshed by subsequent attacks.\n\n    'minimum value of k'\n    Explanation: We need to find the smallest duration for which the poison effect lasts that is sufficient to inflict at least h damage to the dragon.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. This means we need to ensure the sum of damage over all seconds is >= h.\n\n# [degree adverb]\n    'smallest feasible value of k'\n    Explanation: We are looking for the minimum k that satisfies the condition of inflicting at least h damage.\n\n# [code logic]\n    1. For each test case, initialize the binary search boundaries for k.\n    2. Calculate the total damage for a given k by iterating through attack times and summing up the damage inflicted during each poison effect duration.\n    3. Use binary search to adjust k based on whether the total damage meets or exceeds h.\n    4. Return the minimum k found for each test case.\n\n# [edge case]\n    Test case with minimum attacks and minimum damage:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Test case with attacks spaced far apart:\n    2 2\n    1 1000000000\n    Expected output: 1\n    Explanation: Each attack can independently inflict 1 damage, so k=1 is sufficient.\n\n    Test case with maximum possible h:\n    2 1000000000000000000\n    1 1000000000\n    Expected output: Large value (depends on implementation)\n    Explanation: Requires a very large k to meet the high damage requirement.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage.\n", "requirement analysis:\nThe game requires a strategic approach to determine the optimal poison duration (k) to defeat the dragon. The challenge lies in calculating the minimum k that ensures the dragon's hit points are reduced to zero or below, considering the refresh mechanism of the poison effect.\nrequirement pool:\n- Implement the algorithm to calculate minimum k for poison effect\n- Ensure the game handles large numbers efficiently\n- Provide clear instructions and feedback to the player\n- Optimize the game's performance for complex calculations\n- Design an intuitive UI for better player experience\nWe will implement a function to calculate the minimum k using a binary search approach to efficiently handle large numbers and ensure optimal performance. The function will iterate over the attack times and calculate the total damage for a given k, adjusting k until the damage meets or exceeds the dragon's hit points.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism through which Monocarp inflicts damage on the dragon. It lasts for k seconds after each attack, refreshing with each new attack.\n\n    'refreshes the poison effect'\n    Explanation: When Monocarp strikes the dragon again before the current poison effect ends, the poison duration resets, starting a new k-second period of damage.\n\n# [phrase showing quantity relationship]\n    'minimum of h damage'\n    Explanation: The goal is to inflict at least h damage to the dragon, meaning the total damage must be greater than or equal to h.\n    Implementation: Ensure the total calculated damage is >= h.\n\n# [degree adverb]\n    'smallest feasible value of k'\n    Explanation: We need to find the smallest k that allows Monocarp to inflict at least h damage.\n    Implementation: Use binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Initialize binary search boundaries for k (e.g., low = 1, high = maximum possible k).\n    2. For each test case, perform binary search:\n        - Calculate total damage for mid value of k.\n        - If damage >= h, adjust high boundary; otherwise, adjust low boundary.\n    3. Return the smallest k found for each test case.\n\n# [edge case]\n    Test case with attacks spaced far apart:\n    Input: 1 1\n           1\n    Expected output: 1\n    Explanation: Only one attack is needed, and k=1 is sufficient to inflict 1 damage.\n\n    Test case with maximum h:\n    Input: 1 10^18\n           1\n    Expected output: 10^18\n    Explanation: With only one attack, k must be equal to h to inflict enough damage.\n\n    Test case with attacks at consecutive seconds:\n    Input: 3 3\n           1 2 3\n    Expected output: 1\n    Explanation: Each attack refreshes the poison effect, so k=1 is sufficient to inflict 3 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting k based on calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of poison effect needed to inflict at least h damage to the dragon, given the sequence of attack times. The solution must efficiently handle large numbers and multiple test cases, ensuring accurate and quick results.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum poison duration\n- Ensure the solution handles large input sizes effectively\n- Provide clear output format for each test case\n- Optimize performance for multiple test cases\n- Include detailed comments and documentation\nWe will implement a function to calculate the minimum poison duration using a binary search approach to efficiently find the smallest k that satisfies the damage requirement. This approach is chosen due to its ability to handle large input sizes effectively, ensuring optimal performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism through which Monocarp inflicts damage on the dragon. It lasts for k seconds after each attack, refreshing with each new attack.\n\n    'minimum value of k'\n    Explanation: The smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted by the poison effect must be greater than or equal to h. This can be implemented by ensuring the sum of damage over all affected seconds meets or exceeds h.\n\n# [degree adverb]\n    'smallest feasible value'\n    Explanation: We need to find the minimum possible k that still allows Monocarp to inflict at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., 1 to a large number).\n        - Calculate the total damage for a given k by iterating over attack times and summing up the damage.\n        - Adjust the bounds based on whether the calculated damage meets or exceeds h.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k must be at least 1.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100] => Expected output: A large number\n    Explanation: With maximum possible h, k needs to be large enough to cover all attacks and meet the damage requirement.\n\n    Case 3: n = 2, h = 10, a = [1, 1000000000] => Expected output: 10\n    Explanation: The attacks are far apart, so k must be at least 10 to ensure enough damage is dealt.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k seconds) needed to inflict at least h damage on the dragon, given a sequence of attack times. The solution must efficiently handle up to 1000 test cases, with each test case having up to 100 attack times and requiring up to 10^18 damage.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case.\n- Ensure the solution handles large input sizes efficiently.\n- Optimize the algorithm to minimize computational complexity.\n- Validate the solution against edge cases and large numbers.\n- Provide clear and concise output for each test case.\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k seconds) needed to inflict at least h damage on the dragon. This approach is chosen because it allows us to handle large input sizes and constraints effectively, ensuring that the solution is both optimal and scalable.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is the mechanism by which damage is inflicted on the dragon. Each attack refreshes the poison effect, causing it to last for k seconds, dealing 1 damage per second.\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage inflicted must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'smallest feasible value'\n    Explanation: This indicates that we need to find the minimum possible k that satisfies the condition of inflicting at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Implement a binary search to find the minimum k:\n   - Set initial bounds for k (e.g., 1 to a large number).\n   - For each mid value of k, calculate the total damage:\n     - Initialize total damage to 0.\n     - Iterate over attack times and calculate damage intervals.\n     - Accumulate damage for each interval.\n   - If total damage >= h, adjust the upper bound of k.\n   - Otherwise, adjust the lower bound.\n5. Output the minimum k for each test case.\n\n# [edge case]\n    Test case 1: 1 1\n                 1\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k = 1 is sufficient to inflict the required damage.\n\n    Test case 2: 2 2\n                 1 3\n    Expected output: 1\n    Explanation: Two attacks at seconds 1 and 3 with k = 1 will inflict damage at seconds 1 and 3, totaling 2 damage.\n\n    Test case 3: 3 5\n                 1 2 3\n    Expected output: 2\n    Explanation: With attacks at seconds 1, 2, and 3, k = 2 will cover seconds [1,2], [2,3], and [3,4], totaling 5 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the accumulated damage compared to h.\n", "requirement analysis:\nThe requirement is to calculate the minimum duration of poison effect needed to inflict at least h damage to the dragon, given the sequence of attack times. The solution must efficiently handle up to 1000 test cases with large values for n and h.\nrequirement pool:\n- Calculate minimum k for poison effect to meet or exceed h damage\n- Optimize algorithm for large input sizes\n- Ensure output format matches requirements\n- Handle edge cases effectively\n- Provide user-friendly error messages\nWe will implement a function to determine the minimum duration of the poison effect (k) required to inflict at least h damage to the dragon. The approach involves iterating over the attack times and calculating the damage inflicted by the poison effect. We will use binary search to efficiently find the minimum k that satisfies the condition. This approach ensures that we handle large input sizes effectively.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'poison effect'\n    Explanation: The poison effect is a crucial mechanic in the game that inflicts damage over a period of time after each attack. The duration of this effect is determined by the variable k, and it can be refreshed with each new attack.\n\n    'minimum value of k'\n    Explanation: This refers to finding the smallest duration for which the poison effect must last to ensure that the total damage inflicted is at least h.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage inflicted by the poison effect must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'smallest': This indicates that we need to find the minimum possible value of k that satisfies the condition of inflicting at least h damage. In code, this can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n (number of attacks) and h (required damage).\n3. Read the attack times into a list.\n4. Use binary search to find the minimum k:\n   - Set low = 1 and high = maximum possible k (a large number).\n   - While low < high:\n     - Calculate mid = (low + high) // 2.\n     - Calculate total damage for k = mid:\n       - Initialize total_damage = 0.\n       - For each attack time, calculate the damage contributed by that attack.\n       - If total_damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n5. Output the value of low as the minimum k for each test case.\n\n# [edge case]\n    Test case 1: n = 1, h = 1, a = [1] => k = 1\n    Explanation: With only one attack and h = 1, the minimum k is 1 since one second of poison is enough.\n\n    Test case 2: n = 2, h = 10^18, a = [1, 10^9] => k = 10^18\n    Explanation: With a large h and widely spaced attacks, k must be very large to accumulate enough damage.\n\n    Test case 3: n = 100, h = 100, a = [1, 2, ..., 100] => k = 1\n    Explanation: With consecutive attacks and h equal to n, k can be minimal since each attack contributes immediately.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search approach inherently handles these scenarios by adjusting k based on the required damage and attack timing.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 679, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "rephrase_one", "parent_index": 417}
