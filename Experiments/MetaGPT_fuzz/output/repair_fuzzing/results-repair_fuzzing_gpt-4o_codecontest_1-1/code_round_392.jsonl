{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books, each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m, and Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds: * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books, each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m, and Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds: * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books, each book is represented by the book title \u2014 a string s_i numbered from 1 to n. Each title has a length of m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds: * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "Andi and Budi were given an assignment to tidy up their bookshelf of n books, each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m, and Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending, so settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds: * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: sort descending, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: sort ascending, use ASCII value as is\n                key.append(ord(char))\n        return key\n\n    # Create a list of tuples (index, book_title) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key function\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: descending order, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order, use ASCII value\n                key.append(ord(char))\n        return key\n\n    # Create a list of tuples (index, book) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n\n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in a custom 'asc-desc-ending' order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of original indices of the books sorted in the custom order.\n    \"\"\"\n    \n    def custom_sort_key(book: str) -> List:\n        \"\"\"Generates a custom key for sorting based on 'asc-desc-ending' order.\n\n        Args:\n            book (str): The book title to generate the key for.\n\n        Returns:\n            List: A list of tuples representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(book):\n            # Odd-indexed positions (0-based index is even) - ascending order\n            if i % 2 == 0:\n                key.append((char, False))\n            # Even-indexed positions (0-based index is odd) - descending order\n            else:\n                key.append((char, True))\n        return key\n\n    # Pair each book with its original index\n    indexed_books = [(i + 1, book) for i, book in enumerate(books)]\n    \n    # Sort using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc_ending(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in a custom order where odd-indexed characters are sorted\n    ascendingly and even-indexed characters are sorted descendingly.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the sorted book titles.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given title based on the asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list of tuples representing the custom sort key.\n        \"\"\"\n        return [(c if i % 2 == 0 else chr(255 - ord(c))) for i, c in enumerate(title)]\n    \n    # Create a list of tuples (index, title) to maintain original indices\n    indexed_titles = list(enumerate(book_titles, start=1))\n    \n    # Sort the titles using the custom sort key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc_ending(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts the book titles according to the custom asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): The list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in the custom order.\n    \"\"\"\n    \n    def custom_key(book: str) -> List:\n        \"\"\"Generates a key for sorting based on the custom asc-desc-ending order.\n\n        Args:\n            book (str): The book title.\n\n        Returns:\n            List: A list of tuples representing the custom sort key.\n        \"\"\"\n        return [(char, -ord(char)) if i % 2 == 0 else (ord(char), char) for i, char in enumerate(book)]\n    \n    # Create a list of tuples (index, book) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    indexed_books.sort(key=lambda x: custom_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n: Number of books.\n        m: Length of each book title.\n        books: List of book titles.\n\n    Returns:\n        List of indices representing the sorted order of book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title: The book title.\n\n        Returns:\n            A list representing the custom sort key.\n        \"\"\"\n        return [(title[i], -ord(title[i])) if i % 2 == 0 else (title[i], ord(title[i])) for i in range(m)]\n\n    # Create a list of tuples (index, book title) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n\n    # Sort the indexed books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in a custom 'asc-desc-ending' order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the sorted book titles.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List[int]:\n        \"\"\"Generates a custom key for sorting based on 'asc-desc-ending' order.\n\n        Args:\n            title (str): The book title to generate the key for.\n\n        Returns:\n            List[int]: A list of integers representing the custom sort key.\n        \"\"\"\n        key = []\n        for index, char in enumerate(title):\n            if index % 2 == 0:\n                # Even index: sort descendingly, use negative ASCII value\n                key.append(-ord(char))\n            else:\n                # Odd index: sort ascendingly, use ASCII value\n                key.append(ord(char))\n        return key\n\n    # Create a list of tuples (index, title) to keep track of original indices\n    indexed_titles = list(enumerate(titles, start=1))\n    \n    # Sort the titles using the custom key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom 'asc-desc-ending' order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: A list of indices representing the sorted order of books.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom key for sorting based on 'asc-desc-ending' order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple where odd-indexed characters are sorted ascendingly\n                   and even-indexed characters are sorted descendingly.\n        \"\"\"\n        # Create a tuple with odd-indexed characters sorted ascendingly\n        # and even-indexed characters sorted descendingly\n        return tuple(\n            (title[i] if i % 2 == 0 else chr(255 - ord(title[i])))\n            for i in range(m)\n        )\n\n    # Pair each book with its original index\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in the custom order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom key for sorting based on asc-desc-ending order.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        odd_chars = [title[i] for i in range(m) if i % 2 == 0]\n        even_chars = [title[i] for i in range(m) if i % 2 == 1]\n        return (odd_chars, [-ord(c) for c in even_chars])\n\n    # Create a list of tuples (index, book_title) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> tuple:\n        \"\"\"Creates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            tuple: A tuple representing the custom sort key.\n        \"\"\"\n        odd_chars = [title[i] for i in range(m) if i % 2 == 0]\n        even_chars = [title[i] for i in range(m) if i % 2 == 1]\n        return (odd_chars, [-ord(c) for c in even_chars])\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n"], "plans": ["requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The solution must handle up to 10^6 characters efficiently and output the indices of the sorted titles.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles large input sizes efficiently.\n- Optimize the algorithm for performance.\n- Provide clear documentation and comments in the code.\n- Include test cases to validate the solution.\nWe will implement a custom sorting algorithm that sorts book titles based on the specified asc-desc-ending order. The algorithm will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will handle up to 10^6 characters efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending order'\n    Explanation: This is a custom sorting order where characters at odd indices are sorted in ascending order and characters at even indices are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This refers to the dictionary order of strings, where strings are compared based on the alphabetical order of their characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No explicit degree adverb\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each book title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the string, if its index is odd, use the character as is for comparison (ascending order).\n   - If its index is even, use the negative of the character's ASCII value for comparison (descending order).\n4. Use Python's `sorted()` function with the custom key to sort the list of book titles.\n5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 0 (odd), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 2 1 3\n    Explanation: At index 0 (odd), 'B' comes before 'A', so 'BAC' comes first. Then 'ABC' and 'CAB' are compared at index 1 (even), where 'B' comes after 'A'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by applying the specified sorting rules consistently across all input strings.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of n book titles, each of length m, and the output should be the indices of the titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise documentation for the sorting logic.\n- Include test cases to validate the sorting algorithm.\n- Optimize the code for readability and maintainability.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will handle up to 10^6 characters efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': sorting order where characters are compared based on their position in the alphabet from A to Z.\n    'lexicographically descending': sorting order where characters are compared based on their position in the alphabet from Z to A.\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the title, if its index is odd, use the character as is for comparison (ascending order).\n   - If its index is even, use the negative of the character's ASCII value for comparison (descending order).\n4. Sort the list of titles using this custom key function.\n5. Output the indices of the sorted titles.\n\n# [edge case] \n    1 1\n    A\n    = 1\n    Explanation: With only one book, it is already sorted, so the output is its index, 1.\n\n    2 2\n    AB\n    BA\n    = 2 1\n    Explanation: For index 1 (odd), 'A' < 'B', and for index 2 (even), 'B' > 'A', so \"BA\" comes before \"AB\".\n\n    3 3\n    ABC\n    BAC\n    CAB\n    = 1 3 2\n    Explanation: At index 1 (odd), \"ABC\" < \"BAC\" < \"CAB\". At index 2 (even), \"CAB\" > \"BAC\" > \"ABC\". At index 3 (odd), \"ABC\" < \"BAC\" < \"CAB\".\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering both odd and even indexed character comparisons.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The solution must efficiently handle up to 10^6 characters in total.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Ensure the solution handles large inputs efficiently.\n- Optimize the code for readability and maintainability.\n- Test the solution against multiple test cases.\n- Document the code and provide usage instructions.\nWe will implement a custom sorting function that compares strings based on the specified asc-desc-ending order. The function will iterate over each character of the strings, comparing them according to their index (odd or even) and applying the appropriate lexicographical order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to a custom sorting order where odd-indexed characters are sorted in ascending lexicographical order, and even-indexed characters are sorted in descending lexicographical order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters, similar to how words are ordered in a dictionary.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of books (n) and the length of each book title (m).\n2. Store each book title in a list along with its original index.\n3. Define a custom sorting function that:\n   - Iterates over each character of two strings being compared.\n   - For odd-indexed positions, compares characters in ascending order.\n   - For even-indexed positions, compares characters in descending order.\n4. Use Python's `sorted()` function with the custom sorting function as the key.\n5. Extract and print the original indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, the output is simply its index.\n\n    Input: 2 3\n           ABC\n           ACB\n    Output: 2 1\n    Explanation: At position 2 (even), 'C' > 'B', so ACB comes before ABC.\n\n    Input: 3 2\n           AB\n           BA\n           AC\n    Output: 3 1 2\n    Explanation: At position 1 (odd), 'A' < 'B', so AC comes first. Then, AB comes before BA because at position 2 (even), 'B' > 'A'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by comparing characters based on their indices and applying the appropriate lexicographical order.\n", "requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified character comparison rules. The solution must efficiently handle up to 10^6 characters, ensuring performance and accuracy.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Optimize for performance with large datasets\n- Ensure accurate character comparison\n- Provide clear input/output handling\n- Enhance user interface for better experience\nWe will implement a custom sorting function that adheres to the asc-desc-ending order rules. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles up to 10^6 characters efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting in alphabetical order (A-Z).\n    'lexicographically descending': means sorting in reverse alphabetical order (Z-A).\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb]\n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each title `m`.\n2. Read the `n` book titles.\n3. Implement a custom sorting function:\n   - For each pair of titles, compare characters at each position.\n   - If the position is odd, compare characters in ascending order.\n   - If the position is even, compare characters in descending order.\n4. Use Python's `sorted()` function with the custom key to sort the titles.\n5. Output the indices of the sorted titles.\n\n# [edge case]\n    1. Input: 1 1\n       A\n       Output: 1\n       Explanation: With only one book, it is already sorted.\n       \n    2. Input: 2 2\n       AA\n       AB\n       Output: 1 2\n       Explanation: The first character is odd-indexed and both are 'A', so we move to the second character which is even-indexed. 'B' comes before 'A' in descending order, so 'AA' comes before 'AB'.\n\n    3. Input: 3 3\n       ABC\n       ACB\n       BAC\n       Output: 1 3 2\n       Explanation: At the first position (odd), 'A' comes before 'B', so 'ABC' and 'ACB' come before 'BAC'. Between 'ABC' and 'ACB', at the second position (even), 'C' comes before 'B' in descending order, so 'ACB' comes after 'ABC'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by comparing each character according to its index position rules.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input size constraint is significant, with n * m up to 10^6, which requires an efficient sorting algorithm. The output should be the indices of the sorted titles.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise output as per the format.\n- Optimize for performance and memory usage.\n- Consider edge cases such as minimum input size.\nWe will implement a custom sorting algorithm using a comparator function that adheres to the asc-desc-ending order rules. The sorting will be efficient enough to handle the maximum input size constraint using Python's built-in sorting capabilities with a custom key function.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending order'\n    Explanation: This is a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This refers to the dictionary order of strings, where strings are compared based on the alphabetical order of their characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No explicit degree adverb\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each book title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom comparator function that:\n   - Compares characters at odd indices in ascending order.\n   - Compares characters at even indices in descending order.\n4. Use Python's built-in sorting function with the custom comparator to sort the list of book titles.\n5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is already sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 1 (odd), 'B' comes after 'A', so 'BA' comes before 'AB'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: At index 1 (odd), 'A' comes before 'B' and 'C', so 'ABC' comes first. At index 2 (even), 'A' comes after 'B', so 'BAC' comes before 'CAB'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom comparator function inherently handles all cases by comparing each character position according to the specified rules.\n", "requirement analysis:\nThe requirement is to sort book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The solution must handle up to 10^6 characters efficiently and output the indices of the sorted titles.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Optimize the algorithm for large input sizes\n- Ensure the output format matches the requirements\n- Test the solution against multiple test cases\n- Document the code for maintainability\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles up to 10^6 characters efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n        - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key.\n    5. Output the indices of the sorted book titles.\n\n# [edge case]\n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: For odd positions, 'A' comes before 'B', and for even positions, 'B' comes before 'A'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 1 2 3\n    Explanation: The first character determines the order since they differ at odd positions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting based on custom keys will handle all cases, including edge cases.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The challenge is to implement an efficient sorting algorithm that adheres to these rules, given the constraints on input size.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise output as per the specified format.\n- Optimize the code for readability and maintainability.\n- Include comments and documentation for the implemented solution.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities, leveraging the key parameter to define our custom sorting logic. The key will be a function that compares characters based on their positions (odd or even) and sorts them accordingly. This approach ensures efficiency and simplicity, given the constraints on input size.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'lexicographically ascending': means sorting strings based on dictionary order from A to Z.\n    'lexicographically descending': means sorting strings based on dictionary order from Z to A.\n    'asc-desc-endingly': a custom sorting order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of books `n` and the length of each book title `m`.\n2. Read the `n` book titles into a list.\n3. Define a custom sorting key function:\n   - For each character in the string, determine its index (odd or even).\n   - If the index is odd, use the character as is for comparison (ascending order).\n   - If the index is even, use the negative of the character's ASCII value for comparison (descending order).\n4. Sort the list of book titles using this custom key function.\n5. Output the indices of the sorted book titles.\n\n# [edge case] \n    1. Input: 1 1\n       A\n       Output: 1\n       Explanation: With only one book, it remains in its position.\n       \n    2. Input: 2 2\n       AB\n       BA\n       Output: 2 1\n       Explanation: For the first character (odd), 'A' < 'B', so 'BA' comes before 'AB'.\n       \n    3. Input: 3 3\n       ABC\n       BAC\n       CAB\n       Output: 1 2 3\n       Explanation: The first character (odd) determines the order, so they remain in input order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering both odd and even indexed characters appropriately.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The solution must efficiently handle up to 10^6 characters in total, ensuring performance and correctness across multiple test cases.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order\n- Optimize the algorithm for large input sizes\n- Ensure the solution passes all test cases\n- Provide clear documentation for the code\n- Consider edge cases and input validation\nWe will implement a custom sorting algorithm that sorts book titles based on the asc-desc-ending order. The algorithm will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles up to 10^6 characters efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This is a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Define a custom key function for sorting:\n        - For each book title, create a tuple where odd-indexed characters are sorted normally (ascending) and even-indexed characters are sorted in reverse order (descending).\n    4. Use Python's sorted function with the custom key to sort the list of book titles.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 1\n           A\n           B\n    Output: 1 2\n    Explanation: With single-character titles, sorting is straightforward based on the single character.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 2 1 3\n    Explanation: Sorting based on asc-desc-ending order results in BAC being first due to 'B' at odd index being earlier than 'A' in ABC, followed by ABC, and then CAB.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases by using the custom sorting key function.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The challenge is to implement an efficient sorting algorithm that can handle up to 10^6 characters in total.\nrequirement pool:\n- Implement the main sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm for performance given the constraint of 1 \u2264 n \u22c5 m \u2264 10^6.\n- Ensure the solution handles edge cases, such as minimum and maximum input sizes.\n- Provide clear and concise documentation for the implemented solution.\n- Develop test cases to validate the sorting algorithm against various scenarios.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will utilize Python's built-in sorting capabilities with a custom key function to achieve the desired order. Given the constraints, we will ensure the solution is efficient and can handle large inputs by leveraging Python's efficient sorting algorithms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-endingly'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: This means sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n        - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it remains in its original position.\n\n    Input: 2 3\n           ABC\n           BAC\n    Output: 2 1\n    Explanation: At the first differing position (index 0, odd), 'B' comes after 'A', so BAC comes before ABC.\n\n    Input: 3 2\n           AB\n           BA\n           AC\n    Output: 3 1 2\n    Explanation: At the first differing position (index 0, odd), 'A' comes before 'B', so AC comes first. Then AB comes before BA at index 1 (even).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases by considering both odd and even positions as specified.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of n book titles, each of length m, and the output should be the indices of the titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Optimize the sorting algorithm to handle large inputs efficiently.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases such as minimum and maximum input sizes.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'asc-desc-ending'\n    Explanation: This refers to the sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n\n    'lexicographically'\n    Explanation: Sorting based on the alphabetical order of characters.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of books (n) and the length of each title (m).\n    2. Read the book titles into a list.\n    3. Implement a custom sorting function:\n        - For each book title, create a tuple where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order.\n        - Use this tuple as the key for sorting.\n    4. Sort the list of book titles using the custom key function.\n    5. Output the indices of the sorted book titles.\n\n# [edge case] \n    Input: 1 1\n           A\n    Output: 1\n    Explanation: With only one book, it is trivially sorted.\n\n    Input: 2 2\n           AB\n           BA\n    Output: 2 1\n    Explanation: At index 1 (odd), 'A' comes before 'B', and at index 2 (even), 'B' comes after 'A'.\n\n    Input: 3 3\n           ABC\n           BAC\n           CAB\n    Output: 3 2 1\n    Explanation: At index 1 (odd), 'C' comes before 'B' and 'A', at index 2 (even), 'A' comes after 'B' and 'C'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The custom sorting logic inherently handles all cases, including edge cases, by comparing characters based on their indices.\n"], "scores": [], "pass_results": [true, false, false, true, true, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 392, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "condense_two2one", "parent_index": 254}
