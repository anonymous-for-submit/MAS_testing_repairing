{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is committed to discovering the optimal poison impact. Monocarp wants to do this to efficiently conquer the dragon by using resources sparingly to guarantee triumph.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is committed to discovering the optimal poison impact. Monocarp wants to do this to efficiently conquer the dragon by using resources sparingly to guarantee triumph.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is committed to discovering the optimal poison impact. Monocarp has a strong desire to do this efficiently. This is because conquering the dragon requires using resources sparingly to guarantee triumph.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "Monocarp is committed to discovering the optimal poison impact to efficiently conquer the dragon by using resources sparingly to guarantee triumph.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_k(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to ensure Monocarp deals at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing (n, h, attack_times).\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        \n        while low < high:\n            mid = (low + high) // 2\n            damage = 0\n            \n            # Calculate the damage for the current mid value of k\n            for i in range(n):\n                if i == n - 1:\n                    damage += mid\n                else:\n                    damage += min(mid, attack_times[i + 1] - attack_times[i])\n            \n            # Adjust bounds based on whether the damage meets or exceeds h\n            if damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n    \n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_impact(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison impact needed to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attack_times (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: List of minimum values of k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current k = mid\n            for i in range(n - 1):\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            total_damage += mid  # Add damage for the last attack\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    # Output interface\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_k(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attack_times in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        \n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            \n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n    \n    # Output interface\n    results = minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_min_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Find the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            if can_deal_damage(n, h, a, mid):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef can_deal_damage(n: int, h: int, a: List[int], k: int) -> bool:\n    \"\"\"Check if the total damage with given k is at least h.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage.\n        a (List[int]): List of attack times.\n        k (int): Current value of k being tested.\n\n    Returns:\n        bool: True if the total damage is at least h, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, a[i + 1] - a[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Output interface\n    results = find_min_k(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_impact(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case to deal at least h damage.\"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n        \n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage for current k (mid)\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n            \n            # Check if the total damage is at least h\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_poison_impact(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef find_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Find the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, a in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, a[i + 1] - a[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        # After binary search, low is the minimum k that satisfies the condition\n        results.append(low)\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n\n    # Call the function and print results\n    results = find_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_impact(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that Monocarp will cause at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attack_times (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        low, high = 1, attack_times[-1]\n\n        while low < high:\n            mid = (low + high) // 2\n            damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n - 1):\n                damage += min(mid, attack_times[i + 1] - attack_times[i])\n            damage += mid  # Add damage for the last attack\n\n            if damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n\n    results = minimum_poison_impact(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Find the minimum value of k for each test case such that Monocarp will cause at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of Monocarp's attacks.\n            - h (int): Amount of damage that needs to be dealt.\n            - attacks (List[int]): List of integers representing the seconds when each attack is performed.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        low, high = 1, h  # k must be at least 1 and at most h\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for k = mid\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = find_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Find the minimum value of k for each test case such that Monocarp deals at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage for current mid value\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n\n    results = find_minimum_k(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_minimum_k(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum value of k for each test case such that the total damage is at least h.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of tuples containing n, h, and attack_times.\n\n    Returns:\n        List[int]: List of minimum k values for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attack_times in test_cases:\n        low, high = 1, h\n        \n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n            \n            # Calculate total damage with current mid as k\n            for i in range(n - 1):\n                total_damage += min(mid, attack_times[i + 1] - attack_times[i])\n            total_damage += mid  # Add damage for the last attack\n            \n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n        \n        results.append(low)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n    \n    results = calculate_minimum_k(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to determine the minimum value of the parameter k such that Monocarp's attacks cause at least h damage to the dragon. The challenge lies in efficiently calculating the damage over time given the constraints of attack timings and the required damage threshold.\nrequirement pool:\n- Implement the algorithm to calculate the minimum k for each test case.\n- Optimize the algorithm for performance given the large possible range of h.\n- Ensure the solution handles edge cases, such as minimum and maximum values of n and h.\n- Provide detailed comments and documentation for the code.\n- Develop a user-friendly interface for input and output.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The key challenge is to calculate the damage dealt over time with varying k values and ensure it meets or exceeds the required damage h. Given the constraints, binary search is suitable for optimizing the search for k, as it allows us to efficiently narrow down the possible values of k by leveraging the sorted nature of attack times.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the best value of k that ensures Monocarp deals at least h damage to the dragon using the least resources.\n\n    'efficiently conquer the dragon'\n    Explanation: This implies achieving the goal of dealing at least h damage with minimal effort or resources, which is reflected in finding the minimum k.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The damage dealt must be greater than or equal to h. In code, this means checking if the calculated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This is implemented using binary search to efficiently find the smallest k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Implement a binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - Calculate the damage for a mid value of k.\n        - Adjust bounds based on whether the damage meets or exceeds h.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack and needing only 1 damage, k=1 is sufficient.\n\n    Test case with maximum h:\n    1 10^18\n    1\n    Expected output: 10^18\n    Explanation: With only one attack, k must be equal to h to deal the required damage.\n\n    Test case with attacks at consecutive times:\n    3 3\n    1 2 3\n    Expected output: 1\n    Explanation: Each attack can deal 1 damage per second, so k=1 is sufficient to deal 3 damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on calculated damage.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat the dragon efficiently. The solution should handle multiple test cases and ensure optimal timing of attacks.\nrequirement pool:\n- Calculate minimum poison impact for each test case.\n- Ensure attacks are timed optimally.\n- Handle large input values efficiently.\n- Provide accurate damage calculations.\n- Optimize resource usage.\nWe will use a binary search approach to efficiently determine the minimum value of k. The problem requires calculating the minimum poison impact needed to deal at least h damage to the dragon. By leveraging the sorted nature of attack times, we can simulate the damage dealt for a given k and adjust k using binary search to find the minimum value that satisfies the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that will ensure Monocarp deals at least h damage to the dragon efficiently.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources (in this case, the minimum k) to achieve the desired outcome.\n\n# [phrase showing quantity relationship]\n    'at least h damage': means the total damage dealt must be greater than or equal to h.\n    Implementation: Ensure the sum of damage dealt is >= h.\n\n# [degree adverb]\n    'minimum': means finding the smallest possible value of k that satisfies the condition.\n    Implementation: Use binary search to find the smallest k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Use binary search to find the minimum k:\n        - Initialize low and high bounds for k.\n        - Calculate the total damage for a given k.\n        - Adjust bounds based on whether the damage is sufficient.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack needed and one damage required, k=1 is sufficient.\n\n    Test case with maximum h:\n    1 10^18\n    1\n    Expected output: 10^18\n    Explanation: With only one attack time, k must be equal to h to deal enough damage.\n\n    Test case with consecutive attack times:\n    3 6\n    1 2 3\n    Expected output: 2\n    Explanation: Damage is dealt in seconds [1, 2, 3, 4, 5], which totals to at least 6 with k=2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on damage calculations.\n", "requirement analysis:\nThe main requirement is to determine the minimum value of k such that the total damage dealt is at least h. This involves calculating the damage over time based on the attack timings and ensuring the solution is efficient for large values of h and multiple test cases.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k for given test cases.\n- Optimize the algorithm for handling large input sizes efficiently.\n- Provide clear output format as specified in the requirements.\n- Include user feedback on strategy effectiveness.\n- Ensure the game interface is user-friendly and intuitive.\nWe will use a binary search algorithm to efficiently determine the minimum value of k. The binary search will help us find the smallest k such that the total damage dealt is at least h. This approach is efficient and suitable for handling large input sizes, especially given the constraints on h and the number of test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the best way to use the poison to achieve the desired damage with minimal resources.\n\n    'efficiently conquer the dragon'\n    Explanation: The goal is to defeat the dragon using the least amount of effort or resources.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by ensuring the sum of damage is >= h.\n\n# [degree adverb]\n    'minimum value of the parameter k'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to find the smallest k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Use binary search to find the minimum k such that the total damage is at least h.\n        - Initialize low and high bounds for k.\n        - Calculate the damage for a given k and check if it meets or exceeds h.\n        - Adjust the bounds based on whether the current k is sufficient or not.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values: \n    1 1\n    1\n    Expected output: 1\n    Explanation: With only one attack needed and one damage required, k=1 is sufficient.\n\n    Test case with maximum h:\n    1 10^18\n    1\n    Expected output: 10^18\n    Explanation: With only one attack time, k must be equal to h to deal enough damage.\n\n    Test case with attacks spaced far apart:\n    2 10\n    1 1000000000\n    Expected output: 10\n    Explanation: The attacks are spaced far apart, requiring k to be equal to h to deal enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k until the condition is met.\n", "requirement analysis:\nThe task requires calculating the minimum value of k such that the total damage dealt is at least h. The input consists of multiple test cases, each with a sequence of attack times. The solution must efficiently handle up to 1000 test cases and large values of h.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum k.\n- Ensure the solution handles up to 1000 test cases.\n- Optimize for large values of h up to 10^18.\n- Provide clear input-output format.\n- Include detailed comments and documentation.\nWe will implement a binary search algorithm to efficiently find the minimum value of k. This approach is suitable given the constraints, as it allows us to handle large values of h and multiple test cases efficiently. We will use Python's built-in capabilities without additional frameworks, ensuring simplicity and performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the most efficient way to deal the required damage to the dragon using the minimum resources, specifically the parameter k.\n\n    'efficiently'\n    Explanation: This indicates the need for a solution that minimizes computational resources and time, suggesting the use of efficient algorithms like binary search.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to find the lowest k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n and h, and then read the attack times.\n    3. Implement a binary search to find the minimum k:\n        - Set initial bounds for k (e.g., 1 to h).\n        - Calculate the damage for a given k and check if it meets or exceeds h.\n        - Adjust bounds based on whether the current k is sufficient or not.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values: \n    Input: 1 1\n           1\n    Output: 1\n    Explanation: With only one attack needed and one damage required, k must be at least 1.\n\n    Test case with maximum h:\n    Input: 1 1000000000000000000\n           1\n    Output: 1000000000000000000\n    Explanation: With only one attack time, k must be equal to h to deal the required damage.\n\n    Test case with attacks spaced far apart:\n    Input: 2 10\n           1 1000000000\n    Output: 5\n    Explanation: The attacks are spaced far apart, requiring a larger k to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe requirements focus on calculating the minimum poison impact needed to defeat a dragon efficiently across multiple test cases. The solution must handle large values of damage and provide accurate results while optimizing resource usage.\nrequirement pool:\n- Efficient calculation of minimum poison impact\n- Support for multiple test cases\n- Handle large values of damage efficiently\n- Optimize resource usage\n- Provide user-friendly interface\nWe will use a binary search algorithm to efficiently determine the minimum value of the parameter k. The binary search will be applied on the possible values of k, and for each candidate k, we will simulate the damage dealt to the dragon to check if it meets or exceeds the required damage h. This approach is efficient and suitable for handling large values of h and multiple test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the most efficient way to deal the required damage to the dragon using Monocarp's attacks.\n\n    'efficiently'\n    Explanation: This implies that the solution should minimize resource usage, in this case, the parameter k, to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage meets or exceeds h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the smallest possible value of k that allows Monocarp to deal at least h damage. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read n, h, and the list of attack times.\n    3. Use binary search to find the minimum k:\n        - Set initial bounds for k (e.g., 1 to max possible value).\n        - For each candidate k, simulate the damage dealt:\n            - Calculate the total damage using the attack times and k.\n            - Check if the total damage is at least h.\n        - Adjust bounds based on whether the current k meets the requirement.\n    4. Output the minimum k for each test case.\n\n# [edge case]\n    Test case with minimum values: \n    Input: 1 1\n           1\n    Output: 1\n    Explanation: With only one attack and minimum damage required, k must be at least 1.\n\n    Test case with maximum h:\n    Input: 1 10^18\n           1\n    Output: 10^18\n    Explanation: With only one attack, k must be equal to h to meet the damage requirement.\n\n    Test case with attacks spaced far apart:\n    Input: 2 10\n           1 1000000000\n    Output: 5\n    Explanation: The attacks are spaced far apart, requiring a larger k to accumulate enough damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the damage calculation.\n", "requirement analysis:\nThe main requirement is to determine the minimum value of k such that the total damage dealt is at least h. This involves calculating the damage over time based on the attack timings and ensuring the solution is efficient enough to handle the upper limits of input constraints.\nrequirement pool:\n- Implement the algorithm to calculate minimum k for given test cases.\n- Optimize the algorithm for handling large values of h efficiently.\n- Ensure the solution handles up to 1000 test cases in a single run.\n- Provide clear input and output instructions for users.\n- Include detailed comments and documentation in the code.\nWe will implement a binary search algorithm to efficiently find the minimum value of k that ensures the total damage dealt is at least h. This approach is optimal for handling large values of h and multiple test cases, as it reduces the complexity of the problem significantly. We will use Python's built-in capabilities to handle large integers and ensure the solution is efficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the most efficient way to deal damage to the dragon, ensuring that the minimum resources (in this case, the parameter k) are used to achieve at least the required damage h.\n\n    'binary search'\n    Explanation: A search algorithm that efficiently finds the target value by repeatedly dividing the search interval in half. It is used here to find the minimum k.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage dealt must be greater than or equal to h. In code, this can be implemented using a condition like `total_damage >= h`.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition. In code, this is achieved by using binary search to minimize k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Initialize binary search bounds for k (e.g., low = 1, high = h).\n   - Perform binary search:\n     - Calculate mid as the average of low and high.\n     - Simulate the damage dealt with k = mid.\n     - If total damage is at least h, adjust high to mid.\n     - Otherwise, adjust low to mid + 1.\n   - After binary search, low will be the minimum k that satisfies the condition.\n3. Output the result for each test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, a = [1] => Expected output: 1\n    Explanation: With only one attack needed and h = 1, k must be at least 1 to deal the required damage.\n\n    Case 2: n = 100, h = 10^18, a = [1, 2, ..., 100] => Expected output: A large number close to h/n\n    Explanation: With maximum n and h, k needs to be large enough to ensure total damage is at least h.\n\n    Case 3: n = 2, h = 10, a = [1, 1000000000] => Expected output: 5\n    Explanation: The large gap between attacks means k must be large enough to cover this gap and still deal at least h damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n", "requirement analysis:\nThe main requirement is to determine the minimum value of k such that the total damage dealt is at least h. This involves calculating the damage over time based on the attack timings and ensuring the solution is efficient enough to handle the upper limits of input constraints.\nrequirement pool:\n- Implement the algorithm to calculate the minimum k for each test case.\n- Optimize the algorithm for performance with large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output for each test case.\n- Include comprehensive test cases to validate the solution.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The binary search will be applied on the possible values of k, and for each k, we will calculate the total damage dealt using the given attack times. This approach ensures that we handle large input sizes efficiently, as binary search reduces the time complexity significantly compared to a linear search.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that allows Monocarp to deal at least h damage to the dragon.\n\n    'resources sparingly'\n    Explanation: This implies using the least amount of resources, which in this context means finding the smallest k.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented as a condition where the calculated damage is checked against h.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This indicates that we need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. In code, this is typically achieved using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the attack times into a list.\n   - Use binary search to find the minimum k:\n     - Set low = 1 and high = a_n (last attack time).\n     - While low < high:\n       - Calculate mid = (low + high) // 2.\n       - Calculate total damage for k = mid:\n         - Initialize damage = 0.\n         - For each attack time except the last, add min(mid, next_attack_time - current_attack_time) to damage.\n         - Add mid for the last attack time.\n       - If damage >= h, set high = mid.\n       - Else, set low = mid + 1.\n   - Output low as the minimum k for this test case.\n\n# [edge case]\n    Case 1: n = 1, h = 1, attack times = [1]\n    Expected output: 1\n    Explanation: With only one attack and h = 1, k must be at least 1 to deal the required damage.\n\n    Case 2: n = 2, h = 10^18, attack times = [1, 10^9]\n    Expected output: 10^18\n    Explanation: The damage required is extremely high, so k must be at least h since there are only two attacks.\n\n    Case 3: n = 100, h = 1, attack times = [1, 2, ..., 100]\n    Expected output: 1\n    Explanation: The minimum k is 1 because even with the smallest k, the total damage will exceed h due to multiple attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting the range of k based on the calculated damage.\n", "requirement analysis:\nThe requirement is to determine the minimum value of parameter k such that Monocarp's attacks cause at least h damage to the dragon. The solution must handle up to 1000 test cases efficiently, with each test case involving up to 100 attacks and a damage requirement as high as 10^18. The attacks are performed at increasing time intervals, and the solution should calculate the optimal k to meet the damage requirement.\nrequirement pool:\n- Implement the algorithm to calculate minimum k for each test case.\n- Ensure the solution handles large input sizes efficiently.\n- Provide clear output format as specified in the requirements.\n- Optimize the code for performance on various devices.\n- Include user feedback on strategy efficiency.\nWe will use a binary search algorithm to efficiently determine the minimum value of k for each test case. This approach is suitable given the constraints, as it allows us to handle large input sizes and high damage requirements efficiently. The binary search will help us find the smallest k such that the cumulative damage meets or exceeds the required damage h.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that allows Monocarp to deal at least h damage to the dragon using the least amount of resources.\n\n    'test cases'\n    Explanation: The problem involves multiple scenarios (test cases) where the solution must be applied independently.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the cumulative damage is >= h.\n\n# [degree adverb]\n    'minimum value'\n    Explanation: We need to find the smallest possible value of k that satisfies the condition. This can be implemented using a binary search to efficiently find the minimum k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Use binary search to find the minimum k:\n     - Initialize low and high bounds for k.\n     - While low < high:\n       - Calculate mid as the average of low and high.\n       - Calculate the total damage for k = mid.\n       - If total damage >= h, set high = mid.\n       - Otherwise, set low = mid + 1.\n   - Output the value of low as the minimum k for that test case.\n\n# [edge case]\n    Test case 1: (1, 1, [1]) = 1\n    Explanation: With only one attack needed and one second, k=1 is sufficient to deal the required damage.\n\n    Test case 2: (2, 10, [1, 1000000000]) = 10\n    Explanation: The attacks are far apart, so k must be at least 10 to ensure enough damage is dealt.\n\n    Test case 3: (3, 3, [1, 2, 3]) = 1\n    Explanation: With attacks every second and only 3 damage needed, k=1 is sufficient.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the cumulative damage calculation.\n", "requirement analysis:\nThe problem requires calculating the minimum value of k such that Monocarp's attacks cause at least h damage to the dragon. The solution must efficiently handle up to 1000 test cases with large values for h, ensuring scalability and performance.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Verify the solution with multiple test cases\n- Ensure the output format matches the requirements\nWe will use a binary search approach to efficiently determine the minimum value of k. The key observation is that the damage dealt by Monocarp's attacks can be calculated by considering the intervals between attacks and the value of k. By using binary search on k, we can find the smallest k that results in at least h damage. This approach ensures that we handle large inputs and multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that will ensure Monocarp deals at least h damage to the dragon.\n\n    'efficiently conquer'\n    Explanation: This implies using the least amount of resources, in this case, the smallest k, to achieve the desired damage.\n\n# [phrase showing quantity relationship]\n    'at least h damage': This means the total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the calculated damage is >= h.\n\n# [degree adverb] \n    'minimum': This indicates that we need to find the smallest possible value of k that satisfies the condition of dealing at least h damage. In code, this is typically achieved using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Use binary search to find the minimum k:\n     - Initialize low and high bounds for k.\n     - While low < high:\n       - Calculate mid as the average of low and high.\n       - Calculate total damage using mid as k.\n       - If total damage is at least h, set high = mid.\n       - Otherwise, set low = mid + 1.\n   - Output the value of low as the minimum k for that test case.\n\n# [edge case] \n    1. n = 1, h = 1, a = [1] = 1\n    Explanation: With only one attack needed and h = 1, k must be at least 1 to deal the required damage.\n    \n    2. n = 100, h = 10^18, a = [1, 2, ..., 100] = 10^18\n    Explanation: The maximum possible h requires careful calculation to ensure k is large enough to cover all intervals.\n    \n    3. n = 2, h = 10^9, a = [1, 10^9] = 10^9\n    Explanation: With a large gap between attacks, k must be large enough to cover this gap and deal sufficient damage.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the calculated damage relative to h.\n", "requirement analysis:\nThe requirement focuses on calculating the minimum parameter k to ensure Monocarp's attacks deal at least h damage to the dragon. The solution must efficiently handle multiple test cases and adhere to the input-output format.\nrequirement pool:\n- Calculate minimum k for each test case\n- Ensure damage dealt is at least h\n- Optimize attack timing\n- Handle large input values efficiently\n- Provide clear output format\nWe will use a binary search approach to efficiently determine the minimum value of k for each test case. The binary search will help us find the smallest k such that the total damage is at least h. This approach is efficient and suitable for handling the large input constraints provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'optimal poison impact'\n    Explanation: This refers to finding the minimum value of k that ensures the total damage dealt is at least h, using the least resources.\n\n    'efficiently conquer the dragon'\n    Explanation: This implies achieving the required damage with minimal k, ensuring resource efficiency.\n\n# [phrase showing quantity relationship]\n    'at least h damage'\n    Explanation: The total damage dealt must be greater than or equal to h. In code, this can be implemented by checking if the accumulated damage is >= h.\n\n# [degree adverb] \n    'minimum value of the parameter k'\n    Explanation: We need to find the smallest possible k that satisfies the condition of dealing at least h damage. This can be implemented using a binary search to efficiently find the smallest k.\n\n# [code logic]\n1. Parse the number of test cases, t.\n2. For each test case:\n   - Read n and h.\n   - Read the list of attack times.\n   - Use binary search to find the minimum k:\n     - Set low = 1 and high = h (or a large enough value).\n     - While low < high:\n       - Calculate mid = (low + high) // 2.\n       - Calculate total damage with current mid as k.\n       - If total damage >= h, set high = mid.\n       - Else, set low = mid + 1.\n   - Output the value of low as the minimum k.\n\n# [edge case] \n    Edge Case 1: n = 1, h = 1, a = [1]\n    Expected Output: 1\n    Explanation: With only one attack needed and h = 1, k must be at least 1 to deal the required damage.\n\n    Edge Case 2: n = 100, h = 1, a = [1, 2, ..., 100]\n    Expected Output: 1\n    Explanation: Even with multiple attacks, since h = 1, k can be as small as 1 to meet the requirement.\n\n    Edge Case 3: n = 2, h = 10^18, a = [1, 10^9]\n    Expected Output: A large value close to h\n    Explanation: With a large h and sparse attack times, k needs to be large enough to cover the gap between attacks.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The binary search logic inherently handles these scenarios by adjusting k based on the total damage calculation.\n"], "scores": [], "pass_results": [true, true, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 421, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "expand_one2two", "parent_index": 274}
