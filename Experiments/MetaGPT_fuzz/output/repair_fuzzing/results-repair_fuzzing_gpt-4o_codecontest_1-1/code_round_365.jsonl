{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, consider n = 4. The number 17 is special. It can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, consider n = 4. The number 17 is special. It can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. A positive number is considered special under these conditions. For example, consider n = 4. The number 17 is special. It can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, consider n = 4, the number 17 is special as it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing n and k for each test case.\n\n    Returns:\n        List[int]: List of k-th special numbers modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % n != 0:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= n\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed as a sum\n    of different non-negative powers of a given integer n. The k-th special number\n    is the k-th number in the sequence of special numbers when sorted in increasing order.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k >>= 1\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    \n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % n != 0:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= n\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % n != 0:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= n\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = calculate_kth_special_number(n, k)\n        results.append(special_number)\n    return results\n\ndef calculate_kth_special_number(n: int, k: int) -> int:\n    \"\"\"Calculate the k-th special number for a given n.\n\n    Args:\n        n: The base integer for generating special numbers.\n        k: The position in the sequence of special numbers.\n\n    Returns:\n        The k-th special number modulo 10^9+7.\n    \"\"\"\n    special_number = 0\n    power = 1\n    while k > 0:\n        if k % 2 == 1:\n            special_number = (special_number + power) % MODULO\n        power = (power * n) % MODULO\n        k //= 2\n    return special_number\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    num_test_cases = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(num_test_cases)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % n != 0:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= n\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        test_cases.append((n, k))\n    \n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_numbers = generate_special_numbers(n, k)\n        results.append(special_numbers[k-1] % MOD)\n    return results\n\ndef generate_special_numbers(n: int, k: int) -> List[int]:\n    \"\"\"Generate special numbers up to the k-th one for a given n.\n\n    Args:\n        n: The base integer for generating special numbers.\n        k: The number of special numbers to generate.\n\n    Returns:\n        A list of special numbers sorted in increasing order.\n    \"\"\"\n    special_numbers = []\n    limit = 1 << k  # This is 2^k, which is a safe upper bound for the number of combinations\n    for i in range(limit):\n        special_number = 0\n        power = 0\n        while i > 0:\n            if i & 1:\n                special_number += n**power\n            i >>= 1\n            power += 1\n        special_numbers.append(special_number)\n    special_numbers.sort()\n    return special_numbers\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of a given integer n.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers where each integer is the k-th special number\n        modulo 10^9+7 for the corresponding test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        # Calculate the k-th special number using binary representation\n        special_number = 0\n        power = 0\n        while k > 0:\n            if k & 1:\n                special_number += pow(n, power, MOD)\n                special_number %= MOD\n            k >>= 1\n            power += 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds the k-th special number for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k & 1:\n                special_number = (special_number + power) % MODULO\n            power = (power * n) % MODULO\n            k >>= 1\n        results.append(special_number)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    test_cases = [tuple(map(int, input().strip().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe task requires computing the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently. The result should be computed modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient algorithm to compute k-th special number.\n- Handle large input values for n and k.\n- Implement modular arithmetic to manage large outputs.\n- Optimize for multiple test cases in a single run.\n- Provide clear and concise output format.\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and handles large values of n and k effectively. We will also use modular arithmetic to ensure the results are within the specified modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers is sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Convert k to its base-n representation. This representation will help determine which powers of n are included in the k-th special number.\n3. Calculate the k-th special number by summing the powers of n indicated by the base-n representation of k.\n4. Apply modulo 10^9+7 to the result to ensure it fits within the required range.\n5. Output the result for each test case.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: Even for very large n, the first special number is still 1.\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: A large number modulo 10^9+7\n    Explanation: This tests the upper limit of k and ensures that the calculation handles large numbers correctly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to its base-n representation and summing the corresponding powers of n inherently handles these cases.\n", "requirement analysis:\nThe problem requires calculating the k-th special number for given n and k, where a special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases efficiently, with n and k as large as 10^9. The output should be the k-th special number modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input sizes for n and k\n- Optimize for performance and memory usage\n- Ensure correct output format\n- Provide detailed error messages for invalid inputs\nWe will use a mathematical approach to generate the k-th special number by representing it as a sum of distinct powers of n. The key insight is to treat k as a binary number and use its bits to determine which powers of n to sum. This approach is efficient and can handle large values of n and k. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure performance and correctness.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Convert k to its binary representation.\n3. For each bit in the binary representation of k, if the bit is set (i.e., it is 1), add the corresponding power of n to the sum.\n4. Calculate the sum modulo 10^9+7 to handle large numbers.\n5. Output the result for each test case.\n\n# [edge case]\n    Test case: (n=2, k=1) = 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Test case: (n=2, k=2) = 2\n    Explanation: The second special number for n=2 is 2^1 = 2.\n\n    Test case: (n=3, k=1) = 1\n    Explanation: The first special number for n=3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to binary and summing the corresponding powers of n inherently handles these cases.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n and k values across multiple test cases. The solution must efficiently handle large values of n and k, ensuring results are computed modulo 10^9+7. The algorithm should be optimized for performance and scalability, given the constraints.\nrequirement pool:\n- Efficient computation of special numbers\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Ensure correct input/output format\n- Optimize for performance and scalability\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and scales well with large values of n and k. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, etc.).\n\n# [degree adverb] \n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Convert k to its base-n representation. This representation will help identify which powers of n are included in the k-th special number.\n3. Calculate the k-th special number by summing the powers of n indicated by the base-n representation of k.\n4. Return the result modulo 10^9+7 to handle large numbers.\n\n# [edge case] \n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: A large number modulo 10^9+7\n    Explanation: This tests the ability to handle large values of k and ensure the result is computed modulo 10^9+7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to its base-n representation and summing the corresponding powers of n inherently handles these cases.\n", "requirement analysis:\nThe task requires computing the k-th special number for given n and k values. A special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are output modulo 10^9+7.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Output results modulo 10^9+7\n- Support multiple test cases\n- Optimize for minimal computational overhead\nWe will use a mathematical approach to determine the k-th special number by representing k in base n. Each digit in this base-n representation corresponds to a power of n that contributes to the sum. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and modular arithmetic to ensure results are computed modulo 10^9+7.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n.\n\n    'k-th special number'\n    Explanation: This refers to finding the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is non-negative (including zero). In code, this can be implemented by iterating over powers of n and checking combinations that sum up to the desired number.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This affects how we generate and store these numbers, ensuring they are ordered correctly.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Convert k into its base-n representation.\n    3. Calculate the sum of n raised to the power of each digit in the base-n representation.\n    4. Return the result modulo 10^9+7.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: The second special number for n=2 is 2 (2^1).\n\n    Input: 3 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by correctly computing the base-n representation and summing the powers.\n", "requirement analysis:\nThe problem requires calculating the k-th special number for given n and k values. A special number is defined as a sum of distinct powers of n. The solution must handle up to 10^4 test cases and large values of n and k efficiently, ensuring results are computed modulo 10^9+7.\nrequirement pool:\n- Implement an efficient algorithm to compute the k-th special number.\n- Ensure the solution can handle the maximum constraints of n and k.\n- Optimize the solution for performance to handle up to 10^4 test cases.\n- Validate the output format to match the specified requirements.\n- Consider edge cases and test thoroughly.\nWe will use a mathematical approach to generate special numbers by considering the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will use Python's built-in capabilities to handle large integers and modular arithmetic efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Use a loop to generate special numbers by considering the binary representation of numbers. Each bit in the binary representation corresponds to whether a particular power of n is included in the sum.\n3. Calculate the k-th special number by iterating through possible combinations of powers of n.\n4. Use modular arithmetic to ensure the result is within the range specified (modulo 10^9+7).\n5. Output the k-th special number for each test case.\n\n# [edge case]\n    Test case: (n=2, k=1) = 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Test case: (n=3, k=2) = 3\n    Explanation: The second special number for n=3 is 3^1 = 3.\n\n    Test case: (n=10, k=1) = 1\n    Explanation: The first special number for n=10 is 10^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of generating special numbers using binary representation inherently handles these cases by considering all possible combinations of powers of n.\n", "requirement analysis:\nThe task requires computing the k-th special number for given n and k values. A special number is defined as a sum of distinct powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently. The result should be output modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient algorithm to compute k-th special number.\n- Handle large input values for n and k.\n- Output results modulo 10^9+7.\n- Optimize for performance with multiple test cases.\n- Ensure code readability and maintainability.\nWe will use a mathematical approach to determine the k-th special number. A special number can be represented as a sum of distinct powers of n. To find the k-th special number, we can convert k into a binary representation and use the positions of the '1's in the binary form to determine which powers of n to sum. This approach is efficient and works well within the constraints. We will use Python's built-in capabilities to handle large integers and perform modulo operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Convert k into its binary representation.\n3. Initialize a variable to store the k-th special number.\n4. Iterate over each bit in the binary representation of k:\n   - If the bit is set (i.e., it is '1'), add the corresponding power of n to the special number.\n5. Compute the result modulo 10^9+7 to handle large numbers.\n6. Output the result for each test case.\n\n# [edge case]\n    Test case: n = 2, k = 1\n    Expected output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Test case: n = 2, k = 2\n    Expected output: 2\n    Explanation: The second special number for n = 2 is 2^1 = 2.\n\n    Test case: n = 3, k = 1\n    Expected output: 1\n    Explanation: The first special number for n = 3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of converting k into binary and summing the corresponding powers of n inherently handles these cases.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently. The result should be output modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient algorithm to compute k-th special number\n- Handle large input values for n and k\n- Implement modulo operation to manage large outputs\n- Optimize for performance with multiple test cases\n- Ensure code readability and maintainability\nWe will use a binary representation approach to determine the k-th special number. Each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in base-n. By converting k to its base-n representation, we can directly determine the k-th special number. This approach is efficient and handles large values of n and k effectively. We will use Python's built-in capabilities for handling large integers and perform modulo operations to ensure the results fit within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, if n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n    - Convert k to its base-n representation.\n    - Each digit in the base-n representation corresponds to a power of n that contributes to the special number.\n    - Calculate the sum of these powers to determine the k-th special number.\n    - Use modulo 10^9+7 to ensure the result fits within the constraints.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: The second special number for n=2 is 2, as it corresponds to n^1.\n\n    Input: 3 1\n    Expected Output: 1\n    Explanation: The first special number for n=3 is also 1, as it corresponds to n^0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k to its base-n representation inherently handles these cases by correctly calculating the sum of powers.\n", "requirement analysis:\nThe requirement is to compute the k-th special number for given n efficiently, ensuring the result is modulo 10^9+7. The solution must handle up to 10^4 test cases and large values of n and k, requiring an algorithm that can compute powers and combinations efficiently.\nrequirement pool:\n- Implement efficient algorithm to compute special numbers.\n- Ensure results are modulo 10^9+7.\n- Optimize for large values of n and k.\n- Handle up to 10^4 test cases efficiently.\n- Provide clear and accurate output format.\nWe will use a combination of bit manipulation and mathematical properties to efficiently compute the k-th special number. The key insight is that each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will leverage this property to generate the sequence of special numbers and find the k-th one. Python's built-in functions and libraries will be used to handle large integers and modular arithmetic efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n.\n\n    'modulo 10^9+7'\n    Explanation: This is a common modulus used in competitive programming to ensure numbers do not become too large. It requires the output to be the remainder when the k-th special number is divided by 10^9+7.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (including zero). In code, this can be implemented by iterating over possible powers and checking combinations.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers must be sorted from smallest to largest. This affects how we generate and store these numbers.\n\n# [code logic]\n    - Parse the number of test cases.\n    - For each test case, read n and k.\n    - Generate special numbers using combinations of powers of n.\n    - Sort these numbers in increasing order.\n    - Retrieve the k-th special number.\n    - Return the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The smallest special number for any n is always 1 (n^0).\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: For n=2, the sequence starts as [1, 2, 3, ...]. The second special number is 2.\n\n    Input: 3 1\n    Expected Output: 1\n    Explanation: The smallest special number for n=3 is also 1 (3^0).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for generating and sorting special numbers inherently handles these cases.\n", "requirement analysis:\nThe task requires finding the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently. The result should be output modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Implement an efficient algorithm to compute the k-th special number.\n- Ensure the solution can handle the maximum constraints for n and k.\n- Optimize the solution to run within acceptable time limits for all test cases.\n- Validate the output format to match the specified requirements.\n- Consider edge cases and test thoroughly.\nWe will use a mathematical approach to generate special numbers by considering the binary representation of numbers. Each special number can be represented as a sum of distinct powers of n, which corresponds to the binary representation of numbers. We will use Python's built-in capabilities to handle large integers and perform modulo operations efficiently. The itertools library can be used to generate combinations if needed, but for this problem, a direct calculation using powers of n will be more efficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is a non-negative integer. In code, this can be implemented by iterating over possible powers and checking combinations.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that the k-th special number is the k-th smallest in this sorted sequence.\n\n# [code logic]\n1. Parse the input to get the number of test cases, and for each test case, retrieve n and k.\n2. For each test case, generate special numbers using powers of n.\n3. Use binary representation to determine which powers of n to sum for each special number.\n4. Sort the generated special numbers in increasing order.\n5. Retrieve the k-th special number from the sorted list.\n6. Return the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Test case with smallest values: (n=2, k=1) = 1\n    Explanation: The smallest special number for n=2 is 2^0 = 1.\n\n    Test case with large n and small k: (n=10^9, k=1) = 1\n    Explanation: Regardless of how large n is, the smallest special number is always 1 (n^0).\n\n    Test case with large k: (n=2, k=10^9) = <expected output>\n    Explanation: This tests the efficiency and correctness of generating large sequences and handling modulo operations.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large values of n and k.\n```python\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n, k):\n    special_numbers = []\n    i = 0\n    while len(special_numbers) < k:\n        num = 0\n        power = 0\n        while (1 << power) <= i:\n            if i & (1 << power):\n                num += n**power\n            power += 1\n        special_numbers.append(num)\n        i += 1\n    special_numbers.sort()\n    return special_numbers[k-1] % MOD\n\ndef process_test_cases(test_cases):\n    results = []\n    for n, k in test_cases:\n        results.append(find_kth_special_number(n, k))\n    return results\n\n# Example usage:\ntest_cases = [(3, 4), (2, 12), (105, 564)]\nprint(process_test_cases(test_cases))\n```\nThis code efficiently handles large values by using binary representation to generate combinations of powers and ensures results are within the modulo constraint.\n", "requirement analysis:\nThe task requires computing the k-th special number for given n, where a special number is defined as a sum of distinct powers of n. The solution must handle large values of n and k efficiently, and results should be provided modulo 10^9+7 to manage large outputs.\nrequirement pool:\n- Efficient algorithm to compute special numbers.\n- Handle large input values for n and k.\n- Implement modular arithmetic to manage large outputs.\n- Optimize for performance and scalability.\n- Provide clear and concise output format.\nWe will use a mathematical approach to generate special numbers by considering the binary representation of k. Each bit in the binary representation corresponds to a power of n, which will be summed to form the special number. This approach efficiently handles large values of n and k by leveraging bit manipulation and modular arithmetic using Python's built-in capabilities.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over the binary representation of k and using each bit to determine whether to include a corresponding power of n in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers must be sorted from smallest to largest. This ensures that when we find the k-th special number, it is the k-th smallest in the sequence.\n\n# [code logic]\n    1. Read the number of test cases, t.\n    2. For each test case, read n and k.\n    3. Convert k to its binary representation.\n    4. Initialize a variable to store the special number.\n    5. Iterate over each bit in the binary representation of k:\n        - If the bit is set (1), add n raised to the power of the bit's position to the special number.\n    6. Take the result modulo 10^9+7.\n    7. Output the result for each test case.\n\n# [edge case]\n    Input: 1 2\n    Output: 1\n    Explanation: For n = 1, the sequence is [1, 2, 3, ...]. The 2nd special number is 2.\n\n    Input: 2 1\n    Output: 1\n    Explanation: For n = 2, the sequence starts with [1, 2, ...]. The 1st special number is 1.\n\n    Input: 10^9 1\n    Output: 1\n    Explanation: For n = 10^9, the sequence starts with [1, ...]. The 1st special number is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases by considering the binary representation of k and using modular arithmetic.\n"], "scores": [], "pass_results": [false, true, false, true, true, false, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 365, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "expand_one2two", "parent_index": 66}
