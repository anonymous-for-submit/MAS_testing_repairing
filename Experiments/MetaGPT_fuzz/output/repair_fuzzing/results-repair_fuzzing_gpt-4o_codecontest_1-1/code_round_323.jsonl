{"name": "1613_E. Crazy Robot", "description": "There is a grid, consisting of n rows and m columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "tags": ["dfs and similar", "graphs"], "difficulty": 11, "id": 1613, "sample_io": [{"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n"]}], "test_list": [{"input": "1\n3 31\n############################..#\n.............................L.\n############################..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n3 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n############################..#\n", "output": ["#++############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n#..######################\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n#..######################\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n#++######################\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "1\n3 25\n##..#####################\n.......................L.\n#..######################\n", "output": ["##..#####################\n....+++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 31\n#############################..\n...........L...................\n############################..#\n", "output": ["#############################..\n+++++++++++L++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n#++######################\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#..###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#..############################\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n#++############################\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n############################..#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n######################..#\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n######################..#\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n#..######$####\"#$########\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n3 31\n..#############################\n.L.............................\n############################..#\n", "output": ["++#############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n##########\"######\"##########./#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n############################..#\n", "output": ["#############################..\n+++++++++++++++++++L++++++++...\n############################..#\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#.##.##########################\n", "output": ["#++############################\n+L++...........................\n#+##.##########################\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"#################..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"########..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.......................L.\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n.......................L+\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n################.############.#\n", "output": ["#++############################\n+L++++++++++++++...............\n################.############.#\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n..#..\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n..#..\n.....\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#..############################\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 25\n##.#####.################\n.L.......................\n#..######$####\"#$########\n", "output": ["##.#####.################\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#.##.##########################\n", "output": ["#..############################\n.....++++++++++++++++++++++++L+\n#.##.##########################\n"]}, {"input": "1\n2 25\n######################..#\n......................L..\n#..###$##################\n", "output": ["######################++#\n++++++++++++++++++++++L++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n++++L++#.\n"]}, {"input": "1\n2 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n"]}, {"input": "1\n2 25\n########.#############.##\n.L.......................\n#..###$###########$######\n", "output": ["########.#############.##\n+L++++++.................\n"]}, {"input": "1\n2 25\n###########.##########.##\n.L.......................\n####\"#################..#\n", "output": ["###########.##########.##\n+L+++++++++..............\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n################.############.#\n", "output": ["#..############################\n.................++++++++++++L+\n################.############+#\n"]}, {"input": "1\n2 25\n##########.############.#\n......................L..\n#..###$##################\n", "output": ["##########.############.#\n...........+++++++++++L..\n"]}, {"input": "1\n2 31\n#..############################\n...............L...............\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++L+++++++++++++++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\nL.##.\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#....\nL.##.\n...#.\n.....\nL\n++++L++#.\n"]}, {"input": "1\n2 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n2 25\n#..######################\n....................L....\n#..######################\n", "output": ["#..######################\n...+++++++++++++++++L++++\n"]}, {"input": "1\n2 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n"]}, {"input": "1\n2 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n######################..#\n", "output": ["##..#####################\n+L.......................\n######################..#\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n#..############################\n", "output": ["#############################..\n...++++++++++++++++L+++++++++..\n#..############################\n"]}, {"input": "1\n2 25\n######.###############.##\n.......................L.\n#..###$##################\n", "output": ["######.###############.##\n.......................L+\n"]}, {"input": "1\n3 31\n############################..#\n.............................L.\n#..############################\n", "output": ["############################++#\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 31\n#..############################\n.L.............................\n#################\"##########-.#\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"##########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$##################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$###########$######\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$###########$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"##############$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"####\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##########\"###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$####$###\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$##$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#.#############.#########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$##################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############\"######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########$##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#######\"######$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n##################$###..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##################$###..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########./#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#$########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##############\"#######..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$#####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##$##$###########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############!######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$$#..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$#####$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n####\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n$#######$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###################$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#############\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"##########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########-.#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$########$##$######\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##$#\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n##########\"######\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"\"###\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######!###############..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$##################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-##########\"#################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######$##$########$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"##$######$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#########$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"###\"###$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#########\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n######\"######\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#####\"###\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$#####..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$######\"####$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#######\"#########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.#############.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########%##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#..##########\"######\"##########\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$$\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n##############\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#/.###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###################$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#./######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####$########\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n###$####$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########-.#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$##\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"..##$#########\"####\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"############\"####..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##%#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"##\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######\"#######\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$#####$##\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#$#######$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###\"\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"####$######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#########\"####$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$##\"..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$#$..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..$\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n.#################$####.#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n########$#\"####$######..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n\"###\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$######$###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"######\"##########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-######\"#####################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"###\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"#############$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#######$#########\"###\"\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########!##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.############$.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######$##%########$###..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$#$###..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$\"#\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$###$########\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"#$#\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n$..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$###\"\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}], "task_id": "codecontest/117", "prompt": "There exists a grid made up of n rows and m columns. Each grid cell is either free or obstructed. One of the free cells holds a laboratory. All cells outside the boundaries of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab. Note that the path to the lab may involve both moving towards and away from the lab due to the robot's erratic behavior.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "repair_prompt": ["There exists a grid made up of n rows and m columns. Each grid cell is either free or obstructed. One of the free cells holds a laboratory. All cells outside the boundaries of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab. Note that the path to the lab may involve both moving towards and away from the lab due to the robot's erratic behavior.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "There exists a grid made up of n rows and m columns. Each grid cell is either free or obstructed. One of the free cells holds a laboratory. All cells outside the boundaries of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction to move such that it differs from the one in command. The robot will ensure that the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab. Note that the path to the lab may involve both moving towards and away from the lab due to the robot's erratic behavior.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "There exists a grid made up of n rows and m columns, and each grid cell is either free or obstructed with one of the free cells holding a laboratory. All cells outside the boundaries of the grid are also blocked.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", with each command meaning moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command, choosing a direction that differs from the one in the command and is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction; otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell, meaning after each step of the robot a command can be sent such that no matter what different directions the robot chooses, it will end up in a lab. Note that the path to the lab may involve both moving towards and away from the lab due to the robot's erratic behavior.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determines which free cells can lead the robot to the lab in each test case grid.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable free cells marked with '+'.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for easier manipulation\n        grid = [list(row) for row in grid]\n\n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        # Directions for BFS: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Mark the cell as reachable\n                        grid[nx][ny] = '+'\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds all free cells that can lead the robot to the lab using BFS.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the grid dimensions and the grid itself.\n\n    Returns:\n        A list of grids with reachable free cells marked with '+'.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for easier manipulation\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Initialize BFS\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        \n        # Directions for BFS: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        grid[nx][ny] = '+'\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n    \n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output the results\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds free cells that can be forced to reach the lab in each test case grid.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: List of modified grids for each test case with reachable free cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for easier manipulation\n        grid = [list(row) for row in grid]\n\n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        # BFS to find all reachable free cells from the lab\n        queue = deque([lab_position])\n        reachable = set()\n        reachable.add(lab_position)\n\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in reachable:\n                    reachable.add((nx, ny))\n                    queue.append((nx, ny))\n\n        # Mark reachable free cells with '+'\n        for x, y in reachable:\n            if grid[x][y] == '.':\n                grid[x][y] = '+'\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function\nresults = find_reachable_cells(t, test_cases)\n\n# Output interface\nfor result in results:\n    for line in result:\n        print(line)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Finds free cells that can be forced to reach the lab in each test case grid.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of grids representing each test case.\n\n    Returns:\n        A list of modified grids where reachable free cells are marked with '+'.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        reachable = [[False] * m for _ in range(n)]\n        reachable[lab_position[0]][lab_position[1]] = True\n\n        # Directions for BFS: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and not reachable[nx][ny]:\n                    # Check if the cell can be forced to reach the lab\n                    free_directions = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] != '#':\n                            free_directions += 1\n\n                    # If the cell has only one free direction, it can be forced to reach the lab\n                    if free_directions <= 1:\n                        reachable[nx][ny] = True\n                        queue.append((nx, ny))\n\n        # Modify the grid based on reachable cells\n        modified_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if grid[i][j] == '.' and reachable[i][j]:\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            modified_grid.append(''.join(row))\n\n        results.append(modified_grid)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print the result\n    results = find_reachable_cells(t, test_cases)\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds free cells that can be forced to reach the lab in each test case grid.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - grid: A list of strings representing the grid.\n\n    Returns:\n        A list of modified grids with reachable free cells marked with '+'.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for easier manipulation\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Initialize BFS\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        \n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Mark as reachable\n                        grid[nx][ny] = '+'\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n        \n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Call the function and print the results\n    results = find_reachable_cells(t, test_cases)\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of test cases, each containing a grid represented as a list of strings.\n\n    Returns:\n        A list of modified grids where reachable free cells are marked with '+'.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        visited = [[False] * m for _ in range(n)]\n        visited[lab_position[0]][lab_position[1]] = True\n\n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # Perform BFS to mark reachable cells\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.':\n                    # Check if the cell can be forced to reach the lab\n                    free_directions = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] != '#':\n                            free_directions += 1\n\n                    # If only one free direction, it can be forced to the lab\n                    if free_directions <= 1:\n                        queue.append((nx, ny))\n                        visited[nx][ny] = True\n\n        # Prepare the result grid\n        result_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if grid[i][j] == '.' and visited[i][j]:\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            result_grid.append(''.join(row))\n\n        results.append(result_grid)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the grid dimensions and the grid itself.\n\n    Returns:\n        A list of grids with reachable free cells marked with '+'.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Performs BFS to mark reachable cells from the lab.\n\n        Args:\n            n: Number of rows in the grid.\n            m: Number of columns in the grid.\n            grid: The grid representation.\n\n        Returns:\n            The modified grid with reachable cells marked.\n        \"\"\"\n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS (up, down, left, right)\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        # Initialize BFS queue and visited set\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        \n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        grid[nx][ny] = '+'\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n\n        # Convert grid back to list of strings\n        return [''.join(row) for row in grid]\n\n    # Process each test case\n    result = []\n    for n, m, grid in test_cases:\n        modified_grid = bfs(n, m, grid)\n        result.append(modified_grid)\n\n    return result\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can lead the robot to the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable free cells marked.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        visited = [[False] * m for _ in range(n)]\n        visited[lab_position[0]][lab_position[1]] = True\n\n        # Directions for moving up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        # Perform BFS\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.':\n                    # Check if the cell is a free cell and not visited\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n\n        # Modify the grid based on reachable cells\n        modified_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if grid[i][j] == '.' and visited[i][j]:\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            modified_grid.append(''.join(row))\n\n        results.append(modified_grid)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = find_reachable_cells(t, test_cases)\n    for result in results:\n        for line in result:\n            print(line)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Finds free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of grids for each test case.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    def bfs(grid: List[str], n: int, m: int, lab_pos: Tuple[int, int]) -> List[List[str]]:\n        \"\"\"Performs BFS to find all reachable cells from the lab.\n\n        Args:\n            grid (List[str]): The grid representation.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            lab_pos (Tuple[int, int]): Position of the lab in the grid.\n\n        Returns:\n            List[List[str]]: Grid with reachable cells marked.\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        queue = deque([lab_pos])\n        visited = set([lab_pos])\n        reachable = [[False] * m for _ in range(n)]\n\n        while queue:\n            x, y = queue.popleft()\n            reachable[x][y] = True\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.':\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n\n        # Mark reachable cells with '+'\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '.' and reachable[i][j]:\n                    grid[i] = grid[i][:j] + '+' + grid[i][j+1:]\n\n        return grid\n\n    result = []\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_pos = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_pos = (i, j)\n                    break\n            if lab_pos:\n                break\n\n        # Perform BFS from the lab position\n        modified_grid = bfs(grid, n, m, lab_pos)\n        result.append(modified_grid)\n\n    return result\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Finds free cells that can be forced to reach the lab in each test case grid.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of grids for each test case.\n\n    Returns:\n        A list of modified grids where reachable free cells are marked with '+'.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        reachable = [[False] * m for _ in range(n)]\n        reachable[lab_position[0]][lab_position[1]] = True\n\n        # Directions for BFS: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and not reachable[nx][ny]:\n                    # Check if the cell can be forced to reach the lab\n                    free_directions = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] != '#':\n                            free_directions += 1\n\n                    if free_directions > 1:\n                        reachable[nx][ny] = True\n                        queue.append((nx, ny))\n\n        # Modify the grid based on reachable cells\n        modified_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if grid[i][j] == '.' and reachable[i][j]:\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            modified_grid.append(''.join(row))\n\n        results.append(modified_grid)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic movement behavior. The solution must efficiently handle large grids and multiple test cases, ensuring correct output format.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Optimize the solution for large grid sizes.\n- Ensure the output format matches the specified requirements.\n- Test the solution against edge cases and large inputs.\n- Document the solution approach and edge case handling.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. Starting from the lab, we will explore all reachable free cells and mark them accordingly. This approach efficiently handles large grids and ensures that all possible paths are considered.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed', 'lab', 'robot', 'command'\n    Explanation: \n    - 'grid': A matrix of cells with n rows and m columns.\n    - 'free cell': A cell in the grid that is not blocked and can be traversed.\n    - 'obstructed': A cell in the grid that is blocked and cannot be traversed.\n    - 'lab': A specific free cell in the grid where the robot needs to reach.\n    - 'robot': An entity that moves within the grid, starting from a free cell.\n    - 'command': Instructions given to the robot to move, which it will not follow directly.\n\n# [phrase showing quantity relationship]\n    No specific phrases showing quantity relationships are present in the requirement.\n\n# [degree adverb] \n    No degree adverbs are present in the requirement.\n\n# [code logic]\n1. Parse the input to read the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab ('L') in the grid.\n4. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells:\n   - Initialize a queue with the lab's position.\n   - Mark all visited cells that can reach the lab.\n   - For each cell, check all four possible directions (up, down, left, right).\n   - If a neighboring cell is free and not yet visited, add it to the queue.\n5. Replace all reachable free cells with '+'.\n6. Output the modified grid for each test case.\n\n# [edge case] \n    1. Test case with a single cell grid containing only the lab:\n       Input: 1 1 L\n       Output: L\n       Explanation: The grid is already at the lab, no movement needed.\n\n    2. Test case with all cells blocked except for the lab:\n       Input: 3 3\n              ###\n              #L#\n              ###\n       Output: ###\n               #L#\n               ###\n       Explanation: No free cells to reach the lab from.\n\n    3. Test case with a free path directly to the lab:\n       Input: 3 3\n              ...\n              .L.\n              ...\n       Output: ...\n               .L.\n               ...\n       Explanation: No free cells can be forced to reach the lab due to erratic behavior.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking only those cells that can reach the lab through valid paths.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed. The challenge lies in accounting for the robot's unpredictable movement and ensuring that all possible paths to the lab are considered.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells for the robot.\n- Ensure the solution handles the maximum constraints of grid size and test cases.\n- Optimize the algorithm to reduce time complexity.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will use a Breadth-First Search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it explores all possible paths from the lab to free cells, ensuring that we can find all reachable cells efficiently. We will start the BFS from the lab and mark all reachable free cells with a '+'. This approach ensures that we handle large grids within the constraints provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed', 'laboratory', 'crazy robot', 'command'\n    Explanation: The grid is a matrix of cells, each cell can be free ('.'), obstructed ('#'), or contain a laboratory ('L'). The robot is located in a free cell and can move in any direction except the one commanded, provided the cell is not obstructed. The goal is to determine which free cells can lead the robot to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb]\n    No explicit degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, locate the lab position in the grid.\n    3. Use Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n    4. Mark all free cells that can reach the lab with a '+'.\n    5. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, no free cells to mark.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells are available to reach the lab.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    Input: 3 3 ... .L. ...\n    Output: +++ +L+ +++\n    Explanation: All free cells can reach the lab directly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking reachable cells from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed. The algorithm should be optimized to minimize computational complexity while ensuring correctness.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells for the robot.\n- Ensure the solution handles the maximum input size within constraints.\n- Optimize the algorithm to reduce time complexity.\n- Provide clear and concise output for each test case.\n- Consider edge cases and test thoroughly.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab to determine which free cells can be forced to reach the lab. The BFS will propagate from the lab to all reachable free cells, marking them as reachable. This approach ensures that we efficiently explore all possible paths from the lab to free cells, considering the robot's erratic behavior. The BFS is chosen for its efficiency in exploring all possible paths in an unweighted grid.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, each cell can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab despite its erratic behavior.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb]\n    No explicit degree adverb\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Implement a Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n    4. For each free cell, determine if it can be forced to reach the lab by checking if it can be reached through BFS.\n    5. Mark reachable free cells with a '+'.\n    6. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, no free cells to mark.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells are available to reach the lab.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    Input: 3 3 ... .L. ...\n    Output: +++ +L+ +++\n    Explanation: All free cells can be forced to reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking reachable cells from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed. The algorithm should be optimized to minimize computational complexity while providing accurate results.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles the maximum input size within constraints.\n- Optimize the algorithm for speed and memory usage.\n- Provide clear documentation and comments in the code.\n- Include edge case testing in the test suite.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab cell to determine which free cells can reach the lab. The BFS will propagate through free cells, marking them as reachable if they can eventually lead to the lab. This approach ensures that we efficiently explore all possible paths from the lab to other free cells, taking into account the robot's erratic behavior.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed cell', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, each of which can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab despite its erratic behavior.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Implement a Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n    4. For each free cell, check if it can be forced to reach the lab by considering all possible moves the robot can make.\n    5. Mark the free cells that can reach the lab with a '+'.\n    6. Output the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist to mark.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells exist that can reach the lab.\n\n    Test case with a direct path from every free cell to the lab:\n    Input: 3 3 ... .L. ...\n    Output: +++ .L. +++\n    Explanation: All free cells can directly reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by exploring all possible paths from the lab to free cells.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab despite its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is clear and adheres to the requirements.\nrequirement pool:\n- Efficiently determine reachable cells for the robot.\n- Ensure the solution handles large grids and multiple test cases.\n- Provide clear output format as specified.\n- Optimize algorithm for better performance.\n- Consider edge cases and ensure robustness.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab to determine which free cells can reach the lab. The BFS will propagate through free cells, marking them as reachable if they can eventually lead to the lab. This approach efficiently handles large grids and multiple test cases by leveraging the properties of BFS to explore all possible paths from the lab.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid'\n    Explanation: A grid is a two-dimensional array of cells, each of which can be free, obstructed, or contain a lab.\n\n    'free cell'\n    Explanation: A cell in the grid that is not obstructed and can be moved into by the robot.\n\n    'obstructed cell'\n    Explanation: A cell in the grid that cannot be moved into by the robot.\n\n    'lab'\n    Explanation: A specific free cell in the grid that the robot needs to reach.\n\n    'crazy robot'\n    Explanation: A robot that moves in any direction except the one commanded, provided the chosen direction is not blocked.\n\n# [phrase showing quantity relationship]\n    'one of the following commands': This indicates that there are four possible commands to send to the robot, each corresponding to a direction (right, down, left, up).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to read the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab in the grid.\n4. Use a Breadth-First Search (BFS) starting from the lab to explore all reachable free cells:\n   - Initialize a queue with the lab's position.\n   - Mark the lab as visited.\n   - While the queue is not empty, dequeue a cell and check its neighbors.\n   - For each free neighbor, if it hasn't been visited, mark it as reachable and add it to the queue.\n5. After BFS completes, replace all reachable free cells with '+'.\n6. Print the modified grid for each test case.\n\n# [edge case]\n    1. A grid with only one cell which is a lab:\n       Input: 1 1 L\n       Output: L\n       Explanation: The grid contains only the lab, so no free cells to mark.\n\n    2. A grid where all cells are blocked except for the lab:\n       Input: 3 3\n              ###\n              #L#\n              ###\n       Output: ###\n               #L#\n               ###\n       Explanation: No free cells are available to reach the lab.\n\n    3. A grid where all cells are free:\n       Input: 2 2\n              ..\n              .L\n       Output: ++\n               +L\n       Explanation: All free cells can be forced to reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking only reachable free cells from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed. The algorithm should be optimized to minimize computational complexity while providing correct results for all possible scenarios.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles the maximum input size within time limits.\n- Optimize the algorithm for better performance.\n- Provide detailed documentation for the solution.\n- Include comprehensive test cases to cover edge scenarios.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab cell to determine which free cells can reach the lab. This approach is efficient for grid-based problems and ensures that we explore all possible paths from the lab to other free cells. The BFS will propagate from the lab, marking all reachable free cells with a '+'. This ensures that we only mark cells that can eventually lead the robot to the lab, considering its erratic behavior.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed cell', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, where each cell can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab despite its erratic behavior.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No explicit degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n    4. For each free cell, check if it can be forced to reach the lab by considering all possible moves the robot can make.\n    5. Mark the free cells that can reach the lab with a '+'.\n    6. Output the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist to mark.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: All cells are blocked except the lab, so no free cells exist to mark.\n\n    Test case with a grid where all free cells are isolated by blocked cells:\n    Input: 3 3 .#. #L# .#.\n    Output: .#. #L# .#.\n    Explanation: The free cells are isolated by blocked cells, so no free cells can reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by only marking reachable free cells from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and ensure correct output formatting.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Optimize the solution for performance given constraints.\n- Ensure the solution handles edge cases effectively.\n- Verify output format matches the requirements.\n- Document the solution for future reference.\nWe will use a Breadth-first Search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to free cells, ensuring that we can identify all reachable cells regardless of the robot's erratic behavior. We will start the BFS from the lab and mark all reachable free cells with a '+'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed', 'laboratory', 'crazy robot', 'commands'\n    Explanation: The grid is a matrix of cells, each of which can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and moves erratically, ignoring commands and choosing a different direction unless blocked. The goal is to determine which free cells can lead the robot to the lab.\n\n# [phrase showing quantity relationship]\n    'one of the following commands': indicates that there are four possible commands to move the robot.\n    'exactly one lab': means there is only one 'L' in the grid.\n    Implementation: These phrases guide the constraints and setup of the problem, ensuring that the BFS starts from the single lab and considers all possible movement commands.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to read the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab ('L') in the grid.\n4. Implement a BFS starting from the lab:\n   - Use a queue to explore each cell.\n   - For each cell, check all four possible movements (up, down, left, right).\n   - If moving in a direction leads to a free cell ('.'), mark it as reachable ('+') and add it to the queue.\n5. Continue until all reachable cells are marked.\n6. Output the modified grid for each test case.\n\n# [edge case]\n    1. A grid with all cells blocked except for the lab:\n       Input: \n       1\n       3 3\n       ###\n       #L#\n       ###\n       Output:\n       ###\n       #L#\n       ###\n       Explanation: No free cells are reachable from the lab.\n\n    2. A grid with a single row and multiple free cells leading to the lab:\n       Input:\n       1\n       1 5\n       ...L.\n       Output:\n       +++L+\n       Explanation: All free cells can lead to the lab.\n\n    3. A grid with multiple disconnected free areas:\n       Input:\n       1\n       4 4\n       .##.\n       .L#.\n       .##.\n       ....\n       Output:\n       .##.\n       +L#.\n       .##.\n       ....\n       Explanation: Only cells directly connected to the lab can be marked as reachable.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles different grid configurations by exploring all possible paths from the lab.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and provide accurate outputs for each test case.\nrequirement pool:\n- Implement efficient grid traversal to identify reachable cells.\n- Ensure output format strictly follows the requirements.\n- Optimize algorithm for performance given constraints.\n- Handle edge cases such as minimal and maximal grid sizes.\n- Provide clear documentation for the solution.\nWe will use a Breadth-First Search (BFS) algorithm to determine which free cells can lead the robot to the lab. The BFS will start from the lab and explore all reachable free cells, marking them as reachable. This approach ensures that we efficiently traverse the grid and handle large grid sizes within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed', 'lab', 'robot', 'command'\n    Explanation: The grid is a matrix of cells, each of which can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and can move to adjacent cells based on commands. The goal is to determine which free cells can lead the robot to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab ('L') in the grid.\n4. Use a Breadth-First Search (BFS) starting from the lab to explore all reachable free cells:\n   - Initialize a queue with the lab's position.\n   - Mark all visited cells to avoid re-processing.\n   - For each cell, check its neighbors (up, down, left, right).\n   - If a neighbor is a free cell and not visited, mark it as reachable and add it to the queue.\n5. After BFS completes, replace all reachable free cells with '+'.\n6. Output the modified grid for each test case.\n\n# [edge case] \n    1. A grid with only one cell which is a lab:\n       Input: 1 1 L\n       Output: L\n       Explanation: There are no free cells to mark.\n\n    2. A grid where all cells are blocked except for the lab:\n       Input: 3 3 ### #L# ###\n       Output: ### #L# ###\n       Explanation: No free cells can be reached from the lab.\n\n    3. A grid where the lab is surrounded by free cells:\n       Input: 3 3 ... .L. ...\n       Output: +++ +L+ +++\n       Explanation: All free cells can lead to the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking only those free cells that can be reached from the lab.\n", "requirement analysis:\nThe requirements focus on determining which free cells can lead the robot to the lab despite its erratic behavior. The solution must efficiently process large grids and ensure accurate output for each test case.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Ensure the solution handles maximum grid size efficiently\n- Optimize the algorithm for performance\n- Validate output format against requirements\n- Consider edge cases and unusual grid configurations\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it explores all possible paths from the lab to free cells, ensuring that we can find all reachable cells efficiently. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case independently, and the output will be formatted according to the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed', 'lab', 'robot', 'command'\n    Explanation: \n    - 'grid': A matrix of cells with n rows and m columns.\n    - 'free cell': A cell that the robot can move into, marked with '.'.\n    - 'obstructed': A cell that the robot cannot move into, marked with '#'.\n    - 'lab': The target cell where the robot needs to reach, marked with 'L'.\n    - 'robot': The entity that needs to be guided to the lab.\n    - 'command': Instructions sent to the robot, which it will not follow directly.\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to read the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab ('L') in the grid.\n4. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n5. For each free cell, determine if it can be forced to reach the lab by checking if all possible moves lead towards the lab.\n6. Mark such cells with a '+'.\n7. Output the modified grid for each test case.\n\n# [edge case] \n    1. A grid with only one cell which is a lab:\n       Input: 1 1 L\n       Output: L\n       Explanation: The grid is already at the lab, no free cells to mark.\n\n    2. A grid where all cells are blocked except for one free cell and the lab:\n       Input: 3 3\n              ###\n              #L#\n              #.#\n       Output: ###\n               #L#\n               #+#\n       Explanation: The only free cell can be forced to reach the lab.\n\n    3. A grid where all cells are free:\n       Input: 2 2\n              ..\n              .L\n       Output: ++\n               +L\n       Explanation: All free cells can be forced to reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by exploring all possible paths from the lab and marking reachable cells accordingly.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic movement behavior. The solution must efficiently handle large grids and multiple test cases, ensuring correct output format.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells for the robot.\n- Ensure the solution handles edge cases and large inputs within constraints.\n- Optimize the algorithm to reduce computational complexity.\n- Provide clear documentation and comments in the code for maintainability.\n- Include additional test cases to verify the solution's robustness.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab cell to determine which free cells can be forced to reach the lab. The BFS will propagate from the lab to all reachable free cells, marking them as reachable. This approach ensures that we efficiently explore all possible paths from the lab to other cells, taking into account the robot's erratic behavior.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'obstructed cell', 'lab', 'robot'\n    Explanation: The grid is a matrix of cells, each of which can be free ('.'), obstructed ('#'), or contain a lab ('L'). The robot starts in a free cell and must be guided to the lab despite its erratic behavior.\n\n# [phrase showing quantity relationship]\n    'one of the free cells holds a laboratory': means there is exactly one lab in the grid.\n    'no matter what different directions the robot chooses': implies that the robot must be able to reach the lab from any free cell that can be forced to reach it.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and the grid for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n    4. Mark free cells as reachable ('+') if they can be forced to reach the lab.\n    5. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist to mark.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells exist, so no cells can be marked as reachable.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    Input: 3 3 ... .L. ...\n    Output: +++ +L+ +++\n    Explanation: All free cells can be forced to reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by marking reachable cells starting from the lab.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 323, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "mutate_method": "add_1_sentence_at_end", "parent_index": 226}
