{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer), which is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array a and n are given and you have to return the count of such pairs. The final answer should be an integer representing the number of valid pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer), which is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array a and n are given and you have to return the count of such pairs. The final answer should be an integer representing the number of valid pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements. It is possible that k is not an integer. It is the sum of elements divided by the number of these elements (i. e. sum divided by n). Monocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array a and n are given and you have to return the count of such pairs. The final answer should be an integer representing the number of valid pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has got an array a consisting of n integers, and k is the sum of elements divided by n and may not be an integer. Monocarp wants to delete exactly two elements from a so the mean of the remaining (n - 2) elements is still equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Assume that the array a and n are given and you have to return the count of such pairs. The final answer should be an integer representing the number of valid pairs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        required_sum = 2 * mean * n - total_sum\n\n        # Use a hashmap to store frequencies of elements\n        frequency = defaultdict(int)\n        for num in a:\n            frequency[num] += 1\n\n        count = 0\n        for i in range(n):\n            # Decrease the frequency of the current element\n            frequency[a[i]] -= 1\n            # Calculate the required second element to form a valid pair\n            needed = required_sum - a[i]\n            # Check if the needed element exists in the remaining elements\n            if needed in frequency and frequency[needed] > 0:\n                count += frequency[needed]\n\n        # Append the result for the current test case\n        results.append(count)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append(a)\n\n# Output interface\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing these elements keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing a tuple with the number of elements and the array.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean = total_sum / n\n        required_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        element_count = defaultdict(int)\n        for num in a:\n            element_count[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            current_value = a[i]\n            required_value = required_sum - current_value\n\n            # Check if the required value exists in the hashmap\n            if required_value in element_count:\n                # If the required value is the same as the current value, we need to ensure there are at least two occurrences\n                if required_value == current_value:\n                    valid_pairs += element_count[required_value] - 1\n                else:\n                    valid_pairs += element_count[required_value]\n\n        # Since each pair is counted twice (once for each element), divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices (i, j) such that removing\n    the elements at these indices keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # We need to find pairs (i, j) such that:\n        # total_sum - a[i] - a[j] == (n - 2) * mean\n        # Simplifying, we get: a[i] + a[j] == 2 * mean\n\n        target_sum = 2 * mean\n        count_map = defaultdict(int)\n        valid_pairs = 0\n\n        for number in a:\n            # Check if there exists a number in the map that can form the target_sum with the current number\n            complement = target_sum - number\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n\n            # Add the current number to the map for future pairs\n            count_map[number] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices (i, j) such that removing these two elements\n    keeps the mean of the remaining elements the same as the original mean.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing a tuple with\n            the number of elements and the array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for num in a:\n            required_pair_value = target_sum - num\n\n            # Decrease the count of the current element to avoid using it in the pair\n            count_map[num] -= 1\n\n            # Check if the required pair value exists in the hashmap\n            if required_pair_value in count_map:\n                valid_pairs += count_map[required_pair_value]\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    if the elements on these positions are deleted, the mathematic mean of (n - 2)\n    remaining elements is equal to the mean of the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # Calculate the target sum for pairs\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through the array to find valid pairs\n        for num in a:\n            # Calculate the required pair value\n            required_pair_value = target_sum - num\n\n            # Check if the required pair value exists in the hashmap\n            if required_pair_value in count_map:\n                valid_pairs += count_map[required_pair_value]\n\n            # Decrement the count of the current number to avoid counting the same pair twice\n            count_map[num] -= 1\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices [i, j] such that removing these elements\n    from the array does not change the mean of the remaining elements.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an integer n followed by n integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        a = case[1:]\n        \n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = mean * (n - 2)\n        \n        count = 0\n        value_count = {}\n        \n        for value in a:\n            if value in value_count:\n                value_count[value] += 1\n            else:\n                value_count[value] = 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] + a[j] == total_sum - target_sum:\n                    count += 1\n        \n        results.append(count)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append([n] + a)\n    \n    # Call the function and print the results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    if the elements on these positions are deleted, the mean of the remaining\n    elements is equal to the mean of the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map: Dict[int, int] = {}\n        for num in case:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate through each element to find valid pairs\n        for num in case:\n            complement = target_sum - num\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n                # If complement is the same as num, we should not count the pair twice\n                if complement == num:\n                    valid_pairs -= 1\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    if the elements on these positions are deleted, the mean of the remaining\n    elements is equal to the mean of the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an integer n\n                                      followed by n integers representing the array.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = case[0]\n        a = case[1:]\n        \n        # Calculate the mean of the original array\n        total_sum = sum(a)\n        mean = total_sum / n\n        \n        # Calculate twice the mean\n        target_sum = 2 * mean\n        \n        # Use a hashmap to count occurrences of each element\n        element_count: Dict[int, int] = {}\n        pair_count = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in element_count:\n                pair_count += element_count[complement]\n            \n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        results.append(pair_count)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append([n] + a)\n\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    the elements at these positions keeps the mean of the remaining elements equal\n    to the original mean.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the number\n                                      of elements followed by the elements themselves.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        a = case[1:]\n        \n        # Calculate the original sum and mean\n        total_sum = sum(a)\n        original_mean = total_sum / n\n        \n        # Calculate the target sum for the remaining elements\n        target_sum = original_mean * (n - 2)\n        \n        # Use a hashmap to store frequencies of each element\n        frequency_map: Dict[int, int] = {}\n        for num in a:\n            if num in frequency_map:\n                frequency_map[num] += 1\n            else:\n                frequency_map[num] = 1\n        \n        # Count valid pairs\n        valid_pairs = 0\n        \n        # Iterate over pairs of elements\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Calculate the sum of the pair\n                pair_sum = a[i] + a[j]\n                \n                # Check if removing the pair maintains the mean\n                if total_sum - pair_sum == target_sum:\n                    valid_pairs += 1\n        \n        results.append(valid_pairs)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append([n] + a)\n    \n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n\n        # Calculate the target sum for the remaining elements\n        target_sum = mean * (n - 2)\n\n        # Use a hashmap to count frequencies of elements\n        freq = defaultdict(int)\n        for num in case:\n            freq[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            # Decrease the frequency of the current element\n            freq[case[i]] -= 1\n\n            # Calculate the required second element to maintain the mean\n            required = target_sum - (total_sum - case[i])\n\n            # Check if the required element exists in the remaining elements\n            if required in freq and freq[required] > 0:\n                valid_pairs += freq[required]\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires calculating the number of valid pairs of elements that can be removed from an array while maintaining the original mean. The solution must efficiently handle multiple test cases and large arrays, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient algorithm to find valid pairs\n- Ensure solution handles maximum constraints\n- Optimize for performance with large datasets\n- Provide clear output format\n- Include edge case handling\nWe will implement a function that calculates the number of valid pairs of positions [i, j] such that removing these elements keeps the mean of the array unchanged. The approach involves calculating the total sum of the array and using a hashmap to track the frequency of elements. This allows us to efficiently find pairs that satisfy the condition by checking if the sum of the two elements equals twice the mean times the number of elements minus the total sum.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean is the sum of all elements divided by the number of elements. In this problem, it is crucial to maintain the mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We are required to remove exactly two elements from the array.\n\n    'sum of elements divided by the number of these elements'\n    Explanation: This describes how the mean is calculated, which is crucial for understanding how to maintain it after removing elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the mean.\n2. For each element, calculate the required sum of two elements that need to be removed to maintain the mean.\n3. Use a hashmap to store frequencies of elements.\n4. Iterate through each element and check if there exists another element such that their sum equals the required sum.\n5. Count valid pairs and ensure each pair is counted only once.\n\n# [edge case]\n    Input: 4, [8, 8, 8, 8] = 6\n    Explanation: Any pair can be removed since all elements are equal, maintaining the mean.\n\n    Input: 3, [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean as all elements are distinct and do not satisfy the condition.\n\n    Input: 5, [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should handle all cases by checking pairs and their sums against the required condition.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices [i, j] such that removing these elements from the array does not change the mean of the remaining elements. The solution must handle multiple test cases efficiently, especially given the constraints on input size.\nrequirement pool:\n- Implement the main algorithm to find valid pairs.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases, such as all elements being the same.\n- Provide clear documentation and comments in the code.\n- Include test cases to validate the solution.\nWe will iterate over each test case, calculate the total sum of the array, and then use a hashmap to count occurrences of each element. For each element, we will check if there exists another element such that their sum equals twice the mean of the array. This approach ensures that we efficiently find valid pairs without checking all possible pairs explicitly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean is the sum of all elements divided by the number of elements. In this problem, it is denoted as k.\n\n    'delete exactly two elements'\n    Explanation: We need to find pairs of indices (i, j) such that removing these elements keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This refers to calculating the mean of the array. In code, it can be implemented as `mean = sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, calculate the total sum of the array and the mean.\n2. Use a hashmap to store the frequency of each element in the array.\n3. Iterate over each element and for each element `a[i]`, calculate the required pair value `required_value = 2 * mean - a[i]`.\n4. Check if `required_value` exists in the hashmap and count valid pairs.\n5. Ensure that pairs are counted only once by maintaining order (i < j).\n\n# [edge case]\n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to find pairs efficiently handles all cases.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle up to 200,000 elements across all test cases, ensuring that the algorithm is both time and space efficient.\nrequirement pool:\n- Implement an efficient algorithm to find valid pairs of indices.\n- Ensure the solution handles edge cases, such as all elements being the same.\n- Optimize the solution to minimize time complexity.\n- Provide clear and concise output for each test case.\n- Include comments and documentation for better understanding.\nWe will use a mathematical approach to determine the number of valid pairs. The key observation is that the sum of the remaining elements after removing two elements should be equal to the sum of the original array minus twice the mean. We will use a hashmap to efficiently count pairs that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean is calculated as the sum of all elements divided by the number of elements. The task requires maintaining this mean after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We need to remove precisely two elements from the array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial sum of the array and the mean.\n    2. For each pair of elements (i, j), check if removing them keeps the mean unchanged.\n    3. Use a hashmap to store and count potential pairs efficiently.\n    4. Iterate through the array to find valid pairs based on the condition derived from the mean.\n\n# [edge case]\n    Input: 3\n           10 10 10\n    Output: 0\n    Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n\n    Input: 4\n           0 0 0 0\n    Output: 6\n    Explanation: All elements are zero, so any pair can be removed without changing the mean.\n\n    Input: 5\n           1 1 1 1 1\n    Output: 10\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will naturally handle these scenarios by checking the conditions for maintaining the mean after removal.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices [i, j] such that removing these elements from the array does not change the mean of the remaining elements. The solution must handle multiple test cases efficiently, especially given the constraints on n and the sum of n across all test cases.\nrequirement pool:\n- Efficiently calculate the number of valid pairs for each test case.\n- Ensure the solution handles the maximum constraints effectively.\n- Provide clear and formatted output for each test case.\n- Optimize the algorithm to run within time limits for large inputs.\n- Include comments and documentation for code clarity.\nWe will iterate over each test case, calculate the total sum of the array, and then use a hashmap to count occurrences of each element. For each element, we will check if there exists another element such that their sum equals twice the mean of the array. This approach ensures that we efficiently find valid pairs without checking every possible pair explicitly, which is crucial given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean is the sum of all elements divided by the number of elements. In this problem, it is denoted as k and is calculated as the sum of the array divided by n.\n\n    'delete exactly two elements'\n    Explanation: We need to find pairs of indices (i, j) such that removing these two elements keeps the mean of the remaining elements the same as the original mean.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This refers to calculating the mean of the array. In code, it can be implemented as `mean = sum(array) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. For each test case, calculate the total sum of the array.\n2. Calculate the mean k using the formula `k = total_sum / n`.\n3. Iterate over each element and use a hashmap to count occurrences of each element.\n4. For each element a[i], calculate the required pair value as `2 * k - a[i]`.\n5. Check if this required pair value exists in the hashmap and count valid pairs.\n6. Ensure that i < j when counting pairs to avoid duplicates.\n7. Return the total count of valid pairs for each test case.\n\n# [edge case]\n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to find pairs efficiently handles all cases, including edge cases.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must handle multiple test cases efficiently, especially given the constraints on input size.\nrequirement pool:\n- Implement the main algorithm to find valid pairs.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases correctly.\n- Provide clear documentation and comments in the code.\n- Include additional test cases for validation.\nWe will use a mathematical approach to determine the number of valid pairs. The key observation is that the sum of the array minus the sum of the two removed elements should be equal to the mean multiplied by (n-2). This can be simplified to finding pairs (i, j) such that a[i] + a[j] = 2 * mean. We will use a hashmap to efficiently count occurrences and find pairs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean is the average of the numbers, calculated as the sum of the elements divided by the number of elements.\n\n    'delete exactly two elements'\n    Explanation: We need to remove two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This refers to calculating the mean by dividing the sum of all elements by the number of elements. In code, this is implemented as `mean = sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the mean of the array.\n    2. For each test case, iterate through the array and use a hashmap to store occurrences of each element.\n    3. For each element, calculate the required pair value that would maintain the mean when both are removed.\n    4. Check if this pair value exists in the hashmap and count valid pairs.\n    5. Ensure that pairs are counted only once (i < j).\n\n# [edge case]\n    Input: 4\n           3\n           1 1 1\n           3\n           1 2 3\n           3\n           0 0 0\n           3\n           1000000000 1000000000 1000000000\n    Output: \n           3\n           0\n           3\n           3\n    Explanation:\n    - In the first case, all elements are equal, so any pair can be removed.\n    - In the second case, no pair can be removed without changing the mean.\n    - In the third case, all elements are zero, so any pair can be removed.\n    - In the fourth case, all elements are equal, so any pair can be removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking pairs using a hashmap will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires calculating the number of valid pairs of indices [i, j] such that removing these elements from the array does not change the mean of the remaining elements. The solution must efficiently handle up to 10,000 test cases with a total of up to 200,000 elements across all test cases. The algorithm should be optimized to handle large numbers and ensure correct output for each test case.\nrequirement pool:\n- Implement an efficient algorithm to find valid pairs of indices.\n- Ensure the solution handles the maximum constraints effectively.\n- Optimize the solution to minimize time complexity.\n- Provide clear and concise output for each test case.\n- Include comments and documentation for better understanding.\nWe will implement a function that calculates the number of valid pairs of indices [i, j] such that removing these elements from the array does not change the mean of the remaining elements. The approach involves calculating the total sum of the array and using a hashmap to efficiently find pairs that satisfy the condition. The solution will be optimized to handle large input sizes by minimizing unnecessary computations and using efficient data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematic mean is the average of a set of numbers, calculated as the sum of the numbers divided by the count of numbers.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This phrase describes how the mean is calculated, which is the total sum of elements divided by the number of elements. In code, this can be implemented as `mean = sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial mean of the array.\n    2. Iterate over all pairs of elements (i, j) in the array.\n    3. For each pair, calculate the sum of the remaining elements after removing a[i] and a[j].\n    4. Check if the mean of the remaining elements equals the initial mean.\n    5. Count and return the number of valid pairs.\n\n# [edge case]\n    Input: [4, 8, 8, 8, 8]\n    Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: [3, 50, 20, 10]\n    Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n    Input: [5, 1, 4, 7, 3, 5]\n    Output: 2\n    Explanation: Removing pairs (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking all possible pairs and their impact on the mean.\n", "requirement analysis:\nThe task requires calculating pairs of positions in an array such that removing these elements maintains the mean of the remaining elements. The solution must efficiently handle up to 10,000 test cases and arrays with up to 200,000 elements, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient algorithm to find valid pairs\n- Optimize for large input sizes\n- Ensure accuracy for edge cases\n- Provide clear output format\n- Handle multiple test cases efficiently\nWe will use a hashmap to efficiently count occurrences of each element in the array. This will allow us to quickly determine valid pairs by checking if the sum of two elements equals twice the mean of the array. The approach leverages the properties of arithmetic mean and uses combinatorial counting to find pairs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n    'pairs of positions [i, j] (i < j)': Refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'sum of elements divided by n': This refers to calculating the mean of the array, which is the sum of all elements divided by the number of elements.\n    'twice the mean': This implies that we need to check if the sum of two elements equals twice the mean of the array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the mean of the array.\n    2. Use a hashmap to count occurrences of each element.\n    3. Iterate through each element and check if there exists another element such that their sum equals twice the mean.\n    4. Count valid pairs using combinatorial counting.\n\n# [edge case]\n    Input: 4\n           4\n           8 8 8 8\n    Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Input: 3\n           50 20 10\n    Output: 0\n    Explanation: No pair can be removed to maintain the mean.\n\n    Input: 5\n           1 4 7 3 5\n    Output: 2\n    Explanation: Pairs (1,3) and (4,5) can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap and combinatorial counting will handle all cases efficiently.\n", "requirement analysis:\nThe problem requires calculating the number of valid pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle up to 200,000 elements across all test cases, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently calculate the number of valid pairs of indices for each test case.\n- Ensure the solution handles the maximum constraints effectively.\n- Optimize the algorithm to reduce time complexity.\n- Provide clear and concise output for each test case.\n- Implement additional test cases to ensure robustness.\nWe will use a hashmap to count occurrences of each element in the array. The key insight is that for the mean to remain unchanged after removing two elements, the sum of the two removed elements must equal twice the mean of the original array. This allows us to efficiently find pairs using the hashmap.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n    'pairs of positions [i, j] (i < j)': Refers to selecting two distinct positions in the array such that the first position is less than the second.\n\n# [phrase showing quantity relationship]\n    'sum of elements divided by n': This refers to calculating the mean of the array.\n    'twice the mean': This means that the sum of the two elements removed should be equal to twice the mean of the original array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the mean of the original array.\n    2. Use a hashmap to count occurrences of each element in the array.\n    3. Iterate through each element and find pairs such that their sum equals twice the mean.\n    4. For each valid pair, ensure that the positions are distinct and i < j.\n    5. Return the count of such pairs.\n\n# [edge case]\n    Input: 4, [8, 8, 8, 8] = 6\n    Explanation: Any pair can be removed since all elements are equal, maintaining the mean.\n    \n    Input: 3, [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean as no two elements sum to twice the mean.\n    \n    Input: 5, [1, 4, 7, 3, 5] = 2\n    Explanation: Pairs (1, 3) and (4, 5) can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap and checking for pairs will naturally handle these cases.\n", "requirement analysis:\nThe problem requires calculating the number of valid pairs of indices such that removing these elements keeps the mean of the array unchanged. The key is to understand that the sum of the remaining elements must equal the original sum minus the sum of the removed elements. Efficiently finding these pairs involves using mathematical properties and possibly sorting or hashing techniques to reduce complexity.\nrequirement pool:\n- Implement the main algorithm to find valid pairs of indices.\n- Optimize the solution to handle the upper constraint limits efficiently.\n- Ensure the solution is tested against a variety of edge cases.\n- Document the solution approach and edge case handling.\n- Provide a user-friendly output format for the results.\nWe will use a mathematical approach to solve the problem efficiently. The key observation is that the sum of the remaining elements after removing two elements should be equal to the original sum minus the sum of the removed elements. We can use a hashmap to store the frequency of each element and then iterate through pairs to check if they satisfy the condition. This approach ensures that we handle large inputs efficiently within the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mean': The average value of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n    'pairs of positions [i, j]': Refers to the indices of elements in the array that can be removed to maintain the mean.\n    Explanation: The task is to find pairs of indices such that removing the elements at these indices keeps the mean of the remaining elements equal to the original mean.\n\n# [phrase showing quantity relationship]\n    'sum divided by n': This refers to calculating the mean of the array.\n    Explanation: The mean is calculated by dividing the sum of all elements by the number of elements.\n    Implementation: `mean = sum(a) / n`\n    'exactly two elements': Refers to removing two elements from the array.\n    Explanation: We need to find pairs of indices where removing these two elements keeps the mean unchanged.\n    Implementation: Iterate over pairs of indices and check if removing them maintains the mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the original sum and mean of the array.\n    2. Use a hashmap to store frequencies of each element.\n    3. Iterate over pairs of elements and check if removing them maintains the mean.\n    4. Count valid pairs and return the result.\n\n# [edge case]\n    Input: 4, Array: [8, 8, 8, 8] = Output: 6\n    Explanation: Any pair can be removed since all elements are equal, maintaining the mean.\n    \n    Input: 3, Array: [50, 20, 10] = Output: 0\n    Explanation: No pair can be removed to maintain the mean as all elements are different.\n    \n    Input: 5, Array: [1, 4, 7, 3, 5] = Output: 2\n    Explanation: Removing elements at positions (1,3) or (4,5) maintains the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap and pair iteration will handle all cases efficiently.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of deletions such that the mean of the remaining elements remains unchanged. The solution must efficiently handle up to 200,000 elements across multiple test cases, ensuring both speed and accuracy. Edge cases, such as arrays with identical elements or minimal size, must be considered.\nrequirement pool:\n- Efficient algorithm to find valid pairs of deletions.\n- Handle large input sizes within given constraints.\n- Ensure correct output format for each test case.\n- Consider edge cases like identical elements.\n- Optimize for both speed and accuracy.\nWe will use a mathematical approach to determine the number of valid pairs. The key observation is that the sum of the array must remain unchanged when two elements are removed. We can use a hashmap to store the frequency of each element and efficiently calculate the number of pairs that satisfy the condition. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mathematical mean is the average of a set of numbers, calculated by dividing the sum of the numbers by the count of numbers.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array while maintaining the same average for the remaining elements.\n\n# [phrase showing quantity relationship]\n    'sum divided by n'\n    Explanation: This phrase describes how to calculate the mean, which is the sum of all elements divided by the number of elements. In code, this can be implemented as `mean = sum(a) / n`.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the initial sum of the array and its mean.\n    2. For each pair of elements (i, j), check if removing them keeps the mean unchanged.\n    3. Use a hashmap to store frequencies of elements to efficiently find pairs that satisfy the condition.\n    4. Iterate through each test case and calculate the number of valid pairs.\n\n# [edge case]\n    Input: 3\n           3\n           1 1 1\n    Output: 0\n    Explanation: With only three identical elements, removing any two will not change the mean, but since n-2 = 1, no valid pair exists.\n\n    Input: 4\n           4\n           0 0 0 0\n    Output: 6\n    Explanation: All elements are zero, so any pair can be removed without changing the mean.\n\n    Input: 5\n           5\n           10 10 10 10 10\n    Output: 10\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap and checking pairs will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, true, true, false, true, true, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 827, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "condense_two2one", "parent_index": 503}
