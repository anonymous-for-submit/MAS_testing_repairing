{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematic mean of these elements and keep in mind that it's possible for k not to be an integer.\n\nThe mean of an array with n elements is computed by dividing the sum of the elements by the number of these elements. The sum of elements of an array is obtained by adding all the individual numbers. This sum is then divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematic mean of these elements and keep in mind that it's possible for k not to be an integer.\n\nThe mean of an array with n elements is computed by dividing the sum of the elements by the number of these elements. The sum of elements of an array is obtained by adding all the individual numbers. This sum is then divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematic mean of these elements and keep in mind that it's possible for k not to be an integer.\n\nThe mean of an array with n elements is computed by dividing the sum of the elements by the number of these elements. To find the sum of these elements, you add all the individual numbers together. This sum is then divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "Monocarp has acquired an array a made up of n integers. Let's denote k as the mathematic mean of these elements and keep in mind that it's possible for k not to be an integer.\n\nThe mean of an array with n elements is computed by dividing the sum of the elements by the number of these elements, obtained by adding all the individual numbers and then divided by n.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted,\n    the mathematic mean of (n - 2) remaining elements is equal to the original mean of n elements of the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the number of elements followed by the elements themselves.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n    \n    for test_case in test_cases:\n        n = test_case[0]\n        array = test_case[1:]\n        \n        total_sum = sum(array)\n        original_mean = total_sum / n\n        \n        # We need to find pairs (i, j) such that:\n        # (total_sum - array[i] - array[j]) / (n - 2) == original_mean\n        # Simplifying, we get:\n        # total_sum - array[i] - array[j] == original_mean * (n - 2)\n        # array[i] + array[j] == total_sum - original_mean * (n - 2)\n        \n        target_sum = total_sum - original_mean * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in array:\n            count_map[num] += 1\n        \n        valid_pairs = 0\n        \n        # Iterate over each element and find pairs\n        for num in array:\n            complement = target_sum - num\n            # Check if the complement exists in the map\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n                # If num and complement are the same, we counted the pair twice\n                if complement == num:\n                    valid_pairs -= 1\n        \n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n    \n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of an integer n followed by n integers\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append([n] + array)\n\n# Call the function and print the results\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing these elements keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        original_mean = total_sum / n\n        required_sum = original_mean * (n - 2)\n        \n        element_count: Dict[int, int] = {}\n        for num in a:\n            element_count[num] = element_count.get(num, 0) + 1\n        \n        valid_pairs = 0\n        \n        for num in a:\n            complement = total_sum - required_sum - num\n            if complement in element_count:\n                valid_pairs += element_count[complement]\n                if complement == num:\n                    valid_pairs -= 1\n        \n        results.append(valid_pairs // 2)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    the elements at these positions keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for array in test_cases:\n        n = len(array)\n        total_sum = sum(array)\n        original_mean = total_sum / n\n\n        # Calculate the target sum for the remaining elements\n        target_sum = original_mean * (n - 2)\n\n        # Use a hashmap to count occurrences of elements\n        element_count = defaultdict(int)\n        valid_pairs = 0\n\n        for i in range(n):\n            # Calculate the required sum of the pair\n            required_sum = total_sum - target_sum - array[i]\n\n            # Check if there exists a previous element that can form a valid pair\n            if required_sum in element_count:\n                valid_pairs += element_count[required_sum]\n\n            # Update the count of the current element\n            element_count[array[i]] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append(array)\n\n# Call the function and print results\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\ndef count_valid_pairs(t: int, test_cases: list[tuple[int, list[int]]]) -> list[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] (i < j) such that\n    removing the elements at these positions keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, list[int]]]): List of test cases, each containing\n            the number of elements and the array of integers.\n\n    Returns:\n        list[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for n, a in test_cases:\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean * (n - 2)\n        \n        count = 0\n        element_count = {}\n        \n        for num in a:\n            element_count[num] = element_count.get(num, 0) + 1\n        \n        for num in a:\n            element_count[num] -= 1\n            complement = target_sum - num\n            if complement in element_count:\n                count += element_count[complement]\n        \n        results.append(count // 2)  # Each pair is counted twice, so divide by 2\n    \n    return results\n\n# Interface using input() and print()\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n    \n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing these elements\n    maintains the mean of the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        element_count = defaultdict(int)\n        for num in a:\n            element_count[num] += 1\n\n        pair_count = 0\n\n        # Iterate through each element to find valid pairs\n        for num in a:\n            complement = target_sum - num\n            # Check if the complement exists in the hashmap\n            if complement in element_count:\n                pair_count += element_count[complement]\n                # If complement is the same as num, we need to decrement the count by one\n                if complement == num:\n                    pair_count -= 1\n\n        # Each pair is counted twice (i, j) and (j, i), so divide by 2\n        results.append(pair_count // 2)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append(a)\n\n# Output interface\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate through each element to find valid pairs\n        for num in a:\n            complement = target_sum - num\n            count_map[num] -= 1  # Decrement count to avoid using the same element twice\n\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map: Dict[int, int] = {}\n        for num in a:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate through each element to find valid pairs\n        for num in a:\n            complement = target_sum - num\n            count_map[num] -= 1  # Decrement count of current element\n\n            if complement in count_map and count_map[complement] > 0:\n                valid_pairs += count_map[complement]\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of indices that can be removed\n    while maintaining the mean of the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = mean * (n - 2)\n        \n        # Use a hashmap to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        valid_pairs = 0\n        \n        # Iterate over each element to find valid pairs\n        for i in range(n):\n            # Calculate the required pair value to maintain the mean\n            required_pair_value = target_sum - (total_sum - a[i])\n            \n            # Check if the required pair value exists in the hashmap\n            if required_pair_value in element_count:\n                valid_pairs += element_count[required_pair_value]\n                \n                # If the required pair value is the same as the current element, decrement by one\n                if required_pair_value == a[i]:\n                    valid_pairs -= 1\n        \n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the mean unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the number\n            of elements followed by the elements themselves.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        a = case[1:]\n        \n        # Calculate the original sum and mean\n        total_sum = sum(a)\n        original_mean = total_sum / n\n        target_sum = 2 * original_mean\n        \n        # Dictionary to count occurrences of each element\n        element_count = {}\n        for num in a:\n            if num in element_count:\n                element_count[num] += 1\n            else:\n                element_count[num] = 1\n        \n        # Calculate the number of valid pairs\n        valid_pairs = 0\n        for i in range(n):\n            # Decrease the count of the current element\n            element_count[a[i]] -= 1\n            \n            # Calculate the complement that would satisfy the condition\n            complement = target_sum - a[i]\n            \n            # Check if the complement exists in the dictionary\n            if complement in element_count:\n                valid_pairs += element_count[complement]\n        \n        results.append(valid_pairs)\n    \n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of an integer n followed by n integers\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    test_cases.append([n] + a)\n\n# Call the function and print results\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n\n        # To find pairs (i, j) such that removing them keeps the mean unchanged\n        # We need to find pairs (a[i], a[j]) such that:\n        # (total_sum - a[i] - a[j]) / (n - 2) = mean\n        # Simplifying gives: a[i] + a[j] = 2 * mean\n\n        target_sum = 2 * mean\n        count_map = defaultdict(int)\n        valid_pairs = 0\n\n        for number in case:\n            # Calculate the complement that would form a valid pair with the current number\n            complement = target_sum - number\n\n            # If the complement exists in the map, it means we have found valid pairs\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n\n            # Add the current number to the map for future pair checks\n            count_map[number] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        array = list(map(int, input().strip().split()))\n        cases.append(array)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of means and efficiently iterating through possible pairs.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Optimize for large input sizes\n- Ensure accurate mean calculation\n- Provide clear output format\n- Handle edge cases gracefully\nWe will use a mathematical approach to determine the number of pairs of elements that can be removed without changing the mean of the array. The key observation is that the sum of the remaining elements must be equal to the sum of the original array minus the sum of the two removed elements. We will use a hashmap to efficiently count pairs that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain the same even after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We are required to remove exactly two elements from the array.\n\n    'equal to'\n    Explanation: The mean of the remaining elements must be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the original mean.\n2. For each pair of elements (i, j), calculate the sum of the remaining elements after removing these two.\n3. Check if the mean of the remaining elements equals the original mean.\n4. Use a hashmap to efficiently count and check pairs that satisfy this condition.\n5. Return the count of such pairs.\n\n# [edge case]\n    Input: 3\n           3\n           1 1 1\n    Output: 0\n    Explanation: With only three elements, removing any two will leave one element, which cannot maintain the original mean.\n\n    Input: 4\n           4\n           0 0 0 0\n    Output: 6\n    Explanation: All elements are zero, so any pair can be removed without changing the mean.\n\n    Input: 5\n           5\n           10 10 10 10 10\n    Output: 10\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where all elements are equal or when n is minimal (3).\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must handle multiple test cases efficiently, especially given the constraints on input size.\nrequirement pool:\n- Implement the main algorithm to find valid pairs.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases correctly.\n- Provide clear documentation and comments in the code.\n- Include additional test cases for validation.\nWe will calculate the total sum of the array and the mean. For each element, we will check if there exists another element such that removing these two elements keeps the mean unchanged. This can be efficiently done using a hashmap to count occurrences of each element and checking the condition derived from the mean equation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. The task is to find pairs of elements that can be removed while keeping the mean unchanged.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We need to remove exactly two elements from the array.\n\n    'equal to k'\n    Explanation: The mean of the remaining elements after removing two should be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the original mean.\n2. For each element, calculate the required sum of the remaining elements to maintain the mean.\n3. Use a hashmap to count occurrences of each element.\n4. For each element, check if there exists another element such that removing these two elements keeps the mean unchanged.\n5. Count valid pairs and ensure each pair is counted only once.\n\n# [edge case]\n    Input: 4, 8 8 8 8\n    Output: 6\n    Explanation: All elements are equal, so any pair can be removed.\n\n    Input: 3, 50 20 10\n    Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n    Input: 5, 1 4 7 3 5\n    Output: 2\n    Explanation: Pairs (1,3) and (4,5) can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where all elements are equal or no valid pairs exist.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of means and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement efficient pair checking algorithm\n- Ensure correct handling of large numbers and arrays\n- Optimize for performance with large datasets\n- Provide clear output format\n- Include comprehensive test cases\nWe will use a mathematical approach to determine the number of pairs that can be removed while maintaining the mean. The key observation is that the sum of the remaining elements must be equal to the sum of the original array minus the sum of the two removed elements. We will use a hashmap to efficiently count pairs that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the array should remain the same even after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We are required to remove exactly two elements from the array.\n\n    'equal to k'\n    Explanation: The mean of the remaining elements after removing two should be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the total sum of the array and the original mean.\n2. For each pair of elements (i, j), calculate the sum of the remaining elements.\n3. Check if the mean of the remaining elements equals the original mean.\n4. Use a hashmap to efficiently count valid pairs.\n\n# [edge case]\n    Case 1: Input: [4, 4, 4, 4] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Case 2: Input: [50, 20, 10] = 0\n    Explanation: No pair can be removed to maintain the mean as all elements are distinct and removing any pair changes the mean.\n\n    Case 3: Input: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing pairs (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using a hashmap to count valid pairs will handle all cases efficiently.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of means and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Ensure accurate mean calculation\n- Optimize for large input sizes\n- Provide clear output format\n- Handle edge cases and errors gracefully\nWe will calculate the total sum of the array and the mean. For each element, we will check if removing it along with another element keeps the mean unchanged. This involves checking if the sum of the two elements equals twice the mean times the number of elements minus two. We will use a dictionary to count occurrences of each element to efficiently find valid pairs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is calculated by dividing the sum of its elements by the number of elements. The task requires maintaining this mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove precisely two elements from the array.\n    'number of pairs of positions [i, j] (i < j)': We need to find pairs of indices where the first index is less than the second.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the total sum of the array and the mean.\n    2. For each element, check if removing it along with another element keeps the mean unchanged.\n    3. This involves checking if the sum of the two elements equals twice the mean times the number of elements minus two.\n    4. Use a dictionary to count occurrences of each element to efficiently find valid pairs.\n    5. Iterate through each element and use the dictionary to find pairs that satisfy the condition.\n\n# [edge case]\n    Input: 3\n           1 1 1\n    Output: 0\n    Explanation: With only three identical elements, removing any two will not change the mean, but there are no valid pairs since all elements are identical.\n\n    Input: 4\n           0 0 0 0\n    Output: 6\n    Explanation: All pairs are valid since removing any two zeros will keep the mean unchanged.\n\n    Input: 5\n           1 2 3 4 5\n    Output: 0\n    Explanation: No pair of elements can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking pairs based on their sum will naturally handle these cases.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of means and efficiently iterating through possible pairs to check the condition.\nrequirement pool:\n- Implement efficient mean calculation after element removal\n- Optimize for large input sizes\n- Ensure correct handling of edge cases\n- Provide clear output format\n- Enhance user input handling\nWe will use a mathematical approach to determine the number of pairs of elements that can be removed while maintaining the mean. The key observation is that removing two elements should not affect the mean, which implies that the sum of the removed elements should be equal to twice the mean of the original array. We will use a hashmap to efficiently count pairs that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is calculated by dividing the sum of its elements by the number of elements. The task requires maintaining this mean after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove precisely two elements from the array.\n    'sum of the removed elements should be equal to twice the mean': This implies that the sum of the two removed elements must equal 2 * k, where k is the mean of the original array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the mean (k) of the original array.\n    2. Determine the target sum for the two elements to be removed, which is 2 * k.\n    3. Use a hashmap to count occurrences of each element in the array.\n    4. Iterate through pairs of elements and check if their sum equals the target sum.\n    5. Count valid pairs and ensure each pair is unique (i < j).\n\n# [edge case]\n    Input: 4, Array: [8, 8, 8, 8] = Output: 6\n    Explanation: Any pair can be removed since all elements are equal, maintaining the mean.\n    \n    Input: 3, Array: [50, 20, 10] = Output: 0\n    Explanation: No pair can be removed without changing the mean.\n    \n    Input: 5, Array: [1, 4, 7, 3, 5] = Output: 2\n    Explanation: Pairs (1, 3) and (4, 5) can be removed to maintain the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to count pairs that satisfy the condition will handle all cases efficiently.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array while maintaining the original mean. The solution must efficiently handle up to 10,000 test cases and arrays with up to 200,000 elements, ensuring performance and accuracy.\nrequirement pool:\n- Implement efficient algorithm to find valid pairs.\n- Ensure the solution handles edge cases and large inputs.\n- Optimize the code for performance.\n- Provide clear documentation and output format.\n- Test extensively with diverse test cases.\nWe will use a hashmap to count occurrences of each element in the array. The key observation is that for the mean to remain unchanged after removing two elements, the sum of the two removed elements must equal twice the mean of the array. This allows us to efficiently find pairs of elements that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is calculated by dividing the sum of its elements by the number of elements. It represents the average value of the array.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements remains unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two'\n    Explanation: This indicates that precisely two elements must be removed from the array to achieve the desired condition.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the mean of the original array.\n    2. Determine the sum required for the two elements to be removed, which is twice the mean.\n    3. Use a hashmap to count occurrences of each element in the array.\n    4. Iterate through each element and check if there exists another element such that their sum equals twice the mean.\n    5. Count all valid pairs and ensure i < j for each pair.\n\n# [edge case]\n    Input: 3\n           1 1 1\n    Output: 0\n    Explanation: With only three identical elements, removing any two will not change the mean, but no valid pairs exist as per the condition.\n\n    Input: 4\n           0 0 0 0\n    Output: 6\n    Explanation: All elements are zero, so any pair can be removed without changing the mean.\n\n    Input: 5\n           10 10 10 10 10\n    Output: 10\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to count occurrences and checking pairs will naturally handle these cases.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must handle multiple test cases efficiently, especially given the constraints on input size.\nrequirement pool:\n- Implement the main algorithm to find valid pairs.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases correctly.\n- Provide clear documentation and comments in the code.\n- Include additional test cases for validation.\nWe will use a hashmap to count occurrences of each element in the array. The key observation is that for the mean to remain unchanged after removing two elements, the sum of the two removed elements must equal twice the mean of the array. This allows us to efficiently find pairs of elements that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is calculated by dividing the sum of its elements by the number of elements. It represents the average value of the array.\n\n    'delete exactly two elements'\n    Explanation: The task requires removing two elements from the array such that the mean of the remaining elements is unchanged.\n\n# [phrase showing quantity relationship]\n    'twice the mean'\n    Explanation: For the mean to remain unchanged after removing two elements, the sum of the two removed elements must equal twice the mean of the array. This is because removing two elements should not affect the average value of the remaining elements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the mean of the original array.\n2. Determine the target sum for the two elements to be removed, which is twice the mean.\n3. Use a hashmap to count occurrences of each element in the array.\n4. Iterate through each element and check if there exists another element such that their sum equals the target sum.\n5. Count all valid pairs and ensure each pair is unique (i < j).\n\n# [edge case]\n    Input: 3\n           1 1 1\n    Output: 0\n    Explanation: With only three identical elements, removing any two will not satisfy the condition as there are no distinct pairs.\n\n    Input: 4\n           0 0 0 0\n    Output: 6\n    Explanation: All elements are zero, so any pair can be removed without changing the mean.\n\n    Input: 5\n           10 10 10 10 10\n    Output: 10\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hashmap and checking pairs will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle up to 200,000 elements across all test cases, ensuring the algorithm is optimized for both time and space complexity.\nrequirement pool:\n- Implement an efficient algorithm to find valid pairs of indices.\n- Ensure the solution handles edge cases, such as arrays with identical elements.\n- Optimize the solution to run within the given constraints for large inputs.\n- Provide clear and concise output for each test case.\n- Document the solution approach and edge cases considered.\nWe will use a mathematical approach to determine the number of pairs of indices that can be removed while maintaining the mean of the array. The key observation is that the sum of the remaining elements must be equal to the sum of the original array minus twice the mean times the number of elements removed. We will use a hashmap to efficiently count pairs that satisfy this condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the original array must be equal to the mean of the array after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We are required to remove exactly two elements from the array.\n\n    'equal to'\n    Explanation: The mean of the remaining elements must be equal to the mean of the original array.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the sum of the original array and its mean.\n2. For each pair of elements (i, j), calculate the sum of the remaining elements after removing these two.\n3. Check if this new sum divided by (n - 2) equals the original mean.\n4. Use a hashmap to efficiently count pairs that satisfy this condition.\n\n# [edge case]\n    Case 1: Input: [4, 4, 4, 4] = Output: 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Case 2: Input: [1, 1, 1] = Output: 0\n    Explanation: With only three elements, removing two will always change the mean.\n\n    Case 3: Input: [1, 2, 3, 4, 5] = Output: 0\n    Explanation: No pair can be removed to keep the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles cases where no valid pairs exist or all elements are equal.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. This involves understanding the mathematical properties of means and efficiently iterating over possible pairs to check the condition.\nrequirement pool:\n- Implement efficient pair calculation algorithm\n- Optimize for large input sizes\n- Ensure accurate mean calculation\n- Provide clear output format\n- Handle edge cases like all elements being equal\nWe will use a mathematical approach to determine the number of pairs that can be removed without changing the mean. The key observation is that the sum of the remaining elements must be equal to the sum of the original elements minus the sum of the two removed elements. We will use a dictionary to count occurrences of each element and efficiently find pairs that satisfy the condition.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is calculated by dividing the sum of its elements by the number of elements. In this problem, the mean of the array should remain unchanged after removing two elements.\n\n# [phrase showing quantity relationship]\n    'exactly two elements': We need to remove precisely two elements from the array.\n    'equal to': The mean of the remaining elements must be equal to the original mean.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Calculate the original sum of the array and its mean.\n    2. For each pair of elements (i, j), check if removing them keeps the mean unchanged.\n    3. Use a dictionary to count occurrences of each element to efficiently find pairs.\n    4. Iterate through possible pairs and check if the condition is satisfied.\n    5. Return the count of valid pairs.\n\n# [edge case]\n    Input: 3\n           3\n           1 1 1\n    Output: 0\n    Explanation: With only three identical elements, removing any two will not change the mean, but since we need exactly two elements removed, no valid pairs exist.\n\n    Input: 4\n           4\n           0 0 0 0\n    Output: 6\n    Explanation: All elements are zero, so any pair can be removed without changing the mean.\n\n    Input: 5\n           5\n           10 10 10 10 10\n    Output: 10\n    Explanation: All elements are identical, so any pair can be removed without changing the mean.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will handle these cases correctly by checking all possible pairs and ensuring the mean remains unchanged.\n", "requirement analysis:\nThe requirement is to find pairs of elements in an array such that removing them keeps the mean of the remaining elements unchanged. This involves calculating the mean of the original array and ensuring the mean remains the same after removing two elements. The solution must efficiently handle large arrays and multiple test cases.\nrequirement pool:\n- Implement efficient mean calculation and comparison\n- Optimize for large datasets\n- Ensure robust input handling\n- Provide clear output format\n- Include error handling for edge cases\nWe will calculate the mean of the array and then determine the number of pairs of elements that can be removed while keeping the mean unchanged. This involves using a hashmap to count occurrences of each element and efficiently finding pairs that satisfy the condition. The solution will be optimized to handle large datasets by avoiding unnecessary computations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'mathematic mean'\n    Explanation: The mean of an array is the sum of its elements divided by the number of elements. In this problem, the mean of the original array must remain the same after removing two elements.\n\n    'pairs of positions [i, j] (i < j)'\n    Explanation: We need to find pairs of indices such that removing the elements at these indices keeps the mean unchanged.\n\n# [phrase showing quantity relationship]\n    'exactly two elements'\n    Explanation: We must remove exactly two elements from the array to check if the mean remains unchanged.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Calculate the sum of the array and determine the mean `k`.\n2. For each test case, iterate through the array to find pairs of elements that can be removed while keeping the mean unchanged.\n3. Use a hashmap to store occurrences of each element to efficiently find valid pairs.\n4. For each element `a[i]`, calculate the required `a[j]` such that removing `a[i]` and `a[j]` keeps the mean unchanged.\n5. Count valid pairs using the hashmap and ensure `i < j`.\n\n# [edge case]\n    Test case 1: [8, 8, 8, 8] = 6\n    Explanation: All elements are equal, so any pair can be removed without changing the mean.\n\n    Test case 2: [50, 20, 10] = 0\n    Explanation: No pair can be removed to keep the mean unchanged as all elements are distinct.\n\n    Test case 3: [1, 4, 7, 3, 5] = 2\n    Explanation: Removing elements at positions (1, 3) or (4, 5) keeps the mean unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a hashmap to count occurrences and find valid pairs will handle all cases efficiently.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 337, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "expand_one2two", "parent_index": 136}
