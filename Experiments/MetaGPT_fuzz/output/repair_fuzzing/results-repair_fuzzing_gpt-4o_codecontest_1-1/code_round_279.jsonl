{"name": "1582_C. Grandma Capa Knits a Scarf", "description": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "tags": ["brute force", "data structures", "greedy", "strings", "two pointers"], "difficulty": 9, "id": 1582, "sample_io": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}], "test_list": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["3\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhhyhhyyky\n", "output": ["-1\n-1\n1\n3\n3\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyzxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabcaacba\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhkhhhy\n", "output": ["-1\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nxkhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxzxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrpparlar\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxxzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyyxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nyyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcbacaa\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabbaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabca\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyzyhhhhky\n", "output": ["2\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhhyky\n", "output": ["2\n1\n1\n3\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxzzxyy\n4\nbaba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwxz\n4\nbaba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n1\n1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyx\n4\nacbb\n8\nsakparpr\n10\nkyyyhhhhky\n", "output": ["2\n1\n-1\n-1\n4\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["-1\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\naabb\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n2\n-1\n4\n"]}, {"input": "5\n8\nabcaacba\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["0\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbcaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n-1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyx\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbabca\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzzyx\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n0\n0\n-1\n-1\n"]}, {"input": "5\n8\naacaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["-1\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["3\n1\n1\n3\n2\n"]}, {"input": "5\n8\naccabcaa\n6\nxyzxyy\n4\nabbc\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["3\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nacba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nbbcaacbb\n6\nzyxzyx\n4\nabba\n8\nroqarlap\n10\nykhxhhyyhk\n", "output": ["0\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyhyhyhhky\n", "output": ["2\n1\n1\n-1\n3\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhiyyhk\n", "output": ["-1\n2\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzxx\n4\nabbb\n8\nqprarlap\n10\nkhhyyhyhky\n", "output": ["2\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nbabb\n8\nrpqapkas\n10\njyyyhhhhky\n", "output": ["2\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nzzzxyx\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyxzyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhhyky\n", "output": ["3\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkgyyhhyhky\n", "output": ["3\n1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcabcba\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbabaadba\n6\nxyyxxy\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n3\n-1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nyzywyz\n4\nacda\n8\napqrrlap\n10\nykhxhhyyhk\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbabaadba\n6\nyxxxyx\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n1\n-1\n-1\n-1\n"]}, {"input": "5\n8\ncbabacbb\n6\nyyzyxx\n4\naabb\n8\nrpqarlap\n10\nkyyyhhhhkx\n", "output": ["3\n-1\n2\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhghhyyyk\n", "output": ["2\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n0\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyyhyhhk\n", "output": ["-1\n-1\n2\n-1\n3\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaslap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqpr\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbbaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nacba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrplarqap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\ncaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrpsarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlbp\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\npalraqps\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpparlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naaba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxghyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\njhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrpraqlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\naaba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbbcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nylhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykgk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyxxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\naaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nzxxzyw\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxzxxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\ncbcaaaab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqlraap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqaralp\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaaa\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqor\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabbb\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzzx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\npalrarpr\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nzywzxx\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nacba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nzyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nyhkyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqaalrp\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacba\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}], "task_id": "codecontest/30", "prompt": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, yet she doesn't want to offend him in any way. Therefore, to avoid offending him, she will choose one lowercase English letter. She will then erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not. You need to consider all possibilities for the letter choice and find the optimal solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "repair_prompt": ["Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, yet she doesn't want to offend him in any way. Therefore, to avoid offending him, she will choose one lowercase English letter. She will then erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not. You need to consider all possibilities for the letter choice and find the optimal solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, yet she doesn't want to offend him in any way. Therefore, to avoid offending him, she will choose one lowercase English letter. By making this choice, she shows she respects his pattern. She will then erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not. You need to consider all possibilities for the letter choice and find the optimal solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, which consists of lowercase English letters, and Grandpa Sher wrote a string s of length n. Grandma Capa wants to knit a beautiful scarf, and in her opinion, that can only be done with a palindrome, so she wants to change the pattern written by Grandpa Sher without offending him.\n\nShe will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s. She also wants to minimize the number of erased symbols from the pattern, and you need to help her find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible.\n\nNotice that she can only erase symbols equal to the one letter she chose. A string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not. You need to consider all possibilities for the letter choice and find the optimal solution.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make a palindrome by removing this character\n\n        return removals\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_removals_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make a string a palindrome by removing occurrences of a single chosen character.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum removals required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing occurrences of a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum erasures for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_erasures_for_letter(s: str, letter: str) -> int:\n        \"\"\"Calculate the minimum erasures needed to make the string a palindrome by removing a specific letter.\"\"\"\n        left, right = 0, len(s) - 1\n        erasures = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == letter:\n                left += 1\n                erasures += 1\n            elif s[right] == letter:\n                right -= 1\n                erasures += 1\n            else:\n                return float('inf')  # Impossible to make a palindrome by removing this letter\n\n        return erasures\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_letters = set(s)\n        min_erasures = float('inf')\n\n        for letter in unique_letters:\n            erasures = min_erasures_for_letter(s, letter)\n            min_erasures = min(min_erasures, erasures)\n\n        if min_erasures == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_erasures)\n\n    return results\n\n# Input interface\nt = int(input().strip())\ntest_cases = []\nfor _ in range(t):\n    n = int(input().strip())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Call the function and get results\nresults = min_erasures_to_palindrome(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings to be processed.\n\n    Returns:\n        List[int]: List of results for each test case, indicating the minimum number of erasures\n                   required to make the string a palindrome, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_letter(s: str, letter: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing occurrences of a specific letter.\n\n        Args:\n            s (str): The string to process.\n            letter (str): The letter to remove.\n\n        Returns:\n            int: Minimum number of deletions required, or float('inf') if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == letter:\n                left += 1\n                deletions += 1\n            elif s[right] == letter:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')  # Impossible to form a palindrome\n\n        return deletions\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_letters = set(s)\n        min_deletions = float('inf')\n\n        for letter in unique_letters:\n            deletions = min_deletions_for_letter(s, letter)\n            min_deletions = min(min_deletions, deletions)\n\n        results.append(min_deletions if min_deletions != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_erasures_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erased_symbols_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erased symbols required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum number of erased symbols for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum number of removals needed to make the string a palindrome by removing a specific character.\n\n        Args:\n            s (str): The string to transform.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals, or float('inf') if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')\n        \n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_erased_symbols_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum erasures required for each test case, or -1 if impossible.\n    \"\"\"\n    def can_form_palindrome(s: str, char_to_erase: str) -> int:\n        \"\"\"Check if a palindrome can be formed by erasing occurrences of a specific character.\n\n        Args:\n            s (str): The string to process.\n            char_to_erase (str): The character to erase.\n\n        Returns:\n            int: Minimum number of erasures required, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        erasures = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_erase:\n                left += 1\n                erasures += 1\n            elif s[right] == char_to_erase:\n                right -= 1\n                erasures += 1\n            else:\n                return -1\n\n        return erasures\n\n    results = []\n    for n, s in test_cases:\n        unique_chars = set(s)\n        min_erasures = float('inf')\n\n        for char in unique_chars:\n            erasures = can_form_palindrome(s, char)\n            if erasures != -1:\n                min_erasures = min(min_erasures, erasures)\n\n        results.append(min_erasures if min_erasures != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_erasures_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[Tuple[int, str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, str]]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum deletions required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                deletions += 1\n            elif s[right] == char:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')  # Impossible to form a palindrome by removing this character\n\n        return deletions\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = min_deletions_for_char(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        if min_deletions == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_deletions)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append((n, s))\n\n    # Call the function and get results\n    results = min_deletions_to_palindrome(t, test_cases)\n\n    # Output interface\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum erasures for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make a string a palindrome\n        by removing occurrences of a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                deletions += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')  # Impossible to form a palindrome with this character choice\n\n        return deletions\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = min_deletions_for_palindrome(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        if min_deletions == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_deletions)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_erasures_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erased symbols required to make the string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum number of erased symbols for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals required to make the string a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals, or a large number if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to form a palindrome\n\n        return removals\n\n    results = []\n\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_erasures_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erase_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erased symbols required to make the string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum number of erased symbols for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals required to make the string a palindrome by removing occurrences of a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Call the function and print results\nresults = min_erase_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to determine the minimum number of characters that need to be erased from a given string to make it a palindrome by only removing occurrences of a single chosen character. The solution must efficiently handle multiple test cases and large input sizes, ensuring that the sum of all string lengths does not exceed 200,000 characters.\nrequirement pool:\n- Implement the main algorithm to determine the minimum number of erasures needed to form a palindrome.\n- Optimize the solution to handle the maximum input size efficiently.\n- Ensure the solution handles edge cases, such as already palindromic strings or strings where no palindrome can be formed.\n- Provide clear and concise output for each test case.\n- Consider user experience in terms of input and output format.\nWe will implement a function that iterates over each possible character choice for removal and checks if the resulting string can be a palindrome. The function will use a two-pointer technique to efficiently check for palindromes and count the number of removals required. We will use Python's built-in capabilities for string manipulation and list operations to achieve this.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The requirement is to transform the given string into a palindrome by removing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means we need to find the smallest number of occurrences of a chosen letter to remove in order to make the string a palindrome. In code, this involves iterating over possible letters and calculating the number of removals needed for each.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to ensure that the number of symbols erased is the smallest possible to achieve a palindrome. This requires checking all possible letters and choosing the one that results in the least removals.\n\n# [code logic]\n    1. For each test case, iterate over each unique character in the string.\n    2. For each character, use a two-pointer approach to check if the string can be a palindrome by removing occurrences of that character.\n    3. Count the number of removals needed for each character choice.\n    4. Track the minimum number of removals across all character choices.\n    5. If no character choice results in a palindrome, return -1 for that test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Choosing 'a' and removing its first and last occurrences results in 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single letter removal can make this string a palindrome, so the output is -1.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character and checking for palindrome formation inherently handles edge cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of characters to erase from a string to make it a palindrome by only removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum number of erasures needed.\n- Ensure the solution handles edge cases, such as already palindromic strings.\n- Optimize the solution to run within time limits for large inputs.\n- Provide clear error handling for impossible cases.\n- Enhance user experience with detailed output explanations.\nWe will implement a function that checks if a string can be transformed into a palindrome by removing occurrences of a single chosen character. The function will iterate over each character in the string, attempt to make the string a palindrome by removing occurrences of that character, and calculate the minimum number of removals required. If no character can be chosen to make the string a palindrome, the function will return -1. We will use a two-pointer technique to efficiently check for palindromes and calculate removals.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. For example, 'racecar' and 'level' are palindromes.\n\n    'erase some occurrences'\n    Explanation: This means removing certain instances of a chosen character from the string to potentially form a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This refers to the smallest possible count of character removals needed to transform the string into a palindrome. In code, this can be implemented by iterating over each character, attempting to form a palindrome, and keeping track of the minimum removals required.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest amount or number. In this context, it refers to the least number of characters that need to be removed to achieve a palindrome. In code, this can be implemented by maintaining a variable that tracks the minimum number of removals across all possible character choices.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of removals required for each test case.\n3. For each unique character in the string:\n   - Use a two-pointer approach to check if the string can be made into a palindrome by removing occurrences of this character.\n   - Count the number of removals needed.\n   - Update the minimum removals if this count is lower.\n4. If no palindrome can be formed by removing any single character, return -1 for that test case.\n5. Output the minimum number of removals for each test case.\n\n# [edge case]\n    abba = 0\n    Explanation: The string is already a palindrome, so no characters need to be removed.\n\n    xyzxyz = -1\n    Explanation: No single character can be removed to make this string a palindrome, so the output is -1.\n\n    a = 0\n    Explanation: A single character is inherently a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each character and using two pointers will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to transform a given string into a palindrome by erasing occurrences of a single chosen letter, minimizing the number of erasures. The solution must efficiently handle up to 100 test cases with string lengths up to 100,000, ensuring the sum of all string lengths does not exceed 200,000. The output should clearly indicate the minimum number of erasures or if it's impossible to achieve a palindrome.\nrequirement pool:\n- Efficiently handle large input sizes\n- Minimize the number of erased symbols\n- Provide clear output format\n- Handle edge cases effectively\n- Optimize for speed and performance\nWe will implement a function that checks if a string can be transformed into a palindrome by erasing occurrences of a single chosen letter. The function will iterate over each possible letter choice and attempt to form a palindrome by removing occurrences of that letter. We will use a two-pointer technique to efficiently check for palindromes and count the necessary erasures. The solution will handle multiple test cases and ensure optimal performance for large inputs. We will use standard Python libraries for string manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The requirement is to transform the given string into a palindrome by erasing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest possible occurrences of a chosen letter to make the string a palindrome. This means finding the optimal solution with the least deletions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement is to minimize the number of erased symbols, meaning we need to find the solution with the least deletions possible.\n\n# [code logic]\n    1. For each test case, iterate over each possible letter in the string.\n    2. For each letter, use a two-pointer approach to check if the string can be transformed into a palindrome by removing occurrences of that letter.\n    3. Count the number of deletions required for each letter choice.\n    4. Track the minimum number of deletions across all letter choices.\n    5. If no palindrome can be formed, return -1 for that test case.\n    6. Output the minimum number of deletions for each test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Choose 'a' and erase its first and last occurrences to get 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: It is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no erasures are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each possible letter choice and using a two-pointer approach will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to transform a given string into a palindrome by erasing occurrences of a single chosen letter, minimizing the number of erasures. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring the sum of lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Efficiently handle large input sizes\n- Provide clear output format\n- Optimize for minimal erasures\n- Handle multiple test cases\n- Determine impossibility of palindrome transformation\nWe will implement a function that iterates over each possible letter choice and attempts to form a palindrome by erasing occurrences of that letter. The function will use a two-pointer technique to check if the string can be transformed into a palindrome by erasing the chosen letter. If a mismatch occurs, it will attempt to skip the chosen letter and continue checking. The solution will be efficient enough to handle the constraints provided, using O(n) time complexity per test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. The requirement is to transform the given string into a palindrome by erasing occurrences of a chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest possible occurrences of the chosen letter to make the string a palindrome. This means finding the optimal solution with the least deletions.\n\n# [degree adverb]\n    'impossible'\n    Explanation: If no choice of letter allows the string to be transformed into a palindrome, the output should be -1, indicating that it is impossible.\n\n# [code logic]\n    - For each test case, iterate over each unique letter in the string.\n    - Use a two-pointer approach to check if the string can be transformed into a palindrome by erasing occurrences of the chosen letter.\n    - If a mismatch occurs between the two pointers, attempt to skip the chosen letter and continue checking.\n    - Track the minimum number of deletions required for each letter choice.\n    - If no letter choice results in a palindrome, return -1 for that test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Choosing 'a' and erasing its first and last occurrences results in 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No choice of letter allows transformation into a palindrome, so it is impossible.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each letter choice and using a two-pointer approach will naturally handle these cases.\n", "requirement analysis:\nThe problem requires finding the minimum number of characters to erase from a given string to make it a palindrome, by only erasing occurrences of a single chosen character. The solution must efficiently handle multiple test cases and large input sizes, ensuring optimal performance.\nrequirement pool:\n- Implement the main algorithm to solve the palindrome problem\n- Optimize the solution for large input sizes\n- Ensure the solution handles edge cases correctly\n- Provide clear output format as specified in the requirements\n- Test the solution against a variety of test cases\nWe will use a two-pointer technique to check if a string can be transformed into a palindrome by removing occurrences of a single chosen character. For each character in the string, we will simulate the removal of that character and check if the remaining string can be a palindrome. This approach ensures that we efficiently handle large input sizes by minimizing unnecessary operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. The requirement is to transform the given string into a palindrome by removing occurrences of a single chosen character.\n\n    'minimize the number of erased symbols'\n    Explanation: The goal is to remove the fewest possible occurrences of a chosen character to achieve a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This indicates that we need to find the smallest number of characters to remove to make the string a palindrome. In code, this can be implemented by iterating through possible characters and calculating the number of removals needed for each, then selecting the minimum.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the least number of characters to erase to achieve the desired outcome. In code, this involves keeping track of the minimum number of removals required across all possible character choices.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of removals required, starting with infinity.\n3. Iterate over each unique character in the string s.\n4. Use a two-pointer approach to simulate removing occurrences of the current character and check if the remaining string can be a palindrome.\n5. If it can be a palindrome, update the minimum removals variable with the number of removals needed.\n6. After checking all characters, if the minimum removals variable is still infinity, output -1 (indicating it's impossible). Otherwise, output the minimum number of removals.\n\n# [edge case]\n    Test case: 1\n    Input: 1\n           a\n    Output: 0\n    Explanation: The string 'a' is already a palindrome, so no removals are needed.\n\n    Test case: 2\n    Input: 2\n           aa\n    Output: 0\n    Explanation: The string 'aa' is already a palindrome, so no removals are needed.\n\n    Test case: 3\n    Input: 3\n           abc\n    Output: -1\n    Explanation: It's impossible to make 'abc' a palindrome by removing occurrences of a single character.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers cases where no removals are needed or where it's impossible to achieve a palindrome.\n", "requirement analysis:\nThe task requires developing an algorithm that can efficiently determine the minimum number of characters to erase from a string to make it a palindrome, considering all possible choices of a single character to erase. The solution must handle up to 100 test cases with a total of up to 200,000 characters across all test cases.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum number of erasures needed to make a string a palindrome.\n- Ensure the solution handles the maximum input size within the given constraints.\n- Provide clear output indicating the number of erasures or impossibility.\n- Optimize the algorithm for performance and accuracy.\n- Consider edge cases and ensure robustness of the solution.\nWe will implement a function that iterates over each possible choice of a single character to erase from the string. For each choice, we will attempt to form a palindrome by erasing occurrences of that character. The function will use a two-pointer technique to check if the remaining string can be a palindrome and count the number of erasures required. If a palindrome can be formed, we will keep track of the minimum number of erasures needed. If no choice results in a palindrome, we will return -1 for that test case. This approach ensures we consider all possibilities and find the optimal solution efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. For example, 'kek' and 'abacaba' are palindromes.\n\n    'erase some occurrences of one letter'\n    Explanation: You can choose one letter and remove some or all of its occurrences to try to form a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest number of symbols possible to form a palindrome. This means finding the optimal solution with the least deletions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This indicates that we need to find the smallest number of deletions required to achieve a palindrome.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of deletions required, starting with a large value.\n3. Iterate over each unique character in the string s.\n4. For each character, use a two-pointer approach to attempt forming a palindrome by erasing occurrences of that character:\n   - Initialize two pointers, one at the start and one at the end of the string.\n   - Move the pointers towards each other, skipping over the chosen character.\n   - Count the number of deletions required.\n5. If a palindrome is formed, update the minimum deletions if this attempt requires fewer deletions than previously recorded.\n6. If no palindrome can be formed for any character choice, return -1 for that test case.\n7. Output the minimum number of deletions for each test case.\n\n# [edge case]\n    Test case 1: \"a\" = 0\n    Explanation: A single character is already a palindrome, so no deletions are needed.\n\n    Test case 2: \"abc\" = -1\n    Explanation: No single character can be removed to make this string a palindrome.\n\n    Test case 3: \"aaabaaa\" = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking each character and using two pointers will naturally handle these cases.\n", "requirement analysis:\nThe task requires developing an algorithm that can determine the minimum number of deletions needed to make a string a palindrome by removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions for palindrome formation.\n- Ensure the solution handles edge cases and large inputs within constraints.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm to minimize the number of erased symbols.\n- Include detailed comments and documentation for the code.\nWe will implement a function that iterates over each possible character choice and attempts to form a palindrome by removing occurrences of that character. The function will use a two-pointer technique to check if the remaining string can be a palindrome and count the number of deletions required. If a palindrome can be formed, it will return the minimum number of deletions; otherwise, it will return -1. The solution will efficiently handle up to 100 test cases with a total character count of up to 200,000.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. The requirement is to transform the given string into a palindrome by erasing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: The goal is to erase the fewest possible occurrences of a chosen letter to make the string a palindrome. This involves finding the optimal solution with the least deletions.\n\n# [degree adverb]\n    'minimum'\n    Explanation: This indicates that the solution should aim to minimize the number of deletions required to achieve a palindrome.\n\n# [code logic]\n    1. For each test case, read the integer n and the string s.\n    2. Initialize a variable to store the minimum number of deletions required, starting with a large value.\n    3. Iterate over each unique character in the string s.\n    4. For each character, use a two-pointer approach to attempt forming a palindrome by removing occurrences of that character.\n    5. Count the number of deletions required for each character choice.\n    6. Update the minimum deletions if a palindrome can be formed with fewer deletions.\n    7. If no palindrome can be formed for any character choice, return -1 for that test case.\n    8. Output the minimum number of deletions for each test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Choose 'a' and erase its first and last occurrences to get 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: It is impossible to form a palindrome by erasing occurrences of any single letter.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over each character choice and using a two-pointer approach will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to convert a given string into a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle multiple test cases and large strings, ensuring optimal performance and clear output.\nrequirement pool:\n- Implement the main algorithm to find the minimum erasures for palindrome conversion.\n- Ensure the solution handles edge cases and large input sizes efficiently.\n- Provide clear and consistent output format for all test cases.\n- Optimize the algorithm for performance and scalability.\n- Include detailed comments and documentation for code clarity.\nWe will implement a function that iterates over each possible letter in the string and attempts to form a palindrome by removing occurrences of that letter. The function will use a two-pointer technique to check if the string can be a palindrome after removing certain characters. The solution will efficiently handle multiple test cases and large strings by iterating over each character and using a linear scan to check for palindromes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The task is to make the string a palindrome by removing occurrences of one chosen letter.\n\n    'minimize the number of erased symbols'\n    Explanation: The goal is to remove the fewest possible occurrences of a single letter to achieve a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This indicates that we need to find the smallest number of deletions required to make the string a palindrome by removing occurrences of one specific letter.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to find the least number of deletions required to achieve a palindrome.\n\n# [code logic]\n1. For each test case, iterate over each unique character in the string.\n2. For each character, use a two-pointer approach to attempt forming a palindrome by removing occurrences of that character.\n3. Initialize two pointers at the start and end of the string.\n4. Move the pointers towards each other, skipping over the chosen character.\n5. If the characters at the pointers do not match and are not the chosen character, break and try the next character.\n6. Count the number of deletions required for each character choice.\n7. Track the minimum number of deletions across all character choices.\n8. If no palindrome can be formed, return -1 for that test case.\n\n# [edge case]\n    abcaacab = 2\n    Explanation: Choose 'a' and remove first and last 'a' to form 'bcaacb', which is a palindrome.\n    \n    xyzxyz = -1\n    Explanation: No single letter removal can form a palindrome, so return -1.\n    \n    abba = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles all cases by iterating over each character and checking for possible palindromes.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to convert a given string into a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle multiple test cases and large strings, ensuring minimal erasures and clear output.\nrequirement pool:\n- Efficiently handle large input sizes up to 10^5 characters\n- Provide clear output format indicating erasures or impossibility\n- Optimize algorithm to minimize erasures\n- Ensure solution is scalable for multiple test cases\n- Include detailed explanation for cases where palindrome formation is impossible\nWe will implement a function that iterates over each possible letter choice and attempts to form a palindrome by removing occurrences of that letter. The function will use a two-pointer technique to check if the string can be a palindrome after removals. If a palindrome can be formed, it will calculate the minimum number of removals required. If no palindrome can be formed for any letter choice, it will return -1. The solution will efficiently handle large strings using this approach.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forward and backward. For example, 'kek', 'abacaba', and 'r' are palindromes.\n\n    'erase some occurrences'\n    Explanation: This means selectively removing instances of a chosen letter from the string to potentially form a palindrome.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This refers to the smallest number of deletions required to transform the string into a palindrome. In code, this can be implemented by iterating over possible deletions and keeping track of the minimum count.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The least amount of something, in this case, the fewest number of deletions needed. In code, this is typically managed by maintaining a variable that updates only when a smaller value is found.\n\n# [code logic]\n1. For each test case, read the integer n and the string s.\n2. Initialize a variable to store the minimum number of deletions required, starting with a large value.\n3. Iterate over each unique character in the string as a potential candidate for removal.\n4. For each character, use a two-pointer approach to attempt forming a palindrome:\n   - Initialize two pointers at the start and end of the string.\n   - Move the pointers inward, skipping over occurrences of the chosen character.\n   - Count how many characters are skipped.\n5. If the remaining string between the pointers is a palindrome, update the minimum deletions if the current count is lower.\n6. If no palindrome can be formed for any character, return -1 for that test case.\n7. Output the minimum deletions for each test case.\n\n# [edge case]\n    Test case 1: \"a\" = 0\n    Explanation: A single character is already a palindrome, so no deletions are needed.\n\n    Test case 2: \"abc\" = -1\n    Explanation: No single character removal can make this string a palindrome.\n\n    Test case 3: \"aaabaaa\" = 0\n    Explanation: The string is already a palindrome, so no deletions are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic inherently handles these scenarios by checking if the string is already a palindrome or if no valid palindrome can be formed.\n", "requirement analysis:\nThe problem requires finding the minimum number of characters to erase from a string to make it a palindrome by only removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with string lengths up to 10^5, ensuring the sum of all string lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Implement the main algorithm to find the minimum number of erasures\n- Ensure the solution handles edge cases and large inputs efficiently\n- Optimize the algorithm for minimal computational complexity\n- Test the solution against provided examples and additional test cases\n- Document the solution approach and edge case handling\nWe will iterate over each character in the string and attempt to make the string a palindrome by removing occurrences of that character. For each character, we will use a two-pointer technique to check if the string can be made a palindrome by removing only that character. We will keep track of the minimum number of removals required. If no character can be removed to make the string a palindrome, we will return -1 for that test case.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'palindrome'\n    Explanation: A palindrome is a string that reads the same forwards and backwards. The requirement is to transform the given string into a palindrome by removing occurrences of a single chosen letter.\n\n# [phrase showing quantity relationship]\n    'minimum number of erased symbols'\n    Explanation: This means we need to find the least number of occurrences of a chosen letter to remove in order to make the string a palindrome.\n\n# [degree adverb]\n    'minimum'\n    Explanation: We need to ensure the number of erased symbols is as small as possible while achieving the goal of making the string a palindrome.\n\n# [code logic]\n    1. For each test case, iterate over each unique character in the string.\n    2. For each character, use a two-pointer approach to attempt to make the string a palindrome by removing occurrences of that character.\n    3. Track the number of removals required for each character and update the minimum removals found.\n    4. If no character can be removed to make the string a palindrome, return -1 for that test case.\n    5. Output the minimum number of removals for each test case.\n\n# [edge case]\n    Test case with already palindrome string:\n    abba = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n    Test case with no possible palindrome:\n    xyzxyz = -1\n    Explanation: No single character removal can make this string a palindrome.\n\n    Test case with all identical characters:\n    aaaaa = 0\n    Explanation: The string is already a palindrome, so no removals are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic will naturally handle these scenarios by checking if the string is already a palindrome or if no valid transformation is possible.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 279, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "mutate_method": "expand_one2two", "parent_index": 101}
