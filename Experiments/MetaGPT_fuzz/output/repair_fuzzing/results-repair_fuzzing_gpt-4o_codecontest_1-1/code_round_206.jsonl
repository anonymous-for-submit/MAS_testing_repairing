{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This design ensures that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed. They need this information to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n).\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This design ensures that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed. They need this information to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n).\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them. This design ensures that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y. This journey takes max(|a_x + a_y|, |a_x - a_y|) energy to complete. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed. They need this information to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n).\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them, ensuring that it is possible to travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it, and Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed, needing this information to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\nfrom typing import List, Tuple\nimport networkx as nx\n\nclass HeavyLightDecomposition:\n    def __init__(self, n: int):\n        self.n = n\n        self.parent = [-1] * n\n        self.depth = [0] * n\n        self.size = [0] * n\n        self.chain_head = [-1] * n\n        self.chain_index = [-1] * n\n        self.pos_in_base = [-1] * n\n        self.base_array = []\n        self.current_pos = 0\n        self.segment_tree = []\n\n    def dfs(self, tree: nx.Graph, current: int, parent: int):\n        \"\"\"Perform DFS to calculate size and parent of each node.\"\"\"\n        self.parent[current] = parent\n        self.size[current] = 1\n        for neighbor in tree.neighbors(current):\n            if neighbor != parent:\n                self.depth[neighbor] = self.depth[current] + 1\n                self.dfs(tree, neighbor, current)\n                self.size[current] += self.size[neighbor]\n\n    def hld(self, current: int, chain_head: int, tree: nx.Graph):\n        \"\"\"Perform Heavy-Light Decomposition.\"\"\"\n        if self.chain_head[current] == -1:\n            self.chain_head[current] = chain_head\n        self.chain_index[current] = len(self.base_array)\n        self.base_array.append(current)\n        self.pos_in_base[current] = self.current_pos\n        self.current_pos += 1\n\n        # Find the special child (heavy child)\n        special_child = -1\n        max_size = -1\n        for neighbor in tree.neighbors(current):\n            if neighbor != self.parent[current] and self.size[neighbor] > max_size:\n                max_size = self.size[neighbor]\n                special_child = neighbor\n\n        if special_child != -1:\n            self.hld(special_child, chain_head, tree)\n\n        # Decompose the light edges\n        for neighbor in tree.neighbors(current):\n            if neighbor != self.parent[current] and neighbor != special_child:\n                self.hld(neighbor, neighbor, tree)\n\n    def build_segment_tree(self, illusion_rates: List[int]):\n        \"\"\"Build a segment tree for the base array.\"\"\"\n        self.segment_tree = [0] * (4 * len(self.base_array))\n        self._build_segment_tree(0, 0, len(self.base_array) - 1, illusion_rates)\n\n    def _build_segment_tree(self, node: int, start: int, end: int, illusion_rates: List[int]):\n        \"\"\"Helper function to build the segment tree.\"\"\"\n        if start == end:\n            self.segment_tree[node] = illusion_rates[self.base_array[start]]\n        else:\n            mid = (start + end) // 2\n            left_child = 2 * node + 1\n            right_child = 2 * node + 2\n            self._build_segment_tree(left_child, start, mid, illusion_rates)\n            self._build_segment_tree(right_child, mid + 1, end, illusion_rates)\n            self.segment_tree[node] = self.segment_tree[left_child] + self.segment_tree[right_child]\n\n    def update_segment_tree(self, idx: int, value: int):\n        \"\"\"Update the segment tree at a specific index.\"\"\"\n        self._update_segment_tree(0, 0, len(self.base_array) - 1, idx, value)\n\n    def _update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int):\n        \"\"\"Helper function to update the segment tree.\"\"\"\n        if start == end:\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            left_child = 2 * node + 1\n            right_child = 2 * node + 2\n            if start <= idx <= mid:\n                self._update_segment_tree(left_child, start, mid, idx, value)\n            else:\n                self._update_segment_tree(right_child, mid + 1, end, idx, value)\n            self.segment_tree[node] = self.segment_tree[left_child] + self.segment_tree[right_child]\n\n    def query_segment_tree(self, L: int, R: int) -> int:\n        \"\"\"Query the segment tree for the sum in a range.\"\"\"\n        return self._query_segment_tree(0, 0, len(self.base_array) - 1, L, R)\n\n    def _query_segment_tree(self, node: int, start: int, end: int, L: int, R: int) -> int:\n        \"\"\"Helper function to query the segment tree.\"\"\"\n        if R < start or end < L:\n            return 0\n        if L <= start and end <= R:\n            return self.segment_tree[node]\n        mid = (start + end) // 2\n        left_child = 2 * node + 1\n        right_child = 2 * node + 2\n        left_sum = self._query_segment_tree(left_child, start, mid, L, R)\n        right_sum = self._query_segment_tree(right_child, mid + 1, end, L, R)\n        return left_sum + right_sum\n\n    def query_up(self, u: int, v: int) -> int:\n        \"\"\"Query the path from u to v.\"\"\"\n        uchain, vchain = self.chain_head[u], self.chain_head[v]\n        result = 0\n        while uchain != vchain:\n            if self.depth[uchain] < self.depth[vchain]:\n                u, v = v, u\n                uchain, vchain = vchain, uchain\n            result += self.query_segment_tree(self.pos_in_base[uchain], self.pos_in_base[u])\n            u = self.parent[uchain]\n            uchain = self.chain_head[u]\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u\n        result += self.query_segment_tree(self.pos_in_base[u], self.pos_in_base[v])\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], hld: HeavyLightDecomposition) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    hld.update_segment_tree(hld.pos_in_base[room - 1], new_rate)\n\ndef calculate_min_energy_path(u: int, v: int, hld: HeavyLightDecomposition) -> int:\n    \"\"\"Calculate the minimum energy path from room u to room v.\"\"\"\n    return hld.query_up(u - 1, v - 1)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = nx.Graph()\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree.add_edge(s - 1, t - 1)\n    \n    hld = HeavyLightDecomposition(n)\n    hld.dfs(tree, 0, -1)\n    hld.hld(0, 0, tree)\n    hld.build_segment_tree(illusion_rates)\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            update_illusion_rate(query[1], query[2], illusion_rates, hld)\n        elif query[0] == 2:\n            result = calculate_min_energy_path(query[1], query[2], hld)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room_illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Updates the illusion rate of the specified room.\"\"\"\n    room_illusion_rates[u - 1] = c\n\ndef calculate_minimum_energy(room_illusion_rates: List[int], tunnels: List[Tuple[int, int]], u: int, v: int) -> int:\n    \"\"\"Calculates the minimum sum of energy needed to travel from room u to room v.\"\"\"\n    # Build adjacency list for the tree\n    adjacency_list = [[] for _ in range(len(room_illusion_rates))]\n    for s, t in tunnels:\n        adjacency_list[s - 1].append(t - 1)\n        adjacency_list[t - 1].append(s - 1)\n\n    # Perform DFS to find path from u to v\n    def dfs(current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n        if current == target:\n            path.append(current)\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target, visited, path):\n                    return True\n        path.pop()\n        return False\n\n    visited = [False] * len(room_illusion_rates)\n    path = []\n    dfs(u - 1, v - 1, visited, path)\n\n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = room_illusion_rates[path[i]]\n        a_y = room_illusion_rates[path[i + 1]]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    # Read input values\n    n, q = map(int, input().split())\n    room_illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    # Process each query\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(room_illusion_rates, u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_minimum_energy(room_illusion_rates, tunnels, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\nsys.setrecursionlimit(200000)\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def update(self, pos: int, value: int):\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left: int, right: int) -> int:\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef dfs(u: int, parent: int, graph: Dict[int, List[int]], path: List[int], paths: Dict[Tuple[int, int], List[int]]):\n    \"\"\"Perform DFS to find all paths in the tree.\"\"\"\n    path.append(u)\n    for v in graph[u]:\n        if v != parent:\n            dfs(v, u, graph, path, paths)\n    if parent != -1:\n        paths[(parent, u)] = path[:]\n    path.pop()\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], graph: Dict[int, List[int]], paths: Dict[Tuple[int, int], List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    if u == v:\n        return 0\n    path = paths.get((u, v)) or paths.get((v, u))\n    if not path:\n        return 0\n    energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    return energy\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    illusion_rates = []\n    for _ in range(n):\n        illusion_rates.append(int(data[index]))\n        index += 1\n    \n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(n - 1):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        graph[s].append(t)\n        graph[t].append(s)\n    \n    queries = []\n    for _ in range(q):\n        queries.append(data[index:index+3])\n        index += 3\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    paths = {}\n    dfs(1, -1, graph, [], paths)\n    \n    for query in queries:\n        if query[0] == '1':\n            u = int(query[1])\n            c = int(query[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u = int(query[1])\n            v = int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, graph, paths)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n\n    def update(self, pos: int, value: int):\n        # Update the value at position pos\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left: int, right: int) -> int:\n        # Query the sum in the range [left, right)\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    # Update the illusion rate for a specific room\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    # Use DFS to find the path from u to v and calculate the energy\n    def dfs(current: int, target: int, visited: set, path: List[int]) -> bool:\n        if current == target:\n            return True\n        visited.add(current)\n        for neighbor in adjacency_list[current]:\n            if neighbor not in visited:\n                path.append(neighbor)\n                if dfs(neighbor, target, visited, path):\n                    return True\n                path.pop()\n        return False\n\n    # Build adjacency list from tunnels\n    adjacency_list = {i: [] for i in range(1, len(illusion_rates) + 1)}\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    # Find path from u to v\n    path = [u]\n    dfs(u, v, set(), path)\n\n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        total_energy += max(abs(a_x + a_y), abs(a_x - a_y))\n\n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n\n    segment_tree = SegmentTree(illusion_rates)\n\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n\n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates, segment_tree)\n        elif query_type == 2:\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef update_illusion_rate(room: int, new_rate: int) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    global illusion_rates\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(start_room: int, end_room: int) -> int:\n    \"\"\"Calculate the minimum energy required to travel between two rooms.\"\"\"\n    path = find_path(start_room, end_room)\n    energy = 0\n    for i in range(len(path) - 1):\n        room1 = path[i]\n        room2 = path[i + 1]\n        energy += max(abs(illusion_rates[room1 - 1] + illusion_rates[room2 - 1]),\n                      abs(illusion_rates[room1 - 1] - illusion_rates[room2 - 1]))\n    return energy\n\ndef find_path(start_room: int, end_room: int) -> list:\n    \"\"\"Find the path between two rooms using DFS.\"\"\"\n    visited = [False] * n\n    path = []\n    dfs(start_room, end_room, visited, path)\n    return path\n\ndef dfs(current_room: int, target_room: int, visited: list, path: list) -> bool:\n    \"\"\"Depth First Search to find path between two rooms.\"\"\"\n    visited[current_room - 1] = True\n    path.append(current_room)\n    if current_room == target_room:\n        return True\n    for neighbor in adjacency_list[current_room]:\n        if not visited[neighbor - 1]:\n            if dfs(neighbor, target_room, visited, path):\n                return True\n    path.pop()\n    return False\n\ndef build_adjacency_list(tunnels: list) -> dict:\n    \"\"\"Build adjacency list from tunnel connections.\"\"\"\n    adj_list = {i: [] for i in range(1, n + 1)}\n    for s, t in tunnels:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n    return adj_list\n\n## Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [input().strip() for _ in range(q)]\n\n## Build adjacency list\nadjacency_list = build_adjacency_list(tunnels)\n\n## Output interface\nfor query in queries:\n    parts = query.split()\n    if parts[0] == '1':\n        update_illusion_rate(int(parts[1]), int(parts[2]))\n    elif parts[0] == '2':\n        result = calculate_min_energy(int(parts[1]), int(parts[2]))\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nfrom collections import defaultdict, deque\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[u - 1] = c\n\ndef calculate_minimum_energy(n: int, edges: List[Tuple[int, int]], illusion_rates: List[int], u: int, v: int) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    # Build the adjacency list for the tree\n    adjacency_list = defaultdict(list)\n    for s, t in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    # Perform BFS to find the path from u to v\n    def bfs(start: int, end: int) -> List[int]:\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            current = queue.popleft()\n            if current == end:\n                break\n            for neighbor in adjacency_list[current]:\n                if neighbor not in parent:\n                    parent[neighbor] = current\n                    queue.append(neighbor)\n        \n        # Reconstruct the path from u to v\n        path = []\n        step = end\n        while step is not None:\n            path.append(step)\n            step = parent[step]\n        path.reverse()\n        return path\n\n    # Get the path from u to v\n    path = bfs(u, v)\n\n    # Calculate the total energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        energy = max(abs(a_x + a_y), abs(a_x - a_y))\n        total_energy += energy\n\n    return total_energy\n\ndef main():\n    # Read input\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    # Process each query\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(illusion_rates, u, c)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_minimum_energy(n, edges, illusion_rates, u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\nsys.setrecursionlimit(200000)\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, pos: int, value: int):\n        # Update the value at position pos\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left: int, right: int) -> int:\n        # Query the sum in the range [left, right)\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(graph: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]):\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(graph, neighbor, node, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    # Bring u and v to the same depth\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while depth[v] > depth[u]:\n        v = parent_list[v]\n    # Find the common ancestor\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(a_x: int, a_y: int) -> int:\n    return max(abs(a_x + a_y), abs(a_x - a_y))\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    n = len(illusion_rates)\n    graph = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        graph[s].append(t)\n        graph[t].append(s)\n\n    depth = [0] * (n + 1)\n    parent_list = [-1] * (n + 1)\n    dfs(graph, 1, -1, depth, parent_list)\n\n    ancestor = lca(u, v, depth, parent_list)\n\n    energy = 0\n    current = u\n    while current != ancestor:\n        next_node = parent_list[current]\n        energy += calculate_energy(illusion_rates[current - 1], illusion_rates[next_node - 1])\n        current = next_node\n\n    current = v\n    while current != ancestor:\n        next_node = parent_list[current]\n        energy += calculate_energy(illusion_rates[current - 1], illusion_rates[next_node - 1])\n        current = next_node\n\n    return energy\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    illusion_rates[room - 1] = new_rate\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict, deque\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of the specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    # Build adjacency list for the tree\n    adjacency_list = defaultdict(list)\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    \n    # Perform BFS to find the path from u to v\n    queue = deque([(u, 0)])  # (current room, accumulated energy)\n    visited = set()\n    visited.add(u)\n    \n    while queue:\n        current_room, current_energy = queue.popleft()\n        \n        if current_room == v:\n            return current_energy\n        \n        for neighbor in adjacency_list[current_room]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                energy = max(abs(illusion_rates[current_room - 1] + illusion_rates[neighbor - 1]),\n                             abs(illusion_rates[current_room - 1] - illusion_rates[neighbor - 1]))\n                queue.append((neighbor, current_energy + energy))\n    \n    return -1  # This should not happen as the tree is connected\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    # Output interface\n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\nsys.setrecursionlimit(200000)\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, pos: int, value: int):\n        # Update the value at position pos\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left: int, right: int) -> int:\n        # Query the sum in the range [left, right)\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    segment_tree.update(room - 1, new_rate)\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(u: int, v: int, parent: int, graph: List[List[int]], illusion_rates: List[int], min_energy: List[int]) -> int:\n    if u == v:\n        return 0\n    for neighbor in graph[u]:\n        if neighbor == parent:\n            continue\n        energy = max(abs(illusion_rates[u] + illusion_rates[neighbor]), abs(illusion_rates[u] - illusion_rates[neighbor]))\n        min_energy[0] = min(min_energy[0], dfs(neighbor, v, u, graph, illusion_rates, min_energy) + energy)\n    return min_energy[0]\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    n = len(illusion_rates)\n    graph = [[] for _ in range(n)]\n    for s, t in tunnels:\n        graph[s - 1].append(t - 1)\n        graph[t - 1].append(s - 1)\n    min_energy = [float('inf')]\n    return dfs(u - 1, v - 1, -1, graph, illusion_rates, min_energy)\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    segment_tree = SegmentTree(illusion_rates)\n\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = min_energy_path(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict, deque\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\"\"\"\n    # Perform BFS to find the path from u to v\n    def bfs(start: int, end: int) -> List[int]:\n        queue = deque([start])\n        visited = set()\n        parent = {start: None}\n        \n        while queue:\n            current = queue.popleft()\n            if current == end:\n                break\n            visited.add(current)\n            for neighbor in tree[current]:\n                if neighbor not in visited:\n                    parent[neighbor] = current\n                    queue.append(neighbor)\n        \n        # Reconstruct path from u to v\n        path = []\n        while end is not None:\n            path.append(end)\n            end = parent[end]\n        path.reverse()\n        return path\n    \n    path = bfs(u, v)\n    total_energy = 0\n    \n    # Calculate energy for the path\n    for i in range(len(path) - 1):\n        room1 = path[i]\n        room2 = path[i + 1]\n        energy = max(abs(illusion_rates[room1 - 1] + illusion_rates[room2 - 1]),\n                     abs(illusion_rates[room1 - 1] - illusion_rates[room2 - 1]))\n        total_energy += energy\n    \n    return total_energy\n\ndef main():\n    # Input interface\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    \n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    queries = [input().split() for _ in range(q)]\n    \n    # Output interface\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe project requires handling a tree structure with rooms and tunnels, where each room has an illusion rate. The main challenge is efficiently processing updates to the illusion rates and calculating the minimum energy path between rooms. The solution must handle up to 100,000 rooms and queries, ensuring quick updates and path calculations. The energy calculation involves absolute values and maximum operations, which must be optimized for performance.\nrequirement pool:\n- Efficiently update illusion rates for rooms\n- Calculate minimum energy path between two rooms\n- Handle large input sizes and queries efficiently\n- Ensure robustness against invalid inputs\n- Provide clear documentation for energy calculations\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy path efficiently using a technique called Heavy-Light Decomposition (HLD). This will allow us to handle updates and queries in logarithmic time. We will use the networkx library to manage the tree structure and efficiently perform operations on it.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes. In this problem, the rooms and tunnels form a tree structure.\n\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It can be changed by queries.\n\n    'energy'\n    Explanation: Energy is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms being traveled between.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to travel between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the max function and abs function.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This involves calculating the energy for each path and selecting the path with the lowest total energy.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Implement DFS to preprocess the tree for Heavy-Light Decomposition (HLD).\n3. Use HLD to efficiently handle type 2 queries by calculating the minimum energy path.\n4. Implement logic to update illusion rates for type 1 queries.\n5. For each type 2 query, calculate and output the minimum energy required.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: With only two rooms and both having an illusion rate of 0, the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n    Output: 3000000000\n    Explanation: The path from room 1 to room 3 involves high illusion rates, resulting in high energy costs.\n\n    Input: 4 3\n           -1 -1 -1 -1\n           1 2\n           2 3\n           3 4\n           2 1 4\n    Output: 6\n    Explanation: The path from room 1 to room 4 involves consistent illusion rates, resulting in moderate energy costs.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and HLD will efficiently handle all cases, including edge cases.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to room illusion rates and calculating the minimum energy required for navigation. The solution must be scalable to handle large input sizes and provide quick responses to queries.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Accurately calculate the minimum energy required for type 2 queries.\n- Ensure the solution can handle the maximum input size efficiently.\n- Provide clear output format for type 2 queries.\n- Optimize the algorithm for faster query processing.\nWe will use Depth First Search (DFS) to traverse the tree structure of the maze efficiently. For type 1 queries, we will update the illusion rate of the specified room directly. For type 2 queries, we will calculate the minimum energy required using DFS to find the path between the specified rooms and compute the energy based on the given formula. We will use adjacency lists to represent the tree and efficiently handle updates and queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms.\n\n# [degree adverb] \n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from one room to another.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. For type 1 queries, update the illusion rate of the specified room.\n3. For type 2 queries, use DFS to find the path between the specified rooms and calculate the total energy using the given formula.\n4. Output the calculated energy for each type 2 query.\n\n# [edge case] \n    1. Minimum number of rooms (n=2): \n       Input: \n       ```\n       2 1\n       5 -5\n       1 2\n       2 1 2\n       ```\n       Expected Output: \n       ```\n       10\n       ```\n       Explanation: With only two rooms, the energy is simply max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    2. All illusion rates are zero:\n       Input:\n       ```\n       3 1\n       0 0 0\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output:\n       ```\n       0\n       ```\n       Explanation: Since all illusion rates are zero, any path will have zero energy cost.\n\n    3. Large illusion rate values:\n       Input:\n       ```\n       3 1\n       1000000000 -1000000000 1000000000\n       1 2\n       2 3\n       2 1 3\n       ```\n       Expected Output:\n       ```\n       3000000000\n       ```\n       Explanation: The path from room 1 to room 3 will have an energy cost of max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) + max(|-1000000000 + 1000000000|, |-1000000000 - 1000000000|) = 2000000000 + 1000000000 = 3000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases as they are naturally handled by the logic of calculating energy using the given formula and updating illusion rates directly.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to room illusion rates and calculating the minimum energy needed for navigation. The system must handle dynamic updates to room rates and ensure accurate energy calculations for each query.\nrequirement pool:\n- Efficient query processing for large datasets\n- Accurate energy calculation for navigation\n- Dynamic updates to room illusion rates\n- User-friendly interface for input and output\n- Scalability to handle increasing number of rooms and queries\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The Segment Tree will help in managing the dynamic updates to the illusion rates and efficiently calculating the minimum energy required for navigation between rooms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required is the maximum of the absolute sum or absolute difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb] \n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy needed to travel from room u to room v. This involves finding the path with the least energy cost.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists from the tunnel connections.\n3. Implement a DFS to traverse the tree and calculate initial energy costs between connected rooms.\n4. Use a Segment Tree to handle dynamic updates to illusion rates and efficiently compute minimum energy paths for type 2 queries.\n5. For type 1 queries, update the illusion rate of the specified room in the Segment Tree.\n6. For type 2 queries, use the Segment Tree to calculate and return the minimum energy required to travel from room u to room v.\n\n# [edge case] \n    1. Query: 2 1 1 = 0\n       Explanation: The start and end rooms are the same, so no energy is needed.\n    \n    2. Query: 2 1 n (where n is the last room) = calculated energy\n       Explanation: This tests the longest possible path in the tree, ensuring that the algorithm handles maximum path lengths correctly.\n    \n    3. Query: 1 u c (where c is a large value) followed by 2 u v = recalculated energy\n       Explanation: This tests if the update mechanism correctly adjusts the energy calculations after a significant change in illusion rate.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to updates and path calculations.\n    \n```python\ndef handle_query_type_1(segment_tree, u, c):\n    # Update the illusion rate of room u to c\n    segment_tree.update(u, c)\n\ndef handle_query_type_2(segment_tree, u, v):\n    # Calculate and return the minimum energy required from room u to room v\n    return segment_tree.query(u, v)\n\n# Additional logic for handling updates and queries efficiently\n```\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to room illusion rates and calculating the minimum energy needed for traversal. The solution must handle dynamic updates to illusion rates and ensure accurate energy calculations while maintaining the integrity of the maze structure.\nrequirement pool:\n- Efficient query processing for large datasets\n- Accurate energy calculations for room traversal\n- Dynamic updates to room illusion rates\n- Maintain maze integrity during queries\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The Segment Tree will help in managing dynamic updates to the illusion rates and efficiently calculating the minimum energy required for traversal between rooms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, ensuring connectivity between rooms without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to travel between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to travel between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the max function and abs function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the smallest sum.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to traverse the tree and calculate energy for paths.\n    4. Use a Segment Tree to efficiently handle updates to illusion rates and calculate minimum energy for type 2 queries.\n    5. For type 1 queries, update the illusion rate in the Segment Tree.\n    6. For type 2 queries, use DFS and Segment Tree to find and return the minimum energy required.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: Only one path exists, and it takes max(|5 + (-5)|, |5 - (-5)|) = 10 energy.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: All rooms have zero illusion rate, so any path will have zero energy cost.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After changing the illusion rate of room 1, traveling from room 1 to room 3 takes max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000 energy.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to dynamic updates and large values.\n    \n```python\ndef update_illusion_rate(segment_tree, room_index, new_rate):\n    # Update the segment tree with new illusion rate for room_index\n    pass\n\ndef calculate_min_energy(segment_tree, start_room, end_room):\n    # Use DFS and segment tree to calculate minimum energy from start_room to end_room\n    pass\n\n# Additional logic for handling large values and ensuring efficient updates in segment tree.\n```\n", "requirement analysis:\nThe project requires handling a tree structure with dynamic updates and efficient path calculations. The main challenge is to ensure that the system can process up to 100,000 queries efficiently, especially when updating illusion rates and calculating minimum energy paths.\nrequirement pool:\n- Implement efficient data structures to handle tree operations and updates.\n- Develop algorithms to calculate minimum energy paths quickly.\n- Ensure the system can handle edge cases and invalid inputs gracefully.\n- Optimize for performance to handle the maximum input size.\n- Provide a user-friendly interface for input and output operations.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure and queries. The DFS will help in precomputing necessary information for quick path calculations, while LCA will be used to determine the path between two nodes efficiently. We will also use a Segment Tree to handle dynamic updates of the illusion rates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, ensuring connectivity between rooms without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to move between two rooms, taking the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute value.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy needed to travel from room u to room v. This involves calculating the path with the least energy consumption.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to precompute necessary information for path calculations.\n    4. Use LCA to efficiently determine paths between nodes for type 2 queries.\n    5. Implement a Segment Tree to handle dynamic updates of illusion rates for type 1 queries.\n    6. For each type 2 query, calculate the minimum energy required using precomputed information and output the result.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy calculation is straightforward using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, the energy required is zero regardless of the path.\n\n    Case 3: Maximum possible illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After changing the illusion rate of room 1, the energy calculation becomes max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS, LCA, and Segment Tree will efficiently handle these scenarios.\n", "requirement analysis:\nThe project requires efficient handling of tree structures to represent the maze and quick updates to the illusion rates. The main challenge is to compute the minimum energy path efficiently for large input sizes, ensuring the solution is scalable and responsive.\nrequirement pool:\n- Efficiently handle tree structures for the maze representation.\n- Implement quick updates to the illusion rates of rooms.\n- Calculate minimum energy paths efficiently for large datasets.\n- Ensure the solution is scalable to handle up to 100,000 queries.\n- Provide a user-friendly interface for input and output.\nWe will use a tree data structure to represent the maze, where each room is a node and each tunnel is an edge. We will use Depth First Search (DFS) to efficiently calculate the minimum energy path between two rooms. For updating the illusion rate, we will directly update the value in an array. We will use adjacency lists to represent the tree for efficient traversal and updates. The use of DFS ensures that we can handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, ensuring connectivity between rooms without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': This indicates that for type 2 queries, we need to find the path with the least energy consumption between two rooms. This can be implemented using a pathfinding algorithm like DFS or BFS to explore all possible paths and select the one with the minimum energy sum.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Implement DFS to calculate the minimum energy path between two rooms for type 2 queries.\n    3. For type 1 queries, update the illusion rate directly in the array.\n    4. For each type 2 query, use DFS to find and output the minimum energy required.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: With only two rooms, the energy calculation is straightforward using max(|5 + (-5)|, |5 - (-5)|) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, any path will have zero energy consumption.\n\n    Case 3: Large illusion rate change\n    Input:\n    ```\n    3 2\n    1000000000 -1000000000 0\n    1 2\n    2 3\n    1 1 -1000000000\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    2000000000\n    ```\n    Explanation: After changing the illusion rate of room 1, the energy calculation becomes max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and direct updates will handle these scenarios efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to maze navigation and dynamic updates to room illusion rates. The solution must handle large input sizes and ensure accurate energy calculations for navigation.\nrequirement pool:\n- Efficient query processing for large input sizes\n- Accurate energy calculations for navigation\n- Dynamic updates to room illusion rates\n- Verification of tunnel connections\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficient updates and queries. The Segment Tree will help in managing dynamic updates to the illusion rates and efficiently calculating the minimum energy required for navigation between rooms.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, ensuring connectivity between rooms without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required is the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function combined with `abs`.\n\n# [degree adverb]\n    'minimum': In the context of type 2 queries, it refers to finding the minimum sum of energy needed to travel from one room to another. This can be implemented using algorithms that find the shortest path or minimum cost in a tree structure.\n\n# [code logic]\n    - Initialize a Segment Tree to manage updates to illusion rates efficiently.\n    - Use Depth First Search (DFS) to traverse the tree and calculate paths.\n    - For type 1 queries, update the illusion rate of a specific room in the Segment Tree.\n    - For type 2 queries, calculate the minimum energy required using DFS and Segment Tree to find paths and update rates dynamically.\n\n# [edge case]\n    1. Input: 2 1\n       0 0\n       1 2\n       2 1 2\n       Expected Output: 0\n       Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    2. Input: 3 2\n       1000000000 -1000000000 0\n       1 2\n       2 3\n       2 1 3\n       Expected Output: 2000000000\n       Explanation: The maximum possible illusion rates result in maximum energy required.\n\n    3. Input: 4 3\n       5 -5 5 -5\n       1 2\n       2 3\n       3 4\n       2 1 4\n       Expected Output: 30\n       Explanation: The path from room 1 to room 4 involves alternating high illusion rates, resulting in significant energy expenditure.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree should be able to handle these scenarios efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree structure with dynamic updates and queries. The main challenge is to ensure that the solution can handle up to 100,000 rooms and queries efficiently. The solution must also be robust to handle large integer values for illusion rates and ensure accurate energy calculations.\nrequirement pool:\n- Implement efficient data structures to handle dynamic updates and queries.\n- Optimize energy calculation to ensure fast query responses.\n- Ensure the solution is robust against invalid inputs.\n- Provide clear and concise output for each query.\n- Include detailed logging for debugging and performance monitoring.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle dynamic updates and queries on the tree structure. DFS will help in traversing the tree and calculating paths, while the Segment Tree will allow for quick updates and range queries on the illusion rates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, ensuring connectivity between rooms without cycles.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy calculation when moving between rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the respective rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute value.\n\n# [degree adverb]\n    'minimum sum': This indicates that for type 2 queries, we need to find the path with the least total energy required to move from room u to room v. This can be implemented using pathfinding algorithms like DFS or Dijkstra's algorithm to find the shortest path in terms of energy.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n2. Construct the tree using adjacency lists based on the tunnel connections.\n3. Implement DFS to traverse the tree and calculate paths.\n4. Use a Segment Tree to handle dynamic updates to illusion rates efficiently.\n5. For type 1 queries, update the illusion rate of a specified room.\n6. For type 2 queries, calculate the minimum energy required to move from room u to room v using DFS or Dijkstra's algorithm.\n\n# [edge case]\n    Edge Case 1: Minimum number of rooms (n=2) with maximum illusion rates.\n    Input: \n    ```\n    2 1\n    1000000000 -1000000000\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    Explanation: The energy calculation would be max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000.\n\n    Edge Case 2: All rooms have zero illusion rate.\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: \n    Explanation: The energy calculation would be max(|0 + 0|, |0 - 0|) = 0 for all paths.\n\n    Edge Case 3: Single query with no movement (u = v).\n    Input:\n    ```\n    4 1\n    5 -5 10 -10\n    1 2\n    2 3\n    3 4\n    2 3 3\n    ```\n    Expected Output: \n    Explanation: Since u = v, no movement is needed, so the energy required is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic should handle them correctly by considering the conditions in the energy calculation and pathfinding algorithms.\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree structure representing a maze with dynamic updates to node values and path queries. The main challenge is to ensure that the solution can handle up to 100,000 rooms and queries efficiently, which suggests the need for advanced data structures like segment trees or heavy-light decomposition for optimal performance.\nrequirement pool:\n- Implement efficient data structures to handle dynamic updates and queries.\n- Ensure accurate calculation of energy requirements between rooms.\n- Optimize for performance to handle the maximum input size.\n- Design a user-friendly interface for input and output operations.\n- Provide detailed documentation and examples for users.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficiently handling updates and queries. The Segment Tree will allow us to update the illusion rates and calculate the minimum energy path efficiently. This approach is suitable for handling large input sizes and dynamic updates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree': A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n    'illusion rate': This is a value associated with each room that affects the energy calculation when moving between rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum': In the context of the type 2 query, it refers to finding the path with the least energy cost between two rooms. This can be implemented using algorithms that find minimum paths, such as Dijkstra's algorithm or BFS/DFS with appropriate conditions.\n\n# [code logic]\n    1. Parse the input to construct the tree structure using adjacency lists.\n    2. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    3. Use DFS to traverse the tree and calculate energy costs for paths.\n    4. For type 1 queries, update the Segment Tree with new illusion rates.\n    5. For type 2 queries, use DFS or another pathfinding algorithm to find the minimum energy path between specified rooms.\n\n# [edge case]\n    Case 1: Minimum number of rooms (n=2)\n    Input: \n    ```\n    2 1\n    5 -5\n    1 2\n    2 1 2\n    ```\n    Expected Output: \n    ```\n    10\n    ```\n    Explanation: The only path is from room 1 to room 2, and the energy is max(|5 + (-5)|, |5 - (-5)|) = max(0, 10) = 10.\n\n    Case 2: All illusion rates are zero\n    Input:\n    ```\n    3 1\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: All rooms have an illusion rate of zero, so any path will have zero energy cost.\n\n    Case 3: Large illusion rates\n    Input:\n    ```\n    3 1\n    1000000000 -1000000000 1000000000\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    3000000000\n    ```\n    Explanation: The path from room 1 to room 3 via room 2 will have maximum energy costs due to large illusion rates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will naturally handle these scenarios by calculating energy based on current illusion rates and tree structure.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze allows for efficient traversal and query processing.\nrequirement pool:\n- Efficiently process up to 100,000 queries\n- Accurately calculate energy requirements between rooms\n- Allow dynamic updates to room illusion rates\n- Ensure scalability for large mazes\n- Provide user-friendly interface for input and output\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the energy required for each query efficiently. We will utilize adjacency lists to represent the tree structure and segment trees to handle dynamic updates to the illusion rates. This approach ensures efficient query processing and updates, leveraging libraries like collections for adjacency list and bisect for efficient searching.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to travel between rooms. It can be dynamically changed through queries.\n\n    'tree'\n    Explanation: The maze is structured as a tree, meaning there are n rooms and n-1 tunnels, ensuring a unique path between any two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy calculation for traveling between two rooms. It requires finding the maximum of the absolute values of the sum and difference of the illusion rates of two rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'minimum'\n    Explanation: For type 2 queries, we need to find the minimum sum of energy required to travel from one room to another. This involves calculating the energy for all possible paths and selecting the smallest value.\n\n# [code logic]\n    1. Parse the input to construct the tree using adjacency lists.\n    2. Implement DFS to preprocess the tree and calculate initial energy values.\n    3. Use segment trees or similar data structures to efficiently handle updates to illusion rates.\n    4. For type 1 queries, update the illusion rate of the specified room.\n    5. For type 2 queries, calculate the minimum energy required using preprocessed data and updated rates.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so the energy required is max(|0 + 0|, |0 - 0|) = 0.\n\n    Input: 3 2\n           1000000000 -1000000000 1000000000\n           1 2\n           2 3\n           2 1 3\n           1 2 -1000000000\n    Output: 2000000000\n    Explanation: The initial energy from room 1 to room 3 is max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 2:\n            return max(abs(a[0] + a[1]), abs(a[0] - a[1]))\n        # Additional logic for handling large values and updates efficiently using segment trees or similar structures.\n"], "scores": [], "pass_results": [true, true, true, false, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 206, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "expand_one2two", "parent_index": 2}
