{"name": "1622_B. Berland Music", "description": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\n\n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "tags": ["data structures", "greedy", "math", "sortings"], "difficulty": 8, "id": 1622, "sample_io": [{"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}], "test_list": [{"input": "1\n7\n1 2 3 4 5 6 7\n0101010\n", "output": ["1 5 2 6 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n10101010101010101010101010101010101010101010101010\n", "output": ["26 1 27 2 28 3 29 4 30 5 31 6 32 7 33 8 34 9 35 10 36 11 37 12 38 13 39 14 40 15 41 16 42 17 43 18 44 19 45 20 46 21 47 22 48 23 49 24 50 25\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 4 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n3 1 2\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["2 1\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101010\n", "output": ["4 5 1 6 2 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 1 2\n1 6 5 8 2 7 4 3\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101000\n", "output": ["5 6 1 7 2 3 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n3 1 2\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n1 2 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 2 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 1 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 7 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["2 1\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01100100\n", "output": ["2 1\n3 2 1\n1 7 6 5 2 8 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n1 2 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 5 2 6 3 4 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 1 6 2 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 1 2 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n1 2 3\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 4 2 5 6 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 7 4 5 6\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111011\n", "output": ["2 1\n1 6 2 7 3 4 5\n3 4 2 8 5 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 2 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 5 6 7 2 3 4\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 6 7 1 2 3\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110100\n", "output": ["2 1\n3 2 1\n5 6 4 8 1 7 3 2\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n2 3 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1001000\n", "output": ["6 1 2 7 3 4 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00100001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 7 6 4 3 5 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n2 3 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 3 2 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n3 2 1\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n1 5 6 7 2 3 4\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010010\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 6 1 8 3 2 7 4\n"]}, {"input": "3\n2\n2 1\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 4 5 6 1 7 2\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 7 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 4 3 8 2 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111101\n", "output": ["2 1\n3 2 1\n1 4 3 8 6 5 2 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n2 3 4 5 6 1 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0110000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 7 2 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n2 1 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 6 4 7 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 3 1\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110110\n", "output": ["2 1\n3 2 1\n1 5 4 8 2 6 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n10010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 2 1 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 2 1\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 2 1\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 2 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 5 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1100010\n", "output": ["5 6 1 2 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110111\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 4 8 3 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n4 5 6 7 1 2 3\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 4 2 5 3 6 7\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 4 1 5 6 7 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110110\n", "output": ["2 1\n3 2 1\n4 5 3 8 1 6 7 2\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["1 2\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n3 4 5 6 7 1 2\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01100001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 7 6 5 3 2 4 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 7 2 3 4 5 6\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11011011\n", "output": ["2 1\n1 5 2 6 3 4 7\n3 4 1 8 5 2 7 6\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}], "task_id": "codecontest/155", "prompt": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation and each of these predicted ratings is unique. No two predicted ratings are the same.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them. Consider exploring efficient algorithms to achieve optimal permutations for large inputs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "repair_prompt": ["Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation and each of these predicted ratings is unique. No two predicted ratings are the same.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them. Consider exploring efficient algorithms to achieve optimal permutations for large inputs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation and each of these predicted ratings is unique. No two predicted ratings are the same.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song. The string s is constructed of binary numbers, namely ones and zeros, where s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold).\n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them. Consider exploring efficient algorithms to achieve optimal permutations for large inputs.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "Berland Music is a music streaming service built specifically to support Berland local artist, and its developers are currently working on a song recommendation module. So imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once\u2014in other words, p is a permutation and each of these predicted ratings is unique. After listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it. Now the service has to re-evaluate the song ratings in such a way that: * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). Among all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x. Print the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0."], "completions": ["from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings, a permutation of numbers from 1 to n.\n            - s (str): String of '0's and '1's indicating dislike and like respectively.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings\n        sorted_p = sorted(p)\n\n        # Assign the highest available ratings to liked songs\n        liked_ratings = sorted_p[-len(liked_indices):]\n        disliked_ratings = sorted_p[:len(disliked_indices)]\n\n        # Create a new permutation q\n        q = [0] * n\n        for idx, rating in zip(liked_indices, liked_ratings):\n            q[idx] = rating\n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            q[idx] = rating\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): String representing Monocarp's likes (1) and dislikes (0).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings permutations for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign ratings: highest to liked, lowest to disliked\n        q = [0] * n\n        current_rating = n\n\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of songs.\n            - p: List of predicted ratings (a permutation of numbers from 1 to n).\n            - s: String of likes ('1') and dislikes ('0').\n\n    Returns:\n        A list of lists, where each list is the re-evaluated ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices into liked and disliked based on s\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort liked indices by their predicted ratings in descending order\n        liked_indices.sort(key=lambda i: p[i], reverse=True)\n        # Sort disliked indices by their predicted ratings in ascending order\n        disliked_indices.sort(key=lambda i: p[i])\n\n        # Assign ratings from n downwards to liked songs and from 1 upwards to disliked songs\n        q = [0] * n\n        current_rating = n\n\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        p = list(map(int, input().strip().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings, a permutation of numbers from 1 to n.\n            - s (str): Feedback string, where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings for liked and disliked songs\n        liked_ratings = sorted([p[i] for i in liked_indices])\n        disliked_ratings = sorted([p[i] for i in disliked_indices])\n\n        # Assign the highest available ratings to liked songs\n        liked_ratings.sort(reverse=True)\n        # Assign the lowest available ratings to disliked songs\n        disliked_ratings.sort()\n\n        # Create a new permutation for the re-evaluated ratings\n        q = [0] * n\n        for i, index in enumerate(liked_indices):\n            q[index] = liked_ratings[i]\n        for i, index in enumerate(disliked_indices):\n            q[index] = disliked_ratings[i]\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): String indicating liked (1) or disliked (0) songs.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings permutations for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked based on the string s\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked songs in descending order and disliked songs in ascending order\n        liked.sort(reverse=True)\n        disliked.sort()\n\n        # Assign ratings such that liked songs have higher ratings than disliked ones\n        q = [0] * n\n        liked_index = 0\n        disliked_index = 0\n\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                q[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of songs.\n            - p: List of predicted ratings (a permutation of numbers from 1 to n).\n            - s: String of likes ('1') and dislikes ('0').\n\n    Returns:\n        A list of lists, where each list contains the re-evaluated ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices into liked and disliked based on s\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort liked indices by their predicted ratings in descending order\n        liked_indices.sort(key=lambda i: p[i], reverse=True)\n        # Sort disliked indices by their predicted ratings in ascending order\n        disliked_indices.sort(key=lambda i: p[i])\n\n        # Assign ratings\n        q = [0] * n\n        current_rating = n\n\n        # Assign highest ratings to liked songs\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        # Assign lowest ratings to disliked songs\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        p = list(map(int, data[index:index + n]))\n        index += n\n        s = data[index]\n        index += 1\n        test_cases.append((n, p, s))\n    \n    # Call the function and get the result\n    results = re_evaluate_ratings(t, test_cases)\n    \n    # Output interface\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings, a permutation of numbers from 1 to n.\n            - s (str): Feedback string, where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign ratings\n        q = [0] * n\n        current_rating = n\n\n        # Assign highest ratings to liked songs\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        # Assign remaining ratings to disliked songs\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on their values in p\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Assign ratings\n        q = [0] * n\n        current_rating = n\n\n        # Assign highest ratings to liked songs\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        # Assign remaining ratings to disliked songs\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating -= 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort liked and disliked indices based on their predicted ratings\n        liked_indices.sort(key=lambda x: p[x], reverse=True)\n        disliked_indices.sort(key=lambda x: p[x])\n\n        # Create a new permutation q\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    results = []\n    \n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n        \n        # Sort liked and disliked indices based on their predicted ratings\n        liked_indices.sort(key=lambda x: p[x])\n        disliked_indices.sort(key=lambda x: p[x])\n        \n        # Assign the highest available ratings to liked songs and the lowest to disliked songs\n        q = [0] * n\n        current_rating = 1\n        \n        # Assign ratings to disliked songs first\n        for index in disliked_indices:\n            q[index] = current_rating\n            current_rating += 1\n        \n        # Assign ratings to liked songs\n        for index in liked_indices:\n            q[index] = current_rating\n            current_rating += 1\n        \n        results.append(q)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n    \n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. Efficient algorithms are necessary to handle large inputs and multiple test cases.\nrequirement pool:\n- Develop the song recommendation algorithm.\n- Ensure liked songs have higher ratings than disliked ones.\n- Optimize the algorithm for large datasets.\n- Support local artists in the recommendation system.\n- Create a user-friendly interface for song feedback.\nWe will implement a function that processes each test case independently. The function will separate the songs into liked and disliked categories based on the input string. It will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring the permutation constraint is satisfied. The algorithm will be efficient enough to handle the upper limits of input size by using sorting and direct index assignments.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the predicted ratings and the new ratings must each contain every integer from 1 to n exactly once.\n\n    'liked' and 'disliked'\n    Explanation: These terms refer to Monocarp's feedback on the songs. A 'liked' song should have a higher rating than any 'disliked' song in the new permutation.\n\n# [phrase showing quantity relationship]\n    'greater than'\n    Explanation: This indicates that the rating of liked songs must be numerically higher than the rating of disliked songs. In code, this can be implemented by ensuring that the indices of liked songs are assigned higher values than those of disliked songs.\n\n# [degree adverb]\n    'smallest'\n    Explanation: The goal is to find a permutation that minimizes the sum of absolute differences between the predicted and new ratings. This can be implemented by sorting and assigning values to minimize these differences.\n\n# [code logic]\n1. For each test case, read n, p (predicted ratings), and s (like/dislike string).\n2. Separate indices of liked and disliked songs based on s.\n3. Sort the predicted ratings.\n4. Assign the highest available ratings to liked songs and the lowest to disliked songs.\n5. Ensure that the permutation constraint is satisfied by using sorting and direct index assignments.\n6. Output the new permutation for each test case.\n\n# [edge case]\n    Test case 1: n = 1, p = [1], s = \"1\"\n    Expected output: 1\n    Explanation: With only one song that is liked, the permutation remains the same.\n\n    Test case 2: n = 3, p = [3, 2, 1], s = \"000\"\n    Expected output: 1 2 3\n    Explanation: All songs are disliked, so they can be assigned the lowest possible ratings.\n\n    Test case 3: n = 4, p = [4, 3, 2, 1], s = \"1111\"\n    Expected output: 4 3 2 1\n    Explanation: All songs are liked, so they can retain their original order to minimize the sum of absolute differences.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning based on like/dislike status inherently handles these cases.\n", "requirement analysis:\nThe main requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution should handle large inputs efficiently.\nrequirement pool:\n- Develop the song recommendation algorithm\n- Ensure liked songs have higher ratings than disliked ones\n- Optimize the algorithm for large datasets\n- Support local artists in the recommendation process\n- Provide a user-friendly interface for feedback\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust the ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it refers to the unique arrangement of song ratings where each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that songs Monocarp liked should have higher ratings than those he disliked. In code, this can be implemented by ensuring that for indices i and j, if s_i=1 and s_j=0, then q_i > q_j.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation q that minimizes the sum of absolute differences between predicted and re-evaluated ratings. In code, this involves sorting and rearranging ratings to achieve the minimum possible sum.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Read n, the number of songs.\n   - Read the permutation p of predicted ratings.\n   - Read the string s representing Monocarp's likes and dislikes.\n3. Separate the indices of liked and disliked songs based on s.\n4. Sort the liked and disliked indices separately.\n5. Assign the highest available ratings to liked songs and the lowest to disliked songs while maintaining permutation constraints.\n6. Calculate the permutation q that minimizes the sum of absolute differences |p_i-q_i|.\n7. Output the permutation q for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but using p itself minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but using p itself minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (indices 1 and 3) should have higher ratings than disliked ones (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting liked and disliked songs separately and assigning ratings accordingly will handle these cases naturally.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in efficiently computing the permutation that minimizes the sum of absolute differences between predicted and re-evaluated ratings, especially for large datasets.\nrequirement pool:\n- Implement efficient permutation algorithm for song ratings.\n- Ensure liked songs have higher ratings than disliked ones.\n- Optimize for large input sizes up to 2 \u22c5 10^5.\n- Support multiple test cases efficiently.\n- Provide flexibility in output for multiple valid permutations.\nWe will implement an efficient algorithm to re-evaluate song ratings based on user feedback. The algorithm will ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences between predicted and re-evaluated ratings. We will use sorting and indexing techniques to achieve this efficiently, given the constraints on input size.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this requirement, it refers to the unique arrangement of song ratings where each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. In this requirement, it is used to calculate the sum of differences between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs. In code, this can be implemented by ensuring that for indices i and j, if s_i=1 and s_j=0, then q_i > q_j.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation q that minimizes the sum of absolute differences between predicted and re-evaluated ratings. In code, this can be implemented by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, the permutation p, and the string s.\n    3. Separate indices into liked and disliked based on s.\n    4. Sort the liked indices in descending order and disliked indices in ascending order.\n    5. Assign ratings from n downwards to liked songs and from 1 upwards to disliked songs.\n    6. Calculate the permutation q and ensure it minimizes the sum of absolute differences.\n    7. Output the permutation q for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: \n    3\n    3\n    3 1 2\n    111\n    Expected Output: \n    3 1 2\n    Explanation: Since all songs are liked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: \n    3\n    3\n    3 1 2\n    000\n    Expected Output: \n    1 2 3\n    Explanation: Since all songs are disliked, they should be assigned the lowest possible ratings.\n\n    Test case with alternating likes and dislikes:\n    Input: \n    4\n    4\n    4 3 2 1\n    1010\n    Expected Output: \n    4 1 3 2\n    Explanation: Liked songs (indices 1 and 3) should have higher ratings than disliked songs (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting liked and disliked indices separately and assigning ratings accordingly will handle these cases naturally.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. Efficient algorithms are necessary to handle large inputs and multiple test cases.\nrequirement pool:\n- Develop the song recommendation algorithm.\n- Ensure liked songs have higher ratings than disliked ones.\n- Optimize for minimal difference between predicted and re-evaluated ratings.\n- Implement efficient handling of large inputs.\n- Create a visually appealing and responsive UI.\nWe will implement a function that processes each test case independently. For each test case, we will separate the songs into two groups based on Monocarp's feedback: liked and disliked. We will then assign the highest available ratings to the liked songs and the lowest available ratings to the disliked songs. This ensures that all liked songs have higher ratings than disliked ones. We will use sorting to efficiently assign ratings while minimizing the absolute difference between predicted and re-evaluated ratings.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the predicted ratings and the re-evaluated ratings are unique and cover all integers from 1 to n.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that the liked songs should have a higher rating than the disliked songs. In code, this can be implemented by ensuring that all liked songs are assigned higher numbers than disliked ones.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between predicted and re-evaluated ratings. In code, this can be achieved by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n1. For each test case, read the number of songs, predicted ratings, and feedback string.\n2. Separate the indices of liked and disliked songs based on the feedback string.\n3. Sort the predicted ratings of liked and disliked songs separately.\n4. Assign the highest available ratings to liked songs and the lowest available ratings to disliked songs.\n5. Construct the new permutation by placing these assigned ratings back in their original positions.\n6. Output the new permutation for each test case.\n\n# [edge case]\n    Test case 1: \n    Input: 1\n           1\n           1\n           0\n    Output: 1\n    Explanation: With only one song that is disliked, it retains its original rating.\n\n    Test case 2:\n    Input: 2\n           2 1\n           01\n    Output: 1 2\n    Explanation: The disliked song gets the lowest rating, and the liked song gets the highest rating.\n\n    Test case 3:\n    Input: 3\n           3 2 1\n           000\n    Output: 1 2 3\n    Explanation: All songs are disliked, so they retain their original order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on feedback will naturally handle these cases.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in optimizing the permutation to minimize the sum of absolute differences between predicted and new ratings, ensuring liked songs have higher ratings than disliked ones.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback.\n- Ensure permutation of song ratings is maintained.\n- Optimize algorithm for large input sizes.\n- Develop user interface for seamless song browsing.\n- Integrate local artist support features.\nWe will implement a function to re-evaluate song ratings based on user feedback using efficient sorting and permutation techniques. The approach will involve separating liked and disliked songs, sorting them, and then merging them to form a valid permutation. We will use Python's built-in sorting capabilities to ensure optimal performance for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the ratings must be rearranged such that each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its non-negative value without regard to its sign. Here, it is used to calculate the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that songs liked by Monocarp should have higher ratings than those disliked.\n    Implementation: Ensure that for all indices i and j, if s_i=1 and s_j=0, then q_i > q_j.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation q that minimizes the sum of absolute differences between p and q.\n    Implementation: Sort liked songs to have higher ratings and disliked songs to have lower ratings, minimizing the sum of differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Separate songs into liked and disliked based on the string s.\n   - Sort the liked songs in descending order and disliked songs in ascending order.\n   - Assign ratings such that liked songs have higher ratings than disliked ones.\n   - Calculate the permutation q that minimizes the sum of absolute differences.\n3. Output the permutation q for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but the one equal to p minimizes the sum of differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but the one equal to p minimizes the sum of differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (4, 2) should have higher ratings than disliked (3, 1), minimizing the sum of differences.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting liked and disliked songs separately and merging them ensures correct handling of edge cases.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. Efficient algorithms are necessary to handle large inputs and multiple test cases.\nrequirement pool:\n- Implement song recommendation algorithm that respects user feedback.\n- Ensure permutation of song ratings with minimal absolute difference.\n- Optimize algorithm for large datasets and multiple test cases.\n- Enhance user interface for better engagement.\n- Support local artists through targeted recommendations.\nWe will implement a function that processes each test case independently. For each test case, we will separate the songs into two groups based on Monocarp's feedback: liked and disliked. We will then assign the highest available ratings to the liked songs and the lowest available ratings to the disliked songs. This ensures that all liked songs have higher ratings than disliked ones. We will use sorting to efficiently assign ratings while minimizing the sum of absolute differences between predicted and re-evaluated ratings.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the predicted ratings are unique and each integer from 1 to n appears exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. Here, it is used to minimize the difference between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs. In code, this can be implemented by ensuring that the ratings assigned to liked songs are numerically higher than those assigned to disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between predicted and re-evaluated ratings. In code, this can be achieved by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, the permutation p, and the string s.\n3. Separate indices into liked and disliked based on s.\n4. Sort the indices of liked songs in descending order and disliked songs in ascending order.\n5. Assign the highest available ratings to liked songs and lowest available ratings to disliked songs.\n6. Construct the permutation q based on these assignments.\n7. Output the permutation q for each test case.\n\n# [edge case]\n    Test case with all songs liked: \n    Input: 3, 1 2 3, 111\n    Output: 1 2 3\n    Explanation: Since all songs are liked, the original permutation is already optimal.\n\n    Test case with all songs disliked:\n    Input: 3, 3 2 1, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, assigning the lowest ratings in ascending order minimizes the sum of differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 3 4 1 2\n    Explanation: Liked songs (indices 1 and 3) get higher ratings than disliked ones (indices 2 and 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on likes and dislikes inherently handles these scenarios efficiently.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution must handle multiple test cases efficiently and adhere to the input-output format.\nrequirement pool:\n- Implement the song recommendation algorithm.\n- Ensure the algorithm efficiently handles up to 10,000 test cases.\n- Develop a responsive UI for seamless user experience.\n- Integrate user feedback to influence future recommendations.\n- Enhance the accuracy of song recommendations.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust the ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this efficiently. The solution will handle up to 10,000 test cases and ensure the sum of absolute differences is minimized.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this requirement, the predicted ratings and the re-evaluated ratings must both be permutations of numbers from 1 to n.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. In this requirement, it is used to calculate the sum of differences between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs. In code, this can be implemented by ensuring that all liked songs are assigned higher numbers than disliked songs.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation that minimizes the sum of absolute differences between predicted and re-evaluated ratings. In code, this can be implemented by sorting and assigning ratings in a way that minimizes these differences.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Read the number of songs, predicted ratings, and Monocarp's feedback.\n   - Separate the indices of liked and disliked songs.\n   - Sort the liked and disliked indices based on their predicted ratings.\n   - Assign the highest available ratings to liked songs and lowest to disliked songs.\n   - Ensure the permutation minimizes the sum of absolute differences.\n3. Output the re-evaluated ratings for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 3 1 2, 111\n    Output: 3 1 2\n    Explanation: Since all songs are liked, any permutation works, but using the original order minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 1 2, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but using the original order minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 4 1 3 2\n    Explanation: Liked songs (indices 0 and 2) get higher ratings than disliked songs (indices 1 and 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and assigning ratings based on feedback will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences between predicted and re-evaluated ratings.\nrequirement pool:\n- Implement the song recommendation algorithm.\n- Ensure the algorithm respects user feedback (likes/dislikes).\n- Optimize the algorithm for performance with large datasets.\n- Support multiple test cases efficiently.\n- Provide a user-friendly interface for feedback.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust the ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the predicted ratings and the new ratings both need to be unique sequences of numbers from 1 to n.\n\n    'liked' and 'disliked'\n    Explanation: These terms refer to Monocarp's feedback on the songs. A 'liked' song should have a higher rating than any 'disliked' song in the new permutation.\n\n# [phrase showing quantity relationship]\n    'greater than'\n    Explanation: This indicates that the new rating for a liked song must be numerically higher than the rating for any disliked song. In code, this can be implemented by ensuring that all liked songs are assigned higher numbers than disliked songs.\n\n# [degree adverb]\n    'smallest'\n    Explanation: The goal is to find a permutation that minimizes the sum of absolute differences between the predicted and new ratings. This means we need to find the permutation with the least total change from the original ratings.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n, the permutation p, and the string s.\n3. Separate the indices of liked and disliked songs based on s.\n4. Sort the liked and disliked indices based on their values in p.\n5. Assign the highest available ratings to liked songs and the lowest to disliked songs to ensure q is a permutation.\n6. Calculate q such that it minimizes the sum of absolute differences with p.\n7. Output q for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 1 2 3, 111\n    Expected output: 1 2 3\n    Explanation: Since all songs are liked, the permutation can remain unchanged.\n\n    Test case with all songs disliked:\n    Input: 3, 3 2 1, 000\n    Expected output: 1 2 3\n    Explanation: Since all songs are disliked, they can be assigned any permutation, but we choose the one closest to p.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Expected output: 3 4 1 2\n    Explanation: Liked songs (1st and 3rd) get higher ratings than disliked (2nd and 4th).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting liked and disliked songs separately and assigning ratings accordingly will handle these cases effectively.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences between predicted and re-evaluated ratings. The solution must handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation algorithm ensuring liked songs have higher ratings than disliked ones.\n- Optimize the algorithm to minimize the sum of absolute differences between predicted and re-evaluated ratings.\n- Ensure the solution can handle up to 10,000 test cases efficiently.\n- Develop a responsive UI for user interaction with song recommendations.\n- Integrate local artist support features into the recommendation module.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust their ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this, ensuring the solution is optimal given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the predicted ratings and the re-evaluated ratings must each contain every integer from 1 to n exactly once.\n\n    'absolute value'\n    Explanation: The absolute value of a number is its distance from zero on the number line, without considering direction. Here, it is used to minimize the sum of differences between predicted and re-evaluated ratings.\n\n# [phrase showing quantity relationship]\n    'greater than': This indicates that liked songs should have higher ratings than disliked songs. In code, this can be implemented by ensuring that for indices i and j, if s_i=1 and s_j=0, then q_i > q_j.\n\n# [degree adverb]\n    'smallest': This refers to finding the permutation q that minimizes the sum of absolute differences between p and q. In code, this involves sorting and rearranging elements to achieve the minimum possible sum.\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read n, the permutation p, and the string s.\n    3. Separate indices into liked and disliked based on s.\n    4. Sort the liked indices in descending order and disliked indices in ascending order.\n    5. Assign ratings such that liked songs have higher ratings than disliked songs.\n    6. Calculate the permutation q that minimizes the sum of absolute differences.\n    7. Output the permutation q for each test case.\n\n# [edge case]\n    Test case with all songs liked:\n    Input: 3, 1 2 3, 111\n    Output: 1 2 3\n    Explanation: Since all songs are liked, any permutation works, but the one equal to p minimizes the sum of absolute differences.\n\n    Test case with all songs disliked:\n    Input: 3, 3 2 1, 000\n    Output: 1 2 3\n    Explanation: Since all songs are disliked, any permutation works, but sorting them in ascending order minimizes the sum of absolute differences.\n\n    Test case with alternating likes and dislikes:\n    Input: 4, 4 3 2 1, 1010\n    Output: 3 4 1 2\n    Explanation: Liked songs (indices 0 and 2) should have higher ratings than disliked songs (indices 1 and 3). The permutation minimizes the sum of absolute differences.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting liked and disliked songs separately and assigning ratings accordingly will handle these cases effectively.\n", "requirement analysis:\nThe main requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution should handle large inputs efficiently.\nrequirement pool:\n- Develop the song recommendation algorithm to re-evaluate ratings based on user feedback.\n- Ensure the algorithm can handle up to 200,000 songs efficiently.\n- Support local artists by prioritizing their songs in recommendations.\n- Implement a user-friendly interface for liking and disliking songs.\n- Provide analytics for artists to understand their song performance.\nWe will implement a function to re-evaluate song ratings based on user feedback using efficient sorting and permutation techniques. The approach will involve separating liked and disliked songs, sorting them, and then merging them to form the new permutation. We will use Python's built-in sorting capabilities to ensure efficiency, especially for large inputs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'permutation'\n    Explanation: A permutation is a rearrangement of elements in a particular order. In this context, it means that the predicted ratings and the new ratings must each be a unique sequence of numbers from 1 to n.\n\n    'like or dislike'\n    Explanation: This refers to Monocarp's feedback on each song, where '1' indicates a like and '0' indicates a dislike. The new ratings must ensure that all liked songs have higher ratings than disliked ones.\n\n# [phrase showing quantity relationship]\n    'greater than': \n    Explanation: For every song Monocarp liked, its new rating must be greater than the new rating of any song he disliked. This can be implemented by ensuring that all liked songs are assigned higher numbers in the permutation than disliked songs.\n\n# [degree adverb] \n    'smallest': \n    Explanation: Among all valid permutations, we need to find one that minimizes the sum of absolute differences between the predicted and new ratings. This involves minimizing \u2211_{i=1}^n |p_i-q_i|.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case:\n   - Read n, the permutation p, and the string s.\n   - Separate the indices of liked and disliked songs based on s.\n   - Sort the liked and disliked indices based on their predicted ratings.\n   - Assign the highest available ratings to liked songs and the lowest to disliked songs.\n   - Construct the new permutation q by merging these two sorted lists.\n3. Output the new permutation for each test case.\n\n# [edge case] \n    Test case 1: \n    Input: 1 1 1\n    Output: 1\n    Explanation: With only one song, it is both liked and disliked, so it retains its original rating.\n\n    Test case 2:\n    Input: 3 3 2 1 000\n    Output: 1 2 3\n    Explanation: All songs are disliked, so they can be assigned any permutation of ratings.\n\n    Test case 3:\n    Input: 4 4 3 2 1 1111\n    Output: 4 3 2 1\n    Explanation: All songs are liked, so they retain their original order to minimize the sum of absolute differences.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and merging based on likes and dislikes inherently handles these scenarios.\n"], "scores": [], "pass_results": [false, false, false, false, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 456, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "mutate_method": "add_1_sentence_at_end", "parent_index": 173}
