{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM uncovered a rectangular area A with size dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nRemember that there should be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM uncovered a rectangular area A with size dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nRemember that there should be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM uncovered a rectangular area A with size dimensions n by m. There are n rows and m columns of blocks. Each block in the rectangle is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block in a single operation. You can make this switch as often as you need until all blocks are as desired.\n\nA rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nRemember that there should be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "CQXYM uncovered a rectangular area A with size dimensions n by m, consisting of n rows and m columns of blocks, in which each block is either an obsidian block or an empty block, and CQXYM can switch an obsidian block to an empty block or an empty block to an obsidian block with a single operation. A rectangle M of size a \u00d7 b is referred to as a portal if and only if it meets the following criteria:\n\n  * a \u2265 5,b \u2265 4, meaning it is necessary that the quantity of rows is not less than 5 and the number of columns is not less than 4.\n  * For every 1 < x < a, the blocks M_{x,1} and M_{x,b} need to be obsidian blocks.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks.\n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type.\n\nRemember that there should be a rows and b columns, not b rows and a columns.\n\nCQXYM wants to determine the minimum number of operations needed to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples containing grid dimensions and grid data.\n\n    Returns:\n        list: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and transform border blocks\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n\n    # Check and transform inner blocks\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions (n, m) and the matrix.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        if n < 5 or m < 4:\n            results.append(float('inf'))  # Impossible to form a portal\n            continue\n\n        # Convert matrix to numpy array for efficient operations\n        grid = np.array([[int(char) for char in row] for row in matrix])\n\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and transform the borders\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n\n    # Check and transform the inner blocks\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to create a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix) where matrix is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for easier manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of operations needed to transform this sub-rectangle into a portal\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param grid: The grid representing the blocks\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check and count necessary changes for the border conditions\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n\n    # Check and count necessary changes for the interior conditions\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to create a portal for each test case.\n    \n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing n, m, and the matrix as a list of strings.\n    \n    Returns:\n        list: List of integers representing the minimum operations for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient manipulation\n        matrix_np = np.array([list(map(int, row)) for row in matrix])\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n        \n        # Iterate over all possible submatrices of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate the number of operations needed to transform the submatrix into a portal\n                        operations = calculate_operations(matrix_np, start_row, start_col, a, b)\n                        # Update the minimum operations if a smaller value is found\n                        min_operations = min(min_operations, operations)\n        \n        # Append the result for the current test case\n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a submatrix into a portal.\n    \n    Args:\n        matrix (np.ndarray): The matrix as a numpy array.\n        start_row (int): The starting row of the submatrix.\n        start_col (int): The starting column of the submatrix.\n        a (int): The number of rows in the submatrix.\n        b (int): The number of columns in the submatrix.\n    \n    Returns:\n        int: The number of operations needed.\n    \"\"\"\n    operations = 0\n    \n    # Check the border conditions for obsidian blocks\n    for x in range(1, a - 1):\n        if matrix[start_row + x, start_col] == 0:\n            operations += 1\n        if matrix[start_row + x, start_col + b - 1] == 0:\n            operations += 1\n    \n    for y in range(1, b - 1):\n        if matrix[start_row, start_col + y] == 0:\n            operations += 1\n        if matrix[start_row + a - 1, start_col + y] == 0:\n            operations += 1\n    \n    # Check the inner conditions for empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[start_row + x, start_col + y] == 1:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for case_index in range(t):\n        grid = test_cases[case_index]\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed for this sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and count operations for the border conditions\n    for x in range(start_row + 1, end_row):\n        if grid[x][start_col] != '1':\n            operations += 1\n        if grid[x][end_col] != '1':\n            operations += 1\n\n    for y in range(start_col + 1, end_col):\n        if grid[start_row][y] != '1':\n            operations += 1\n        if grid[end_row][y] != '1':\n            operations += 1\n\n    # Check and count operations for the interior conditions\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x][y] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([[int(char) for char in row] for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_rect, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be transformed.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and count operations for the boundary conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n\n    # Check and count operations for the inner empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing dimensions and matrix of blocks.\n\n    Returns:\n        list: Minimum operations needed for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_operations = float('inf')\n\n        # Convert matrix to numpy array for efficient operations\n        np_matrix = np.array(matrix)\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = np_matrix[i:i+a, j:j+b]\n\n                        # Calculate operations needed to transform sub-rectangle into a portal\n                        operations = calculate_operations(sub_rect, a, b)\n\n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): Sub-rectangle of blocks.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Ensure border blocks are obsidian\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n\n    # Ensure inner blocks are empty\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\n\n# Initialize list to store test cases\ntest_cases = []\n\n# Read each test case\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().strip())) for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and store the result\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\n# Print each result in a new line\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to make at least one sub-rectangle a portal.\n\n    Parameters:\n    t (int): Number of test cases.\n    test_cases (list): A list of tuples, each containing n, m, and a 2D list representing the grid.\n\n    Returns:\n    list: A list of integers, each representing the minimum operations for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n\n        # Convert grid to numpy array for efficient manipulation\n        grid_np = np.array(grid)\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_np[start_row:start_row + a, start_col:start_col + b]\n\n                        # Calculate the number of operations needed to convert this sub-rectangle into a portal\n                        operations = calculate_operations(sub_rect, a, b)\n\n                        # Track the minimum operations needed\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Parameters:\n    sub_rect (np.ndarray): The sub-rectangle to be converted.\n    a (int): Number of rows in the sub-rectangle.\n    b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n    int: The number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check border conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n\n    # Check inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nnum_cases = int(input())\ntest_cases = []\nfor _ in range(num_cases):\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(num_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_operations_to_portal(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible dimensions a x b where a \u2265 5 and b \u2265 4\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        operations = 0\n\n                        # Check the conditions for the sub-rectangle to be a portal\n                        for x in range(start_row, start_row + a):\n                            for y in range(start_col, start_col + b):\n                                if (x == start_row or x == start_row + a - 1) and (y > start_col and y < start_col + b - 1):\n                                    # Border rows (except corners) should be obsidian\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                                elif (y == start_col or y == start_col + b - 1) and (x > start_row and x < start_row + a - 1):\n                                    # Border columns (except corners) should be obsidian\n                                    if grid[x][y] != '1':\n                                        operations += 1\n                                elif (x > start_row and x < start_row + a - 1) and (y > start_col and y < start_col + b - 1):\n                                    # Inner blocks should be empty\n                                    if grid[x][y] != '0':\n                                        operations += 1\n\n                        # Track the minimum number of operations across all sub-rectangles\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to create a portal for each test case.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate operations needed to transform the sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param grid: The grid as a numpy array\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n\n    # Check the borders and interior of the sub-rectangle\n    for i in range(a):\n        for j in range(b):\n            current_value = grid[start_row + i, start_col + j]\n            if i == 0 or i == a - 1 or j == 0 or j == b - 1:\n                # Border conditions\n                if (i == 0 or i == a - 1) and 1 < j < b - 1:\n                    # Top and bottom borders need to be obsidian\n                    if current_value == 0:\n                        operations += 1\n                elif (j == 0 or j == b - 1) and 1 < i < a - 1:\n                    # Left and right borders need to be obsidian\n                    if current_value == 0:\n                        operations += 1\n            else:\n                # Interior needs to be empty\n                if current_value == 1:\n                    operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Function call\nresults = min_operations_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires identifying a sub-rectangle within a given grid that can be transformed into a 'portal' with the minimum number of operations. The constraints ensure that the solution must be efficient due to the potential size of the grid. The solution should iterate over possible sub-rectangles and calculate the number of operations needed to transform them into a portal, keeping track of the minimum operations required.\nrequirement pool:\n- Implement an efficient algorithm to find the minimum operations for transforming a sub-rectangle into a portal.\n- Ensure the solution handles edge cases and large inputs effectively.\n- Optimize the algorithm to reduce time complexity.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal according to the given criteria. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle within the given grid that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching a block from obsidian to empty or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': \n    Explanation: The sub-rectangle must have at least 5 rows and 4 columns. In code, this means iterating over sub-rectangles with dimensions starting from 5x4.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the dimensions of each grid.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid with all blocks as obsidian (1)\n    Explanation: The minimum operations would be to convert the inner blocks to empty (0) while keeping the border as obsidian.\n    \n    Case 2: A grid with all blocks as empty (0)\n    Explanation: The minimum operations would be to convert the border blocks to obsidian (1) while keeping the inner blocks empty.\n    \n    Case 3: A grid with alternating blocks\n    Explanation: The operations would depend on the specific arrangement but generally involve converting alternating blocks to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        # Example code snippet for handling edge cases\n        def handle_edge_cases(grid):\n            # Check if all blocks are obsidian\n            if all(block == '1' for row in grid for block in row):\n                # Calculate operations needed to convert inner blocks to empty\n                pass\n            \n            # Check if all blocks are empty\n            elif all(block == '0' for row in grid for block in row):\n                # Calculate operations needed to convert border blocks to obsidian\n                pass\n            \n            # Handle alternating blocks\n            else:\n                # Calculate operations based on specific arrangement\n                pass\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient for large matrices, and the algorithm should be able to handle multiple test cases in a single run. The solution should focus on optimizing the number of operations while ensuring correctness.\nrequirement pool:\n- Develop an efficient algorithm to minimize operations\n- Ensure the solution handles all edge cases\n- Optimize for large input sizes\n- Provide clear documentation and examples\n- Implement additional test cases for validation\nWe will use a dynamic programming approach to efficiently calculate the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, keeping track of the minimum cost. We will utilize numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle within the given rectangle that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching a block from obsidian to empty or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': \n    Explanation: The portal must have at least 5 rows and 4 columns. In code, this means checking sub-rectangles of size at least 5x4.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal.\n    4. Keep track of the minimum number of operations for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case] \n    Case 1: A rectangle with all blocks already forming a portal.\n    Explanation: The expected output is 0 since no operations are needed.\n    \n    Case 2: A rectangle with no possible portal due to insufficient dimensions.\n    Explanation: The expected output should be handled gracefully, possibly returning a large number indicating impossibility.\n    \n    Case 3: A rectangle with exactly one possible portal configuration.\n    Explanation: The expected output is the number of operations needed to transform that configuration.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 5 or m < 4:\n            return float('inf') # or some large number indicating impossibility\n        (other code for handling portals)\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints are clear, with specific conditions for the portal structure. The solution must efficiently handle multiple test cases and large matrices, ensuring accurate computation and output.\nrequirement pool:\n- Implement efficient algorithm to determine minimum operations\n- Ensure solution handles maximum constraints effectively\n- Provide clear output format for user understanding\n- Optimize performance for large input sizes\n- Include detailed comments for code clarity\nWe will implement a function to determine the minimum number of operations needed to transform a given sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of operations required to convert each into a portal. We will use numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is defined as a sub-rectangle of size a \u00d7 b (where a \u2265 5 and b \u2265 4) that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means that the sub-rectangle must have at least 5 rows and 4 columns.\n    '1 < x < a': This indicates that the condition applies to rows between the first and last row of the sub-rectangle.\n    '1 < x < b': This indicates that the condition applies to columns between the first and last column of the sub-rectangle.\n\n# [degree adverb]\n    'minimum': This means we need to find the smallest number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangle.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met by checking and counting necessary changes.\n   - Ensure the interior conditions are met by checking and counting necessary changes.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: \n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: \n    0\n    Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    Case 2: \n    Input: \n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: \n    12\n    Explanation: All border blocks need to be converted to obsidian, and all interior blocks need to be empty, requiring a total of 12 operations.\n\n    Case 3: \n    Input: \n    1\n    6 5\n    11111\n    10001\n    10001\n    10001\n    10001\n    11111\n    Expected Output: \n    0\n    Explanation: The rectangle already satisfies the portal conditions, so no operations are needed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on dimensions and block types are crucial for ensuring the portal's validity. The solution must efficiently handle multiple test cases and large matrices while providing accurate results.\nrequirement pool:\n- Implement the main algorithm to transform blocks into a portal\n- Optimize the solution for handling large matrices efficiently\n- Provide clear documentation of the transformation process\n- Ensure the solution is scalable for multiple test cases\n- Develop a user-friendly interface for input and output\nWe will implement a function to determine the minimum number of operations needed to transform a given matrix into a portal. The function will iterate over all possible submatrices of size at least 5x4 and calculate the number of operations required to convert each submatrix into a portal. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of the given matrix that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': This indicates that for rows between the first and last, certain blocks must be obsidian.\n    'For all 1 < x < b': This indicates that for columns between the first and last, certain blocks must be obsidian.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to retrieve the number of test cases and the dimensions of each matrix.\n    2. For each test case, iterate over all possible submatrices of size at least 5x4.\n    3. For each submatrix, check if it can be transformed into a portal by counting the number of operations needed.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A matrix with exactly one portal already formed.\n    Explanation: The expected output is 0 since no operations are needed.\n    \n    Case 2: A matrix with no obsidian blocks.\n    Explanation: The expected output is the number of operations needed to form a portal from scratch.\n    \n    Case 3: A matrix where all blocks are obsidian.\n    Explanation: The expected output is the number of operations needed to convert the necessary blocks to empty blocks to form a portal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if a portal already exists and return 0 if true.\n        - Implement logic to handle matrices with all empty or all obsidian blocks efficiently.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangular area into a portal with minimal operations. The constraints on dimensions and block types are crucial for determining the operations needed. Efficient handling of multiple test cases is essential due to the potential size of inputs.\nrequirement pool:\n- Implement the main algorithm to transform the rectangle into a portal.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles edge cases effectively.\n- Provide clear output for each test case.\n- Allow for efficient input handling of multiple test cases.\nWe will implement a function to determine the minimum number of operations needed to transform a given rectangular area into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations required to convert each into a portal. We will use efficient iteration and calculation to handle the constraints of up to 400x400 blocks. The solution will focus on minimizing operations and handling multiple test cases efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b (where a \u2265 5 and b \u2265 4) that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    '1 < x < a': This indicates that for rows between the second and the second-to-last, certain conditions must be met.\n    '1 < x < b': This indicates that for columns between the second and the second-to-last, certain conditions must be met.\n\n# [degree adverb]\n    'minimum': This means we need to find the smallest number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each rectangular area.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n   - Ensure the border conditions are met by checking and counting necessary changes.\n   - Ensure the interior conditions are met by checking and counting necessary changes.\n4. Track the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle that is already a portal.\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The rectangle already satisfies all portal conditions, so no operations are needed.\n\n    Case 2: A rectangle with all blocks as obsidian.\n    Input:\n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 12\n    Explanation: The interior blocks need to be converted to empty blocks, requiring multiple operations.\n\n    Case 3: A rectangle with alternating blocks.\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: Depends on specific arrangement; requires calculation.\n    Explanation: The pattern requires careful selection of sub-rectangle to minimize operations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangular area into a portal with specific obsidian and empty block configurations. The challenge lies in minimizing the number of operations required to achieve this transformation across multiple test cases, while adhering to constraints on the dimensions of the rectangle and the portal.\nrequirement pool:\n- Implement the main algorithm to transform the rectangle into a portal\n- Optimize the algorithm for large input sizes\n- Ensure the solution is easy to understand and maintain\n- Provide detailed documentation for the algorithm\n- Include test cases to validate the solution\nWe will implement a function to determine the minimum number of operations needed to transform a given rectangular area into a portal. The approach will involve iterating over possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle and calculating the number of operations required to convert each sub-rectangle into a portal. We will use numpy for efficient matrix manipulation and calculation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle within the given rectangle that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    'For every 1 < x < a': This indicates that for rows between the first and last, certain blocks must be obsidian.\n    'For all 1 < x < b': This indicates that for columns between the first and last, certain blocks must be obsidian.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required to transform a sub-rectangle into a portal.\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each rectangle.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b.\n    3. For each sub-rectangle, calculate the number of operations needed to convert it into a portal.\n    4. Keep track of the minimum number of operations required for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A rectangle already in portal form\n    Explanation: If a rectangle is already in portal form, no operations are needed, so the expected output is 0.\n    \n    Case 2: A rectangle with all blocks as obsidian\n    Explanation: The maximum number of operations will be needed to convert inner blocks to empty blocks while maintaining the portal structure.\n    \n    Case 3: A rectangle with all blocks as empty\n    Explanation: The maximum number of operations will be needed to convert boundary blocks to obsidian while maintaining the portal structure.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if a rectangle is already in portal form and return 0 immediately.\n        - Implement logic to efficiently calculate operations for rectangles with uniform block types (all obsidian or all empty).\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must be optimized to handle the maximum input size efficiently. The key challenge is to ensure the algorithm can quickly identify the optimal sub-rectangle and calculate the necessary operations.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for a portal.\n- Ensure the solution handles edge cases and maximum constraints.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for speed and efficiency.\n- Implement robust error handling for invalid inputs.\nWe will use a dynamic programming approach to efficiently find the minimum number of operations needed to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, keeping track of the minimum cost. We will utilize numpy for efficient matrix operations and manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'obsidian block' and 'empty block'\n    Explanation: These are the two types of blocks in the rectangular area. An obsidian block is represented by '1', and an empty block is represented by '0'.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4'\n    Explanation: The portal must have at least 5 rows and 4 columns. This means any sub-rectangle considered must meet these minimum dimensions.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and dimensions of each test case.\n    2. For each test case, iterate over all possible sub-rectangles of size a \u00d7 b where a \u2265 5 and b \u2265 4.\n    3. For each sub-rectangle, calculate the number of operations needed to transform it into a portal:\n        - Ensure the border blocks are obsidian as per the portal criteria.\n        - Ensure the inner blocks are empty.\n    4. Keep track of the minimum number of operations needed for each test case.\n    5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: Minimum size portal\n    Input: \n    1\n    5 4\n    1111\n    1111\n    1111\n    1111\n    1111\n    Expected Output: 0\n    Explanation: The entire rectangle is already a portal, so no operations are needed.\n\n    Case 2: All blocks are empty\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be converted to obsidian, requiring a total of 12 operations.\n\n    Case 3: Mixed blocks with no clear portal\n    Input:\n    1\n    6 5\n    10101\n    01010\n    10101\n    01010\n    10101\n    01010\n    Expected Output: (calculated based on specific transformation)\n    Explanation: The pattern requires strategic conversion to meet portal criteria.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement checks for minimum size portal directly.\n        - Implement logic to handle all empty blocks efficiently.\n        - Use dynamic programming to efficiently calculate transformations for mixed patterns.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangular area into a portal with minimal operations. The constraints on dimensions and block types are critical for ensuring the portal's validity. Efficient handling of multiple test cases and large input sizes is essential.\nrequirement pool:\n- Implement the main algorithm to transform the area into a portal.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output format.\n- Test the solution with various input sizes and scenarios.\nWe will implement a function to determine the minimum number of operations needed to transform a given rectangular area into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and checking the number of operations required to convert it into a valid portal. We will use numpy for efficient matrix manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b (where a \u2265 5 and b \u2265 4) that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    '1 < x < a': This indicates that for rows between the second and the second-to-last, specific conditions must be met.\n    '1 < x < b': This indicates that for columns between the second and the second-to-last, specific conditions must be met.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases and the dimensions of each test case.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the number of operations needed:\n   - Ensure the border conditions are met for obsidian blocks.\n   - Ensure the inner conditions are met for empty blocks.\n4. Track the minimum number of operations needed across all possible sub-rectangles for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid that is already a portal\n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: The grid already satisfies the portal conditions, so no operations are needed.\n\n    Case 2: A grid with no obsidian blocks\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be converted to obsidian, and all inner blocks need to remain empty.\n\n    Case 3: A grid with maximum dimensions but minimal changes needed\n    Input:\n    1\n    400 400\n    (A grid where only a small section needs conversion)\n    Expected Output: (depends on specific section needing conversion)\n    Explanation: The output will depend on the specific section of the grid that needs conversion to form a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating the minimum operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient due to the potential size of the input. The solution should focus on optimizing the number of operations while ensuring correctness.\nrequirement pool:\n- Develop an efficient algorithm to minimize operations.\n- Ensure the solution handles all edge cases.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation.\n- Implement additional test cases for validation.\nWe will use a brute-force approach to check all possible sub-rectangles of size a x b (where a >= 5 and b >= 4) within the given n x m grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will iterate over all possible top-left corners of the sub-rectangles and check the conditions for a portal, counting the necessary changes. This approach is simple and ensures correctness, but may not be the most efficient for the largest inputs. However, given the constraints, it should be feasible.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a x b within the grid that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions meeting these minimum requirements.\n\n    '1 < x < a': This indicates that the condition applies to rows between the first and last row of the sub-rectangle.\n    Implementation: Loop through rows from 2 to a-1.\n\n    '1 < x < b': This indicates that the condition applies to columns between the first and last column of the sub-rectangle.\n    Implementation: Loop through columns from 2 to b-1.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Iterate over all possible top-left corners of sub-rectangles within the grid.\n2. For each top-left corner, iterate over all possible dimensions a x b where a \u2265 5 and b \u2265 4.\n3. For each sub-rectangle, check the conditions for it to be a portal:\n   - Ensure the border blocks (except corners) are obsidian.\n   - Ensure the inner blocks are empty.\n4. Count the number of operations needed to transform the current sub-rectangle into a portal.\n5. Track the minimum number of operations across all sub-rectangles.\n6. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid where all blocks are already in the portal configuration.\n    Example: \n    Input:\n    1\n    5 4\n    1110\n    1001\n    1001\n    1001\n    0111\n    Expected Output: 0\n    Explanation: No operations are needed as it already forms a portal.\n\n    Case 2: A grid with no obsidian blocks.\n    Example:\n    Input:\n    1\n    5 4\n    0000\n    0000\n    0000\n    0000\n    0000\n    Expected Output: 12\n    Explanation: All border blocks need to be changed to obsidian, requiring maximum operations.\n\n    Case 3: A grid with minimum size and random configuration.\n    Example:\n    Input:\n    1\n    5 4\n    1010\n    0101\n    1010\n    0101\n    1010\n    Expected Output: (calculated based on specific changes needed)\n    Explanation: Calculate based on transforming this specific configuration into a portal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through all possible sub-rectangles and calculating the required operations will naturally handle these cases.\n", "requirement analysis:\nThe problem requires determining the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient given the potential size of the input. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal criteria.\nrequirement pool:\n- Develop an efficient algorithm to find the minimum operations for portal creation.\n- Ensure the solution handles the maximum input size within reasonable time limits.\n- Provide detailed comments and documentation for the algorithm.\n- Implement test cases to validate the solution against various scenarios.\n- Optimize the code for readability and maintainability.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will keep track of the minimum number of operations required across all sub-rectangles. We will use numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'portal'\n    Explanation: A portal is a sub-rectangle of size a \u00d7 b that meets specific criteria regarding the arrangement of obsidian and empty blocks.\n\n    'operation'\n    Explanation: An operation refers to switching an obsidian block to an empty block or vice versa.\n\n# [phrase showing quantity relationship]\n    'a \u2265 5, b \u2265 4': This means the sub-rectangle must have at least 5 rows and 4 columns.\n    Implementation: Ensure that any sub-rectangle considered has dimensions meeting these minimum requirements.\n\n# [degree adverb]\n    'minimum': We need to find the least number of operations required to transform a sub-rectangle into a portal.\n    Implementation: Track the number of operations for each sub-rectangle and update the minimum value found.\n\n# [code logic]\n1. Parse the input to retrieve the number of test cases and the dimensions of each grid.\n2. For each test case, iterate over all possible sub-rectangles of size at least 5x4.\n3. For each sub-rectangle, check if it can be transformed into a portal by counting the necessary operations.\n4. Keep track of the minimum number of operations required for each test case.\n5. Output the minimum number of operations for each test case.\n\n# [edge case]\n    Case 1: A grid with all blocks as obsidian (1)\n    Explanation: The entire grid is already filled with obsidian blocks, so transforming any sub-rectangle into a portal will require operations to create empty blocks inside.\n    \n    Case 2: A grid with all blocks as empty (0)\n    Explanation: The entire grid is empty, so transforming any sub-rectangle into a portal will require operations to create obsidian blocks on the borders.\n    \n    Case 3: A grid with alternating rows of obsidian and empty blocks\n    Explanation: This pattern may require more operations due to frequent changes between block types.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating over all possible sub-rectangles and calculating operations will naturally account for these scenarios.\n"], "scores": [], "pass_results": [true, true, false, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 471, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 276}
