{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n. These rooms are connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n. These rooms are connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert.\n\nThe layout of the maze is structured as a tree with n rooms labeled from 1 to n. These rooms are connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i. In order to move from room x to room y, a tunnel must connect x and y directly. You must use the tunnels available between the rooms to move from one place to another. Moving between these rooms requires using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z.\n\nTo deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms. Chanek and Indiana will pose q queries.\n\nQueries are of two sorts:\n\n  * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9).\n  * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n).\n\nAssist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "Chanek Jones has returned to assist his long-lost relative Indiana Jones in discovering a hidden treasure within a maze located beneath an illusion-laden desert. The layout of the maze is structured as a tree with n rooms labeled from 1 to n, and these rooms are connected by n - 1 tunnels in such a way that enables travel between any pair of rooms via multiple tunnels. The i-th room (1 \u2264 i \u2264 n) possesses an illusion rate of a_i, and to move from room x to room y, a tunnel must connect x and y, with moving between these rooms requiring using max(|a_x + a_y|, |a_x - a_y|) energy. |z| represents the absolute value of z. To deter grave robbers, the labyrinth has the ability to alter the illusion rate of its rooms, and Chanek and Indiana will pose q queries. Queries are of two sorts: * 1\\ u\\ c \u2014 Update the illusion rate of the u-th room to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana inquire about the smallest energy sum required to access the secret treasure located in room v if they commence in room u (1 \u2264 u, v \u2264 n). Assist them, so you can obtain a share of the treasure! Your task is to design a program that processes each query efficiently.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef dfs(node: int, parent: int, depth: int, euler: List[int], first: List[int], depth_list: List[int], tree: List[List[int]]) -> None:\n    \"\"\"Perform a Depth First Search to preprocess the tree for LCA queries.\n\n    Args:\n        node (int): The current node being visited.\n        parent (int): The parent of the current node.\n        depth (int): The current depth in the tree.\n        euler (List[int]): The Euler tour of the tree.\n        first (List[int]): The first occurrence of each node in the Euler tour.\n        depth_list (List[int]): The depth of each node in the Euler tour.\n        tree (List[List[int]]): The adjacency list representation of the tree.\n    \"\"\"\n    first[node] = len(euler)\n    euler.append(node)\n    depth_list.append(depth)\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, euler, first, depth_list, tree)\n            euler.append(node)\n            depth_list.append(depth)\n\ndef build_sparse_table(euler: List[int], depth_list: List[int]) -> List[List[int]]:\n    \"\"\"Build a sparse table for RMQ to find LCA efficiently.\n\n    Args:\n        euler (List[int]): The Euler tour of the tree.\n        depth_list (List[int]): The depth of each node in the Euler tour.\n\n    Returns:\n        List[List[int]]: The sparse table for RMQ.\n    \"\"\"\n    n = len(euler)\n    log = [0] * (n + 1)\n    for i in range(2, n + 1):\n        log[i] = log[i // 2] + 1\n\n    k = log[n] + 1\n    st = [[0] * k for _ in range(n)]\n\n    for i in range(n):\n        st[i][0] = i\n\n    j = 1\n    while (1 << j) <= n:\n        i = 0\n        while (i + (1 << j) - 1) < n:\n            if depth_list[st[i][j - 1]] < depth_list[st[i + (1 << (j - 1))][j - 1]]:\n                st[i][j] = st[i][j - 1]\n            else:\n                st[i][j] = st[i + (1 << (j - 1))][j - 1]\n            i += 1\n        j += 1\n\n    return st\n\ndef lca(u: int, v: int, first: List[int], euler: List[int], depth_list: List[int], st: List[List[int]]) -> int:\n    \"\"\"Find the Lowest Common Ancestor of two nodes.\n\n    Args:\n        u (int): The first node.\n        v (int): The second node.\n        first (List[int]): The first occurrence of each node in the Euler tour.\n        euler (List[int]): The Euler tour of the tree.\n        depth_list (List[int]): The depth of each node in the Euler tour.\n        st (List[List[int]]): The sparse table for RMQ.\n\n    Returns:\n        int: The LCA of nodes u and v.\n    \"\"\"\n    left = first[u]\n    right = first[v]\n    if left > right:\n        left, right = right, left\n\n    log = [0] * (len(euler) + 1)\n    for i in range(2, len(euler) + 1):\n        log[i] = log[i // 2] + 1\n\n    j = log[right - left + 1]\n    if depth_list[st[left][j]] < depth_list[st[right - (1 << j) + 1][j]]:\n        return euler[st[left][j]]\n    else:\n        return euler[st[right - (1 << j) + 1][j]]\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], path: List[int]) -> int:\n    \"\"\"Calculate the total energy required to move along a path.\n\n    Args:\n        u (int): The starting node.\n        v (int): The ending node.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        path (List[int]): The path from node u to node v.\n\n    Returns:\n        int: The total energy required to move along the path.\n    \"\"\"\n    total_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        total_energy += max(abs(a_x + a_y), abs(a_x - a_y))\n    return total_energy\n\ndef min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\n\n    Args:\n        u (int): The starting room.\n        v (int): The destination room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representation of the tree.\n\n    Returns:\n        int: The minimum energy required to move from room u to room v.\n    \"\"\"\n    n = len(tree) - 1\n    euler = []\n    first = [-1] * (n + 1)\n    depth_list = []\n\n    dfs(1, -1, 0, euler, first, depth_list, tree)\n    st = build_sparse_table(euler, depth_list)\n\n    ancestor = lca(u, v, first, euler, depth_list, st)\n\n    path_u_to_ancestor = []\n    path_v_to_ancestor = []\n\n    current = u\n    while current != ancestor:\n        path_u_to_ancestor.append(current)\n        for neighbor in tree[current]:\n            if first[neighbor] < first[current]:\n                current = neighbor\n                break\n    path_u_to_ancestor.append(ancestor)\n\n    current = v\n    while current != ancestor:\n        path_v_to_ancestor.append(current)\n        for neighbor in tree[current]:\n            if first[neighbor] < first[current]:\n                current = neighbor\n                break\n    path_v_to_ancestor.append(ancestor)\n\n    path_v_to_ancestor.reverse()\n    full_path = path_u_to_ancestor + path_v_to_ancestor[1:]\n\n    return calculate_energy(u, v, illusion_rates, full_path)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef preprocess_tree(n: int, edges: List[Tuple[int, int]], illusion_rates: List[int]) -> Tuple[List[List[int]], List[List[int]], List[int]]:\n    \"\"\"Preprocess the tree to set up adjacency list, LCA, and depth information.\"\"\"\n    adjacency_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    \n    depth = [-1] * n\n    lca = [[-1] * n for _ in range(n)]\n    \n    def dfs(node: int, parent: int, d: int):\n        \"\"\"Depth First Search to calculate depth and LCA.\"\"\"\n        depth[node] = d\n        lca[node][0] = parent\n        for neighbor in adjacency_list[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, d + 1)\n    \n    dfs(0, -1, 0)\n    \n    # Preprocess LCA using dynamic programming\n    for j in range(1, n):\n        for i in range(n):\n            if lca[i][j - 1] != -1:\n                lca[i][j] = lca[lca[i][j - 1]][j - 1]\n    \n    return adjacency_list, lca, depth\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]], lca: List[List[int]], depth: List[int]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    def find_lca(x: int, y: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor of two nodes.\"\"\"\n        if depth[x] < depth[y]:\n            x, y = y, x\n        # Bring x and y to the same depth\n        diff = depth[x] - depth[y]\n        for i in range(len(lca[x])):\n            if diff & (1 << i):\n                x = lca[x][i]\n        if x == y:\n            return x\n        for i in reversed(range(len(lca[x]))):\n            if lca[x][i] != lca[y][i]:\n                x = lca[x][i]\n                y = lca[y][i]\n        return lca[x][0]\n    \n    def path_energy(x: int, y: int) -> int:\n        \"\"\"Calculate the energy required to move between two nodes.\"\"\"\n        return max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n    \n    lca_node = find_lca(u - 1, v - 1)\n    energy = 0\n    \n    # Calculate energy from u to LCA\n    current = u - 1\n    while current != lca_node:\n        parent = lca[current][0]\n        energy += path_energy(current, parent)\n        current = parent\n    \n    # Calculate energy from v to LCA\n    current = v - 1\n    while current != lca_node:\n        parent = lca[current][0]\n        energy += path_energy(current, parent)\n        current = parent\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to process input and execute queries.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    # Preprocess the tree\n    adjacency_list, lca, depth = preprocess_tree(n, edges, illusion_rates)\n    \n    # Process each query\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, adjacency_list, lca, depth)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: list) -> None:\n    \"\"\"Update the illusion rate of a specified room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (list): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\n\ndef calculate_min_energy_path(u: int, v: int, illusion_rates: list, parent: list) -> int:\n    \"\"\"Calculate the minimum energy required to travel between two rooms.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (list): The list of current illusion rates for all rooms.\n        parent (list): The parent array representing the tree structure.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    path_u = []\n    path_v = []\n\n    # Find path from u to root\n    while u != 0:\n        path_u.append(u)\n        u = parent[u]\n\n    # Find path from v to root\n    while v != 0:\n        path_v.append(v)\n        v = parent[v]\n\n    # Find the lowest common ancestor (LCA)\n    while path_u and path_v and path_u[-1] == path_v[-1]:\n        lca = path_u.pop()\n        path_v.pop()\n\n    # Calculate energy from u to LCA\n    energy = 0\n    for i in range(len(path_u) - 1):\n        x = path_u[i]\n        y = path_u[i + 1]\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]),\n                      abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n\n    # Calculate energy from LCA to v\n    for i in range(len(path_v) - 1, -1, -1):\n        x = path_v[i]\n        y = path_v[i - 1] if i > 0 else lca\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]),\n                      abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n\n    return energy\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    parent = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n\n    # Read tunnels and construct adjacency list\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    # Preprocess the tree using DFS to fill the parent array\n    def dfs(node: int, par: int):\n        parent[node] = par\n        for neighbor in adjacency_list[node]:\n            if neighbor != par:\n                dfs(neighbor, node)\n\n    # Start DFS from node 1 (assuming 1 is the root)\n    dfs(1, 0)\n\n    # Process queries\n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n\n        if query_type == 1:\n            # Update query\n            update_illusion_rate(u, v, illusion_rates)\n        elif query_type == 2:\n            # Path query\n            result = calculate_min_energy_path(u, v, illusion_rates, parent)\n            results.append(result)\n\n    # Output results for all type 2 queries\n    for result in results:\n        print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [[-1] * (n + 1) for _ in range(20)]\n        self.preprocess_tree(tunnels)\n        self.preprocess_lca()\n\n    def preprocess_tree(self, tunnels: List[Tuple[int, int]]) -> None:\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int) -> None:\n        self.parent[0][node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def preprocess_lca(self) -> None:\n        for i in range(1, 20):\n            for j in range(1, self.n + 1):\n                if self.parent[i - 1][j] != -1:\n                    self.parent[i][j] = self.parent[i - 1][self.parent[i - 1][j]]\n\n    def lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        diff = self.depth[u] - self.depth[v]\n        for i in range(20):\n            if (diff >> i) & 1:\n                u = self.parent[i][u]\n        if u == v:\n            return u\n        for i in range(19, -1, -1):\n            if self.parent[i][u] != self.parent[i][v]:\n                u = self.parent[i][u]\n                v = self.parent[i][v]\n        return self.parent[0][u]\n\n    def update_illusion_rate(self, room: int, new_rate: int) -> None:\n        self.illusion_rates[room - 1] = new_rate\n\n    def calculate_min_energy(self, u: int, v: int) -> int:\n        if u == v:\n            return 0\n        lca_node = self.lca(u, v)\n        path = self.get_path(u, lca_node) + self.get_path(v, lca_node)[::-1][1:]\n        total_energy = 0\n        for i in range(len(path) - 1):\n            x, y = path[i], path[i + 1]\n            energy = max(abs(self.illusion_rates[x - 1] + self.illusion_rates[y - 1]),\n                         abs(self.illusion_rates[x - 1] - self.illusion_rates[y - 1]))\n            total_energy += energy\n        return total_energy\n\n    def get_path(self, start: int, end: int) -> List[int]:\n        path = []\n        while start != end:\n            path.append(start)\n            start = self.parent[0][start]\n        path.append(end)\n        return path\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n    \n    maze = Maze(n, illusion_rates, tunnels)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n        \n        if query_type == 1:\n            maze.update_illusion_rate(u, v)\n        elif query_type == 2:\n            result = maze.calculate_min_energy(u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\n\n    Args:\n        room (int): The room number to update.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (List[List[int]]): The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        int: The minimum energy required to move from room u to room v.\n    \"\"\"\n    # Perform DFS to find the path from u to v\n    def dfs(current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n        if current == target:\n            path.append(current)\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target, visited, path):\n                    return True\n        path.pop()\n        return False\n\n    n = len(illusion_rates)\n    visited = [False] * (n + 1)\n    path = []\n    dfs(u, v, visited, path)\n\n    # Calculate the energy required for the path found\n    min_energy = 0\n    for i in range(len(path) - 1):\n        x = path[i]\n        y = path[i + 1]\n        energy = max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n        min_energy += energy\n\n    return min_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            update_illusion_rate(u, c, illusion_rates)\n            index += 3\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\nimport sys\nsys.setrecursionlimit(200000)\n\nclass SegmentTree:\n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n\n    def build(self, data: List[int]):\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n\n    def update(self, pos: int, value: int):\n        # Update the value at position pos\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n\n    def query(self, left: int, right: int) -> int:\n        # Query the sum in the range [left, right)\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], seg_tree: SegmentTree) -> None:\n    seg_tree.update(room - 1, new_rate)\n    illusion_rates[room - 1] = new_rate\n\ndef dfs_find_path(u: int, v: int, parent: Dict[int, int], graph: Dict[int, List[int]], path: List[int]) -> bool:\n    if u == v:\n        path.append(u)\n        return True\n    for neighbor in graph[u]:\n        if neighbor != parent[u]:\n            parent[neighbor] = u\n            if dfs_find_path(neighbor, v, parent, graph, path):\n                path.append(u)\n                return True\n    return False\n\ndef find_min_energy_path(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    graph = {i: [] for i in range(1, len(illusion_rates) + 1)}\n    for s, t in tunnels:\n        graph[s].append(t)\n        graph[t].append(s)\n\n    path = []\n    parent = {u: -1}\n    dfs_find_path(u, v, parent, graph, path)\n    path.reverse()\n\n    min_energy = 0\n    for i in range(len(path) - 1):\n        a_x = illusion_rates[path[i] - 1]\n        a_y = illusion_rates[path[i + 1] - 1]\n        min_energy += max(abs(a_x + a_y), abs(a_x - a_y))\n\n    return min_energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    seg_tree = SegmentTree(illusion_rates)\n\n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates, seg_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = find_min_energy_path(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef preprocess_tree(n: int, edges: List[Tuple[int, int]]) -> List[List[int]]:\n    \"\"\"Preprocess the tree to create an adjacency list representation.\"\"\"\n    tree_structure = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        tree_structure[u].append(v)\n        tree_structure[v].append(u)\n    return tree_structure\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree_structure: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to traverse from room u to room v.\"\"\"\n    # Use DFS to find the path from u to v\n    path = find_path(u, v, tree_structure)\n    energy = 0\n    for i in range(len(path) - 1):\n        room1 = path[i]\n        room2 = path[i + 1]\n        energy += max(abs(illusion_rates[room1 - 1] + illusion_rates[room2 - 1]),\n                      abs(illusion_rates[room1 - 1] - illusion_rates[room2 - 1]))\n    return energy\n\ndef find_path(start: int, end: int, tree_structure: List[List[int]]) -> List[int]:\n    \"\"\"Find the path from start to end using DFS.\"\"\"\n    visited = [False] * len(tree_structure)\n    path = []\n\n    def dfs(current: int):\n        if current == end:\n            return True\n        visited[current] = True\n        path.append(current)\n        for neighbor in tree_structure[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n        path.pop()\n        return False\n\n    dfs(start)\n    return path\n\ndef main():\n    \"\"\"Main function to process input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    # Preprocess the tree\n    tree_structure = preprocess_tree(n, edges)\n\n    # Process each query\n    for query in queries:\n        if query[0] == '1':\n            u, c = int(query[1]), int(query[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree_structure)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Update the illusion rate of the u-th room to c.\"\"\"\n    illusion_rates[u - 1] = c\n\ndef dfs(tree: List[List[int]], current: int, parent: int, path: List[int], paths: List[List[int]]) -> None:\n    \"\"\"Perform DFS to record paths from the root to each node.\"\"\"\n    path.append(current)\n    paths[current] = path[:]\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            dfs(tree, neighbor, current, path, paths)\n    path.pop()\n\ndef calculate_min_energy(illusion_rates: List[int], tree: List[List[int]], u: int, v: int) -> int:\n    \"\"\"Calculate the minimum energy required to move from room u to room v.\"\"\"\n    n = len(tree) - 1\n    paths = [[] for _ in range(n + 1)]\n    dfs(tree, u, -1, [], paths)\n    \n    path_u = paths[u]\n    path_v = paths[v]\n    \n    # Find the lowest common ancestor (LCA)\n    i = 0\n    while i < len(path_u) and i < len(path_v) and path_u[i] == path_v[i]:\n        i += 1\n    i -= 1\n    \n    # Calculate energy from u to LCA and LCA to v\n    energy = 0\n    for j in range(i, len(path_u) - 1):\n        x, y = path_u[j], path_u[j + 1]\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n    \n    for j in range(i, len(path_v) - 1):\n        x, y = path_v[j], path_v[j + 1]\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n    \n    return energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s_i = int(data[index])\n        t_i = int(data[index + 1])\n        index += 2\n        tree[s_i].append(t_i)\n        tree[t_i].append(s_i)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(illusion_rates, u, c)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_min_energy(illusion_rates, tree, u, v)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom collections import defaultdict, deque\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: list, tunnels: list):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = defaultdict(list)\n        self.build_tree(tunnels)\n        self.preprocess()\n\n    def build_tree(self, tunnels: list) -> None:\n        \"\"\"Builds the adjacency list representation of the tree.\"\"\"\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n\n    def preprocess(self) -> None:\n        \"\"\"Preprocess the tree to calculate paths and store necessary information.\"\"\"\n        self.parent = [-1] * (self.n + 1)\n        self.depth = [-1] * (self.n + 1)\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int) -> None:\n        \"\"\"Depth First Search to set parent and depth for each node.\"\"\"\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def update_illusion_rate(self, room: int, new_rate: int) -> None:\n        \"\"\"Update the illusion rate of a specific room.\"\"\"\n        self.illusion_rates[room - 1] = new_rate\n\n    def calculate_min_energy(self, start_room: int, end_room: int) -> int:\n        \"\"\"Calculate the minimum energy required to move between two rooms.\"\"\"\n        path = self.find_path(start_room, end_room)\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u, v = path[i], path[i + 1]\n            a_u, a_v = self.illusion_rates[u - 1], self.illusion_rates[v - 1]\n            energy = max(abs(a_u + a_v), abs(a_u - a_v))\n            total_energy += energy\n        return total_energy\n\n    def find_path(self, u: int, v: int) -> list:\n        \"\"\"Find the path from node u to node v.\"\"\"\n        path_u = []\n        path_v = []\n        while u != -1:\n            path_u.append(u)\n            u = self.parent[u]\n        while v != -1:\n            path_v.append(v)\n            v = self.parent[v]\n        # Find the lowest common ancestor (LCA)\n        lca = -1\n        while path_u and path_v and path_u[-1] == path_v[-1]:\n            lca = path_u.pop()\n            path_v.pop()\n        # Combine paths to form the full path from u to v\n        path_u.append(lca)\n        path_u.reverse()\n        return path_u + path_v\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n    \n    maze = Maze(n, illusion_rates, tunnels)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            maze.update_illusion_rate(u, c)\n            index += 3\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            result = maze.calculate_min_energy(u, v)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle range queries and updates efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1])\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Updates the value at position `pos` to `value`.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1])\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the maximum value in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result = max(result, self.tree[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                result = max(result, self.tree[right])\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], node: int, parent: int, depth: List[int], parent_list: List[int]):\n    \"\"\"Performs DFS to calculate depth and parent of each node.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth[neighbor] = depth[node] + 1\n            parent_list[neighbor] = node\n            dfs(tree, neighbor, node, depth, parent_list)\n\ndef lca(u: int, v: int, depth: List[int], parent_list: List[int]) -> int:\n    \"\"\"Finds the Lowest Common Ancestor (LCA) of nodes u and v.\"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n    # Bring u and v to the same depth\n    while depth[u] > depth[v]:\n        u = parent_list[u]\n    while u != v:\n        u = parent_list[u]\n        v = parent_list[v]\n    return u\n\ndef calculate_energy(u: int, v: int, illusion_rates: List[int], parent_list: List[int], depth: List[int]) -> int:\n    \"\"\"Calculates the energy required to move from node u to node v.\"\"\"\n    ancestor = lca(u, v, depth, parent_list)\n    energy = 0\n    # Calculate energy from u to ancestor\n    while u != ancestor:\n        energy += max(abs(illusion_rates[u] + illusion_rates[parent_list[u]]), abs(illusion_rates[u] - illusion_rates[parent_list[u]]))\n        u = parent_list[u]\n    # Calculate energy from v to ancestor\n    while v != ancestor:\n        energy += max(abs(illusion_rates[v] + illusion_rates[parent_list[v]]), abs(illusion_rates[v] - illusion_rates[parent_list[v]]))\n        v = parent_list[v]\n    return energy\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\"\"\"\n    illusion_rates[room] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to move from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    depth = [0] * n\n    parent_list = [-1] * n\n    dfs(tree, 1, -1, depth, parent_list)\n    return calculate_energy(u, v, illusion_rates, parent_list, depth)\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n    queries = [input().strip() for _ in range(q)]\n\n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            u, c = int(parts[1]), int(parts[2])\n            update_illusion_rate(u, c, illusion_rates)\n        elif parts[0] == '2':\n            u, v = int(parts[1]), int(parts[2])\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe program needs to efficiently handle up to 100,000 queries and rooms, ensuring quick updates and calculations. The tree structure of the maze allows for efficient traversal algorithms, and the energy calculation must be precise to ensure correct outputs.\nrequirement pool:\n- Efficient query processing for large inputs\n- Accurate energy calculation between rooms\n- User-friendly interface for input and output\n- Ability to update room illusion rates quickly\n- Scalability to handle future expansions of the maze\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and LCA will be used to find the shortest path between any two nodes. We will use the Euler Tour technique to flatten the tree and Binary Lifting for efficient LCA queries. For updating the illusion rates, we will directly update the values in an array, which allows for O(1) updates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated and influences the calculation of energy needed for movement.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, allowing travel between any pair of rooms.\n\n    'energy calculation'\n    Explanation: The energy required to move between rooms x and y is calculated using max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of rooms x and y.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the max function and abs function.\n\n# [degree adverb]\n    'smallest': In the context of queries, it refers to finding the minimum sum of energy needed to access the secret treasure from one room to another. This involves calculating the path with the least energy cost.\n\n# [code logic]\n    1. Preprocess the tree using DFS to establish paths and prepare for LCA queries.\n    2. Use Euler Tour technique to flatten the tree structure.\n    3. Implement Binary Lifting for efficient LCA queries.\n    4. For type 1 queries, update the illusion rate directly in an array.\n    5. For type 2 queries, calculate the minimum energy required using LCA to find the path between two rooms and sum up the energy costs using the given formula.\n\n# [edge case]\n    Case 1: When all rooms have an illusion rate of 0.\n    Input: \n    ```\n    3 2\n    0 0 0\n    1 2\n    2 3\n    2 1 3\n    ```\n    Expected Output: \n    ```\n    0\n    ```\n    Explanation: Since all illusion rates are zero, moving between any rooms requires zero energy.\n\n    Case 2: When there is only one room.\n    Input:\n    ```\n    1 1\n    5\n    2 1 1\n    ```\n    Expected Output:\n    ```\n    0\n    ```\n    Explanation: No movement is needed as there is only one room, hence zero energy is required.\n\n    Case 3: When updating a room's illusion rate to its negative value.\n    Input:\n    ```\n    3 3\n    5 -5 10\n    1 2\n    2 3\n    1 1 -5\n    2 1 3\n    ```\n    Expected Output:\n    ```\n    20\n    ```\n    Explanation: After updating room 1's illusion rate from 5 to -5, moving from room 1 to room 3 requires max(|-5 + (-5)|, |-5 - (-5)|) = max(10,0) = 10 energy for each segment.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and LCA handles these scenarios naturally by considering all possible paths and updates efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing updates and queries in a tree-structured maze. The main challenge is to handle large input sizes and ensure quick computation of energy requirements between rooms. The solution must be optimized for both update and query operations, leveraging data structures that support fast updates and path calculations.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy between rooms.\n- Optimize data structures for handling large input sizes.\n- Ensure the program is robust against edge cases in input data.\n- Provide detailed error messages for invalid inputs.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Lowest Common Ancestor (LCA) preprocessing to efficiently handle the queries. The DFS will help in setting up the tree structure and calculating the path between nodes, while LCA will allow us to quickly find the common ancestor of two nodes, which is crucial for calculating the minimum energy path. We will use adjacency lists to represent the tree and segment trees to handle updates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated and is crucial for calculating the energy needed for traversal.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, allowing traversal between any pair of rooms.\n\n    'queries'\n    Explanation: There are two types of queries: updating the illusion rate of a room and finding the minimum energy required to move from one room to another.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy calculation for moving between two rooms. It involves taking the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest'\n    Explanation: In the context of queries, it refers to finding the minimum energy sum required for traversal. This involves calculating the path with the least energy cost using tree traversal techniques like DFS and LCA.\n\n# [code logic]\n    - Initialize adjacency lists to represent the tree structure.\n    - Use DFS to preprocess the tree and set up data structures for LCA.\n    - Implement a segment tree or similar structure to efficiently handle updates to illusion rates.\n    - For type 2 queries, use LCA to find the path between rooms and calculate the energy using the given formula.\n    - For type 1 queries, update the illusion rate in the segment tree.\n\n# [edge case]\n    1 1 -3\n    Explanation: This query updates the illusion rate of room 1 to -3. The expected output is not applicable as it's an update query.\n    \n    2 1 1 = 0\n    Explanation: When querying from a room to itself, no movement is required, hence the energy cost is 0.\n    \n    2 n n = 0\n    Explanation: Similar to querying from a room to itself, querying from the last room to itself also results in an energy cost of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle these edge cases. The original logic handles querying from a room to itself by returning 0 energy cost directly.\n", "requirement analysis:\nThe program needs to efficiently handle updates to the illusion rates and calculate the minimum energy path between rooms. Given the constraints, the solution should focus on optimizing query processing and ensuring accuracy in energy calculations.\nrequirement pool:\n- Efficient query processing for both update and path queries\n- Accurate calculation of energy requirements between rooms\n- Handle large input sizes without performance degradation\n- Ensure robustness and reliability of the solution\n- Provide clear and concise output for each query\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path energy efficiently. For updates, we will directly modify the illusion rate in the list. For path queries, we will use a precomputed parent array to find the path between two nodes and calculate the energy using the given formula. This approach ensures efficient query processing and accurate energy calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated and is used in calculations for energy consumption.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, allowing travel between any pair of rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the calculation of energy required to move between two rooms. It involves taking the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest'\n    Explanation: Refers to finding the minimum energy sum required to access the treasure from one room to another. In code, this involves calculating the path with the least energy consumption.\n\n# [code logic]\n    1. Parse input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Use DFS to preprocess the tree and calculate paths between rooms.\n    3. For update queries, directly modify the illusion rate in the list.\n    4. For path queries, use a precomputed parent array to find the path between two nodes.\n    5. Calculate energy using `max(|a_x + a_y|, |a_x - a_y|)` for each segment of the path.\n    6. Return the total energy for each type 2 query.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Expected Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Expected Output: 2000000000\n    Explanation: The initial path requires maximum energy due to high illusion rates.\n\n    Input: 4 3\n           1 -1 1 -1\n           1 2\n           2 3\n           3 4\n           2 1 4\n           1 4 -1\n           2 1 4\n    Expected Output: 6, then after update, still 6\n    Explanation: The path energy remains unchanged after updating room 4's illusion rate to the same value.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and direct updates will handle these scenarios efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing updates and queries in a tree-structured maze. The challenge lies in handling large input sizes and ensuring the program remains performant. The solution must be able to dynamically update room illusion rates and compute the minimum energy path between any two rooms.\nrequirement pool:\n- Efficiently handle updates to room illusion rates.\n- Calculate minimum energy required for room traversal.\n- Optimize for large input sizes and high query volumes.\n- Ensure accurate and clear output for each query.\n- Provide a user-friendly interface for input and output.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary information for LCA, which will then be used to compute the minimum energy path between any two rooms. We will also use a Segment Tree or Fenwick Tree to handle the dynamic updates of the illusion rates efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'illusion rate'\n    Explanation: The illusion rate is a property of each room that affects the energy required to move between rooms. It can be updated dynamically and is crucial for calculating the energy needed for movement.\n\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning there are n rooms connected by n-1 tunnels, allowing travel between any pair of rooms. This structure is important for efficiently finding paths and calculating energy.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase describes the energy required to move between two rooms x and y. It involves calculating the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'smallest'\n    Explanation: In the context of queries, it refers to finding the minimum sum of energy needed to move from one room to another. This requires efficient pathfinding and energy calculation.\n\n# [code logic]\n    1. Preprocess the tree using DFS to gather necessary information for LCA.\n    2. Implement LCA to efficiently find paths between any two rooms.\n    3. Use a Segment Tree or Fenwick Tree to handle updates to illusion rates.\n    4. For type 2 queries, calculate the minimum energy path using preprocessed data and current illusion rates.\n    5. For type 1 queries, update the illusion rate in the data structure.\n\n# [edge case]\n    Input: 2 1\n    Output: 0\n    Explanation: If u and v are the same room, no movement is needed, so the energy required is 0.\n\n    Input: 1 1 -3\n    Output: No output (update query)\n    Explanation: This query updates the illusion rate of a room, so no output is expected.\n\n    Input: 2 3 3\n    Output: 0\n    Explanation: Again, if u and v are the same room, no movement is needed, so the energy required is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should naturally handle cases where u and v are the same room by returning 0 energy.\n", "requirement analysis:\nThe program must efficiently handle updates to the illusion rates and calculate the minimum energy required for traversal between rooms. Given the constraints, the solution should focus on optimizing query processing and ensuring accuracy in energy calculations. The tree structure of the maze allows for efficient traversal algorithms, which should be leveraged to meet performance goals.\nrequirement pool:\n- Efficient query processing for both update and energy calculation queries.\n- Accurate calculation of energy requirements using the given formula.\n- Handle large input sizes without performance degradation.\n- Ensure robustness and correctness of the solution.\n- Provide clear and concise output for each query.\nWe will use a Depth First Search (DFS) algorithm to efficiently traverse the tree structure of the maze. For handling updates and queries, we will utilize adjacency lists to represent the tree and segment trees to manage the illusion rates and efficiently process updates. This approach ensures that both types of queries are handled in logarithmic time complexity, which is suitable given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree structure'\n    Explanation: The maze is structured as a tree, meaning it has n rooms and n-1 tunnels, allowing traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate, which affects the energy required to move between rooms.\n\n    'queries'\n    Explanation: There are two types of queries: updating the illusion rate of a room and finding the minimum energy required to move from one room to another.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates the energy required to move between two rooms, calculated as the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest'\n    Explanation: For type 2 queries, we need to find the smallest energy sum required to move from one room to another. This involves calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n    - Use Depth First Search (DFS) to traverse the tree structure efficiently.\n    - Represent the tree using adjacency lists for easy traversal.\n    - Use segment trees to manage and update illusion rates efficiently.\n    - For type 1 queries, update the illusion rate of a specified room.\n    - For type 2 queries, calculate the minimum energy required to move from one room to another using DFS and segment trees.\n\n# [edge case]\n    2 1 1 = 0\n    Explanation: Moving from a room to itself requires no energy, so the expected output is 0.\n\n    1 1 0 = No output\n    Explanation: Updating a room's illusion rate does not produce an output.\n\n    2 n n = 0\n    Explanation: Similar to moving from a room to itself, moving from the last room to itself requires no energy, so the expected output is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of handling queries and updates will naturally accommodate these scenarios.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to energy consumption and illusion rate updates in a maze structured as a tree. The solution must handle large input sizes and provide quick responses to queries.\nrequirement pool:\n- Efficient query processing for energy calculation\n- Fast update mechanism for illusion rates\n- Scalability to handle large mazes\n- Accurate pathfinding algorithm\n- User-friendly interface for query input\nWe will use a combination of Depth First Search (DFS) for pathfinding and Segment Tree for efficient updates and queries. DFS will help in finding the path between two nodes in the tree, while the Segment Tree will allow us to efficiently update the illusion rates and calculate the minimum energy required for the path.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, allowing traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This phrase indicates that the energy required to move between two rooms is the maximum of the absolute values of the sum and difference of their illusion rates. In code, this can be implemented using the max function and abs function: `max(abs(a_x + a_y), abs(a_x - a_y))`.\n\n# [degree adverb]\n    'smallest': In the context of the queries, it refers to finding the minimum sum of energy required to access the secret treasure from one room to another. This can be implemented by calculating the energy for all possible paths and selecting the minimum.\n\n# [code logic]\n    1. Parse the input to get the number of rooms, queries, initial illusion rates, and tunnel connections.\n    2. Construct the tree using adjacency lists based on tunnel connections.\n    3. Implement DFS to find paths between rooms for type 2 queries.\n    4. Use a Segment Tree to efficiently update illusion rates for type 1 queries and calculate energy for type 2 queries.\n    5. For each type 2 query, calculate the energy required for each segment of the path using the formula max(|a_x + a_y|, |a_x - a_y|) and sum them up.\n    6. Output the minimum energy required for each type 2 query.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires no energy.\n\n    Input: 3 2\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n           1 2 -10\n           2 1 3\n    Output: 20\n            20\n    Explanation: Initially, moving from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) = max(0, 20) = 20 energy. After updating room 2's illusion rate to -10, the energy remains unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will handle these cases correctly by considering all possible paths and updates efficiently.\n", "requirement analysis:\nThe program must efficiently handle updates to the illusion rates and calculate the minimum energy required for traversal between rooms. Given the constraints, the solution should be optimized for both time and space to handle the maximum input sizes. The tree structure of the maze allows for efficient pathfinding algorithms, and the challenge lies in dynamically updating the illusion rates and recalculating the energy requirements.\nrequirement pool:\n- Efficiently process type 1 and type 2 queries.\n- Optimize for large input sizes (up to 100,000 rooms and queries).\n- Provide clear and concise output for each query.\n- Ensure the program is robust and handles edge cases.\n- Implement a user-friendly interface for input and output.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path between any two nodes efficiently. We will utilize a Segment Tree to handle updates to the illusion rates and efficiently calculate the minimum energy required for traversal between rooms. This approach ensures that both types of queries are processed in logarithmic time, which is suitable given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, allowing traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an illusion rate, which affects the energy required to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between rooms is calculated using the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the maximum of the absolute value of the sum and the absolute value of the difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'smallest'\n    Explanation: For type 2 queries, we need to find the smallest energy sum required to access the secret treasure. This involves finding the minimum path energy between two rooms.\n\n# [code logic]\n    1. Use Depth First Search (DFS) to preprocess the tree and calculate paths between nodes.\n    2. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    3. For type 1 queries, update the illusion rate of a specified room.\n    4. For type 2 queries, calculate the minimum energy required for traversal using preprocessed path information and current illusion rates.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires 0 energy.\n\n    Input: 3 2\n           1000000000 -1000000000 0\n           1 2\n           2 3\n           2 1 3\n           1 1 -1000000000\n    Output: 2000000000\n    Explanation: Initially, moving from room 1 to room 3 requires max(|1000000000 + (-1000000000)|, |1000000000 - (-1000000000)|) = 2000000000 energy. After updating room 1's illusion rate, it still requires max(|-1000000000 + (-1000000000)|, |-1000000000 - (-1000000000)|) = 2000000000 energy.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will efficiently handle all cases including edge cases.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations. The tree structure of the maze must be leveraged to optimize query processing, possibly using data structures like segment trees or binary indexed trees for efficient updates and queries.\nrequirement pool:\n- Efficient query processing for large inputs\n- Accurate energy calculation between rooms\n- User-friendly interface for input and output\n- Clear instructions for users\n- Support for visualizing the maze structure\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path between any two rooms efficiently. For updates, we will directly modify the illusion rate in the list. For queries, we will calculate the energy required using the preprocessed path information. This approach leverages the tree structure and ensures efficient query processing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected graph with no cycles, which means there is exactly one path between any two nodes (rooms in this case).\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy cost of moving between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is determined by the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that the energy required is the maximum of the absolute sum or difference of the illusion rates of two connected rooms. In code, this can be implemented using the `max` function and `abs` for absolute values.\n\n# [degree adverb]\n    'smallest': This refers to finding the minimum energy sum required to reach the treasure. In code, this can be implemented using algorithms that find the shortest path, such as Dijkstra's algorithm.\n\n# [code logic]\n1. Parse the input to get the number of rooms, queries, initial illusion rates, and connections between rooms.\n2. Construct the tree using adjacency lists.\n3. Use Depth First Search (DFS) to preprocess and store paths between rooms.\n4. For each query:\n   - If it's an update query (type 1), update the illusion rate of the specified room.\n   - If it's a path query (type 2), calculate the minimum energy required using preprocessed path information and the current illusion rates.\n5. Output the result for each type 2 query.\n\n# [edge case]\n    1. Single path tree (e.g., a straight line): The energy calculation should handle linear paths correctly.\n    2. All rooms have zero illusion rate: The energy required should be zero for any path.\n    3. Maximum possible illusion rate values: Ensure calculations handle large numbers without overflow.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases related to large numbers and ensure efficient path calculations.\n    - Use efficient data structures like adjacency lists for tree representation.\n    - Implement DFS carefully to avoid stack overflow with large trees.\n    - Use Python's built-in arbitrary-precision integers to handle large numbers in calculations.\n", "requirement analysis:\nThe program must efficiently handle up to 100,000 rooms and queries, ensuring that updates to room illusion rates and energy calculations between rooms are processed quickly. The tree structure of the maze allows for efficient traversal and pathfinding, which should be leveraged to minimize computational overhead.\nrequirement pool:\n- Efficiently process type 1 and type 2 queries.\n- Handle large input sizes up to the maximum constraints.\n- Provide clear and concise output for each query.\n- Ensure the program is robust against invalid inputs.\n- Optimize for minimal memory usage.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path between any two rooms efficiently. We will utilize a Segment Tree to handle updates and queries efficiently, especially given the constraints of up to 100,000 rooms and queries. This approach ensures that both types of queries are processed in logarithmic time complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: A tree is a connected acyclic graph. In this problem, it represents the maze structure where each room is a node and each tunnel is an edge.\n\n    'illusion rate'\n    Explanation: This is a value associated with each room that affects the energy required to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between two rooms is calculated using the formula max(|a_x + a_y|, |a_x - a_y|), where a_x and a_y are the illusion rates of the rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)': This indicates that for each move between two rooms, the energy required is the maximum of the absolute sum or absolute difference of their illusion rates. In code, this can be implemented using the `max` function with `abs`.\n\n# [degree adverb]\n    'smallest': This refers to finding the minimum energy path between two rooms. In code, this can be implemented using algorithms like Dijkstra's or BFS/DFS with priority queues to find the shortest path in terms of energy.\n\n# [code logic]\n1. Parse the input to construct the tree using adjacency lists.\n2. Preprocess the tree using DFS to calculate paths and store necessary information for efficient querying.\n3. Implement a Segment Tree or similar data structure to handle updates to illusion rates and efficiently process queries.\n4. For type 1 queries, update the illusion rate of the specified room.\n5. For type 2 queries, calculate the minimum energy path from room u to room v using preprocessed data and update structures.\n\n# [edge case]\n    1. Single path from start to end: If there's only one direct path between u and v, calculate energy directly.\n    2. All rooms have zero illusion rate: The energy for any path should be zero.\n    3. Maximum possible illusion rate change: Test with maximum allowed values for illusion rates to ensure no overflow or incorrect calculations.\n\n# [extra code for edge case]\n    We need extra code to handle updates efficiently and ensure that calculations are correct even with maximum values.\n    - Implement checks for overflow when calculating energy.\n    - Ensure that updates to illusion rates are reflected in the data structures used for querying paths.\n\n```python\ndef update_illusion_rate(room, new_rate):\n    # Update the illusion rate of a specific room\n    # Update segment tree or other data structures accordingly\n\ndef calculate_min_energy(u, v):\n    # Use preprocessed data to find the minimum energy path from u to v\n    # Consider edge cases like direct paths or zero illusion rates\n```\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to updating room illusion rates and calculating the minimum energy required to traverse the maze. The solution must handle large input sizes and provide accurate results quickly. The challenge lies in optimizing the algorithm to manage both updates and path calculations effectively.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Efficiently process type 2 queries to calculate minimum energy required.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and concise output for each query.\n- Optimize the algorithm for both updates and path calculations.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the path between any two nodes efficiently. We will also use a Segment Tree to handle updates to the illusion rates and efficiently calculate the energy required for type 2 queries. This approach ensures that both types of queries are processed in logarithmic time, which is suitable given the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'tree'\n    Explanation: The maze is structured as a tree, meaning it is a connected graph with no cycles, allowing traversal between any pair of rooms.\n\n    'illusion rate'\n    Explanation: Each room has an associated illusion rate, which affects the energy required to move between rooms.\n\n    'energy'\n    Explanation: The energy required to move between rooms is calculated using the maximum of the absolute values of the sum and difference of the illusion rates of the two rooms.\n\n# [phrase showing quantity relationship]\n    'max(|a_x + a_y|, |a_x - a_y|)'\n    Explanation: This phrase indicates that the energy required to move between two rooms is the maximum of the absolute value of the sum and the absolute value of the difference of their illusion rates. In code, this can be implemented using the `max` function and `abs` function.\n\n# [degree adverb]\n    'smallest'\n    Explanation: For type 2 queries, we need to find the smallest energy sum required to access the secret treasure from one room to another. This involves finding the minimum path energy using DFS and segment tree updates.\n\n# [code logic]\n    1. Use DFS to preprocess the tree and calculate paths between nodes.\n    2. Implement a Segment Tree to handle updates to illusion rates efficiently.\n    3. For type 1 queries, update the illusion rate of a specified room.\n    4. For type 2 queries, calculate the minimum energy required using preprocessed paths and updated illusion rates.\n\n# [edge case]\n    Input: 2 1\n           0 0\n           1 2\n           2 1 2\n    Output: 0\n    Explanation: Both rooms have an illusion rate of 0, so moving between them requires 0 energy.\n\n    Input: 3 2\n           10 -10 10\n           1 2\n           2 3\n           2 1 3\n           1 2 -10\n           2 1 3\n    Output: 20\n            20\n    Explanation: Initially, moving from room 1 to room 3 requires max(|10 + (-10)|, |10 - (-10)|) = max(0, 20) = 20 energy. After updating room 2's illusion rate to -10, the energy remains unchanged.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using DFS and Segment Tree will efficiently handle all cases including edge cases.\n"], "scores": [], "pass_results": [true, true, false, false, true, false, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 305, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "expand_one2two", "parent_index": 135}
