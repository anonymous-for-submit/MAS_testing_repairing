{"name": "1598_E. Staircases", "description": "You are given a matrix, consisting of n rows and m columns. The rows are numbered top to bottom, the columns are numbered left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one, the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\n\n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "tags": ["brute force", "combinatorics", "data structures", "dfs and similar", "dp", "implementation", "math"], "difficulty": 11, "id": 1598, "sample_io": [{"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n"]}, {"input": "1000 1000 2\n239 634\n239 634\n", "output": ["1332632508\n1333333000\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n1\n0\n"]}], "test_list": [{"input": "1 1 1\n1 1\n", "output": ["0\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n238\n233\n222\n207\n186\n180\n162\n140\n151\n144\n137\n144\n137\n111\n109\n91\n82\n77\n87\n78\n76\n83\n81\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 2\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n12\n8\n13\n23\n19\n15\n"]}, {"input": "1 1 2\n1 1\n1 1\n", "output": ["0\n1\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n86\n81\n91\n82\n80\n86\n84\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 1\n1 1\n1 2\n2 1\n1 1\n", "output": ["5\n10\n5\n3\n6\n2\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n77\n68\n66\n72\n70\n"]}, {"input": "3 4 10\n1 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n31\n45\n25\n17\n15\n12\n14\n16\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n17\n14\n12\n15\n17\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n31\n23\n16\n14\n"]}, {"input": "1000 1000 2\n252 634\n239 634\n", "output": ["1332594366\n1331893874\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n89\n77\n74\n69\n79\n70\n68\n74\n72\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n9\n6\n5\n4\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n78\n76\n64\n77\n74\n80\n71\n69\n75\n73\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n14\n12\n8\n13\n23\n31\n27\n"]}, {"input": "1000 1000 2\n59 634\n239 634\n", "output": ["1333160628\n1332460136\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n162\n140\n135\n124\n111\n104\n117\n114\n94\n92\n80\n77\n85\n101\n92\n90\n96\n94\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n98\n90\n76\n64\n77\n74\n80\n69\n67\n71\n69\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n6\n10\n12\n8\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n78\n70\n56\n62\n56\n"]}, {"input": "1000 1000 2\n239 634\n418 634\n", "output": ["1332632508\n1331406830\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n3\n6\n3\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n102\n99\n79\n77\n65\n74\n71\n74\n65\n63\n69\n67\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n75\n72\n"]}, {"input": "3 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n"]}, {"input": "1000 1000 2\n59 323\n239 634\n", "output": ["1333014458\n1332313966\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n142\n137\n126\n116\n109\n103\n99\n91\n77\n65\n78\n73\n79\n68\n66\n70\n69\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n52\n54\n49\n47\n41\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n66\n63\n"]}, {"input": "2 4 1\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "1000 1000 2\n59 323\n239 999\n", "output": ["1333014458\n1333011116\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n83\n72\n70\n74\n73\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n75\n73\n67\n70\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n124\n113\n123\n119\n111\n97\n85\n98\n88\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n194\n183\n154\n151\n138\n130\n121\n129\n126\n119\n118\n106\n100\n95\n105\n92\n90\n76\n79\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n77\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n109\n101\n96\n106\n93\n95\n81\n84\n"]}, {"input": "6 3 4\n1 2\n1 3\n2 2\n2 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n63\n61\n"]}, {"input": "2 1 2\n1 1\n1 1\n", "output": ["1\n3\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n27\n23\n31\n21\n25\n18\n15\n13\n"]}, {"input": "1000 1000 2\n341 634\n239 634\n", "output": ["1332333240\n1331632748\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n116\n109\n112\n109\n83\n81\n69\n78\n73\n83\n74\n72\n77\n75\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n25\n39\n19\n17\n15\n12\n14\n16\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n179\n163\n157\n135\n130\n119\n112\n108\n103\n100\n80\n78\n64\n73\n70\n76\n67\n65\n71\n69\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n35\n31\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 4\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n49\n39\n43\n33\n26\n24\n"]}, {"input": "1000 1000 2\n252 634\n239 877\n", "output": ["1332594366\n1332358004\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n112\n100\n97\n92\n102\n93\n91\n97\n87\n"]}, {"input": "3 4 10\n1 4\n1 3\n2 1\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n39\n19\n14\n12\n9\n11\n10\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n234\n229\n218\n195\n188\n186\n164\n144\n133\n126\n119\n114\n111\n91\n89\n71\n62\n59\n65\n56\n54\n60\n58\n"]}, {"input": "3 3 10\n1 2\n2 3\n2 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n11\n14\n18\n14\n25\n35\n25\n21\n"]}, {"input": "1000 1000 2\n59 634\n239 35\n", "output": ["1333160628\n1332948862\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n107\n98\n96\n102\n100\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n98\n86\n99\n96\n90\n68\n64\n68\n66\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n23\n"]}, {"input": "2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["5\n10\n5\n2\n5\n10\n5\n2\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n108\n105\n91\n90\n78\n75\n70\n80\n71\n69\n78\n75\n"]}, {"input": "1000 1000 2\n59 323\n448 634\n", "output": ["1333014458\n1331700760\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n2 1\n4 5\n3 8\n1 7\n2 1\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n196\n173\n158\n152\n170\n165\n150\n122\n115\n109\n105\n97\n83\n71\n84\n79\n85\n74\n72\n76\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n185\n170\n164\n129\n126\n115\n108\n101\n108\n105\n98\n97\n85\n82\n77\n87\n74\n72\n74\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n77\n80\n69\n67\n71\n70\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n5 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n102\n101\n89\n83\n78\n88\n83\n81\n72\n75\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n127\n113\n101\n114\n104\n92\n81\n79\n83\n82\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n102\n105\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n21\n17\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n208\n197\n174\n159\n153\n131\n126\n113\n110\n121\n124\n121\n95\n93\n81\n90\n85\n95\n86\n84\n89\n87\n"]}, {"input": "3 4 10\n1 4\n2 2\n2 1\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n29\n25\n19\n11\n9\n8\n5\n6\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n1 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n197\n181\n175\n152\n157\n139\n132\n128\n123\n120\n97\n93\n79\n93\n90\n96\n81\n79\n73\n71\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 3\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n38\n28\n25\n29\n21\n17\n"]}, {"input": "1000 1000 2\n142 634\n239 877\n", "output": ["1332917106\n1332680744\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 5\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n190\n165\n150\n144\n176\n171\n144\n122\n115\n137\n134\n114\n110\n98\n95\n90\n100\n93\n91\n98\n88\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n180\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n56\n"]}, {"input": "1000 1000 2\n59 634\n239 24\n", "output": ["1333160628\n1333015896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n127\n115\n109\n117\n133\n122\n120\n127\n119\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 3\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 2\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n348\n332\n303\n261\n256\n240\n211\n196\n190\n168\n163\n152\n143\n136\n128\n124\n116\n119\n107\n120\n117\n111\n81\n77\n81\n78\n"]}, {"input": "3 3 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["26\n18\n15\n14\n"]}, {"input": "2 3 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["12\n18\n12\n7\n10\n18\n10\n7\n"]}, {"input": "3 3 4\n1 3\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n5 2\n2 3\n3 1\n", "output": ["31\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n223\n212\n195\n169\n163\n128\n125\n114\n107\n101\n108\n105\n98\n97\n83\n80\n75\n85\n72\n70\n72\n69\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n144\n133\n143\n139\n120\n108\n105\n116\n106\n94\n88\n86\n93\n92\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 6\n2 8\n4 1\n5 3\n4 6\n5 8\n2 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n123\n116\n115\n102\n94\n89\n99\n112\n122\n127\n130\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n3 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n264\n216\n213\n202\n180\n164\n158\n135\n132\n114\n107\n103\n98\n95\n87\n85\n71\n76\n73\n79\n66\n64\n58\n56\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n54\n52\n58\n60\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n137\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n34\n26\n23\n"]}, {"input": "6 3 4\n1 1\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n75\n71\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n122\n129\n132\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 2\n1 1\n2 4\n2 2\n1 1\n", "output": ["28\n34\n28\n23\n26\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 4\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n113\n112\n92\n90\n70\n61\n56\n61\n52\n50\n56\n58\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n133\n121\n115\n123\n139\n124\n126\n133\n136\n"]}, {"input": "3 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n4 2\n7 2\n2 3\n3 0\n", "output": ["39\n33\n43\n53\n"]}, {"input": "6 3 4\n1 1\n2 3\n1 2\n2 3\n1 3\n1 5\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n71\n68\n73\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n5 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 10\n4 5\n1 2\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n118\n111\n83\n90\n110\n107\n95\n89\n94\n100\n85\n87\n94\n97\n"]}, {"input": "3 6 4\n1 1\n2 3\n1 2\n1 3\n1 3\n3 4\n2 2\n5 2\n2 3\n3 1\n", "output": ["79\n59\n56\n50\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n197\n"]}, {"input": "2 5 1\n1 4\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["26\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n179\n181\n"]}, {"input": "12 3 4\n2 2\n1 3\n1 1\n1 3\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["177\n173\n170\n174\n"]}, {"input": "2 5 1\n1 2\n1 6\n2 1\n1 3\n4 1\n3 2\n0 3\n0 4\n1 3\n3 1\n", "output": ["25\n"]}, {"input": "1 2 1\n1 1\n", "output": ["1\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 3\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n244\n239\n225\n210\n189\n183\n165\n143\n154\n145\n138\n147\n140\n114\n112\n94\n85\n82\n74\n65\n63\n70\n68\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n28\n39\n29\n23\n17\n22\n20\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n116\n123\n120\n100\n98\n86\n95\n90\n100\n91\n89\n95\n93\n"]}, {"input": "3 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n35\n30\n39\n22\n14\n12\n9\n11\n9\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n2 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n272\n251\n209\n205\n194\n171\n164\n159\n137\n132\n121\n114\n107\n102\n100\n80\n78\n66\n75\n72\n78\n69\n67\n73\n71\n"]}, {"input": "3 4 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n29\n27\n41\n21\n17\n13\n10\n14\n15\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n3 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n20\n22\n25\n29\n"]}, {"input": "3 3 10\n1 2\n1 3\n2 2\n2 2\n2 3\n2 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n12\n23\n19\n10\n19\n9\n13\n11\n"]}, {"input": "3 4 10\n1 4\n1 2\n2 3\n1 2\n2 2\n3 2\n1 3\n3 4\n1 1\n3 1\n", "output": ["49\n35\n24\n29\n18\n14\n12\n9\n6\n4\n"]}, {"input": "1000 1000 2\n494 634\n239 634\n", "output": ["1331884338\n1331183846\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n121\n114\n107\n114\n111\n91\n111\n99\n96\n91\n101\n86\n84\n91\n89\n"]}, {"input": "3 4 6\n1 4\n1 3\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n41\n31\n21\n13\n8\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n98\n78\n74\n62\n82\n79\n85\n76\n74\n80\n78\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n106\n99\n112\n109\n101\n99\n87\n84\n92\n108\n95\n93\n87\n85\n"]}, {"input": "3 3 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n23\n19\n9\n4\n9\n13\n11\n"]}, {"input": "5 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n83\n88\n112\n96\n88\n74\n80\n96\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n165\n159\n127\n122\n115\n108\n101\n96\n93\n79\n78\n66\n75\n72\n75\n66\n64\n70\n67\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n260\n218\n213\n202\n180\n170\n160\n128\n123\n116\n109\n102\n109\n102\n88\n87\n81\n76\n71\n81\n72\n74\n80\n77\n"]}, {"input": "3 3 3\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n57\n"]}, {"input": "1000 1000 2\n59 323\n239 587\n", "output": ["1333014458\n1332224196\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n134\n124\n113\n107\n103\n95\n81\n69\n82\n78\n82\n71\n69\n73\n72\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 7\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n290\n261\n219\n212\n201\n184\n169\n158\n135\n132\n121\n114\n105\n112\n109\n112\n110\n98\n91\n86\n96\n81\n79\n72\n75\n"]}, {"input": "5 10 30\n5 3\n5 10\n5 10\n1 3\n5 7\n1 1\n4 9\n2 6\n4 10\n3 1\n2 5\n5 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n1 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n381\n399\n372\n349\n331\n287\n245\n237\n226\n209\n199\n184\n155\n152\n139\n131\n122\n130\n144\n137\n136\n129\n109\n104\n114\n101\n103\n89\n92\n"]}, {"input": "3 4 10\n1 1\n1 3\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n33\n22\n20\n28\n20\n26\n19\n14\n12\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 3\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n119\n132\n125\n118\n115\n89\n87\n75\n84\n79\n87\n78\n76\n83\n81\n"]}, {"input": "1000 1000 2\n252 412\n239 877\n", "output": ["1332147258\n1331910896\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n80\n72\n80\n71\n69\n75\n70\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n15\n10\n14\n11\n7\n"]}, {"input": "1000 1000 2\n59 722\n239 35\n", "output": ["1333201988\n1332990222\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n75\n73\n"]}, {"input": "3 3 4\n1 2\n2 3\n1 2\n2 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 1\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["25\n23\n31\n22\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 6\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 6\n1 1\n", "output": ["399\n373\n355\n328\n305\n282\n259\n227\n220\n209\n187\n174\n166\n134\n130\n123\n116\n107\n114\n111\n97\n96\n84\n78\n73\n83\n74\n72\n81\n78\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n565\n560\n549\n532\n517\n511\n476\n473\n462\n455\n448\n455\n452\n445\n444\n420\n417\n404\n470\n457\n447\n449\n446\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 3\n1 3\n1 3\n3 3\n2 2\n3 3\n2 3\n3 1\n", "output": ["79\n77\n79\n77\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n85\n83\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["79\n77\n71\n73\n"]}, {"input": "6 3 4\n2 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 2\n2 3\n3 1\n", "output": ["69\n65\n63\n61\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 3\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n27\n25\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 10\n2 6\n3 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n3 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n278\n230\n223\n212\n189\n163\n157\n135\n130\n117\n114\n121\n124\n121\n95\n93\n79\n88\n83\n93\n84\n82\n87\n85\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 2\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n47\n37\n32\n28\n31\n20\n18\n"]}, {"input": "1000 1000 2\n63 634\n239 24\n", "output": ["1333148892\n1333004160\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n135\n130\n121\n93\n86\n114\n121\n141\n137\n125\n120\n128\n144\n129\n127\n134\n126\n"]}, {"input": "3 3 4\n1 3\n2 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n0 3\n3 1\n", "output": ["31\n23\n19\n20\n"]}, {"input": "3 3 4\n1 2\n1 2\n1 2\n1 3\n1 3\n3 3\n4 2\n5 2\n2 3\n3 1\n", "output": ["25\n35\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["399\n373\n355\n328\n305\n289\n283\n235\n222\n217\n200\n169\n163\n128\n125\n114\n109\n99\n104\n101\n94\n93\n79\n76\n73\n78\n65\n63\n65\n62\n"]}, {"input": "2 4 1\n2 4\n1 6\n2 1\n1 2\n4 3\n3 2\n1 3\n0 4\n1 3\n3 1\n", "output": ["20\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 3\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 2\n3 10\n5 2\n2 8\n4 7\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n264\n216\n231\n220\n197\n158\n152\n145\n140\n129\n132\n121\n131\n127\n108\n96\n90\n101\n91\n87\n81\n79\n86\n85\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n2 3\n1 3\n1 5\n2 2\n3 3\n2 3\n3 1\n", "output": ["132\n126\n138\n120\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n2 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 7\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n236\n229\n218\n195\n182\n174\n158\n138\n127\n120\n117\n112\n111\n91\n89\n69\n60\n57\n63\n56\n54\n66\n68\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n143\n137\n145\n161\n131\n127\n134\n142\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 1\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n25\n17\n25\n19\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n2 9\n3 7\n4 10\n3 1\n4 5\n3 8\n1 1\n2 2\n1 5\n2 3\n3 2\n3 9\n5 2\n2 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n277\n223\n213\n202\n179\n161\n153\n137\n126\n115\n108\n105\n100\n96\n76\n74\n66\n59\n56\n62\n53\n51\n57\n59\n"]}, {"input": "2 4 1\n1 2\n1 6\n2 1\n1 3\n4 4\n3 3\n0 3\n0 4\n1 3\n3 1\n", "output": ["17\n"]}, {"input": "12 3 4\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n185\n"]}, {"input": "3 4 10\n1 4\n1 4\n2 3\n1 3\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["49\n53\n33\n29\n43\n33\n43\n33\n25\n23\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 8\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n5 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n346\n323\n306\n290\n246\n212\n206\n195\n172\n157\n151\n129\n124\n113\n106\n104\n111\n108\n88\n86\n82\n91\n86\n96\n87\n89\n95\n93\n"]}, {"input": "6 4 10\n1 4\n1 2\n1 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["144\n128\n120\n130\n110\n78\n76\n71\n73\n65\n"]}, {"input": "3 8 10\n2 1\n1 2\n3 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["115\n100\n98\n113\n90\n86\n79\n74\n81\n82\n"]}, {"input": "3 4 10\n2 4\n1 2\n3 1\n1 2\n2 3\n1 4\n1 3\n3 4\n1 3\n3 1\n", "output": ["43\n31\n27\n39\n25\n23\n21\n19\n21\n25\n"]}, {"input": "1000 1000 2\n494 749\n239 634\n", "output": ["1332338588\n1331638096\n"]}, {"input": "5 10 15\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n2 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n132\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 9\n2 3\n3 2\n3 10\n5 2\n1 8\n2 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n203\n180\n165\n159\n137\n131\n120\n113\n107\n102\n106\n86\n82\n70\n90\n87\n93\n84\n82\n88\n86\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 4\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n184\n169\n163\n140\n137\n119\n104\n97\n84\n81\n78\n76\n64\n61\n69\n79\n68\n66\n63\n61\n"]}, {"input": "3 4 10\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 1\n3 2\n2 3\n3 1\n", "output": ["39\n33\n43\n33\n25\n15\n10\n15\n23\n21\n"]}, {"input": "3 3 4\n1 2\n1 3\n2 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n0 1\n", "output": ["25\n23\n12\n14\n"]}, {"input": "5 7 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 1\n1 3\n3 4\n1 3\n3 1\n", "output": ["243\n216\n187\n192\n243\n227\n209\n162\n168\n184\n"]}, {"input": "5 10 30\n5 3\n5 8\n5 10\n1 3\n5 7\n1 8\n4 9\n2 6\n4 10\n3 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n5 2\n2 7\n2 4\n1 4\n4 8\n2 6\n4 1\n5 2\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n372\n354\n328\n313\n297\n268\n234\n229\n218\n180\n165\n159\n124\n119\n112\n104\n97\n92\n89\n75\n74\n70\n79\n76\n79\n70\n72\n86\n83\n"]}, {"input": "3 4 4\n1 4\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["49\n41\n31\n35\n"]}, {"input": "5 4 10\n1 4\n1 2\n1 3\n1 2\n2 3\n5 2\n1 3\n3 4\n1 3\n5 1\n", "output": ["112\n96\n92\n104\n86\n76\n78\n73\n71\n69\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 4\n3 2\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 2\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n222\n204\n181\n166\n160\n150\n145\n119\n109\n98\n92\n88\n79\n77\n65\n78\n74\n78\n69\n67\n70\n69\n"]}, {"input": "6 4 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 4\n2 3\n3 1\n", "output": ["132\n126\n138\n148\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n3 3\n1 3\n1 3\n2 2\n3 2\n2 3\n2 1\n", "output": ["79\n77\n85\n71\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n2 2\n5 7\n1 8\n4 9\n2 6\n4 10\n3 2\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 10\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n320\n293\n277\n248\n206\n201\n188\n163\n148\n142\n159\n154\n127\n155\n148\n120\n117\n97\n95\n83\n78\n70\n78\n69\n67\n73\n68\n"]}, {"input": "3 3 10\n1 2\n2 3\n1 2\n1 2\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n20\n25\n20\n25\n18\n11\n8\n6\n4\n"]}, {"input": "5 10 28\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n3 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n183\n168\n161\n139\n134\n123\n110\n103\n116\n123\n103\n101\n89\n83\n91\n81\n72\n70\n"]}, {"input": "9 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n4 9\n2 10\n4 10\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["1027\n857\n829\n783\n664\n648\n619\n611\n606\n595\n548\n527\n521\n486\n480\n469\n462\n458\n465\n458\n451\n450\n420\n417\n404\n470\n457\n447\n450\n447\n"]}, {"input": "5 10 30\n5 2\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n5 10\n2 1\n4 5\n3 8\n1 7\n2 2\n1 5\n2 3\n2 1\n3 10\n5 2\n2 8\n4 4\n1 4\n4 8\n2 6\n4 1\n5 3\n4 6\n5 8\n4 9\n1 1\n", "output": ["405\n379\n361\n338\n312\n296\n267\n225\n228\n208\n185\n170\n164\n154\n149\n138\n146\n135\n145\n141\n131\n117\n105\n118\n108\n94\n83\n81\n89\n87\n"]}, {"input": "6 3 4\n1 3\n1 3\n1 1\n1 3\n1 3\n1 3\n2 2\n3 1\n2 3\n3 1\n", "output": ["85\n89\n79\n75\n"]}, {"input": "3 4 10\n2 4\n1 3\n2 3\n1 2\n2 3\n3 2\n1 2\n3 4\n1 1\n3 1\n", "output": ["43\n38\n26\n22\n28\n18\n28\n22\n15\n13\n"]}, {"input": "3 5 10\n1 2\n1 3\n2 2\n2 4\n2 1\n3 2\n2 2\n3 2\n2 4\n3 1\n", "output": ["56\n47\n35\n24\n20\n17\n21\n26\n37\n35\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 7\n1 8\n4 9\n2 6\n4 10\n4 1\n5 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 6\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n306\n290\n261\n219\n214\n206\n228\n213\n206\n171\n166\n151\n119\n112\n144\n151\n174\n170\n158\n153\n161\n177\n154\n152\n137\n128\n"]}, {"input": "6 10 30\n5 3\n5 5\n5 10\n1 3\n5 7\n1 8\n1 9\n2 6\n4 2\n3 1\n2 5\n3 8\n1 7\n2 2\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 4\n4 8\n2 8\n4 1\n5 3\n4 6\n5 8\n1 5\n1 1\n", "output": ["536\n474\n446\n413\n358\n342\n336\n280\n267\n262\n245\n214\n208\n173\n170\n159\n154\n144\n149\n146\n139\n138\n116\n113\n108\n121\n108\n102\n104\n101\n"]}, {"input": "5 10 30\n5 3\n5 5\n5 10\n1 2\n5 10\n1 8\n4 9\n2 6\n4 10\n4 1\n4 5\n3 8\n2 7\n2 4\n1 5\n2 3\n3 2\n3 10\n3 2\n2 7\n2 4\n1 1\n4 3\n2 8\n4 1\n5 3\n4 6\n5 8\n4 5\n1 1\n", "output": ["399\n373\n355\n332\n350\n334\n290\n248\n242\n234\n205\n190\n183\n151\n146\n137\n109\n102\n130\n137\n163\n155\n136\n130\n138\n144\n114\n102\n109\n114\n"]}, {"input": "2 5 8\n1 1\n1 1\n1 1\n2 4\n1 2\n2 2\n2 2\n1 1\n", "output": ["28\n34\n28\n19\n14\n11\n14\n17\n"]}, {"input": "6 3 4\n1 1\n1 3\n2 2\n2 3\n1 3\n1 8\n2 2\n4 3\n2 3\n3 1\n", "output": ["79\n75\n62\n60\n"]}, {"input": "12 3 3\n1 2\n1 3\n1 2\n1 2\n1 5\n6 3\n3 4\n3 3\n2 3\n1 1\n", "output": ["187\n185\n193\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 2\n2 2\n2 2\n3 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 1\n1 2\n1 3\n1 3\n3 2\n3 2\n2 2\n3 3\n3 1\n", "output": ["25\n20\n26\n22\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n2 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n3 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["25\n23\n31\n35\n"]}, {"input": "2 4 1\n1 4\n1 6\n2 1\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n", "output": ["22\n"]}, {"input": "6 3 4\n1 2\n1 3\n1 2\n1 3\n1 3\n1 3\n2 2\n3 2\n2 3\n3 1\n", "output": ["79\n77\n85\n89\n"]}, {"input": "3 3 4\n1 2\n1 3\n1 2\n1 2\n2 3\n3 2\n2 2\n3 2\n2 3\n3 0\n", "output": ["25\n23\n31\n23\n"]}], "task_id": "codecontest/62", "prompt": "You are given a matrix, consisting of n rows and m columns. The rows are numbered top to bottom, the columns are numbered left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one. The third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "repair_prompt": ["You are given a matrix, consisting of n rows and m columns. The rows are numbered top to bottom, the columns are numbered left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one. The third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a matrix, consisting of n rows and m columns. The rows are numbered top to bottom, and the columns are numbered left to right.\n\nEach cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one. The third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one. In this manner, each subsequent cell alternates between moving right and moving down;\n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "You are given a matrix, consisting of n rows and m columns with rows numbered top to bottom and columns numbered left to right. Each cell of the matrix can be either free or locked.\n\nLet's call a path in the matrix a staircase if it: \n\n  * starts and ends in the free cell; \n  * visits only free cells; \n  * has one of the two following structures: \n    1. the second cell is 1 to the right from the first one and the third cell is 1 to the bottom from the second one, the fourth cell is 1 to the right from the third one, and so on; \n    2. the second cell is 1 to the bottom from the first one, the third cell is 1 to the right from the second one, the fourth cell is 1 to the bottom from the third one, and so on. \n\nIn particular, a path, consisting of a single cell, is considered to be a staircase.\n\nHere are some examples of staircases:\n\n<image>\n\nInitially all the cells of the matrix are free.\n\nYou have to process q queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.\n\nPrint the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef process_queries(n: int, m: int, queries: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Process queries to toggle matrix cells and count staircases.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (list[tuple[int, int]]): List of queries to toggle cells.\n\n    Returns:\n        list[int]: List of staircase counts after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free\n    matrix = np.full((n, m), 'free')\n    \n    # Function to count staircases in the current matrix state\n    def count_staircases() -> int:\n        # Dynamic programming table to store staircase counts\n        dp_right = np.zeros((n, m), dtype=int)\n        dp_down = np.zeros((n, m), dtype=int)\n        \n        # Count single cell staircases\n        total_staircases = np.sum(matrix == 'free')\n        \n        # Iterate over each cell to count staircases\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 'free':\n                    # Count staircases starting with right movement\n                    if j > 0 and matrix[i][j-1] == 'free':\n                        dp_right[i][j] = dp_down[i][j-1] + 1\n                    # Count staircases starting with down movement\n                    if i > 0 and matrix[i-1][j] == 'free':\n                        dp_down[i][j] = dp_right[i-1][j] + 1\n                    \n                    # Add to total staircases\n                    total_staircases += dp_right[i][j] + dp_down[i][j]\n        \n        return total_staircases\n    \n    # List to store results after each query\n    results = []\n    \n    # Process each query\n    for x, y in queries:\n        # Toggle the state of the cell\n        matrix[x-1][y-1] = 'locked' if matrix[x-1][y-1] == 'free' else 'free'\n        \n        # Count staircases after the toggle\n        results.append(count_staircases())\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Process the queries and get the result\nresult = process_queries(n, m, queries)\n\n# Output interface\nfor count in result:\n    print(count)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of different staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries, each flipping the state of a cell.\n\n    Returns:\n        List[int]: Number of different staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free\n    matrix = [['free' for _ in range(m)] for _ in range(n)]\n    # Initialize a set to track free cells\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n    # Initialize results list\n    results = []\n\n    def is_free(x: int, y: int) -> bool:\n        \"\"\"Check if a cell is free.\"\"\"\n        return matrix[x][y] == 'free'\n\n    def flip_cell(x: int, y: int):\n        \"\"\"Flip the state of a cell.\"\"\"\n        if matrix[x][y] == 'free':\n            matrix[x][y] = 'locked'\n            free_cells.remove((x, y))\n        else:\n            matrix[x][y] = 'free'\n            free_cells.add((x, y))\n\n    def count_staircases_in_matrix() -> int:\n        \"\"\"Count the number of staircases in the current matrix.\"\"\"\n        # Dynamic programming table to store staircase counts\n        dp_right = [[0] * m for _ in range(n)]\n        dp_down = [[0] * m for _ in range(n)]\n\n        # Initialize single cell staircases\n        for i in range(n):\n            for j in range(m):\n                if is_free(i, j):\n                    dp_right[i][j] = 1\n                    dp_down[i][j] = 1\n\n        # Calculate staircases using dynamic programming\n        for i in range(n):\n            for j in range(m):\n                if is_free(i, j):\n                    if j > 0 and is_free(i, j - 1):\n                        dp_right[i][j] += dp_down[i][j - 1]\n                    if i > 0 and is_free(i - 1, j):\n                        dp_down[i][j] += dp_right[i - 1][j]\n\n        # Sum up all staircases\n        total_staircases = sum(dp_right[i][j] + dp_down[i][j] - 1 for i in range(n) for j in range(m) if is_free(i, j))\n        return total_staircases\n\n    # Process each query\n    for x, y in queries:\n        # Convert 1-based index to 0-based index\n        x -= 1\n        y -= 1\n        # Flip the cell state\n        flip_cell(x, y)\n        # Count staircases after the query\n        results.append(count_staircases_in_matrix())\n\n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to toggle.\n\n    Returns:\n        List[int]: List of integers where each integer is the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Function to toggle the state of a cell\n    def toggle_cell(x: int, y: int):\n        matrix[x][y] = not matrix[x][y]\n\n    # Function to count staircases using dynamic programming\n    def count_all_staircases() -> int:\n        # Initialize DP tables\n        dp_right = [[0] * m for _ in range(n)]\n        dp_down = [[0] * m for _ in range(n)]\n        \n        total_staircases = 0\n        \n        # Fill DP tables\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:\n                    # Single cell is a staircase\n                    dp_right[i][j] = 1\n                    dp_down[i][j] = 1\n                    \n                    # Right then down\n                    if j > 0:\n                        dp_right[i][j] += dp_down[i][j - 1]\n                    \n                    # Down then right\n                    if i > 0:\n                        dp_down[i][j] += dp_right[i - 1][j]\n                    \n                    # Add to total staircases\n                    total_staircases += dp_right[i][j] + dp_down[i][j] - 1  # Subtract 1 to avoid double counting single cell\n                    \n        return total_staircases\n\n    results = []\n    for x, y in queries:\n        toggle_cell(x - 1, y - 1)  # Convert to 0-based index\n        results.append(count_all_staircases())\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Count the number of different staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to flip the state of cells.\n\n    Returns:\n        List[int]: Number of different staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True represents free, False represents locked)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Initialize a 2D list to track the number of staircases ending at each cell\n    staircases_count = [[0] * m for _ in range(n)]\n    \n    # Function to update the staircase count for a given cell\n    def update_staircases(x: int, y: int):\n        if matrix[x][y]:  # If the cell is free\n            # Count staircases ending at (x, y) based on its neighbors\n            staircases_count[x][y] = 1  # Single cell staircase\n            if x > 0 and y > 0 and matrix[x-1][y] and matrix[x][y-1]:\n                staircases_count[x][y] += staircases_count[x-1][y-1]\n            if x > 0 and y < m - 1 and matrix[x-1][y] and matrix[x][y+1]:\n                staircases_count[x][y] += staircases_count[x-1][y+1]\n            if x < n - 1 and y > 0 and matrix[x+1][y] and matrix[x][y-1]:\n                staircases_count[x][y] += staircases_count[x+1][y-1]\n            if x < n - 1 and y < m - 1 and matrix[x+1][y] and matrix[x][y+1]:\n                staircases_count[x][y] += staircases_count[x+1][y+1]\n        else:\n            staircases_count[x][y] = 0  # No staircases can end at a locked cell\n    \n    # Precompute staircases for the initial matrix\n    for i in range(n):\n        for j in range(m):\n            update_staircases(i, j)\n    \n    results = []\n    \n    # Process each query\n    for x, y in queries:\n        # Flip the state of the cell\n        matrix[x-1][y-1] = not matrix[x-1][y-1]\n        \n        # Update staircases for the affected cell and its neighbors\n        update_staircases(x-1, y-1)\n        if x > 1:\n            update_staircases(x-2, y-1)\n        if x < n:\n            update_staircases(x, y-1)\n        if y > 1:\n            update_staircases(x-1, y-2)\n        if y < m:\n            update_staircases(x-1, y)\n        \n        # Calculate the total number of staircases\n        total_staircases = sum(sum(row) for row in staircases_count)\n        results.append(total_staircases)\n    \n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the number of different staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cell states.\n\n    Returns:\n        List[int]: Number of different staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free\n    matrix = [[True] * m for _ in range(n)]\n    # Initialize a set to track free cells\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n    \n    def toggle_cell(x: int, y: int):\n        \"\"\"Toggle the state of the cell at position (x, y).\"\"\"\n        if matrix[x][y]:\n            matrix[x][y] = False\n            free_cells.remove((x, y))\n        else:\n            matrix[x][y] = True\n            free_cells.add((x, y))\n    \n    def count_staircases_around_cell(x: int, y: int) -> int:\n        \"\"\"Count staircases affected by the cell at (x, y).\"\"\"\n        count = 0\n        # Check for single cell staircase\n        if matrix[x][y]:\n            count += 1\n        \n        # Check for staircases following the right-down-right pattern\n        if x < n - 1 and y < m - 1:\n            if matrix[x][y] and matrix[x][y + 1] and matrix[x + 1][y + 1]:\n                count += 1\n            if matrix[x][y] and matrix[x + 1][y] and matrix[x + 1][y + 1]:\n                count += 1\n        \n        # Check for staircases following the down-right-down pattern\n        if x > 0 and y > 0:\n            if matrix[x][y] and matrix[x][y - 1] and matrix[x - 1][y - 1]:\n                count += 1\n            if matrix[x][y] and matrix[x - 1][y] and matrix[x - 1][y - 1]:\n                count += 1\n        \n        return count\n    \n    results = []\n    total_staircases = 0\n    for x, y in queries:\n        # Convert to zero-based index\n        x -= 1\n        y -= 1\n        \n        # Subtract staircases affected by the current cell before toggling\n        total_staircases -= count_staircases_around_cell(x, y)\n        \n        # Toggle the cell state\n        toggle_cell(x, y)\n        \n        # Add staircases affected by the current cell after toggling\n        total_staircases += count_staircases_around_cell(x, y)\n        \n        results.append(total_staircases)\n    \n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to toggle.\n\n    Returns:\n        List[int]: List of integers representing the number of unique staircases after each query.\n    \"\"\"\n    # Initialize matrix with all cells free\n    matrix = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n    \n    def calculate_staircases(free_cells: set) -> int:\n        \"\"\"Calculates the number of unique staircases in the matrix.\n\n        Args:\n            free_cells (set): Set of tuples representing free cells in the matrix.\n\n        Returns:\n            int: Number of unique staircases.\n        \"\"\"\n        # Initialize DP tables for staircase counting\n        dp_right_down = [[0] * m for _ in range(n)]\n        dp_down_right = [[0] * m for _ in range(n)]\n        \n        # Iterate over each cell in the matrix\n        for i in range(n):\n            for j in range(m):\n                if (i, j) in free_cells:\n                    # Single cell is a staircase\n                    dp_right_down[i][j] = 1\n                    dp_down_right[i][j] = 1\n                    \n                    # Check for right-down-right pattern\n                    if j > 0 and i > 0:\n                        dp_right_down[i][j] += dp_down_right[i-1][j-1]\n                    \n                    # Check for down-right-down pattern\n                    if i > 0 and j > 0:\n                        dp_down_right[i][j] += dp_right_down[i-1][j-1]\n        \n        # Sum all staircases from both patterns\n        total_staircases = sum(dp_right_down[i][j] + dp_down_right[i][j] for i in range(n) for j in range(m))\n        return total_staircases\n\n    results = []\n    \n    for x, y in queries:\n        # Toggle cell state\n        if (x-1, y-1) in free_cells:\n            free_cells.remove((x-1, y-1))\n        else:\n            free_cells.add((x-1, y-1))\n        \n        # Recalculate staircases\n        num_staircases = calculate_staircases(free_cells)\n        results.append(num_staircases)\n    \n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output results\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Process queries to count the number of staircases in a matrix.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to toggle cell states.\n\n    Returns:\n        List[int]: Number of different staircases after each query.\n    \"\"\"\n    # Initialize matrix and set of free cells\n    matrix = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n\n    def count_staircases_dp() -> int:\n        \"\"\"Count staircases using dynamic programming.\n\n        Returns:\n            int: Number of different staircases.\n        \"\"\"\n        # Initialize DP tables for both movement patterns\n        dp_right_down = [[0] * m for _ in range(n)]\n        dp_down_right = [[0] * m for _ in range(n)]\n\n        # Base case: single cell staircases\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:\n                    dp_right_down[i][j] = 1\n                    dp_down_right[i][j] = 1\n\n        # Fill DP tables\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j]:\n                    if j > 0 and i > 0:\n                        dp_right_down[i][j] += dp_down_right[i-1][j-1]\n                    if i > 0 and j > 0:\n                        dp_down_right[i][j] += dp_right_down[i-1][j-1]\n\n        # Sum all possible staircases\n        total_staircases = sum(sum(row) for row in dp_right_down) + sum(sum(row) for row in dp_down_right)\n        return total_staircases\n\n    results = []\n    for x, y in queries:\n        # Toggle cell state\n        if (x-1, y-1) in free_cells:\n            free_cells.remove((x-1, y-1))\n            matrix[x-1][y-1] = False\n        else:\n            free_cells.add((x-1, y-1))\n            matrix[x-1][y-1] = True\n\n        # Count staircases after each query\n        results.append(count_staircases_dp())\n\n    return results\n\n# Input interface\ndef main():\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n\n    # Output interface\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of different staircases after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating the cell to flip.\n\n    Returns:\n        List[int]: List of integers where each integer is the number of different staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Initialize DP tables to store the number of staircases ending at each cell\n    dp_right_down = [[0] * m for _ in range(n)]\n    dp_down_right = [[0] * m for _ in range(n)]\n    \n    # Function to update the DP tables for a given cell\n    def update_dp(x: int, y: int):\n        if not matrix[x][y]:\n            dp_right_down[x][y] = 0\n            dp_down_right[x][y] = 0\n            return\n        \n        # Single cell is a staircase\n        dp_right_down[x][y] = 1\n        dp_down_right[x][y] = 1\n        \n        # Check for staircases ending at (x, y) with right-down pattern\n        if y > 0 and x > 0 and matrix[x][y-1] and matrix[x-1][y]:\n            dp_right_down[x][y] += dp_down_right[x-1][y-1]\n        \n        # Check for staircases ending at (x, y) with down-right pattern\n        if x > 0 and y > 0 and matrix[x-1][y] and matrix[x][y-1]:\n            dp_down_right[x][y] += dp_right_down[x-1][y-1]\n\n    # Function to recalculate the total number of staircases\n    def recalculate_staircases() -> int:\n        total_staircases = 0\n        for i in range(n):\n            for j in range(m):\n                update_dp(i, j)\n                total_staircases += dp_right_down[i][j] + dp_down_right[i][j]\n        return total_staircases\n\n    # List to store the result after each query\n    results = []\n\n    # Initial calculation of staircases\n    total_staircases = recalculate_staircases()\n    results.append(total_staircases)\n\n    # Process each query\n    for x, y in queries:\n        # Flip the state of the cell\n        matrix[x - 1][y - 1] = not matrix[x - 1][y - 1]\n        \n        # Recalculate the number of staircases\n        total_staircases = recalculate_staircases()\n        \n        # Append the result for this query\n        results.append(total_staircases)\n\n    return results\n\n# Input interface\nn, m, q = map(int, input().split())\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = count_staircases(n, m, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Count the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries where each query is a tuple (x, y) indicating\n                                         the cell to flip between free and locked.\n\n    Returns:\n        List[int]: List of integers where each integer is the number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells free (True)\n    matrix = [[True] * m for _ in range(n)]\n    \n    # Function to check if a cell is within bounds and free\n    def is_free(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m and matrix[x][y]\n\n    # Function to count staircases starting from a given cell\n    def count_staircases_from(x: int, y: int) -> int:\n        if not is_free(x, y):\n            return 0\n        # Count single cell as a staircase\n        count = 1\n        # Check for staircases in the first pattern\n        i, j = x, y\n        while is_free(i, j + 1) and is_free(i + 1, j + 1):\n            count += 1\n            i += 1\n            j += 1\n        # Check for staircases in the second pattern\n        i, j = x, y\n        while is_free(i + 1, j) and is_free(i + 1, j + 1):\n            count += 1\n            i += 1\n            j += 1\n        return count\n\n    results = []\n    for x, y in queries:\n        # Convert 1-based index to 0-based index\n        x -= 1\n        y -= 1\n        # Flip the state of the cell\n        matrix[x][y] = not matrix[x][y]\n        \n        # Recalculate the number of staircases\n        total_staircases = 0\n        for i in range(n):\n            for j in range(m):\n                total_staircases += count_staircases_from(i, j)\n        \n        results.append(total_staircases)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    # Output results\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_staircases(n: int, m: int, queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Counts the number of unique staircases in a matrix after each query.\n\n    Args:\n        n (int): Number of rows in the matrix.\n        m (int): Number of columns in the matrix.\n        queries (List[Tuple[int, int]]): List of queries to flip the state of cells.\n\n    Returns:\n        List[int]: Number of unique staircases after each query.\n    \"\"\"\n    # Initialize the matrix with all cells marked as free\n    locked_cells = set()\n    results = []\n\n    # Precompute the number of staircases for each cell using dynamic programming\n    def precompute_staircases():\n        \"\"\"Precompute the number of staircases for each cell.\"\"\"\n        staircases = [[0] * m for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(m):\n                if is_free(i, j):\n                    # Single cell staircase\n                    staircases[i][j] = 1\n                    \n                    # Pattern 1: Right, Down, Right, Down...\n                    if i > 0 and j > 0 and is_free(i - 1, j) and is_free(i, j - 1):\n                        staircases[i][j] += staircases[i - 1][j - 1]\n                    \n                    # Pattern 2: Down, Right, Down, Right...\n                    if i > 0 and j > 0 and is_free(i, j - 1) and is_free(i - 1, j):\n                        staircases[i][j] += staircases[i - 1][j - 1]\n        \n        return staircases\n\n    def is_free(x: int, y: int) -> bool:\n        \"\"\"Check if a cell is free.\"\"\"\n        return (x, y) not in locked_cells\n\n    def count_staircases_in_matrix() -> int:\n        \"\"\"Count the number of unique staircases in the current matrix state.\"\"\"\n        staircases = precompute_staircases()\n        return sum(sum(row) for row in staircases)\n\n    for x, y in queries:\n        # Flip the state of the specified cell\n        if (x, y) in locked_cells:\n            locked_cells.remove((x, y))\n        else:\n            locked_cells.add((x, y))\n\n        # Recalculate the number of staircases after each query\n        result = count_staircases_in_matrix()\n        results.append(result)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, m, q = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n\n    results = count_staircases(n, m, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on processing a series of queries that flip the state of cells in a matrix and calculating the number of unique staircases after each query. The solution must efficiently handle large matrices and numerous queries, ensuring accurate results and scalability.\nrequirement pool:\n- Implement efficient query processing to update matrix state\n- Develop algorithm to accurately count staircases\n- Ensure scalability for large matrices and query sets\n- Provide clear input/output instructions\n- Optimize performance for real-time query handling\nWe will use a combination of data structures to efficiently manage the matrix state and count staircases. A 2D list will represent the matrix, where each cell can be toggled between free and locked. We will use a dynamic programming approach to count staircases, updating the count efficiently after each query. This approach will ensure that we handle large matrices and numerous queries efficiently. We will also leverage numpy for efficient matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A matrix is a 2D array consisting of rows and columns. In this problem, each cell in the matrix can be either free or locked, and we need to determine paths called staircases.\n\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific structures: alternating right and down movements or alternating down and right movements.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by checking adjacent cells in the matrix for free status and following the specified movement pattern.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a 2D list to represent the matrix, marking all cells as free initially.\n    2. For each query, toggle the state of the specified cell between free and locked.\n    3. After each query, count the number of different staircases:\n        - Iterate over each cell in the matrix.\n        - For each free cell, attempt to construct staircases following both movement patterns.\n        - Use dynamic programming to efficiently count valid paths.\n    4. Output the number of different staircases after each query.\n\n# [edge case]\n    Edge Case 1: Matrix with all cells initially locked\n    Explanation: If all cells are locked initially, no staircases can be formed. The output for any query will be 0.\n\n    Edge Case 2: Matrix with only one cell\n    Explanation: A single free cell is considered a staircase. The output will be 1 if the cell is free and 0 if it is locked.\n\n    Edge Case 3: Queries that toggle the same cell repeatedly\n    Explanation: Repeatedly toggling the same cell will alternate between affecting and not affecting staircase counts. The output will reflect these changes.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            # Handle single cell matrix separately\n            return [1 if matrix[0][0] == 'free' else 0 for _ in range(q)]\n        \n        # Additional logic for handling all locked cells\n        if all(matrix[i][j] == 'locked' for i in range(n) for j in range(m)):\n            return [0] * q\n        \n        # Code for handling repeated toggling of the same cell\n        # This can be managed within the main logic by tracking changes in staircase counts after each query.\n", "requirement analysis:\nThe requirements focus on processing a series of queries that flip the state of cells in a matrix and counting the number of distinct staircases after each query. The solution must efficiently handle large matrices and numerous queries, ensuring accurate staircase counts. The output format must strictly follow the examples provided, and the solution should be scalable to accommodate the maximum constraints.\nrequirement pool:\n- Implement efficient matrix state update mechanism for queries\n- Develop accurate staircase counting algorithm\n- Ensure scalability for large matrices and high query volumes\n- Provide clear input/output formatting instructions\n- Optimize performance for real-time query processing\nWe will use a matrix to represent the grid and a set to track the free cells. For each query, we will flip the state of the specified cell and update the set of free cells. To efficiently count staircases, we will use dynamic programming to track possible paths and update them incrementally as queries are processed. This approach ensures scalability and efficiency, especially for large matrices and numerous queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A matrix is a two-dimensional array consisting of rows and columns. In this requirement, it represents a grid where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific structures: alternating right and down movements or alternating down and right movements.\n\n    'query'\n    Explanation: A query is an operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. \"1 to the right\" means moving horizontally to the next column, and \"1 to the bottom\" means moving vertically to the next row. In code, this can be implemented by adjusting indices in a loop or recursive function.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the grid and a set to track free cells.\n    2. For each query, flip the state of the specified cell and update the set of free cells.\n    3. Use dynamic programming to track possible paths and update them incrementally as queries are processed.\n    4. Count the number of different staircases after each query by checking paths that start and end in free cells and follow the staircase structure.\n    5. Output the count after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Expected Output: 0\n    Explanation: No staircases can exist if all cells are locked.\n\n    Edge Case 2: A matrix with only one cell.\n    Expected Output: 1\n    Explanation: A single free cell is considered a staircase.\n\n    Edge Case 3: A matrix with alternating locked and free cells.\n    Expected Output: Depends on the specific arrangement, but should account for paths that can still form staircases despite locked cells.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            return 1 if matrix[0][0] == 'free' else 0\n        if all(matrix[i][j] == 'locked' for i in range(n) for j in range(m)):\n            return 0\n        # Additional logic to handle alternating locked and free cells efficiently.\n", "requirement analysis:\nThe task requires processing a series of queries that flip the state of cells in a matrix and then counting the number of unique staircases. The solution must efficiently handle up to 10,000 queries on matrices as large as 1000x1000, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently process each query to update the matrix state.\n- Accurately count the number of unique staircases after each query.\n- Optimize the solution for large matrices and numerous queries.\n- Ensure the solution adheres to the specified input and output format.\n- Provide clear documentation and examples for user understanding.\nWe will use a matrix to represent the grid and a set to track the free cells. For each query, we will update the state of the cell and recalculate the number of unique staircases using a depth-first search (DFS) approach. This will allow us to efficiently explore all possible staircase paths starting from each free cell.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure with rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern (either right then down or down then right).\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix to represent the grid and a set to track free cells.\n2. For each query, toggle the state of the specified cell.\n3. Use a depth-first search (DFS) to explore all possible staircase paths starting from each free cell.\n4. Count and store the number of unique staircases after each query.\n5. Output the number of unique staircases for each query.\n\n# [edge case]\n    Edge Case 1: A 1x1 matrix with a single query flipping the only cell.\n    Expected Output: 0\n    Explanation: After flipping, there are no free cells, so no staircases exist.\n\n    Edge Case 2: A 2x2 matrix with all cells initially free and a query that locks one cell.\n    Expected Output: 5\n    Explanation: Initially, there are 5 staircases (each cell individually plus two zigzag paths). Locking one cell reduces the count.\n\n    Edge Case 3: A large matrix (1000x1000) with no queries.\n    Expected Output: A large number representing all possible staircases in a fully free grid.\n    Explanation: The number of staircases is determined by the combinatorial possibilities of zigzag paths in a large grid.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement a check for when all cells are locked to immediately return 0 staircases.\n        - Optimize DFS to handle large matrices efficiently by pruning paths that cannot form valid staircases due to locked cells.\n", "requirement analysis:\nThe task requires efficiently processing a series of queries that flip the state of cells in a matrix and calculating the number of unique staircases after each query. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently process each query to update the matrix state.\n- Accurately count the number of different staircases after each query.\n- Optimize the solution for large matrices and numerous queries.\n- Provide clear and correct output for each query.\n- Ensure the solution is user-friendly and easy to understand.\nWe will use a dynamic programming approach to efficiently count staircases. The matrix will be represented as a 2D list, and we will maintain a separate 2D list to track the number of staircases ending at each cell. For each query, we will update the matrix and recalculate the staircases using the precomputed values, ensuring the solution is scalable for large matrices and numerous queries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A matrix is a two-dimensional array consisting of rows and columns. In this requirement, each cell in the matrix can be either free or locked, and the task involves processing queries that flip the state of these cells.\n\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two alternating movement patterns (right-down-right or down-right-down).\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path, where each subsequent cell alternates between moving one step to the right or one step down. In code, this can be implemented by adjusting the indices of the matrix accordingly.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the free and locked cells.\n    2. Initialize a 2D list to track the number of staircases ending at each cell.\n    3. For each query, flip the state of the specified cell.\n    4. Recalculate the number of staircases using dynamic programming:\n        - For each free cell, check if it can be part of a staircase by following the movement patterns.\n        - Update the staircase count for each cell based on its neighbors.\n    5. Output the number of different staircases after each query.\n\n# [edge case]\n    Edge Case 1: Matrix with all cells initially locked\n    Explanation: If all cells are initially locked, no staircases can exist. Flipping any cell to free will create a single-cell staircase.\n    \n    Edge Case 2: Matrix with only one row or one column\n    Explanation: In a single row or column, staircases can only consist of single cells or follow a straight line pattern.\n\n    Edge Case 3: Queries that repeatedly flip the same cell\n    Explanation: Flipping the same cell multiple times will alternate its state between free and locked, affecting the staircase count accordingly.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Check if all cells are initially locked and handle accordingly.\n        - Implement logic to handle matrices with only one row or column.\n        - Track changes in staircase count when flipping the same cell multiple times.\n", "requirement analysis:\nThe requirements focus on processing a matrix with queries that flip cell states and counting staircases. The solution must efficiently handle large matrices and numerous queries while accurately counting staircases. The output format must strictly follow the examples provided.\nrequirement pool:\n- Efficiently process matrix queries\n- Accurately count staircases after each query\n- Ensure scalability for large matrices\n- Provide clear input/output instructions\n- Optimize for performance in high query scenarios\nWe will use a matrix to represent the grid and a set to track the free cells. For each query, we will toggle the state of the specified cell and then recalculate the number of staircases. The recalculation will involve checking possible staircases starting from each free cell. Given the constraints, we will optimize the counting process by leveraging the alternating pattern of staircases and using efficient data structures to minimize redundant calculations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A matrix is a two-dimensional array consisting of rows and columns. In this requirement, it represents the grid where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two alternating movement patterns (right-down-right or down-right-down).\n\n    'query'\n    Explanation: A query is an operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path, where each subsequent cell is either one step to the right or one step down from the previous cell. In code, this can be implemented by adjusting the indices of the matrix accordingly.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the grid and a set to track free cells.\n    2. For each query, toggle the state of the specified cell.\n    3. Recalculate the number of staircases by checking possible staircases starting from each free cell.\n    4. Use efficient data structures to minimize redundant calculations and optimize counting.\n    5. Output the number of different staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially free and no queries.\n    Expected Output: The number of staircases would be calculated based on all possible paths in the matrix.\n    Explanation: Since no queries are processed, all cells remain free, allowing maximum possible staircases.\n\n    Edge Case 2: A matrix with all cells initially locked and no queries.\n    Expected Output: 0\n    Explanation: Since all cells are locked, no staircases can exist.\n\n    Edge Case 3: A single cell matrix with one query flipping its state.\n    Expected Output: 1 after flipping to free, 0 after flipping to locked.\n    Explanation: A single cell can be a staircase when free, but not when locked.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n == 1 and m == 1:\n            if matrix[0][0] == 'free':\n                return 1\n            else:\n                return 0\n        elif all cells are locked:\n            return 0\n        (other code)\n", "requirement analysis:\nThe task requires efficiently processing a series of queries on a matrix to determine the number of unique staircase paths. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy. The challenge lies in dynamically updating the path count as cells are toggled between free and locked states.\nrequirement pool:\n- Implement efficient matrix query processing.\n- Accurately count unique staircase paths after each query.\n- Optimize for large matrix sizes and numerous queries.\n- Ensure the solution is scalable and performs well under maximum constraints.\n- Provide clear and immediate output for each query.\nWe will use a combination of data structures to efficiently manage the matrix and queries. A 2D list will represent the matrix, and a set will track the free cells. For each query, we will toggle the state of the cell and recalculate the number of unique staircases. The challenge is to efficiently count staircases, which can be achieved by maintaining a dynamic programming table that updates as cells are toggled. This approach ensures that we can handle large matrices and numerous queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    A grid-like structure consisting of rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific alternating pattern of movements (right-down-right or down-right-down).\n\n    'query'\n    An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    These phrases describe the movement pattern of the staircase path, indicating a shift by one cell in the specified direction.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a 2D list to represent the matrix, marking all cells as free initially.\n2. Use a set to track free cells for efficient toggling.\n3. For each query:\n   - Toggle the state of the specified cell.\n   - Update the matrix and set accordingly.\n   - Recalculate the number of unique staircases using a dynamic programming approach:\n     - For each free cell, check if it can be part of a staircase by following the alternating movement pattern.\n     - Count all valid staircases.\n4. Output the number of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with only one cell (1x1) and one query.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: The single cell is toggled to locked, leaving no free cells for a staircase.\n\n    Edge Case 2: A matrix with all cells initially locked.\n    Input: 2 2 1\n           1 1\n    Expected Output: 0\n    Explanation: Toggling one cell to free does not create any valid staircase paths.\n\n    Edge Case 3: A large matrix with no queries.\n    Input: 1000 1000 0\n    Expected Output: 0\n    Explanation: No queries mean no changes to the initial state, so no staircases are formed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no staircases can be formed due to all cells being locked or no queries being present.\n    \n```python\ndef handle_edge_cases(n, m, q, queries):\n    if q == 0:\n        return [0] * q\n    # Initialize matrix and set for free cells\n    matrix = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n    \n    results = []\n    \n    for x, y in queries:\n        # Toggle cell state\n        if (x-1, y-1) in free_cells:\n            free_cells.remove((x-1, y-1))\n        else:\n            free_cells.add((x-1, y-1))\n        \n        # Recalculate staircases (simplified logic for demonstration)\n        # This part would involve dynamic programming logic to count staircases\n        num_staircases = calculate_staircases(free_cells)\n        \n        results.append(num_staircases)\n    \n    return results\n\ndef calculate_staircases(free_cells):\n    # Placeholder function for counting staircases\n    # Implement dynamic programming logic here\n    return len(free_cells)  # Simplified example\n\n# Example usage:\nn, m, q = 2, 2, 8\nqueries = [(1, 1), (1, 1), (1, 1), (2, 2), (1, 1), (1, 2), (2, 1), (1, 1)]\nprint(handle_edge_cases(n, m, q, queries))\n```\nThis code provides a basic structure for handling edge cases and toggling cell states. The `calculate_staircases` function is a placeholder where dynamic programming logic would be implemented to count valid staircases efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries to flip cell states and accurately counting staircases. The solution must handle large matrices and numerous queries, ensuring scalability and performance.\nrequirement pool:\n- Implement efficient query processing to update matrix state\n- Develop algorithm to count staircases accurately\n- Ensure scalability for large matrices and query counts\n- Optimize performance for real-time query handling\n- Provide clear and concise output format\nWe will use a combination of efficient data structures and algorithms to handle the matrix updates and staircase counting. The matrix will be represented as a 2D list, and we will use a set to track the free cells. For each query, we will update the matrix and recalculate the number of staircases using a dynamic programming approach to ensure efficiency. This approach will allow us to handle large matrices and a high number of queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure consisting of rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific pattern of movement (either right then down or down then right).\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right': Move one column to the right in the matrix.\n    \n    '1 to the bottom': Move one row down in the matrix.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a 2D list to represent the matrix and a set to track free cells.\n2. For each query, toggle the state of the specified cell.\n3. After each query, recalculate the number of staircases:\n   - Use dynamic programming to efficiently count paths that meet the staircase criteria.\n   - Consider both patterns of movement (right then down, down then right).\n4. Output the number of different staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can exist if all cells are locked. The output should be 0 after each query unless a cell is unlocked.\n\n    Edge Case 2: A single cell matrix (1x1).\n    Explanation: The only possible staircase is the single cell itself if it is free. The output should be 1 if the cell is free, 0 if locked.\n\n    Edge Case 3: A matrix with alternating locked and free cells.\n    Explanation: Depending on the pattern, staircases may be limited or non-existent. The output will vary based on specific queries.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - For a matrix with all cells initially locked, ensure that no staircases are counted unless a cell is unlocked.\n    - For a single cell matrix, handle it as a special case where the only possible staircase is the cell itself if free.\n    \n```python\ndef process_queries(n, m, queries):\n    # Initialize matrix and set of free cells\n    matrix = [[True] * m for _ in range(n)]\n    free_cells = set((i, j) for i in range(n) for j in range(m))\n    \n    def count_staircases():\n        # Implement dynamic programming approach to count staircases\n        # Consider both movement patterns\n        pass\n    \n    results = []\n    for x, y in queries:\n        # Toggle cell state\n        if (x-1, y-1) in free_cells:\n            free_cells.remove((x-1, y-1))\n            matrix[x-1][y-1] = False\n        else:\n            free_cells.add((x-1, y-1))\n            matrix[x-1][y-1] = True\n        \n        # Count staircases after each query\n        results.append(count_staircases())\n    \n    return results\n```\n\nThis code provides a framework for handling queries and counting staircases, with placeholders for implementing the dynamic programming logic needed to efficiently count staircases.\n", "requirement analysis:\nThe task requires efficiently processing a series of queries that flip the state of cells in a matrix and calculating the number of unique staircases after each query. The solution must handle large matrices and a high number of queries, ensuring performance and accuracy.\nrequirement pool:\n- Efficiently process each query to update the matrix state.\n- Accurately count the number of different staircases after each query.\n- Optimize the solution for large matrices and numerous queries.\n- Ensure the solution is scalable and performs well under maximum constraints.\n- Provide clear and formatted output for each query result.\nWe will use a matrix to represent the grid and a set to track the free cells. For each query, we will flip the state of the cell and update the set accordingly. To efficiently count staircases, we will use a dynamic programming approach to track possible paths and update them as cells are flipped. This will ensure that we can handle large matrices and numerous queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A matrix is a two-dimensional array consisting of rows and columns. In this requirement, it represents a grid where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific structures: alternating right and down movements or alternating down and right movements.\n\n    'query'\n    Explanation: A query is an operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path. In code, this can be implemented by adjusting the indices of the matrix to move right (increment column index) or down (increment row index).\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Initialize a matrix to represent the grid and a set to track free cells.\n    2. For each query, flip the state of the specified cell and update the set of free cells.\n    3. Use dynamic programming to count possible staircase paths by tracking valid paths as cells are flipped.\n    4. After each query, calculate and print the number of different staircases.\n\n# [edge case]\n    Edge Case 1: A matrix with only one cell (1x1) and one query flipping that cell.\n    Expected Output: 0\n    Explanation: Initially, there is one staircase (the single free cell). After flipping, there are no free cells, so no staircases exist.\n\n    Edge Case 2: A matrix with all cells initially locked and queries unlocking them one by one.\n    Expected Output: Depends on the sequence of queries; initially 0, then increases as cells are unlocked.\n\n    Edge Case 3: A matrix with alternating free and locked cells in a checkerboard pattern.\n    Expected Output: Depends on the sequence of queries; staircases can only form in contiguous free areas.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Implement logic to handle matrices with minimal dimensions (e.g., 1x1).\n        - Ensure dynamic programming efficiently updates paths as cells are flipped.\n        - Consider edge cases where all cells are initially locked or unlocked.\n", "requirement analysis:\nThe requirements focus on processing matrix queries efficiently and accurately counting staircases. The solution must handle large matrices and provide consistent output as per the examples. User input should be straightforward, and the output should match the expected format.\nrequirement pool:\n- Implement efficient matrix query processing.\n- Ensure accurate staircase counting after each query.\n- Optimize performance for large matrices.\n- Provide clear input and output instructions.\n- Enhance user interface for better usability.\nWe will use a combination of efficient data structures and algorithms to handle matrix queries and staircase counting. The approach will involve maintaining a dynamic representation of the matrix and efficiently updating and querying it using a segment tree or similar structure. Libraries such as NumPy can be used for matrix operations to optimize performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A grid-like structure consisting of rows and columns where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A path in the matrix that starts and ends in a free cell, visits only free cells, and follows a specific zigzag pattern.\n\n    'query'\n    Explanation: An operation that flips the state of a single cell in the matrix from free to locked or vice versa.\n\n# [phrase showing quantity relationship]\n    '1 to the right', '1 to the bottom'\n    Explanation: These phrases describe the movement pattern of the staircase path, where each step is either one cell to the right or one cell down from the previous cell.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix of size n x m with all cells marked as free.\n2. For each query, flip the state of the specified cell (from free to locked or vice versa).\n3. After each query, count the number of different staircases:\n   - Iterate through each cell in the matrix.\n   - For each free cell, attempt to form a staircase path following the two defined patterns.\n   - Use a set to track unique staircases based on their cell composition.\n4. Output the count of unique staircases after each query.\n\n# [edge case]\n    Edge Case 1: A matrix with all cells initially locked.\n    Explanation: No staircases can be formed, so the output after any query should be 0.\n\n    Edge Case 2: A single cell matrix (1x1).\n    Explanation: The only possible staircase is the single cell itself, so the output should be 1 after any query that makes it free.\n\n    Edge Case 3: A matrix with alternating locked and free cells initially.\n    Explanation: Depending on the initial configuration, some queries may not change the number of staircases if they flip a cell that doesn't affect any existing staircase paths.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Specifically, handle cases where the matrix is very small (e.g., 1x1) or where all cells are initially locked.\n    - Implement logic to efficiently check and update staircase paths when a query affects a critical cell in an existing path.\n", "requirement analysis:\nThe requirement is to efficiently calculate the number of unique staircases in a matrix after each query. The matrix can be large, and the number of queries is significant, so performance optimization is crucial. The solution should handle toggling of cell states and recalculate the staircases accurately.\nrequirement pool:\n- Efficiently handle matrix size up to 1000x1000.\n- Process up to 10,000 queries efficiently.\n- Accurately calculate the number of unique staircases after each query.\n- Provide clear and concise output format.\n- Optimize for performance to handle high query volumes.\nWe will use a combination of data structures to efficiently track the state of the matrix and calculate the number of unique staircases. A set will be used to store the coordinates of locked cells, and a function will be implemented to count staircases by iterating over the matrix and checking possible staircase paths. This approach ensures that we can handle large matrices and a high number of queries efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'matrix'\n    Explanation: A matrix is a two-dimensional array of elements arranged in rows and columns. In this requirement, it represents the grid where each cell can be either free or locked.\n\n    'staircase'\n    Explanation: A staircase is a path in the matrix that starts and ends in a free cell, visits only free cells, and follows one of two specific patterns: alternating right and down movements or alternating down and right movements.\n\n    'query'\n    Explanation: A query is an operation that flips the state of a single cell in the matrix from free to locked or from locked to free.\n\n# [phrase showing quantity relationship]\n    '1 to the right': means moving horizontally to the next column.\n    '1 to the bottom': means moving vertically to the next row.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize a matrix with all cells marked as free.\n2. Use a set to track locked cells.\n3. Implement a function to count staircases:\n   - Iterate over each cell in the matrix.\n   - For each free cell, attempt to build staircases following both patterns.\n   - Count valid staircases that do not intersect with locked cells.\n4. For each query:\n   - Flip the state of the specified cell.\n   - Recalculate the number of staircases using the function.\n   - Output the result after each query.\n\n# [edge case]\n    Edge Case 1: A 1x1 matrix with one query flipping the only cell.\n    Input: 1 1 1\n           1 1\n    Expected Output: 0\n    Explanation: The single cell is flipped to locked, leaving no free cells for a staircase.\n\n    Edge Case 2: A 2x2 matrix with all cells initially free and no queries.\n    Input: 2 2 0\n    Expected Output: No output since there are no queries, but initially, there are 5 staircases (each cell individually plus two 2-cell staircases).\n\n    Edge Case 3: A large matrix (1000x1000) with no locked cells and one query locking a central cell.\n    Input: 1000 1000 1\n           500 500\n    Expected Output: A large number representing staircases minus those affected by locking the central cell.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large matrices:\n    \n```python\ndef count_staircases(matrix, locked_cells):\n    # Implement efficient counting logic here\n    pass\n\ndef process_queries(n, m, queries):\n    locked_cells = set()\n    results = []\n    \n    for x, y in queries:\n        if (x, y) in locked_cells:\n            locked_cells.remove((x, y))\n        else:\n            locked_cells.add((x, y))\n        \n        # Recalculate staircases after each query\n        result = count_staircases((n, m), locked_cells)\n        results.append(result)\n    \n    return results\n```\nThis code structure allows handling of edge cases by recalculating staircases efficiently after each query.\n"], "scores": [], "pass_results": [true, false, false, false, false, false, true, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 27, "examples": "\nInput\n\nThe first line contains three integers n, m and q (1 \u2264 n, m \u2264 1000; 1 \u2264 q \u2264 10^4) \u2014 the sizes of the matrix and the number of queries.\n\nEach of the next q lines contains two integers x and y (1 \u2264 x \u2264 n; 1 \u2264 y \u2264 m) \u2014 the description of each query.\n\nOutput\n\nPrint q integers \u2014 the i-th value should be equal to the number of different staircases after i queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.\n\nExamples\n\nInput\n\n\n2 2 8\n1 1\n1 1\n1 1\n2 2\n1 1\n1 2\n2 1\n1 1\n\n\nOutput\n\n\n5\n10\n5\n2\n5\n3\n1\n0\n\n\nInput\n\n\n3 4 10\n1 4\n1 2\n2 3\n1 2\n2 3\n3 2\n1 3\n3 4\n1 3\n3 1\n\n\nOutput\n\n\n49\n35\n24\n29\n49\n39\n31\n23\n29\n27\n\n\nInput\n\n\n1000 1000 2\n239 634\n239 634\n\n\nOutput\n\n\n1332632508\n1333333000", "mutate_method": "expand_one2two", "parent_index": 27}
