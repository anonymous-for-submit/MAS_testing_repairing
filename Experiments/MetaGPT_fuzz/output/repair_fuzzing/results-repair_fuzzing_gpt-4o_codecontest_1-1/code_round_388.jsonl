{"name": "1615_A. Closing The Gap", "description": "There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can perform the following operation:\n\n  * Choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j), and move a block from tower i to tower j. This essentially decreases a_i by 1 and increases a_j by 1. \n\n\n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "tags": ["greedy", "math"], "difficulty": 7, "id": 1615, "sample_io": [{"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}], "test_list": [{"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n1 0 2 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 2 0 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 10\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 3 -1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 2\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 10\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 2\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n24 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 3 1 0\n5\n1 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n40 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 1 9\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 10 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 5 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n3 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 2 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 10\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n6 2 1 0\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n4 2 1 4\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 2\n5\n2 1 2 0 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 2 1 2\n5\n0 2 3 1 0\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n2 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 3 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 1 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n17 9 10\n4\n1 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 3 0 2\n5\n1 3 6 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 3\n5\n1 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n24 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 2 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 -1 1 2\n5\n0 3 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n24 9 15\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 2 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 2\n5\n0 4 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n36 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 5 13\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 10 9\n4\n2 0 0 1\n5\n1 1 4 1 4\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n41 9 18\n4\n3 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 0 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 10 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 4\n4\n3 3 0 5\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n11 2 9\n4\n2 0 0 4\n5\n1 1 4 0 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 6\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 7 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 11\n5\n0 3 6 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n6 3 1 9\n5\n0 3 10 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n4 7 4\n4\n6 3 1 6\n5\n0 3 2 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n3 10 10\n4\n3 2 1 2\n5\n1 2 4 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 16 10\n4\n1 2 0 2\n5\n1 4 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 2 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n1 0 4 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 9 10\n4\n0 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 2\n5\n0 2 3 1 4\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n15 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 3 3 0 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 20 10\n4\n3 0 1 2\n5\n0 2 3 1 0\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n7 5 10\n4\n6 1 1 2\n5\n1 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 9\n4\n2 1 1 2\n5\n1 2 3 2 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n17 9 8\n4\n4 0 1 3\n5\n1 0 5 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 1 1 0\n5\n4 0 2 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 17 20\n4\n4 1 1 2\n5\n2 1 3 1 4\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n1 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n13 0 10\n4\n3 2 0 2\n5\n1 2 3 -1 9\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 20 10\n4\n3 2 0 0\n5\n0 2 3 1 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n4 5 10\n4\n3 3 0 3\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 2 2\n5\n1 2 3 -1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 10 7\n4\n2 0 1 2\n5\n1 1 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 14 10\n4\n4 1 1 2\n5\n2 1 3 1 10\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n13 10 10\n4\n0 3 2 2\n5\n1 8 3 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n9 31 10\n4\n3 0 1 2\n5\n0 2 3 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 10\n4\n6 1 1 3\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n15 9 7\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 0 10\n4\n3 0 1 2\n5\n2 2 1 -1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n6 5 0\n4\n6 1 2 2\n5\n1 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 9\n4\n2 0 1 4\n5\n1 1 4 0 4\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n10 0 10\n4\n2 3 1 2\n5\n1 0 1 -1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 8 10\n4\n3 3 0 3\n5\n1 3 6 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 10 15\n4\n2 0 0 4\n5\n1 2 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 9 18\n4\n2 0 1 3\n5\n1 0 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 5 10\n4\n3 3 0 1\n5\n0 3 2 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 5 16\n4\n7 1 2 3\n5\n0 4 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 6 5\n4\n3 3 -1 3\n5\n0 3 6 1 5\n", "output": ["0\n0\n0\n"]}, {"input": "3\n3\n11 12 13\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 2 4\n4\n2 0 0 4\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n11 2 9\n4\n4 0 0 2\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n16 7 4\n4\n6 3 1 3\n5\n0 0 6 1 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n11 1 10\n4\n1 0 0 1\n5\n1 1 4 1 1\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n9 14 7\n4\n3 3 1 6\n5\n0 3 6 1 5\n", "output": ["0\n1\n0\n"]}, {"input": "3\n3\n9 7 4\n4\n3 3 1 13\n5\n0 2 6 1 5\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n3 7 4\n4\n3 3 0 14\n5\n0 3 6 1 5\n", "output": ["1\n0\n0\n"]}, {"input": "3\n3\n3 6 4\n4\n6 3 1 11\n5\n1 3 10 1 5\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n10 10 10\n4\n3 4 1 2\n5\n1 2 5 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 10 19\n4\n6 2 2 2\n5\n1 2 3 1 5\n", "output": ["0\n0\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 2 1 2\n5\n1 3 3 1 5\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n4 0 1 4\n5\n0 0 4 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 9 10\n4\n-1 0 1 2\n5\n2 0 0 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 1 10\n4\n3 4 0 2\n5\n1 2 3 0 5\n", "output": ["0\n1\n1\n"]}, {"input": "3\n3\n10 13 0\n4\n3 2 1 1\n5\n0 2 3 1 4\n", "output": ["1\n1\n0\n"]}, {"input": "3\n3\n9 10 10\n4\n2 0 2 2\n5\n1 2 3 1 4\n", "output": ["1\n1\n1\n"]}, {"input": "3\n3\n10 12 10\n4\n4 0 0 4\n5\n2 0 2 1 1\n", "output": ["1\n0\n1\n"]}, {"input": "3\n3\n10 10 10\n4\n0 0 1 2\n5\n1 2 3 2 7\n", "output": ["0\n1\n0\n"]}], "task_id": "codecontest/119", "prompt": "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. The towers are in a straight line and each has a specific height denoted by a_i. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, which decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "repair_prompt": ["There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. The towers are in a straight line and each has a specific height denoted by a_i. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, which decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. The towers are arranged in a straight line. Each tower has a specific height denoted by a_i. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, which decreases a_i by 1 and increases a_j by 1. \n\nYou think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). \n\nWhat's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "There are n block towers in a row, where tower i has a height of a_i, and you're part of a building crew aiming to make the buildings look as nice as possible. In a single day, you can choose two indices i and j (1 \u2264 i, j \u2264 n; i \u2260 j) and move a block from tower i to tower j, which decreases a_i by 1 and increases a_j by 1. You think the ugliness of the buildings is the height difference between the tallest and shortest buildings. Formally, the ugliness is defined as max(a)-min(a). What's the minimum possible ugliness you can achieve, after any number of days?\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test."], "completions": ["from typing import List\n## main.py\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        remainder = total_blocks % n\n\n        # Calculate the minimum possible ugliness\n        # If remainder is 0, all towers can be made equal\n        # If remainder is not 0, the difference will be 1\n        min_ugliness = 1 if remainder != 0 else 0\n        results.append(min_ugliness)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Sort the heights to easily find the min and max\n        heights.sort()\n        # Calculate the initial ugliness\n        initial_ugliness = heights[-1] - heights[0]\n        \n        # If all towers are already of equal height, ugliness is 0\n        if initial_ugliness == 0:\n            results.append(0)\n            continue\n        \n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        num_towers = len(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // num_towers\n        \n        # Calculate the minimum possible ugliness\n        # The minimum ugliness is achieved when the heights are as equal as possible\n        # This is either 0 or 1 depending on the distribution of blocks\n        if total_blocks % num_towers == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        max_height = max(heights)\n        min_height = min(heights)\n        # Calculate the difference between the maximum and minimum heights\n        difference = max_height - min_height\n        # If the difference is greater than 1, the minimum ugliness is 1, otherwise it's 0\n        if difference > 1:\n            results.append(1)\n        else:\n            results.append(0)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_height = sum(heights)\n        \n        # If the total height is divisible by the number of towers, all towers can be made equal\n        if total_height % n == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of test cases, each containing a list of tower heights.\n\n    Returns:\n        A list of integers representing the minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        # Sort the heights to facilitate redistribution\n        heights.sort()\n        \n        # Calculate the initial ugliness\n        initial_ugliness = heights[-1] - heights[0]\n        \n        # Since we can redistribute blocks freely, the minimum ugliness is either 0 or 1\n        # If the number of towers is 2, the minimum ugliness is the difference between the two towers\n        if len(heights) == 2:\n            min_ugliness = initial_ugliness\n        else:\n            # For more than two towers, we can always achieve an ugliness of 1\n            min_ugliness = min(initial_ugliness, 1)\n        \n        results.append(min_ugliness)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Output interface\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: Minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        # Sort the heights to easily calculate the redistribution\n        heights.sort()\n        \n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        \n        # Calculate the target height for equal distribution\n        n = len(heights)\n        target_height = total_blocks // n\n        \n        # Calculate the remainder to distribute\n        remainder = total_blocks % n\n        \n        # The minimum ugliness is determined by the difference between the tallest and shortest\n        # buildings after redistribution. If the remainder is 0, all buildings can be made equal.\n        # If the remainder is not 0, the difference will be 1.\n        if remainder == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Output interface\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of the buildings.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        total_blocks = sum(heights)\n        num_buildings = len(heights)\n        \n        # Calculate the minimum possible ugliness\n        if total_blocks % num_buildings == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing the heights of the towers.\n\n    Returns:\n        List[int]: A list of minimum possible ugliness values for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        n = len(heights)\n        total_blocks = sum(heights)\n        average_height = total_blocks // n\n        # Calculate the number of towers that need to be one block taller than the average\n        remainder = total_blocks % n\n        # The minimum ugliness is determined by the number of towers that need to be taller\n        min_ugliness = 1 if remainder > 0 else 0\n        results.append(min_ugliness)\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output the results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Call the function and print results\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    for heights in test_cases:\n        # Sort the heights to easily access the minimum and maximum\n        heights.sort()\n        # Calculate the minimum possible ugliness\n        min_ugliness = heights[-1] - heights[0]\n        results.append(min_ugliness)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Parse the number of test cases\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        # Read the number of buildings\n        n = int(input())\n        # Read the heights of the buildings\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n    \n    # Calculate the minimum ugliness for each test case\n    results = minimum_ugliness(t, test_cases)\n    \n    # Output the results\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_ugliness(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum possible ugliness for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing the heights of towers.\n\n    Returns:\n        List[int]: List of minimum possible ugliness for each test case.\n    \"\"\"\n    results = []\n    \n    for heights in test_cases:\n        # Calculate the total number of blocks\n        total_blocks = sum(heights)\n        n = len(heights)\n        \n        # Calculate the average height\n        average_height = total_blocks // n\n        \n        # Calculate the remainder blocks after equal distribution\n        remainder_blocks = total_blocks % n\n        \n        # The minimum possible ugliness is determined by the remainder\n        # If remainder_blocks is 0, all towers can be perfectly equalized\n        # Otherwise, the minimum ugliness is 1 because some towers will be 1 block taller\n        if remainder_blocks == 0:\n            results.append(0)\n        else:\n            results.append(1)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        test_cases.append(heights)\n\n    # Output interface\n    results = minimum_ugliness(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to minimize the height difference between the tallest and shortest buildings by redistributing blocks between towers. The solution should efficiently handle up to 1000 test cases with up to 100 buildings each, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness\n- Ensure the solution handles large inputs efficiently\n- Provide clear and formatted output for each test case\n- Optimize the algorithm for scalability\n- Include comments and documentation for clarity\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistributing blocks to make the heights as equal as possible. We will use a simple approach to find the maximum and minimum heights and calculate their difference.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: The process of moving blocks from one tower to another to minimize the height difference between towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness'\n    Explanation: The smallest value of max(a) - min(a) that can be achieved by redistributing blocks between towers.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest achievable value for the ugliness after redistributing blocks.\n\n# [code logic]\n    1. For each test case, read the number of buildings and their respective heights.\n    2. Calculate the total number of blocks across all towers.\n    3. Determine the average height by dividing the total number of blocks by the number of towers.\n    4. Redistribute blocks to make all tower heights as close to the average height as possible.\n    5. Calculate the minimum possible ugliness as the difference between the maximum and minimum heights after redistribution.\n\n# [edge case]\n    Case 1: Input = [2, 2, 2], Expected Output = 0\n    Explanation: All towers already have equal height, so no redistribution is needed, and ugliness is 0.\n\n    Case 2: Input = [1, 1, 10], Expected Output = 0\n    Explanation: Redistribute blocks from the tallest tower to the shortest towers to achieve equal heights.\n\n    Case 3: Input = [1, 1, 1, 10], Expected Output = 1\n    Explanation: After redistribution, it is impossible to make all towers have exactly equal heights due to integer constraints, resulting in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve equal or nearly equal heights will naturally handle these cases.\n", "requirement analysis:\nThe requirement is to minimize the ugliness of block towers by redistributing blocks between towers. The solution should efficiently handle multiple test cases and provide the minimum possible ugliness for each case. The algorithm must be scalable and robust, ensuring it can handle the maximum constraints provided.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness\n- Optimize for large input sizes\n- Ensure the solution handles edge cases\n- Provide clear output format\n- Test the solution against various scenarios\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights of the towers. By redistributing blocks, we can make the heights as equal as possible, thus minimizing the ugliness. The approach involves sorting the heights and calculating the difference between the maximum and minimum heights after potential redistribution.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the process of moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing blocks. In code, this involves iterating through possible redistributions to achieve the smallest difference.\n\n# [degree adverb] \n    'minimum': \n    Explanation: This indicates that we need to find the smallest possible value of ugliness, which is the difference between the maximum and minimum tower heights after redistribution.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case:\n   - Read the number of towers and their respective heights.\n   - Calculate the initial ugliness as max(a) - min(a).\n   - If all towers are already of equal height, the ugliness is 0.\n   - Otherwise, sort the heights and attempt to redistribute blocks to minimize the difference between the tallest and shortest towers.\n   - The minimum possible ugliness is achieved when the heights are as equal as possible.\n3. Output the minimum ugliness for each test case.\n\n# [edge case] \n    Case 1: [10, 10, 10] = 0\n    Explanation: All towers are already of equal height, so no redistribution is needed, and ugliness is 0.\n\n    Case 2: [1, 1, 1, 10000000] = 0\n    Explanation: By redistributing blocks from the tallest tower to others, all towers can be made equal.\n\n    Case 3: [1, 2, 3, 4, 5] = 0\n    Explanation: Blocks can be redistributed such that all towers have equal height.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve equal heights inherently handles these cases.\n", "requirement analysis:\nThe task requires calculating the minimum possible ugliness of building heights after redistributing blocks. The solution should efficiently handle up to 1000 test cases, each with up to 100 buildings. The main challenge is to determine the optimal redistribution of blocks to minimize the height difference between the tallest and shortest buildings.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear input and output handling.\n- Optimize the code for performance.\n- Include comments and documentation for clarity.\nWe will iterate through each test case, and for each case, calculate the minimum possible ugliness by finding the difference between the maximum and minimum heights of the towers. The optimal strategy is to redistribute blocks such that the difference between the tallest and shortest towers is minimized, which can be achieved by ensuring the difference is at most 1. This can be done by checking if the difference between the maximum and minimum height is greater than 1, and if so, the minimum ugliness will be 1, otherwise it will be 0.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'difference between': This refers to the subtraction operation between the maximum and minimum heights of the towers.\n    'greater than': Used to determine if the difference between the maximum and minimum heights is more than 1, which would result in a minimum ugliness of 1.\n\n# [degree adverb]\n    'minimum': Refers to the smallest possible value of ugliness that can be achieved after redistributing blocks.\n\n# [code logic]\n    - For each test case, read the number of buildings and their respective heights.\n    - Calculate the maximum and minimum heights of the towers.\n    - If the difference between the maximum and minimum heights is greater than 1, set the minimum possible ugliness to 1.\n    - Otherwise, set the minimum possible ugliness to 0.\n    - Output the result for each test case.\n\n# [edge case]\n    Case 1: Input: 2 1 1; Output: 0\n    Explanation: Both towers have the same height, so the ugliness is already 0.\n    \n    Case 2: Input: 3 1 1 2; Output: 0\n    Explanation: We can move one block from the third tower to either of the first two towers to make all heights equal, resulting in an ugliness of 0.\n    \n    Case 3: Input: 4 1 2 3 4; Output: 1\n    Explanation: We can redistribute blocks to make the heights [2, 2, 3, 3], resulting in a minimum possible ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking if the difference between max and min is greater than 1 will suffice.\n", "requirement analysis:\nThe problem requires determining the minimum possible difference between the tallest and shortest towers after redistributing blocks. The solution must efficiently handle up to 1000 test cases with up to 100 towers each, where tower heights can be very large. The key is to balance the heights by redistributing blocks optimally.\nrequirement pool:\n- Implement an algorithm to calculate the minimum ugliness.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear and formatted output for each test case.\n- Optimize the algorithm for speed and memory usage.\n- Include comments and documentation for code clarity.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. By sorting the heights and calculating the difference between the maximum and minimum, we can determine the minimum ugliness. This approach is efficient and handles the constraints well.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the process of moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': This means we need to find the smallest value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb] \n    'minimum': This indicates that we are looking for the smallest possible value of ugliness, which is the difference between the maximum and minimum heights.\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Sort the list of tower heights.\n3. Calculate the initial ugliness as the difference between the maximum and minimum heights.\n4. Since we can redistribute blocks, the minimum possible ugliness is achieved when all towers have equal height, which is possible if the sum of heights is divisible by the number of towers.\n5. If not all towers can be made equal, the minimum ugliness will be 1, as we can make all but one tower equal.\n6. Return the calculated minimum ugliness for each test case.\n\n# [edge case] \n    Case 1: n = 2, heights = [1, 10000000] = 0\n    Explanation: We can move blocks from the taller tower to the shorter one until both are equal.\n\n    Case 2: n = 3, heights = [1, 1, 10000000] = 0\n    Explanation: We can redistribute blocks to make all towers equal.\n\n    Case 3: n = 4, heights = [1, 2, 3, 4] = 0\n    Explanation: We can redistribute blocks to make all towers equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks and checking divisibility by the number of towers will handle these cases effectively.\n", "requirement analysis:\nThe task requires calculating the minimum possible ugliness of block towers after redistributing blocks between them. The solution should efficiently handle up to 1000 test cases with up to 100 towers each, where tower heights can be as large as 10^7.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the code for performance.\n- Provide detailed comments and documentation.\n- Enhance user interface for better readability.\nWe will implement a function to calculate the minimum possible ugliness by redistributing blocks between towers. The approach involves sorting the heights and calculating the difference between the maximum and minimum heights after redistribution. This can be achieved efficiently using Python's built-in sorting and min/max functions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: The process of moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: The difference between the maximum and minimum heights of the towers. In code, this can be implemented using max(a) - min(a).\n\n# [degree adverb]\n    'minimum'\n    Explanation: The smallest possible value of ugliness that can be achieved after redistributing blocks. In code, this involves iterating through possible redistributions to find the smallest max(a) - min(a).\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read the number of towers and their respective heights.\n    3. Sort the heights to facilitate redistribution.\n    4. Calculate the initial ugliness (max - min).\n    5. Redistribute blocks to minimize the height difference:\n        - Move blocks from taller towers to shorter ones.\n        - Update the heights and recalculate ugliness.\n    6. Return the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height.\n    Input: [10, 10, 10]\n    Expected output: 0\n    Explanation: No redistribution is needed as all towers are already equal in height.\n\n    Case 2: Towers with alternating heights.\n    Input: [1, 3, 1, 3]\n    Expected output: 0\n    Explanation: Redistribute blocks to make all towers equal in height.\n\n    Case 3: Towers with one significantly taller tower.\n    Input: [1, 1, 1, 10]\n    Expected output: 1\n    Explanation: Redistribute blocks to minimize height difference, but one block will remain unbalanced.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and redistributing blocks will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires calculating the minimum possible ugliness of building heights after redistributing blocks between towers. The solution must efficiently handle up to 1000 test cases with up to 100 buildings each, ensuring scalability and accuracy.\nrequirement pool:\n- Implement the main algorithm to minimize ugliness\n- Ensure the solution handles maximum input constraints\n- Optimize for performance and scalability\n- Maintain consistent output format\n- Provide detailed documentation for user understanding\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. The optimal strategy is to equalize the heights as much as possible, which can be achieved by calculating the difference between the maximum and minimum heights and checking if this difference can be reduced to 0 or 1.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: The process of moving blocks from one tower to another to minimize the height difference between towers.\n\n# [phrase showing quantity relationship]\n    'difference between the maximum and minimum heights'\n    Explanation: This refers to the calculation of max(a) - min(a) to determine the ugliness. In code, this can be implemented using `max(heights) - min(heights)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The goal is to achieve the smallest possible value for ugliness, ideally 0 or 1. This involves redistributing blocks to equalize tower heights as much as possible.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read the number of towers and their respective heights.\n    3. Calculate the initial ugliness using max(heights) - min(heights).\n    4. Redistribute blocks to minimize the height difference:\n        - Sort the heights.\n        - Calculate the total number of blocks.\n        - Determine the target height for equal distribution.\n        - Adjust heights to approach this target, minimizing the difference.\n    5. Return the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution needed as all heights are equal.\n\n    Case 2: Towers with alternating heights.\n    Input: [1, 3, 1, 3]\n    Expected Output: 0\n    Explanation: Redistribute blocks to achieve equal heights of [2, 2, 2, 2].\n\n    Case 3: Towers with one significantly taller tower.\n    Input: [1, 1, 1, 10]\n    Expected Output: 1\n    Explanation: Redistribute blocks to achieve heights close to [3, 3, 3, 4].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks and calculating the minimum ugliness will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires determining the minimum possible difference between the tallest and shortest building heights after redistributing blocks. The solution should efficiently handle up to 1000 test cases with up to 100 buildings each, where each building height can be as large as 10^7.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Optimize the solution for large input sizes.\n- Ensure the solution adheres to the input-output format strictly.\n- Test the solution with edge cases and large numbers.\n- Document the solution approach and edge cases considered.\nWe will iterate through each test case, sort the building heights, and calculate the minimum possible ugliness by redistributing blocks to make the heights as equal as possible. The minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution, which is at most 1 if the total number of blocks is not perfectly divisible by the number of buildings.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n# [phrase showing quantity relationship]\n    'height difference': This refers to the subtraction operation between the maximum and minimum heights of the towers.\n    Implementation: Calculate max(a) - min(a) for the list of building heights.\n\n# [degree adverb]\n    'minimum': This indicates that we need to find the smallest possible value of ugliness after redistributing blocks.\n    Implementation: Aim to make all building heights as equal as possible, resulting in a minimum difference of 0 or 1.\n\n# [code logic]\n    1. For each test case, read the number of buildings and their respective heights.\n    2. Sort the list of building heights.\n    3. Calculate the total number of blocks and determine if they can be evenly distributed among the buildings.\n    4. If they can be evenly distributed, the minimum ugliness is 0; otherwise, it is 1.\n    5. Output the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: Input = [3, 3, 3], Output = 0\n    Explanation: All buildings are already of equal height, so the ugliness is 0.\n    \n    Case 2: Input = [1, 1, 1, 1], Output = 0\n    Explanation: All buildings are of equal height, so no redistribution is needed, resulting in an ugliness of 0.\n    \n    Case 3: Input = [1, 2, 3], Output = 0\n    Explanation: Blocks can be redistributed to make all buildings of height 2, resulting in an ugliness of 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve equal heights inherently handles these cases.\n", "requirement analysis:\nThe task requires an algorithm to minimize the height difference between the tallest and shortest towers by redistributing blocks. The solution must efficiently handle up to 1000 test cases with up to 100 towers each, where tower heights can be as large as 10^7. The output must be a single integer representing the minimum possible ugliness for each test case.\nrequirement pool:\n- Develop an efficient algorithm to minimize ugliness\n- Ensure the solution handles maximum constraints effectively\n- Provide clear and consistent output format\n- Include edge case handling in the algorithm\n- Optimize for speed and performance\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is determined by the difference between the maximum and minimum heights after redistribution. The optimal strategy is to make the heights as equal as possible, which can be achieved by redistributing blocks to minimize the difference between the tallest and shortest towers. We will use a simple approach to find the maximum and minimum heights and calculate their difference.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the process of moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest possible value of max(a) - min(a) after redistributing blocks.\n\n# [degree adverb] \n    'minimum': \n    Explanation: The goal is to achieve the smallest possible difference between the tallest and shortest towers.\n\n# [code logic]\n1. For each test case, read the number of towers and their respective heights.\n2. Calculate the total number of blocks across all towers.\n3. Determine the average height by dividing the total number of blocks by the number of towers.\n4. Calculate the minimum possible ugliness by considering the distribution of blocks around this average height.\n5. The minimum ugliness is achieved when the heights are as close to the average as possible, which can be calculated as max(a) - min(a) after redistribution.\n\n# [edge case] \n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution is needed as all towers are already equal.\n\n    Case 2: Towers with alternating heights.\n    Input: [1, 3, 1, 3]\n    Expected Output: 0\n    Explanation: Blocks can be redistributed to make all towers have a height of 2.\n\n    Case 3: Towers with a single very tall tower.\n    Input: [1, 1, 1, 10]\n    Expected Output: 0\n    Explanation: Blocks from the tallest tower can be redistributed to make all towers equal.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve equal heights inherently handles these cases.\n", "requirement analysis:\nThe task requires calculating the minimum possible ugliness of block towers after redistributing blocks between them. The solution must efficiently handle up to 1000 test cases with up to 100 buildings each, where building heights can be as large as 10^7. The output must be a single integer for each test case, representing the minimum ugliness achievable.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles large inputs efficiently.\n- Design a user-friendly input and output format.\n- Optimize the code for scalability across multiple test cases.\n- Provide detailed documentation for the solution.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The approach involves sorting the heights and calculating the difference between the maximum and minimum heights after redistribution. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle the input data.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the process of moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'height difference'\n    Explanation: This is the difference between the maximum and minimum heights of the towers. In code, it can be implemented as `max(a) - min(a)`.\n\n# [degree adverb]\n    'minimum'\n    Explanation: The requirement asks for the smallest possible value of ugliness after redistributing blocks. This means we need to find a way to make the heights as equal as possible.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read the number of buildings and their respective heights.\n    3. Sort the list of heights.\n    4. Calculate the difference between the maximum and minimum heights.\n    5. Redistribute blocks to minimize this difference.\n    6. Output the minimum possible ugliness for each test case.\n\n# [edge case]\n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: Since all towers are already of equal height, no redistribution is needed, and ugliness is 0.\n\n    Case 2: Towers with alternating heights.\n    Input: [1, 3, 1, 3]\n    Expected Output: 0\n    Explanation: Blocks can be moved from taller towers to shorter ones to make all heights equal.\n\n    Case 3: Towers with one significantly taller tower.\n    Input: [1, 1, 1, 10]\n    Expected Output: 1\n    Explanation: The best redistribution results in a minimal height difference of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of sorting and redistributing blocks will naturally handle these scenarios.\n", "requirement analysis:\nThe task requires calculating the minimum possible ugliness of building heights after redistributing blocks between towers. The solution should efficiently handle up to 1000 test cases, each with up to 100 buildings, and heights as large as 10^7. The primary goal is to minimize the difference between the tallest and shortest towers.\nrequirement pool:\n- Implement the main algorithm to calculate minimum ugliness.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear and formatted output for each test case.\n- Optimize the code for readability and maintainability.\n- Include comments and documentation for the code.\nWe will implement a function that calculates the minimum possible ugliness by redistributing blocks between towers. The key observation is that the minimum ugliness is achieved when the difference between the maximum and minimum heights is minimized, which can be done by redistributing blocks to equalize the heights as much as possible. We will use Python's built-in functions to efficiently compute the maximum and minimum values and adjust the heights accordingly.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'ugliness'\n    Explanation: In the requirement, ugliness is defined as the difference between the tallest and shortest buildings, i.e., max(a) - min(a).\n\n    'redistributing blocks'\n    Explanation: This refers to the process of moving blocks from one tower to another to minimize the height difference between the tallest and shortest towers.\n\n# [phrase showing quantity relationship]\n    'minimum possible ugliness': \n    Explanation: This means finding the smallest value of max(a) - min(a) after redistributing blocks. In code, this involves iterating over possible redistributions and calculating the resulting max and min values.\n\n# [degree adverb] \n    'minimum': \n    Explanation: This indicates that we need to find the smallest possible value of ugliness, which is achieved by equalizing the tower heights as much as possible.\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case:\n   - Read the number of towers and their respective heights.\n   - Calculate the initial max and min heights.\n   - If max equals min, ugliness is already 0.\n   - Otherwise, calculate the total number of blocks and determine the average height.\n   - Redistribute blocks to make all towers as close to the average height as possible.\n   - Calculate the new max and min heights after redistribution.\n   - The minimum possible ugliness is the difference between these new max and min heights.\n\n# [edge case] \n    Case 1: All towers have the same height initially.\n    Input: [10, 10, 10]\n    Expected Output: 0\n    Explanation: No redistribution needed as all towers are already equal.\n\n    Case 2: Towers with heights that can be perfectly equalized.\n    Input: [3, 2, 1, 2]\n    Expected Output: 0\n    Explanation: Redistribute blocks to make all towers height 2.\n\n    Case 3: Towers with heights that cannot be perfectly equalized.\n    Input: [1, 2, 3, 1, 5]\n    Expected Output: 1\n    Explanation: After redistribution, the closest equalization results in a minimum ugliness of 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of redistributing blocks to achieve minimum ugliness inherently handles these scenarios.\n"], "scores": [], "pass_results": [true, false, false, true, true, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 388, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains one integer n (2 \u2264 n \u2264 100) \u2014 the number of buildings.\n\nThe second line of each test case contains n space separated integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 10^7) \u2014 the heights of the buildings.\n\nOutput\n\nFor each test case, output a single integer \u2014 the minimum possible ugliness of the buildings.\n\nExample\n\nInput\n\n\n3\n3\n10 10 10\n4\n3 2 1 2\n5\n1 2 3 1 5\n\n\nOutput\n\n\n0\n0\n1\n\nNote\n\nIn the first test case, the ugliness is already 0.\n\nIn the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.\n\nIn the third test case, you may do three operations: \n\n  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], \n  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], \n  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. \n\nThe resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.", "mutate_method": "expand_one2two", "parent_index": 249}
