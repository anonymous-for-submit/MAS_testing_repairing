{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp desires the problem set to be difficult yet varied to assist the students in learning effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp desires the problem set to be difficult yet varied to assist the students in learning effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp desires the problem set to be difficult yet varied to assist the students in learning effectively. Monocarp wants to ensure the problems are challenging for the students. At the same time, he believes that including a variety of problems can enhance the learning experience.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp desires the problem set to be difficult yet varied to assist the students in learning effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of ways to select three problems from the given set.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid combinations.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = comb(n, 3)\n\n        # Subtract invalid combinations where all three problems have the same topic\n        invalid_topic_combinations = sum(comb(count, 3) for count in topic_count.values() if count >= 3)\n\n        # Subtract invalid combinations where all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(comb(count, 3) for count in difficulty_count.values() if count >= 3)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_combinations(n: int) -> int:\n    \"\"\"Calculate the number of ways to choose three items from n items.\"\"\"\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Count the number of valid combinations of three problems for each test case.\"\"\"\n    results = []\n    \n    for n, problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        \n        # Count occurrences of each topic and difficulty\n        for a_i, b_i in problems:\n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n        \n        # Calculate total combinations of three problems\n        total_combinations = calculate_combinations(n)\n        \n        # Subtract invalid combinations where problems share the same topic or difficulty\n        for a_i, b_i in problems:\n            total_combinations -= (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        results.append(total_combinations)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            problems.append((a_i, b_i))\n        \n        test_cases.append((n, problems))\n    \n    results = count_problem_sets(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom math import comb\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of ways to select three problems from the given set.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of ways to select three problems for each test case.\n    \"\"\"\n    results = []\n    for n, problems in test_cases:\n        # Calculate the number of ways to select three problems from n problems\n        if n < 3:\n            results.append(0)\n        else:\n            results.append(comb(n, 3))\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n    \n    results = count_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of ways to select three training problems that meet the specified criteria.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid combinations.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting any 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where two problems have the same topic or difficulty\n        invalid_combinations = 0\n\n        # Subtract combinations where two problems have the same topic\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Subtract combinations where two problems have the same difficulty\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Add back combinations where all three problems have the same topic and difficulty\n        for topic, difficulty in problems:\n            if topic_count[topic] > 1 and difficulty_count[difficulty] > 1:\n                invalid_combinations -= (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_problem_selections(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of ways to select three problems from a given set of problems.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of ways to select three problems for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where all three problems have the same topic\n        invalid_topic_combinations = sum(\n            count * (count - 1) * (count - 2) // 6 for count in topic_count.values() if count >= 3\n        )\n\n        # Calculate invalid combinations where all three problems have the same difficulty\n        invalid_difficulty_combinations = sum(\n            count * (count - 1) * (count - 2) // 6 for count in difficulty_count.values() if count >= 3\n        )\n\n        # Valid combinations are total combinations minus invalid ones\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_problem_selections(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_combinations(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of three problems for each testcase.\n\n    Args:\n        t (int): Number of testcases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of testcases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each testcase.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        pair_count = defaultdict(int)\n\n        # Count occurrences of each topic, difficulty, and topic-difficulty pair\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n            pair_count[(topic, difficulty)] += 1\n\n        total_combinations = 0\n\n        # Calculate valid combinations\n        for topic, difficulty in problems:\n            # Calculate combinations excluding the current problem\n            total_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Subtract invalid combinations where all three problems have the same topic and difficulty\n        for (topic, difficulty), count in pair_count.items():\n            if count >= 2:\n                total_combinations -= count * (count - 1) // 2\n\n        results.append(total_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_combinations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid combinations of three problems for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid combinations\n        for the corresponding test case.\n    \"\"\"\n    results = []\n    \n    for n, problems in test_cases:\n        # Dictionary to count occurrences of each topic and difficulty\n        topic_count = {}\n        difficulty_count = {}\n        \n        # Populate the dictionaries with counts\n        for topic, difficulty in problems:\n            if topic not in topic_count:\n                topic_count[topic] = 0\n            if difficulty not in difficulty_count:\n                difficulty_count[difficulty] = 0\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n        \n        # Calculate the number of valid combinations\n        valid_combinations = 0\n        for comb in itertools.combinations(problems, 3):\n            topics = {p[0] for p in comb}\n            difficulties = {p[1] for p in comb}\n            if len(topics) == 3 or len(difficulties) == 3:\n                valid_combinations += 1\n        \n        results.append(valid_combinations)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n    \n    # Output interface\n    results = count_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid ways to select three training problems.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid ways to select three problems for each test case.\n    \"\"\"\n    results = []\n    for n, problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        \n        # Count occurrences of each topic and difficulty\n        for a, b in problems:\n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        # Calculate total combinations of three problems\n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        # Subtract invalid combinations where two problems have the same topic or difficulty\n        for a, b in problems:\n            total_ways -= (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        results.append(total_ways)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n    \n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_selections(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid selections of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid selections for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        if n < 3:\n            results.append(0)\n            continue\n\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n\n        # Subtract combinations where two or more problems have the same topic\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Subtract combinations where two or more problems have the same difficulty\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Add back combinations where all three problems have the same topic or difficulty\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations -= count * (count - 1) * (count - 2) // 6\n\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations -= count * (count - 1) * (count - 2) // 6\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_selections(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_problem_sets(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the number of ways to select three problems with different topics and difficulties.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the number of problems and a list of problems.\n                           Each problem is represented as a tuple of (topic, difficulty).\n\n    Returns:\n        list: A list of integers where each integer represents the number of valid problem sets for a test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Create dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate the total number of ways to choose any 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate the number of invalid combinations\n        invalid_combinations = 0\n\n        # Subtract combinations where two problems have the same topic\n        for count in topic_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Subtract combinations where two problems have the same difficulty\n        for count in difficulty_count.values():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Add back combinations where all three problems have the same topic and difficulty\n        for topic, difficulty in problems:\n            if topic_count[topic] >= 2 and difficulty_count[difficulty] >= 2:\n                invalid_combinations -= (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The constraints involve handling up to 50,000 test cases and ensuring the sum of problems across all test cases does not exceed 200,000. The solution must efficiently process large inputs and provide accurate results.\nrequirement pool:\n- Efficiently handle up to 50,000 test cases.\n- Ensure the sum of problems across all test cases does not exceed 200,000.\n- Provide clear and concise output for each test case.\n- Implement a solution that can handle large input sizes efficiently.\n- Ensure the problem set is diverse and challenging.\nWe will use combinatorial mathematics to efficiently calculate the number of ways to select three problems from the given set. The constraints require handling large input sizes, so we will use Python's built-in data structures and libraries like collections to manage and count occurrences efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial mathematics'\n    Explanation: This refers to the branch of mathematics dealing with combinations of objects. In this context, it is used to calculate the number of ways to select three problems from a given set.\n\n# [phrase showing quantity relationship]\n    'number of ways': This indicates that we need to calculate combinations, specifically the number of ways to choose three problems from a set of n problems.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read the number of problems and their respective topic and difficulty.\n    3. Use combinatorial mathematics to calculate the number of ways to select three problems.\n    4. Ensure that the selected problems meet the requirements described in the statement.\n    5. Output the result for each test case.\n\n# [edge case] \n    Case 1: t = 1, n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select three problems since n = 3.\n    \n    Case 2: t = 1, n = 4, problems = [(1, 1), (2, 2), (3, 3), (4, 4)]\n    Expected output: 4\n    Explanation: All combinations of three problems are valid.\n    \n    Case 3: t = 1, n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected output: 10\n    Explanation: All combinations of three problems are valid.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The combinatorial approach inherently handles these scenarios by calculating all possible combinations of three problems.\n", "requirement analysis:\nThe requirements focus on creating a problem set that is both challenging and varied, ensuring students can learn effectively. The solution must handle large input sizes efficiently and provide accurate outputs for all test cases.\nrequirement pool:\n- Efficiently handle up to 50000 test cases\n- Ensure no two problems have the same topic and difficulty\n- Provide clear output format for the number of ways to select problems\n- Optimize algorithm for performance with large datasets\n- Enhance user engagement through varied problem sets\nWe will use a dictionary to count occurrences of each topic and difficulty. Then, we will calculate the number of valid combinations of three problems based on these counts. This approach ensures efficient handling of large datasets by reducing the problem to counting and simple arithmetic operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problem set': refers to the collection of problems Monocarp has.\n    'topic and difficulty': each problem is characterized by a unique combination of these two attributes.\n    'ways to select three training problems': refers to the combinations of three problems that meet certain criteria.\n\n# [phrase showing quantity relationship]\n    'three': indicates that we need to select exactly three problems.\n    'number of ways': refers to the count of different combinations that can be formed.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case, do the following:\n   - Parse the number of problems, `n`.\n   - Initialize dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the total number of ways to choose any three problems from `n` using combinatorial formula C(n, 3).\n   - Subtract invalid combinations where problems share the same topic or difficulty.\n3. Output the result for each test case.\n\n# [edge case]\n    Case 1: \n    Input: 3\n           3\n           1 1\n           2 2\n           3 3\n    Output: 0\n    Explanation: No three problems can be selected as each has a unique topic and difficulty.\n\n    Case 2:\n    Input: 1\n           4\n           1 2\n           1 3\n           1 4\n           2 4\n    Output: 1\n    Explanation: Only one valid combination (problems with topics 1, 1, and 2) can be selected.\n\n    Case 3:\n    Input: 2\n           5\n           1 1\n           1 2\n           2 2\n           2 3\n           3 3\n    Output: 4\n    Explanation: Valid combinations are (problems with topics/difficulties: (1,1), (1,2), (2,2)), (1,2), (2,2), (2,3)), etc.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where no valid combinations exist or when all problems have unique topics and difficulties.\n    \n```python\ndef calculate_combinations(n):\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topic_count = {}\n        difficulty_count = {}\n        \n        problems = []\n        \n        for _ in range(n):\n            a_i = int(data[index])\n            b_i = int(data[index + 1])\n            index += 2\n            \n            if a_i not in topic_count:\n                topic_count[a_i] = 0\n            if b_i not in difficulty_count:\n                difficulty_count[b_i] = 0\n            \n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n            \n            problems.append((a_i, b_i))\n        \n        total_combinations = calculate_combinations(n)\n        \n        for a_i, b_i in problems:\n            total_combinations -= (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n        \n        results.append(total_combinations)\n    \n    for result in results:\n        print(result)\n\n```\n", "requirement analysis:\nThe requirements focus on creating a problem set that is both challenging and varied, ensuring students can learn effectively. The solution must handle large input sizes efficiently and provide accurate outputs for all test cases.\nrequirement pool:\n- Efficiently handle large input sizes up to 2 \u22c5 10^5\n- Ensure no two problems have the same topic and difficulty\n- Provide clear and accurate output for all test cases\n- Create a diverse set of problems to enhance learning\n- Optimize performance for quick computation\nWe will use combinatorial mathematics to efficiently calculate the number of ways to select three problems from the given set. The constraints allow us to use combinations to determine the number of valid selections. We will leverage Python's built-in libraries to handle large input sizes and ensure performance optimization.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial mathematics'\n    Explanation: This refers to the branch of mathematics dealing with combinations of objects. In this context, it is used to calculate the number of ways to select three problems from a given set.\n\n# [phrase showing quantity relationship]\n    'number of ways': This indicates that we need to calculate the total possible combinations of selecting three problems from the given set.\n    'three': This specifies that we are selecting exactly three problems from the set.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read the number of problems and their respective topic and difficulty.\n    3. Use combinatorial mathematics to calculate the number of ways to select three problems from the given set.\n    4. Ensure that the selection meets the requirements described in the statement.\n    5. Output the result for each test case.\n\n# [edge case]\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: There is only one way to select three problems, which is selecting all three given problems.\n\n    Input: 1\n           4\n           1 2\n           2 3\n           3 4\n           4 5\n    Output: 4\n    Explanation: All combinations of three problems are valid since no two problems have the same topic and difficulty at the same time.\n\n    Input: 1\n           5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations of three problems are valid, and there are a total of C(5,3) = 10 ways to select them.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The combinatorial approach inherently handles all possible selections, including edge cases.\n", "requirement analysis:\nThe requirements focus on creating a problem set that is both challenging and varied. The input constraints are significant, requiring efficient handling of up to 50000 test cases and a total of 200000 problems. The solution must efficiently compute the number of ways to select three problems that meet the specified criteria, ensuring no two problems have the same topic and difficulty simultaneously.\nrequirement pool:\n- Efficiently handle large input sizes up to 200000 problems\n- Ensure no two problems have the same topic and difficulty\n- Provide a variety of problem types to enhance learning\n- Maintain a balance between difficulty and variety\n- Optimize the solution for speed and accuracy\nWe will use a combination of combinatorial mathematics and efficient data structures to handle the large input sizes. Specifically, we will use dictionaries to count occurrences of topics and difficulties, and then apply combinatorial logic to calculate the number of valid problem sets. This approach ensures that we efficiently handle up to 200000 problems across multiple test cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial mathematics'\n    Explanation: This refers to the branch of mathematics dealing with combinations of objects belonging to a finite set in accordance with certain constraints, such as those of graph theory.\n\n    'efficient data structures'\n    Explanation: This refers to using data structures like dictionaries (hash maps) to efficiently store and retrieve data, which is crucial for handling large input sizes.\n\n# [phrase showing quantity relationship]\n    'three training problems': This means we need to select exactly three problems from the given set.\n    'number of ways': This refers to calculating the total number of combinations that meet the specified criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case:\n   - Read the number of problems, `n`.\n   - Initialize dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the number of valid combinations using combinatorial logic:\n     - Use combinations to select three problems.\n     - Ensure that no two problems have the same topic and difficulty simultaneously.\n3. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Expected Output: 1\n    Explanation: Only one way to select three problems, as there are exactly three problems.\n\n    Test case with maximum values:\n    Input:\n    1\n    200000\n    (200000 lines of unique topic-difficulty pairs)\n    Expected Output: Large number based on combinatorial calculations.\n    Explanation: The output will depend on the specific distribution of topics and difficulties.\n\n    Test case with all problems having the same topic or difficulty:\n    Input:\n    1\n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    Expected Output: 0\n    Explanation: No valid set of three problems can be selected as all have the same topic.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial mathematics and efficient data structures will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on creating a problem set that is both challenging and varied to enhance learning. The input and output formats must be strictly followed to ensure compatibility with multiple test cases. The solution should efficiently calculate the number of ways to select three problems that meet the given criteria.\nrequirement pool:\n- Implement efficient algorithm to calculate combinations of problems\n- Ensure output format is compatible with multiple test cases\n- Provide clear documentation for problem selection criteria\n- Optimize performance for large input sizes\n- Include error handling for invalid inputs\nWe will implement a function to calculate the number of ways to select three problems from a given set of problems, ensuring that the selection criteria are met. The function will efficiently handle multiple test cases and large input sizes by using combinatorial logic and data structures like dictionaries to count occurrences of topics and difficulties.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problem set': refers to the collection of problems Monocarp has, each with a topic and difficulty.\n    'training problems': refers to the subset of problems selected for students to learn from.\n\n# [phrase showing quantity relationship]\n    'three': indicates that we need to select exactly three problems from the set.\n    '2 \u22c5 10^5': indicates the upper limit for the sum of n over all test cases, which affects performance considerations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, parse the number of problems and their respective topic and difficulty.\n    3. Use combinatorial logic to determine the number of ways to select three problems that meet the criteria.\n    4. Ensure efficient handling of large input sizes using appropriate data structures.\n\n# [edge case]\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems, as all have unique topics and difficulties.\n\n    Input: 1\n           4\n           1 2\n           2 3\n           3 4\n           4 5\n    Output: 4\n    Explanation: All combinations of three problems are valid as they all have unique topics and difficulties.\n\n    Input: 1\n           5\n           1 1\n           1 2\n           1 3\n           1 4\n           1 5\n    Output: 10\n    Explanation: All combinations of three problems are valid as they all have unique difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should be able to handle these scenarios by considering all combinations of three problems and checking their uniqueness in terms of topic and difficulty.\n", "requirement analysis:\nThe requirement is to create a system that can efficiently determine the number of ways to select three problems from a given set such that they meet specific criteria. The system must handle up to 50,000 test cases and a total of 200,000 problems across all test cases. The problems are defined by two attributes: topic and difficulty, and no two problems share the same topic and difficulty simultaneously.\nrequirement pool:\n- Efficiently process up to 50,000 test cases\n- Handle a total of 200,000 problems across all test cases\n- Ensure no two problems have the same topic and difficulty\n- Provide a variety of problem sets to enhance learning\n- Output the number of valid problem selections for each test case\nWe will use a dictionary to count the occurrences of each topic and difficulty. Then, for each problem, we will calculate the number of valid combinations by considering the other problems that share the same topic or difficulty. This approach ensures that we efficiently handle the constraints and large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problem set': refers to the collection of problems Monocarp has.\n    'topic and difficulty': each problem is characterized by a unique combination of these two attributes.\n    'select three training problems': the task is to find combinations of three problems that meet certain criteria.\n\n# [phrase showing quantity relationship]\n    'number of testcases': indicates the number of different scenarios to evaluate.\n    'number of problems': specifies how many problems are available in each testcase.\n    'sum of n over all testcases doesn't exceed 2 \u22c5 10^5': ensures that the total number of problems across all testcases is manageable within computational limits.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of testcases, `t`.\n2. For each testcase:\n   - Read the number of problems, `n`.\n   - Initialize dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the number of valid combinations by considering problems sharing the same topic or difficulty.\n3. Output the result for each testcase.\n\n# [edge case]\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    0\n    Explanation: No three problems share the same topic or difficulty.\n\n    Input: \n    1\n    4\n    1 2\n    1 3\n    2 2\n    2 3\n    Output: \n    4\n    Explanation: Possible sets are (1,2,3), (1,2,4), (1,3,4), (2,3,4).\n\n    Input: \n    1\n    5\n    1 1\n    1 2\n    1 3\n    2 1\n    3 1\n    Output: \n    10\n    Explanation: Multiple combinations possible due to shared topics and difficulties.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        (code for handling the edge case)\n        - Ensure that combinations are only counted once.\n        - Handle cases where no valid combinations exist by returning zero.\n", "requirement analysis:\nThe requirements focus on creating a problem set that is both challenging and varied, ensuring effective learning for students. The solution must efficiently handle large input sizes and provide accurate outputs for multiple test cases.\nrequirement pool:\n- Efficiently handle large input sizes up to 2 \u22c5 10^5 problems.\n- Ensure no two problems have the same topic and difficulty simultaneously.\n- Provide a diverse set of problems to cater to different learning needs.\n- Optimize the algorithm for performance and accuracy.\n- Facilitate effective learning through varied problem types.\nWe will use a combination of combinatorial mathematics and efficient data structures to solve the problem. Specifically, we will leverage the itertools library to generate combinations and use dictionaries to efficiently count occurrences of topics and difficulties. This approach ensures that we can handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial mathematics'\n    Explanation: This refers to the branch of mathematics dealing with combinations of objects. In this context, it means finding all possible ways to select three problems from a given set.\n\n    'efficient data structures'\n    Explanation: This refers to using data structures like dictionaries to store and retrieve data quickly, which is crucial for handling large input sizes efficiently.\n\n# [phrase showing quantity relationship]\n    'three training problems': This indicates that we need to select exactly three problems from the given set.\n    Implementation: Use combinations from itertools to generate all possible sets of three problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases.\n2. For each test case, read the number of problems.\n3. Store each problem's topic and difficulty in a list.\n4. Use itertools.combinations to generate all possible sets of three problems.\n5. For each combination, check if it meets the criteria (e.g., different topics or difficulties).\n6. Count and print the number of valid combinations for each test case.\n\n# [edge case]\n    Test case with minimum n:\n    Input: 3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination is possible with three problems, and it meets the criteria.\n\n    Test case with maximum n:\n    Input: 200000 (all problems have unique topics and difficulties)\n    Output: Large number (depends on specific criteria)\n    Explanation: The number of combinations will be large, but each must be checked against the criteria.\n\n    Test case with identical topics or difficulties:\n    Input: 4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 0\n    Explanation: No valid combination of three problems meets the criteria since all have overlapping topics or difficulties.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        - Ensure that combinations are checked for unique topics and difficulties.\n        - Use efficient counting and checking mechanisms to handle large input sizes without performance issues.\n        (code for handling the edge case)\n        ```python\n        from itertools import combinations\n\n        def count_valid_combinations(problems):\n            count = 0\n            for comb in combinations(problems, 3):\n                topics = {p[0] for p in comb}\n                difficulties = {p[1] for p in comb}\n                if len(topics) == 3 or len(difficulties) == 3:\n                    count += 1\n            return count\n\n        def solve(test_cases):\n            results = []\n            for problems in test_cases:\n                results.append(count_valid_combinations(problems))\n            return results\n\n        # Example usage:\n        test_cases = [\n            [(2, 4), (3, 4), (2, 1), (1, 3)],\n            [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]\n        ]\n        print(solve(test_cases)) # Output: [3, 10]\n        ```\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The input size can be large, so the solution must be efficient in terms of time complexity. The output should be clear and follow the specified format to ensure it can be easily verified against test cases.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets for each test case.\n- Ensure the solution handles the maximum input size within acceptable time limits.\n- Provide a clear and concise output format.\n- Implement input validation to ensure data integrity.\n- Optimize memory usage for handling large datasets.\nWe will use a dictionary to count occurrences of each topic and difficulty. Then, for each problem, we will calculate the number of valid combinations by considering the constraints that no two problems can have the same topic and difficulty simultaneously. This approach ensures efficient handling of large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problem set': refers to the collection of problems Monocarp has.\n    'topic and difficulty': each problem is characterized by a topic and a difficulty level.\n    'select three training problems': the task is to choose three problems from the set.\n\n# [phrase showing quantity relationship]\n    'number of testcases': indicates the number of different problem sets to evaluate.\n    'number of problems': specifies how many problems are in each problem set.\n    'sum of n over all testcases doesn't exceed 2 \u22c5 10^5': ensures that the total number of problems across all test cases is manageable within computational limits.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case, do the following:\n   - Read the number of problems, `n`.\n   - Initialize dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the total number of ways to choose any three problems from `n` (using combinations).\n   - For each problem, adjust the count by subtracting invalid combinations where two problems have the same topic or difficulty.\n3. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one way to select three problems, as all have unique topics and difficulties.\n\n    Test case with maximum values:\n    200000 problems with unique topics and difficulties\n    = large number (calculated using combinations)\n    Explanation: The number of ways to select three problems is large due to the high number of unique combinations.\n\n    Test case with all problems having the same topic or difficulty:\n    3\n    1 1\n    1 2\n    1 3\n    = 0\n    Explanation: No valid selection as all problems share the same topic.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all problems have the same topic or difficulty.\n    \n```python\ndef calculate_ways(t, test_cases):\n    results = []\n    for n, problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        for a, b in problems:\n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_ways = n * (n - 1) * (n - 2) // 6\n        \n        for a, b in problems:\n            total_ways -= (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        results.append(total_ways)\n    \n    return results\n\n# Example usage:\nt = 2\ntest_cases = [\n    (4, [(2, 4), (3, 4), (2, 1), (1, 3)]),\n    (5, [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)])\n]\nprint(calculate_ways(t, test_cases)) # Output: [3, 10]\n```\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The solution must efficiently handle up to 50,000 test cases with a total of up to 200,000 problems. The output should be the number of valid selections for each test case.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems.\n- Ensure the solution is optimized for time complexity.\n- Provide clear and concise output for each test case.\n- Implement a robust algorithm to count valid problem selections.\n- Consider edge cases and ensure the solution is error-free.\nWe will use a combination of combinatorial counting and hash maps to efficiently determine the number of valid selections of three problems. The key is to count the number of ways to select problems such that they meet the criteria of having different topics and difficulties. We will leverage Python's collections module for efficient counting.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'difficult yet varied'\n    Explanation: This implies that the problems should have a range of difficulties and topics, ensuring diversity in the selection.\n\n    'select three training problems'\n    Explanation: The task is to choose sets of three problems from the given list that meet specific criteria.\n\n# [phrase showing quantity relationship]\n    'number of testcases': This indicates the number of different problem sets to evaluate.\n    \n    'number of problems': Refers to the total problems available in each testcase.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case, do the following:\n   - Parse the number of problems, `n`.\n   - Create a list to store tuples of (topic, difficulty) for each problem.\n   - Use a dictionary to count occurrences of each topic and difficulty.\n   - Calculate the total number of ways to choose any three problems from `n` using combinatorial counting (n choose 3).\n   - Subtract invalid combinations where two or more problems have the same topic or difficulty.\n   - Use the inclusion-exclusion principle to adjust for over-counting.\n3. Output the result for each test case.\n\n# [edge case] \n    Case 1: t = 1, n = 3, problems = [(1, 1), (2, 2), (3, 3)]\n    Expected output: 1\n    Explanation: Only one way to select all three problems since they all have different topics and difficulties.\n\n    Case 2: t = 1, n = 4, problems = [(1, 1), (1, 2), (2, 1), (2, 2)]\n    Expected output: 0\n    Explanation: No valid selection of three problems as they do not meet the criteria of having different topics and difficulties.\n\n    Case 3: t = 1, n = 5, problems = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n    Expected output: 10\n    Explanation: All combinations of three problems are valid since all topics and difficulties are unique.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    - Implement checks for when n < 3 to immediately return 0.\n    - Use combinatorial logic to handle cases where topics or difficulties repeat excessively.\n", "requirement analysis:\nThe requirements focus on creating a problem set that is both challenging and varied, ensuring effective learning. The solution must efficiently handle up to 50000 test cases and a total of 200000 problems, requiring optimized algorithms for performance.\nrequirement pool:\n- Efficiently handle large input sizes up to 200000 problems.\n- Ensure no two problems have the same topic and difficulty.\n- Provide a diverse set of problems to facilitate learning.\n- Optimize the algorithm to calculate the number of valid problem sets.\n- Enhance user experience with clear output formatting.\nWe will use combinatorial counting to efficiently determine the number of ways to select three problems from the given set. The key is to ensure that the selected problems meet the criteria of having different topics and difficulties. We will utilize Python's collections library to manage and count occurrences efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial counting'\n    Explanation: This refers to the mathematical technique used to count the number of ways to choose items from a set, ensuring that certain conditions are met. In this context, it is used to count the number of ways to select three problems with different topics and difficulties.\n\n# [phrase showing quantity relationship]\n    'three': We need to select exactly three problems from the given set.\n    'different': The selected problems must have different topics and difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read the number of problems and their respective topic and difficulty.\n    3. Use combinatorial counting to determine the number of ways to select three problems such that they have different topics and difficulties.\n    4. Utilize collections to efficiently count occurrences and ensure uniqueness in selection.\n    5. Output the result for each test case.\n\n# [edge case]\n    Input: 3\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one way to select three problems with different topics and difficulties: problems 1, 2, and 3.\n\n    Input: 4\n           4\n           1 2\n           2 3\n           3 4\n           4 1\n    Output: 4\n    Explanation: Four ways to select three problems with different topics and difficulties.\n\n    Input: 5\n           5\n           1 1\n           2 2\n           3 3\n           4 4\n           5 5\n    Output: 10\n    Explanation: All combinations of three problems are valid since all topics and difficulties are unique.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using combinatorial counting inherently handles these scenarios by ensuring uniqueness in selection.\n"], "scores": [], "pass_results": [true, false, false, false, false, true, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 99, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "rephrase_one", "parent_index": 70}
