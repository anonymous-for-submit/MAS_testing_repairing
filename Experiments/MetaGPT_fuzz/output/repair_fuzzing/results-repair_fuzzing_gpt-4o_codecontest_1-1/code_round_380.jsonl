{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with, or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You need to determine if there is a combination of 5 people that satisfies these strict party conditions.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with, or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You need to determine if there is a combination of 5 people that satisfies these strict party conditions.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with. Alternatively, a successful party requires that no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You need to determine if there is a combination of 5 people that satisfies these strict party conditions.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.", "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, which must include a gathering of exactly 5 people that is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with, or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. You need to determine if there is a combination of 5 people that satisfies these strict party conditions.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n (int): Number of people on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency list to represent the graph of friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Iterate through all combinations of 5 people\n    for combination in combinations(range(1, n + 1), 5):\n        # Check if the combination forms a clique (all are friends)\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n        \n        # Check if the combination forms an independent set (none are friends)\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendship criteria.\n\n    Args:\n        n (int): Number of people on the island.\n        m (int): Number of friendship pairs.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check for a clique of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(v not in adjacency_list[u] for u, v in combinations(combination, 2)):\n            return list(combination)\n\n    # If no valid combination is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n (int): The number of people on the island.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Check all combinations of 5 people\n    for group in combinations(range(1, n + 1), 5):\n        if is_clique(group, adjacency_list) or is_independent_set(group, adjacency_list):\n            return list(group)\n    \n    return -1\n\ndef is_clique(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if a group of 5 people forms a clique.\n\n    Args:\n        group (Tuple[int, int, int, int, int]): A tuple of 5 people.\n        adjacency_list (dict): The adjacency list representing friendships.\n\n    Returns:\n        bool: True if the group is a clique, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] not in adjacency_list[group[i]]:\n                return False\n    return True\n\ndef is_independent_set(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if a group of 5 people forms an independent set.\n\n    Args:\n        group (Tuple[int, int, int, int, int]): A tuple of 5 people.\n        adjacency_list (dict): The adjacency list representing friendships.\n\n    Returns:\n        bool: True if the group is an independent set, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] in adjacency_list[group[i]]:\n                return False\n    return True\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call the function and print the result\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport itertools\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Find a successful party of 5 people based on friendship conditions.\n\n    Args:\n        n (int): Number of people on the island.\n        m (int): Number of friendship pairs.\n        friendships (list): List of tuples representing friendship pairs.\n\n    Returns:\n        list: A list of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using networkx\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        subgraph = graph.subgraph(combination)\n        if nx.is_clique(subgraph):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        subgraph = graph.subgraph(combination)\n        if nx.is_independent_set(subgraph):\n            return list(combination)\n\n    # If neither a clique nor an independent set is found, return -1\n    return -1\n\n# Provide the Interface using input() and print(), DO NOT use stdin\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport itertools\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Find a successful party of 5 people either forming a clique or an independent set.\n\n    Args:\n        n (int): Number of people on the island.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using networkx\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Iterate over all combinations of 5 people\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        subgraph = graph.subgraph(combination)\n        \n        # Check if the combination forms a clique\n        if nx.is_clique(subgraph):\n            return list(combination)\n        \n        # Check if the combination forms an independent set\n        if nx.is_independent_set(subgraph):\n            return list(combination)\n\n    # If no valid combination is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read input values\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(result)\n    else:\n        print(' '.join(map(str, result)))\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    \n    # Populate the adjacency list with the given friendships\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n    \n    # Check all combinations of 5 people\n    for group in combinations(range(1, n + 1), 5):\n        # Check if the group is a clique (all are friends)\n        if all(v in adjacency_list[u] for u, v in combinations(group, 2)):\n            return list(group)\n        \n        # Check if the group is an independent set (none are friends)\n        if all(v not in adjacency_list[u] for u, v in combinations(group, 2)):\n            return list(group)\n    \n    # If no successful party is found, return -1\n    return -1\n\n# Input and output interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\nimport networkx as nx\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Find a successful party of exactly 5 people either forming a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_edges_from(friendships)\n\n    # Iterate over all combinations of 5 people\n    for combination in combinations(range(1, n + 1), 5):\n        subgraph = graph.subgraph(combination)\n        \n        # Check if the combination forms a clique\n        if nx.is_clique(subgraph):\n            return list(combination)\n        \n        # Check if the combination forms an independent set\n        if nx.is_independent_set(subgraph):\n            return list(combination)\n\n    # If no valid combination is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Find the successful party\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of 5 people either forming a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party of exactly 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of people in Baltia.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people if a successful party is possible, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # Generate all combinations of 5 nodes and check if they form an independent set\n    nodes = list(G.nodes)\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            for k in range(j + 1, len(nodes)):\n                for l in range(k + 1, len(nodes)):\n                    for m in range(l + 1, len(nodes)):\n                        subset = [nodes[i], nodes[j], nodes[k], nodes[l], nodes[m]]\n                        if all(not G.has_edge(u, v) for u in subset for v in subset if u != v):\n                            return subset\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people for a successful party or -1 if not possible.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves graph theory concepts, particularly cliques and independent sets. The solution must efficiently handle up to 200,000 people and friendships, necessitating an optimized algorithm.\nrequirement pool:\n- Develop an algorithm to find a clique or independent set of 5 people.\n- Ensure the solution handles the maximum constraints efficiently.\n- Provide clear output formatting as specified in the requirements.\n- Optimize the algorithm for performance.\n- Consider edge cases such as no friendships or all people being friends.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and look for either a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). We will use adjacency lists to represent the graph and employ efficient algorithms to check for these conditions. Given the constraints, we will optimize the search using combinations and adjacency checks.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'friends'\n    Explanation: Friendship is represented as pairs of people who can communicate directly with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': means the party must consist of precisely 5 individuals.\n    Implementation: Ensure the selection of 5 people from the list of N people.\n\n# [degree adverb]\n    'successful': means the party meets the conditions of either all being friends or none being friends.\n    Implementation: Check for either a complete clique or an independent set among the selected 5 people.\n\n# [code logic]\n    1. Represent friendships using an adjacency list to form a graph.\n    2. Iterate through combinations of 5 people from the list of N people.\n    3. For each combination, check if all are friends (clique) or none are friends (independent set).\n    4. If a successful party is found, print the combination; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set, thus a successful party.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If all possible pairs are friends, no independent set can be formed, and a clique of size 5 may not exist due to constraints.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: Similar to the first case, with no friendships, any group of 5 forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for cliques or independent sets inherently handles these scenarios.\n", "requirement analysis:\nThe requirement is to determine if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships among the people. The solution must efficiently handle up to 200,000 people and friendships, ensuring it operates within time constraints.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party.\n- Ensure the solution can handle the maximum input size within time limits.\n- Provide clear and concise output as per the format requirements.\n- Optimize the algorithm for both dense and sparse friendship graphs.\n- Consider edge cases such as no friendships or everyone being friends.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (all friends) or an independent set of size 5 (no friends) in the graph. We will use adjacency lists to represent the graph and check combinations of 5 people to see if they meet the criteria. Given the constraints, we will optimize the search by leveraging properties of graph theory and efficient traversal methods.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique of size 5'\n    Explanation: A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means finding a group of 5 people where each person is friends with every other person in the group.\n\n    'independent set of size 5'\n    Explanation: An independent set in a graph is a set of vertices no two of which are adjacent. Here, it means finding a group of 5 people where no one is friends with anyone else in the group.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    'all the people at the party are friends with each other': This implies a complete subgraph or clique of size 5.\n    'no two people at the party are friends with each other': This implies an independent set of size 5.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of people (N) and the number of friendships (M).\n2. Construct an adjacency list to represent friendships between people.\n3. Check for a clique of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if every pair within the combination is friends.\n4. Check for an independent set of size 5:\n   - Iterate over all possible combinations of 5 people.\n   - For each combination, check if no pair within the combination is friends.\n5. If either a clique or an independent set is found, print the combination.\n6. If no valid combination is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships and more than 5 people, any group of 5 forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers both cliques and independent sets, which cover all possible scenarios.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently, given the constraints on N and M.\nrequirement pool:\n- Develop an algorithm to check for a successful party configuration.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide clear documentation and examples for users.\n- Consider edge cases and validate input data.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and check for cliques of size 5 (where everyone is friends with each other) or independent sets of size 5 (where no one is friends with each other). Given the constraints, we will use adjacency lists for efficient graph representation and leverage combinations to check possible groups of 5 people.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'friends'\n    Explanation: Friendship is represented as pairs of people who can communicate freely with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': means the party must consist of precisely 5 people.\n    Implementation: Ensure that any group considered for the party has exactly 5 members.\n\n# [degree adverb]\n    'successful': means the party must meet one of the two conditions (all friends or no friends).\n    Implementation: Check for cliques of size 5 or independent sets of size 5.\n\n# [code logic]\n    1. Represent friendships using an adjacency list.\n    2. Iterate through combinations of 5 people.\n    3. For each combination, check if all are friends (clique) or none are friends (independent set).\n    4. If a valid combination is found, print the 5 people; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 7 0\n    Output: Any combination of 5 people\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations of 5 people for cliques or independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people from a larger set such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently, given the constraints on N and M.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party.\n- Ensure the solution works within the given constraints of N and M.\n- Optimize the solution for time complexity.\n- Provide clear and concise output as per the problem statement.\n- Consider edge cases and test thoroughly.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (where everyone knows each other) or an independent set of size 5 (where no one knows each other) in the graph. Given the constraints, we will use adjacency lists to represent the graph and check combinations efficiently. We will leverage itertools for combinations and networkx for graph operations to simplify the implementation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique of size 5'\n    Explanation: A clique of size 5 means a subset of 5 people where every pair of people are friends with each other.\n\n    'independent set of size 5'\n    Explanation: An independent set of size 5 means a subset of 5 people where no two people are friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    'no two people': This indicates that in an independent set, none of the selected individuals should have a friendship link.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of people (N) and the number of friendships (M).\n2. Construct an adjacency list to represent the friendships as a graph.\n3. Check for a clique of size 5:\n   - Iterate over all combinations of 5 people.\n   - For each combination, check if every pair within the combination is friends (i.e., all pairs exist in the adjacency list).\n4. If a clique is found, print the combination and exit.\n5. If no clique is found, check for an independent set of size 5:\n   - Iterate over all combinations of 5 people.\n   - For each combination, check if no pair within the combination is friends (i.e., no pairs exist in the adjacency list).\n6. If an independent set is found, print the combination and exit.\n7. If neither a clique nor an independent set is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: With all possible friendships among any group of 5 people, any group forms a clique.\n\n    Input: 10 0\n    Output: Any combination of 5 numbers from 1 to 10\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already considers both cliques and independent sets, which cover all possible scenarios.\n", "requirement analysis:\nThe requirement is to determine if a group of 5 people can be selected such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships among the people. The solution must efficiently handle up to 200,000 people and friendships, suggesting the need for an algorithm that can quickly evaluate potential groups.\nrequirement pool:\n- Efficiently check combinations of 5 people for friendship or non-friendship conditions.\n- Handle large input sizes up to 200,000 people and friendships.\n- Provide clear output as per the specified format.\n- Optimize for performance to ensure quick results.\n- Consider edge cases such as minimum and maximum input values.\nWe will use graph theory to solve this problem. The problem can be represented as a graph where nodes are people and edges are friendships. We need to find a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). Given the constraints, we will use adjacency lists to represent the graph and check combinations of 5 people to see if they form a clique or an independent set. We will leverage itertools for combinations and networkx for graph operations to efficiently handle the large input size.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique'\n    Explanation: In graph theory, a clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. In this context, it means a group of 5 people where everyone is friends with each other.\n\n    'independent set'\n    Explanation: An independent set in a graph is a set of vertices no two of which are adjacent. In this context, it means a group of 5 people where no one is friends with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any selected group of people contains exactly 5 members.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using adjacency lists.\n2. Iterate over all combinations of 5 people from the total N people.\n3. For each combination, check if it forms a clique (all are friends) or an independent set (none are friends).\n4. If a valid combination is found, print the 5 people.\n5. If no valid combination is found after checking all possibilities, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: -1\n    Explanation: If every possible pair among 6 people is a friendship, no independent set of size 5 can exist.\n\n    Input: 10 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations for cliques or independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that either all are friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M.\nrequirement pool:\n- Efficiently check combinations of 5 people for friendship conditions.\n- Handle large input sizes up to 200,000 people and friendships.\n- Ensure output format is strictly followed.\n- Consider edge cases where no friendships exist or all are friends.\n- Optimize for performance in terms of time complexity.\nWe will use a graph-based approach to solve this problem. We will represent the friendships as an undirected graph where nodes are people and edges are friendships. The task is to find a clique of size 5 (all are friends) or an independent set of size 5 (none are friends). We will use combinations to check all possible groups of 5 people and verify the conditions using adjacency lists. Given the constraints, we will optimize by checking only necessary combinations and using efficient data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'friendship'\n    Explanation: Friendship is represented as pairs of people who can communicate freely with each other.\n\n# [phrase showing quantity relationship]\n    'exactly 5': This means the party must consist of precisely 5 people.\n    Implementation: Ensure that any group considered for the party has exactly 5 members.\n\n# [degree adverb]\n    'successful': This means the party must meet one of the two conditions (all friends or none friends).\n    Implementation: Check if a group of 5 people either forms a complete clique or an independent set.\n\n# [code logic]\n1. Represent friendships using an adjacency list to model the graph.\n2. Iterate through all possible combinations of 5 people.\n3. For each combination, check if all members are friends (clique) or none are friends (independent set).\n4. If a valid combination is found, print the 5 people; otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 10 0\n    Output: Any combination of 5 people\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking combinations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on determining the feasibility of organizing a party with specific friendship conditions. The solution must efficiently handle large datasets and ensure accurate mapping of friendships without duplicates.\nrequirement pool:\n- Implement algorithm to check party feasibility based on friendship conditions.\n- Ensure accurate input parsing and validation.\n- Optimize algorithm for large datasets.\n- Provide clear output format as specified.\n- Handle edge cases such as minimum and maximum values of N and M.\nWe will use graph theory to solve this problem. The friendships can be represented as an undirected graph where nodes are people and edges are friendships. We need to check for cliques of size 5 (where all nodes are connected) or independent sets of size 5 (where no nodes are connected). We will use the NetworkX library to efficiently handle graph operations and check for these conditions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n    'clique'\n    Explanation: A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n\n    'independent set'\n    Explanation: An independent set is a set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution involves exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using adjacency lists or matrices.\n2. Iterate over all possible combinations of 5 people from the N people.\n3. For each combination, check if it forms a clique by verifying if every pair of people in the combination are friends.\n4. Alternatively, check if it forms an independent set by verifying if no pair of people in the combination are friends.\n5. If a valid combination is found, print the 5 people.\n6. If no valid combination is found after checking all possibilities, print -1.\n\n# [edge case]\n    Case 1: N = 5, M = 0\n    Output: Any combination of 5 people (e.g., 1 2 3 4 5)\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Case 2: N = 5, M = 10\n    Output: Any combination of 5 people (e.g., 1 2 3 4 5)\n    Explanation: With all possible friendships, any group of 5 people forms a clique.\n\n    Case 3: N = 6, M = 15\n    Output: -1\n    Explanation: If every person is friends with every other person, and we need exactly one independent set or clique of size 5, it is impossible to have a group of exactly 5 people that are neither all friends nor all non-friends.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking all combinations of 5 people will naturally handle these cases.\n", "requirement analysis:\nThe requirements focus on determining the feasibility of organizing a party with specific friendship conditions. The solution must efficiently handle large datasets and provide accurate results based on the friendship graph. The challenge lies in ensuring the solution can quickly identify valid combinations of attendees or determine impossibility.\nrequirement pool:\n- Efficiently process large datasets to determine party feasibility.\n- Accurately validate friendship connections among potential attendees.\n- Provide quick response times for user queries.\n- Ensure the solution is scalable for varying numbers of people and friendships.\n- Offer flexibility in choosing any successful party combination.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the friendship graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. NetworkX, a Python library for the creation, manipulation, and study of complex networks, can be used to handle graph operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'clique': A subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n    'independent set': A set of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': The party must consist of exactly 5 people.\n    'no two people': In the independent set, no two people should be friends.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as a graph using adjacency lists.\n2. Check for a clique of size 5:\n   - Iterate through each person and their friends to find a subset of 5 people where each person is friends with every other person in the subset.\n3. Check for an independent set of size 5:\n   - Iterate through each person and their non-friends to find a subset of 5 people where no person is friends with any other person in the subset.\n4. If either a clique or an independent set is found, print the 5 people. Otherwise, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: With all possible friendships (complete graph), any group of 5 people forms a clique.\n\n    Input: 7 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to determine if a group of 5 people can be selected such that they are either all friends with each other or none are friends with each other. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party configuration.\n- Ensure the solution can handle the maximum constraints of N and M.\n- Optimize the solution to minimize time complexity.\n- Provide clear and concise output as per the requirements.\n- Consider edge cases and ensure robustness of the solution.\nWe will use graph theory to model the friendships as an undirected graph. The problem can be solved by checking for cliques of size 5 or independent sets of size 5. We will use the NetworkX library to efficiently handle graph operations and check for these conditions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other (a clique) or none are friends with each other (an independent set).\n\n    'clique'\n    Explanation: A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent.\n\n    'independent set'\n    Explanation: An independent set is a subset of vertices in a graph, no two of which are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5 people': This means the party must consist of precisely 5 individuals.\n    Implementation: Ensure that any solution involves selecting exactly 5 people.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Model the friendships as an undirected graph using NetworkX.\n    2. Check for cliques of size 5 using graph algorithms.\n    3. Check for independent sets of size 5 using graph algorithms.\n    4. If either condition is met, print the 5 people involved.\n    5. If neither condition is met, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: Any combination of 5 people\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 7 3\n    Output: -1\n    Explanation: Not enough friendships or lack of independence to form a successful party.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that either all are friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to check combinations of 5 people.\n- Ensure the solution handles edge cases, such as minimum and maximum values of N and M.\n- Optimize for time complexity to handle large inputs.\n- Provide clear output format as specified in requirements.\n- Consider multiple successful party combinations if possible.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by representing friendships as an undirected graph where nodes are people and edges are friendships. We need to find a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). We will use the NetworkX library to handle graph operations efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'successful party'\n    Explanation: A successful party is defined as a gathering of exactly 5 people where either all are friends with each other or none are friends with each other.\n\n    'clique'\n    Explanation: A clique in graph theory is a subset of vertices such that every two distinct vertices are adjacent.\n\n    'independent set'\n    Explanation: An independent set in graph theory is a subset of vertices such that no two vertices are adjacent.\n\n# [phrase showing quantity relationship]\n    'exactly 5': means the party must consist of precisely 5 people.\n    Implementation: Ensure the subset of people selected for the party has a length of 5.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Represent the friendships as an undirected graph using NetworkX.\n2. Check for a clique of size 5 using NetworkX's built-in functions.\n3. Check for an independent set of size 5 using NetworkX's built-in functions.\n4. If either a clique or an independent set of size 5 is found, print the corresponding 5 people.\n5. If neither is found, print -1.\n\n# [edge case]\n    Input: 5 0\n    Output: 1 2 3 4 5\n    Explanation: With no friendships, any group of 5 people forms an independent set.\n\n    Input: 6 15\n    Output: 1 2 3 4 5\n    Explanation: With maximum friendships, any group of 5 people forms a clique.\n\n    Input: 7 3\n    Output: -1\n    Explanation: With insufficient friendships and people, neither a clique nor an independent set of size 5 can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for cliques and independent sets will naturally handle these scenarios.\n"], "scores": [], "pass_results": [true, true, false, false, true, false, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 380, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "condense_two2one", "parent_index": 261}
