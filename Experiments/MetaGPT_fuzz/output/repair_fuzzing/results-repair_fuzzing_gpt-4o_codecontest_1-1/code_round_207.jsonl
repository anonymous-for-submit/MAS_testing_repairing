{"name": "1613_E. Crazy Robot", "description": "There is a grid, consisting of n rows and m columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "tags": ["dfs and similar", "graphs"], "difficulty": 11, "id": 1613, "sample_io": [{"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n"]}], "test_list": [{"input": "1\n3 31\n############################..#\n.............................L.\n############################..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n3 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n############################..#\n", "output": ["#++############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n#..######################\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n#..######################\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n#++######################\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "1\n3 25\n##..#####################\n.......................L.\n#..######################\n", "output": ["##..#####################\n....+++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 31\n#############################..\n...........L...................\n############################..#\n", "output": ["#############################..\n+++++++++++L++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n#++######################\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#..###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#..############################\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n#++############################\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n############################..#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n######################..#\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n######################..#\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n#..######$####\"#$########\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n3 31\n..#############################\n.L.............................\n############################..#\n", "output": ["++#############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n##########\"######\"##########./#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n############################..#\n", "output": ["#############################..\n+++++++++++++++++++L++++++++...\n############################..#\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#.##.##########################\n", "output": ["#++############################\n+L++...........................\n#+##.##########################\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"#################..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"########..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.......................L.\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n.......................L+\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n################.############.#\n", "output": ["#++############################\n+L++++++++++++++...............\n################.############.#\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n..#..\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n..#..\n.....\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#..############################\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 25\n##.#####.################\n.L.......................\n#..######$####\"#$########\n", "output": ["##.#####.################\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#.##.##########################\n", "output": ["#..############################\n.....++++++++++++++++++++++++L+\n#.##.##########################\n"]}, {"input": "1\n2 25\n######################..#\n......................L..\n#..###$##################\n", "output": ["######################++#\n++++++++++++++++++++++L++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n++++L++#.\n"]}, {"input": "1\n2 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n"]}, {"input": "1\n2 25\n########.#############.##\n.L.......................\n#..###$###########$######\n", "output": ["########.#############.##\n+L++++++.................\n"]}, {"input": "1\n2 25\n###########.##########.##\n.L.......................\n####\"#################..#\n", "output": ["###########.##########.##\n+L+++++++++..............\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n################.############.#\n", "output": ["#..############################\n.................++++++++++++L+\n################.############+#\n"]}, {"input": "1\n2 25\n##########.############.#\n......................L..\n#..###$##################\n", "output": ["##########.############.#\n...........+++++++++++L..\n"]}, {"input": "1\n2 31\n#..############################\n...............L...............\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++L+++++++++++++++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\nL.##.\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#....\nL.##.\n...#.\n.....\nL\n++++L++#.\n"]}, {"input": "1\n2 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n2 25\n#..######################\n....................L....\n#..######################\n", "output": ["#..######################\n...+++++++++++++++++L++++\n"]}, {"input": "1\n2 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n"]}, {"input": "1\n2 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n######################..#\n", "output": ["##..#####################\n+L.......................\n######################..#\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n#..############################\n", "output": ["#############################..\n...++++++++++++++++L+++++++++..\n#..############################\n"]}, {"input": "1\n2 25\n######.###############.##\n.......................L.\n#..###$##################\n", "output": ["######.###############.##\n.......................L+\n"]}, {"input": "1\n3 31\n############################..#\n.............................L.\n#..############################\n", "output": ["############################++#\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 31\n#..############################\n.L.............................\n#################\"##########-.#\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"##########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$##################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$###########$######\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$###########$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"##############$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"####\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##########\"###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$####$###\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$##$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#.#############.#########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$##################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############\"######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########$##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#######\"######$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n##################$###..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##################$###..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########./#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#$########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##############\"#######..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$#####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##$##$###########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############!######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$$#..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$#####$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n####\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n$#######$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###################$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#############\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"##########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########-.#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$########$##$######\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##$#\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n##########\"######\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"\"###\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######!###############..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$##################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-##########\"#################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######$##$########$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"##$######$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#########$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"###\"###$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#########\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n######\"######\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#####\"###\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$#####..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$######\"####$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#######\"#########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.#############.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########%##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#..##########\"######\"##########\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$$\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n##############\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#/.###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###################$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#./######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####$########\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n###$####$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########-.#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$##\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"..##$#########\"####\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"############\"####..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##%#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"##\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######\"#######\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$#####$##\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#$#######$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###\"\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"####$######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#########\"####$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$##\"..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$#$..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..$\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n.#################$####.#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n########$#\"####$######..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n\"###\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$######$###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"######\"##########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-######\"#####################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"###\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"#############$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#######$#########\"###\"\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########!##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.############$.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######$##%########$###..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$#$###..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$\"#\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$###$########\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"#$#\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n$..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$###\"\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}], "task_id": "codecontest/117", "prompt": "There exists a grid made up of n rows and m columns, with each individual cell within the grid being either unoccupied or unavailable, and one of the available cells holds a lab. The cells that lie beyond the borders of the grid are all blocked, preventing any movement beyond the grid.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", where each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command; upon receiving a command, it will choose a direction differing from the one in command where the cell in that direction is not blocked, and if there is such a direction, it will move to a neighbouring cell in that direction; otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell; that is, after each step of the robot a command can be sent such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "repair_prompt": ["There exists a grid made up of n rows and m columns, with each individual cell within the grid being either unoccupied or unavailable, and one of the available cells holds a lab. The cells that lie beyond the borders of the grid are all blocked, preventing any movement beyond the grid.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", where each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command; upon receiving a command, it will choose a direction differing from the one in command where the cell in that direction is not blocked, and if there is such a direction, it will move to a neighbouring cell in that direction; otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell; that is, after each step of the robot a command can be sent such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "There exists a grid made up of n rows and m columns, with each individual cell within the grid being either unoccupied or unavailable, and one of the available cells holds a lab. The cells that lie beyond the borders of the grid are all blocked. This setup prevents any movement beyond the grid.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", where each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command; upon receiving a command, it will choose a direction differing from the one in command where the cell in that direction is not blocked, and if there is such a direction, it will move to a neighbouring cell in that direction; otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell; that is, after each step of the robot a command can be sent such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "There exists a grid made up of n rows and m columns, with each individual cell within the grid being either unoccupied or unavailable, and one of the available cells holds a lab, while the cells that lie beyond the borders of the grid are all blocked, preventing any movement beyond the grid.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", where each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command; upon receiving a command, it will choose a direction differing from the one in command where the cell in that direction is not blocked, and if there is such a direction, it will move to a neighbouring cell in that direction; otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell; that is, after each step of the robot a command can be sent such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Finds and marks all free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid.\n\n    Returns:\n        List[List[str]]: List of modified grids with reachable free cells marked.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right\n\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n\n        # Perform BFS\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n\n                        # If only one free neighbor, it can be forced to reach the lab\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Call the function\nresults = find_reachable_cells(t, test_cases)\n\n# Output interface\nfor result in results:\n    for line in result:\n        print(line)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can guide the robot to the lab using BFS.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid.\n\n    Returns:\n        List[List[str]]: Modified grids for each test case with reachable free cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for moving in the grid (up, down, left, right)\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        # BFS to find all reachable free cells from the lab\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can guide the robot to the lab using BFS.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable free cells marked with '+'.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Perform BFS from the lab to find all reachable free cells.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[str]): The grid representation.\n\n        Returns:\n            List[str]: Modified grid with reachable free cells marked with '+'.\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        queue = deque()\n        visited = set()\n        lab_position = None\n\n        # Find the lab position and initialize BFS\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    queue.append(lab_position)\n                    visited.add(lab_position)\n                    break\n            if lab_position:\n                break\n\n        # BFS to explore all reachable free cells\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            grid[nx] = grid[nx][:ny] + '+' + grid[nx][ny+1:]\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        return grid\n\n    result = []\n    for n, m, grid in test_cases:\n        modified_grid = bfs(n, m, grid)\n        result.append(modified_grid)\n\n    return result\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can be forced to reach the lab in each test case grid.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: List of modified grids for each test case with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for moving in the grid: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to find all reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if this cell can be forced to reach the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    results = find_reachable_cells(t, test_cases)\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds and marks the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: List of modified grids for each test case with reachable free cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for moving in the grid (right, down, left, up)\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to find all reachable free cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_directions = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] != '#':\n                                free_directions += 1\n                        if free_directions <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n                    elif grid[nx][ny] == 'L':\n                        visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\nresult = find_reachable_cells(t, test_cases)\n\n# Output interface\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Finds and marks the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of grids for each test case.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Convert grid to a mutable list of lists\n        grid = [list(row) for row in grid]\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Perform BFS from the lab position\n        if lab_position:\n            queue = deque([lab_position])\n            visited = set()\n            visited.add(lab_position)\n\n            while queue:\n                x, y = queue.popleft()\n\n                # Check all four possible directions\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n\n                    if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                        if grid[nx][ny] == '.':\n                            # Check if the cell can be forced to reach the lab\n                            free_directions = 0\n                            for ddx, ddy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                                nnx, nny = nx + ddx, ny + ddy\n                                if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] != '#':\n                                    free_directions += 1\n\n                            if free_directions <= 1:\n                                grid[nx][ny] = '+'\n                                queue.append((nx, ny))\n                                visited.add((nx, ny))\n                        elif grid[nx][ny] == 'L':\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function\n    result = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for grid in result:\n        for row in grid:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Finds free cells that can be forced to reach the lab in each test case grid.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of grids for each test case.\n\n    Returns:\n        List of modified grids with reachable free cells marked with '+'.\n    \"\"\"\n    def bfs(grid: List[str], n: int, m: int, lab_pos: Tuple[int, int]) -> List[str]:\n        \"\"\"Performs BFS to find all free cells that can be forced to reach the lab.\n\n        Args:\n            grid: The grid of the current test case.\n            n: Number of rows in the grid.\n            m: Number of columns in the grid.\n            lab_pos: Position of the lab in the grid.\n\n        Returns:\n            Modified grid with reachable free cells marked with '+'.\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        queue = deque([lab_pos])\n        visited = set([lab_pos])\n        reachable = set()\n\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_directions = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] != '#':\n                                free_directions += 1\n                        if free_directions <= 1:\n                            reachable.add((nx, ny))\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        # Modify the grid to mark reachable cells\n        modified_grid = []\n        for i in range(n):\n            row = list(grid[i])\n            for j in range(m):\n                if (i, j) in reachable:\n                    row[j] = '+'\n            modified_grid.append(''.join(row))\n        \n        return modified_grid\n\n    results = []\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_pos = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_pos = (i, j)\n                    break\n            if lab_pos:\n                break\n\n        # Process the grid using BFS\n        modified_grid = bfs(grid, n, m, lab_pos)\n        results.append(modified_grid)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\nresult = find_reachable_cells(t, test_cases)\n\n# Output interface\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds and marks all free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: List of modified grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for moving up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        # BFS to mark reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds and marks the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: List of modified grids for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n\n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for moving in the grid: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to find all reachable free cells from the lab\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_directions = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] != '#':\n                                free_directions += 1\n\n                        # If only one free direction, mark it as reachable\n                        if free_directions <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n                    elif grid[nx][ny] == 'L':\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Find free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable free cells marked with '+'.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str], lab_pos: Tuple[int, int]) -> List[str]:\n        \"\"\"Perform BFS to find all reachable free cells from the lab.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[str]): The grid representation.\n            lab_pos (Tuple[int, int]): Position of the lab in the grid.\n\n        Returns:\n            List[str]: Modified grid with reachable free cells marked with '+'.\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        queue = deque([lab_pos])\n        visited = set([lab_pos])\n        reachable = set()\n\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if all neighboring free cells can lead to the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            reachable.add((nx, ny))\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        # Modify the grid to mark reachable cells\n        modified_grid = [list(row) for row in grid]\n        for x, y in reachable:\n            modified_grid[x][y] = '+'\n        return [''.join(row) for row in modified_grid]\n\n    results = []\n    for n, m, grid in test_cases:\n        # Find the lab position\n        lab_pos = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_pos = (i, j)\n                    break\n            if lab_pos:\n                break\n\n        # Process the grid using BFS\n        modified_grid = bfs(n, m, grid, lab_pos)\n        results.append(modified_grid)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n"], "plans": ["requirement analysis:\nThe main requirement is to determine which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring accurate results.\nrequirement pool:\n- Implement the algorithm to determine reachable cells for the robot.\n- Optimize the solution for large grid sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide clear output format as specified in the requirements.\n- Develop a user-friendly interface for input and output handling.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. The BFS will start from the lab and explore all reachable free cells, marking them as reachable. This approach ensures that we efficiently handle large grids by only exploring necessary paths. We will use a queue to manage the BFS and a set to track visited cells.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid'\n    Explanation: A grid is a two-dimensional array of cells, each of which can be free, blocked, or contain a lab. The robot moves within this grid.\n\n    'lab'\n    Explanation: The lab is a specific cell in the grid that the robot needs to reach. It is marked with 'L'.\n\n    'free cell'\n    Explanation: A cell that the robot can move into, marked with '.'.\n\n    'blocked cell'\n    Explanation: A cell that the robot cannot move into, marked with '#'.\n\n    'crazy robot'\n    Explanation: A robot that moves in any direction except the one commanded, provided the chosen direction is not blocked.\n\n# [phrase showing quantity relationship]\n    'exactly one lab': There is only one cell marked with 'L' in the grid.\n    \n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab ('L') in the grid.\n4. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells:\n   - Initialize a queue with the lab's position.\n   - Use a set to keep track of visited cells.\n   - For each cell, check its neighbors (up, down, left, right).\n   - If a neighbor is a free cell and not visited, mark it as reachable and add it to the queue.\n5. Replace all reachable free cells with '+'.\n6. Output the modified grid for each test case.\n\n# [edge case]\n    Test case 1:\n    Input:\n    1\n    1 1\n    L\n    Output:\n    L\n    Explanation: The grid consists of only one cell which is the lab itself.\n\n    Test case 2:\n    Input:\n    1\n    2 2\n    L#\n    .#\n    Output:\n    L#\n    +#\n    Explanation: The only free cell can reach the lab directly.\n\n    Test case 3:\n    Input:\n    1\n    3 3\n    ###\n    #L#\n    ###\n    Output:\n    ###\n    #L#\n    ###\n    Explanation: All cells are blocked except for the lab, so no free cells can reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by only marking reachable free cells starting from the lab.\n", "requirement analysis:\nThe task requires determining which free cells can guide a robot to a lab in a grid. The robot moves in a direction different from the command given, provided the cell in that direction is not blocked. The solution must efficiently handle large grids and multiple test cases, ensuring accurate output for each scenario.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Optimize for large grid sizes\n- Ensure clear and accurate output format\n- Handle edge cases effectively\n- Provide user-friendly input and output handling\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can guide the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to free cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the output will be formatted according to the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'blocked cell', 'lab'\n    Explanation: The grid is a matrix of cells, where each cell can be free ('.'), blocked ('#'), or contain a lab ('L'). The robot can move between free cells but cannot move into blocked cells or beyond the grid's borders. The lab is the target location where the robot needs to be guided.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to extract the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n    4. For each free cell, check if it can be forced to reach the lab by ensuring that all possible moves eventually lead to the lab.\n    5. Replace free cells that can reach the lab with '+' and leave others as '.'.\n    6. Output the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells exist that can reach the lab.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    Input: 3 3 .L. ...\n    Output: +L+\n            +++\n    Explanation: All free cells can be forced to reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by exploring all possible paths from the lab and marking reachable free cells.\n", "requirement analysis:\nThe main requirement is to determine which free cells can guide the robot to the lab, ensuring that the robot can be forced to reach the lab from these cells. The solution must handle multiple test cases efficiently and provide clear output for each grid configuration.\nrequirement pool:\n- Implement the algorithm to determine reachable cells for the robot\n- Optimize the solution for large grid sizes\n- Ensure the solution handles edge cases and blocked cells correctly\n- Provide clear output format as specified in the requirements\n- Consider visualization options for better understanding\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can guide the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will be optimized to handle large grid sizes by processing each test case independently and using efficient data structures.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'blocked cell', 'lab', 'robot'\n    Explanation: \n    - 'grid': A matrix of cells with n rows and m columns.\n    - 'free cell': A cell marked with '.', where the robot can move.\n    - 'blocked cell': A cell marked with '#', which the robot cannot enter.\n    - 'lab': A cell marked with 'L', the target destination for the robot.\n    - 'robot': The entity that moves within the grid, starting from a free cell and needing to reach the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships in the requirement.\n\n# [degree adverb] \n    No degree adverbs in the requirement.\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read the grid dimensions and the grid itself.\n    3. Identify the position of the lab ('L') in the grid.\n    4. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n    5. For each free cell, determine if it can be forced to reach the lab by checking if all possible moves eventually lead to the lab.\n    6. Replace free cells that can reach the lab with '+'.\n    7. Print the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    Input: \n    1\n    1 1\n    L\n    Output:\n    L\n    Explanation: The grid only contains the lab, so no free cells exist to modify.\n\n    Test case with all cells blocked except for one free cell and the lab:\n    Input:\n    1\n    3 3\n    ###\n    #L#\n    #.#\n    Output:\n    ###\n    #L#\n    #.#\n    Explanation: The free cell is surrounded by blocked cells, so it cannot reach the lab.\n\n    Test case with a straight path from a free cell to the lab:\n    Input:\n    1\n    1 5\n    .L...\n    Output:\n    +L+++\n    Explanation: The free cells can be forced to reach the lab by sending commands opposite to their current direction.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by exploring all possible paths from the lab and marking reachable cells accordingly.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is correct for each scenario.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles the maximum input constraints.\n- Optimize the algorithm for computational efficiency.\n- Provide clear and correct output for each test case.\n- Test the solution against edge cases and large grids.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab cell to determine which free cells can be forced to reach the lab. The BFS will propagate through all free cells, marking them as reachable if they can be forced to move towards the lab. This approach ensures that we efficiently handle large grids and multiple test cases by exploring only necessary paths.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'blocked cell', 'lab'\n    Explanation: The grid is a matrix of cells, where each cell can be free ('.'), blocked ('#'), or contain a lab ('L'). The robot can move through free cells but cannot move into blocked cells. The goal is to determine which free cells can lead the robot to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use Breadth-First Search (BFS) starting from the lab to explore all reachable free cells.\n    4. For each free cell, check if it can be forced to reach the lab by ensuring that it has only one unblocked neighboring cell (which would be the direction towards the lab).\n    5. Mark these cells with a '+' in the output grid.\n    6. Print the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: There are no free cells to mark, so the output remains unchanged.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells are available to reach the lab, so no changes are made.\n\n    Test case with a grid where all free cells are directly connected to the lab:\n    Input: 3 3 .L. ...\n    Output: +L+\n            +++\n    Explanation: All free cells can be forced to reach the lab, so they are marked with '+'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by checking connectivity and marking reachable cells accordingly.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can force a robot to reach a lab cell, given the robot's erratic movement behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells\n- Ensure the solution handles the maximum input size within constraints\n- Optimize the algorithm for better performance\n- Provide comprehensive test coverage for edge cases\n- Document the solution for maintainability and clarity\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can force the robot to reach the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to free cells, ensuring we find all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the BFS will start from the lab cell, marking reachable free cells with a '+'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'lab', 'free cell', 'blocked cell', 'robot'\n    Explanation: The grid is a matrix of cells, where each cell can be free, blocked, or contain a lab. The lab is the target location for the robot. Free cells are those where the robot can move, and blocked cells are impassable. The robot is the entity that needs to be guided to the lab.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use BFS starting from the lab to explore all reachable free cells ('.') that can force the robot to reach the lab.\n    4. Mark these reachable free cells with '+'.\n    5. Ensure that BFS only explores cells that are free and not already visited.\n    6. Output the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist to mark.\n\n    Test case with all cells blocked except for the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells exist to mark as reachable.\n\n    Test case with a grid where all free cells are isolated by blocked cells:\n    Input: 3 3 .#. #L# .#.\n    Output: .#. #L# .#.\n    Explanation: No free cells can reach the lab due to isolation by blocked cells.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by not marking isolated or non-reachable free cells.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic movement. The solution must efficiently handle large grids and ensure correct output formatting.\nrequirement pool:\n- Implement efficient grid traversal to identify reachable cells.\n- Ensure output format strictly adheres to requirements.\n- Optimize algorithm for performance given constraints.\n- Handle edge cases such as blocked cells and large grids.\n- Provide clear documentation for the solution.\nWe will use a breadth-first search (BFS) algorithm to traverse the grid starting from the lab cell. The BFS will help us determine which free cells can be reached by the robot regardless of its erratic movement. We will mark these cells with a '+' sign. The BFS is efficient for this problem as it explores all possible paths from the lab to free cells, ensuring that we cover all reachable cells.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'blocked cell', 'lab'\n    Explanation: The grid is a matrix of cells, where each cell can be free ('.'), blocked ('#'), or contain a lab ('L'). The robot can move through free cells but cannot move into blocked cells or beyond the grid boundaries. The lab is the target location where the robot needs to be directed.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n    4. For each free cell, check if it can be forced to reach the lab by considering all possible movements.\n    5. Mark the free cells that can be forced to reach the lab with a '+' sign.\n    6. Output the modified grid for each test case.\n\n# [edge case] \n    Test case with a single cell grid containing only the lab:\n    1 1\n    L\n    Output:\n    L\n    Explanation: The grid contains only the lab, so no free cells exist to mark.\n\n    Test case with all cells blocked except the lab:\n    3 3\n    ###\n    #L#\n    ###\n    Output:\n    ###\n    #L#\n    ###\n    Explanation: All cells are blocked except the lab, so no free cells can be marked.\n\n    Test case with a grid where all free cells are isolated by blocked cells:\n    3 3\n    #.#\n    #L#\n    #.#\n    Output:\n    #.#\n    #L#\n    #.#\n    Explanation: Free cells are isolated by blocked cells, so they cannot be forced to reach the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by not marking isolated or blocked cells.\n", "requirement analysis:\nThe requirements focus on determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and provide accurate results for each test case. The output format is crucial and must be adhered to strictly.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Ensure the solution handles large grid sizes efficiently.\n- Provide clear documentation for the code.\n- Optimize the code for better performance.\n- Enhance the output format for better readability.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to free cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the output will be formatted according to the requirements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid'\n    Explanation: A grid is a two-dimensional array of cells, where each cell can be free, blocked, or contain a lab. The robot moves within this grid.\n\n    'lab'\n    Explanation: The lab is a specific cell in the grid that the robot needs to reach. It is marked with 'L'.\n\n    'free cell'\n    Explanation: A free cell is a cell in the grid that the robot can move into. It is marked with '.'.\n\n    'blocked cell'\n    Explanation: A blocked cell is a cell in the grid that the robot cannot move into. It is marked with '#'.\n\n    'crazy robot'\n    Explanation: The robot does not follow direct commands but moves in any direction other than the one commanded, provided it is not blocked.\n\n# [phrase showing quantity relationship]\n    'one of the following commands'\n    Explanation: The robot can receive one of four commands, but it will move in a different direction if possible.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab ('L') in the grid.\n4. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n5. For each free cell, check if it can be forced to reach the lab by ensuring that all possible moves eventually lead to the lab.\n6. Mark these cells with '+'.\n7. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with only one cell being the lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid consists only of the lab, so no free cells exist.\n\n    Test case with all cells blocked except for the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells are available to reach the lab.\n\n    Test case with a single row:\n    Input: 1 5 .L...\n    Output: +L+++\n    Explanation: All free cells can be forced to reach the lab by sending commands opposite to their direction from the lab.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by exploring all possible paths from the lab and marking reachable free cells.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic movements. The solution must efficiently handle large grids and ensure correct output formatting.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Optimize for large grid sizes\n- Ensure output format matches requirements\n- Handle edge cases effectively\n- Test the solution against multiple test cases\nWe will use a Breadth-first Search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to free cells, ensuring that we can identify all reachable cells. The BFS will start from the lab and mark all reachable free cells with a '+'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'lab', 'free cell', 'blocked cell', 'robot'\n    Explanation: The grid is a matrix of cells, where each cell can be free, blocked, or contain a lab. The lab is the target location for the robot. Free cells are those where the robot can move, while blocked cells prevent movement. The robot is the entity that needs to be guided to the lab.\n\n# [phrase showing quantity relationship]\n    'exactly one lab': There is only one lab in the grid, which is the destination for the robot.\n    'number of testcases': The problem involves multiple test cases, each with its own grid configuration.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and the grid dimensions for each test case.\n    2. For each test case, identify the position of the lab ('L') in the grid.\n    3. Implement BFS starting from the lab to explore all reachable free cells ('.').\n    4. During BFS, mark each reachable free cell with a '+'.\n    5. Ensure BFS does not move into blocked cells ('#') or outside the grid boundaries.\n    6. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with a single cell grid containing only a lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid contains only the lab, so no free cells exist to be marked.\n\n    Test case with all cells blocked except the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells are available for the robot to move, so no changes are made.\n\n    Test case with a free path directly to the lab:\n    Input: 3 3 ... .L. ...\n    Output: +++ .L. +++\n    Explanation: All free cells can lead directly to the lab, so they are marked with '+'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by marking reachable free cells and ignoring blocked cells or boundaries.\n", "requirement analysis:\nThe requirements focus on determining which free cells can lead the robot to the lab, considering the robot's unpredictable movement. The solution must efficiently process large grids and provide clear output for each test case.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Ensure the solution handles maximum input limits efficiently\n- Optimize the algorithm for performance\n- Validate output format against requirements\n- Consider edge cases like blocked paths and isolated labs\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it explores all possible paths from the lab to free cells, ensuring that we can efficiently handle large grids. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will start from the lab and mark all reachable free cells with a '+'.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'free cell', 'blocked cell', 'lab', 'robot'\n    Explanation: \n    - 'grid': A matrix of cells with n rows and m columns.\n    - 'free cell': A cell that the robot can move into, marked with '.'.\n    - 'blocked cell': A cell that the robot cannot move into, marked with '#'.\n    - 'lab': The target cell where the robot needs to be directed, marked with 'L'.\n    - 'robot': The entity that needs to be guided to the lab, starting from a free cell.\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationship in the requirement.\n\n# [degree adverb] \n    No degree adverb in the requirement.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the grid dimensions and the grid itself.\n3. Identify the position of the lab ('L') in the grid.\n4. Use a breadth-first search (BFS) starting from the lab to explore all reachable free cells.\n5. For each free cell, check if it can be forced to reach the lab by considering all possible moves and ensuring that at least one move leads towards the lab.\n6. Mark such free cells with '+'.\n7. Output the modified grid for each test case.\n\n# [edge case] \n    1. A grid with only one cell which is a lab: \n       Input: 1 1 L\n       Output: L\n       Explanation: The grid is already at the lab, no free cells to mark.\n       \n    2. A grid where all cells are blocked except for the lab:\n       Input: 3 3\n              ###\n              #L#\n              ###\n       Output: \n              ###\n              #L#\n              ###\n       Explanation: No free cells exist, so no changes are made.\n\n    3. A grid where all cells are free except for one blocked cell:\n       Input: 3 3\n              ...\n              .L.\n              ...\n       Output:\n              ...\n              .L.\n              ...\n       Explanation: No free cells can be forced to reach the lab due to the robot's behavior.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS approach inherently handles these scenarios by only marking reachable free cells that can be forced to reach the lab.\n", "requirement analysis:\nThe solution must efficiently determine which free cells can lead the robot to the lab, considering the robot's unpredictable movement. The algorithm should handle large grids and multiple test cases swiftly.\nrequirement pool:\n- Implement efficient pathfinding algorithm for large grids\n- Ensure accurate output format for each test case\n- Optimize code for performance with up to 1000 test cases\n- Handle edge cases like single cell grids\n- Provide clear documentation for the solution\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to free cells, ensuring that we can identify all cells from which the robot can be forced to reach the lab. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case independently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'grid', 'lab', 'free cell', 'blocked cell', 'commands'\n    Explanation: The grid is a matrix of cells, where each cell can be free, blocked, or contain a lab. The lab is the target location for the robot. Free cells are those where the robot can move, while blocked cells prevent movement. Commands are instructions to move the robot, but it will move in a different direction than commanded.\n\n# [phrase showing quantity relationship]\n    'exactly one lab': means there is only one lab in the grid.\n    'number of testcases': indicates multiple grids to process.\n    'number of rows and columns': defines the size of each grid.\n    Implementation: These phrases help define the structure and constraints of the input data.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, read the grid dimensions and the grid itself.\n    3. Identify the position of the lab in the grid.\n    4. Use BFS starting from the lab to explore all reachable free cells.\n    5. For each free cell, check if it can be forced to reach the lab by ensuring all neighboring free cells can lead to the lab.\n    6. Mark such free cells with '+'.\n    7. Output the modified grid for each test case.\n\n# [edge case]\n    Test case with a single cell grid containing a lab:\n    Input: 1 1 L\n    Output: L\n    Explanation: The grid is already at the lab, no movement needed.\n\n    Test case with all cells blocked except for the lab:\n    Input: 3 3 ### #L# ###\n    Output: ### #L# ###\n    Explanation: No free cells to move from, so no '+' markings.\n\n    Test case with a large grid but only one path to the lab:\n    Input: 5 5 ##### #...# #.#L# #...# #####\n    Output: ##### #+++ #.#L# #+++ #####\n    Explanation: Only cells directly connected to the path leading to the lab can be marked.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The BFS logic inherently handles these scenarios by exploring all possible paths from the lab and marking reachable free cells accordingly.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 207, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "mutate_method": "condense_two2one", "parent_index": 90}
