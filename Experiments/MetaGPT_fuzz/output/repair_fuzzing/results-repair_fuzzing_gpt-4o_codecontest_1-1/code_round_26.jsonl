{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp wants the problemset to be challenging yet diverse to help the students learn effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp wants the problemset to be challenging yet diverse to help the students learn effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp wants the problemset to be challenging yet diverse to help the students learn effectively. Monocarp strives to include problems that cover different topics. The variation in topics ensures that the learning process touches multiple areas.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "Monocarp wants the problemset to be challenging yet diverse to help the students learn effectively.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid sets of three problems for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of tuples\n                    representing the topic and difficulty of each problem.\n\n    Returns:\n        A list of integers representing the number of valid sets of three problems for each test case.\n    \"\"\"\n    results = []\n    \n    for n, problems in test_cases:\n        # Create dictionaries to count occurrences of topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        \n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n        \n        # Calculate the number of valid sets\n        valid_sets = 0\n        \n        # Iterate over all combinations of three problems\n        for comb in combinations(problems, 3):\n            topics = {comb[0][0], comb[1][0], comb[2][0]}\n            difficulties = {comb[0][1], comb[1][1], comb[2][1]}\n            \n            # Check if all topics and difficulties are unique\n            if len(topics) == 3 and len(difficulties) == 3:\n                valid_sets += 1\n        \n        results.append(valid_sets)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n    \n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_combinations(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of results, each representing the number of valid combinations for a test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate the number of valid combinations\n        total_combinations = 0\n        for topic, difficulty in problems:\n            # Total combinations without any restrictions\n            total_combinations += (n - 1) * (n - 2) // 2\n            # Subtract invalid combinations where two problems share the same topic\n            total_combinations -= (topic_count[topic] - 1) * (n - 2)\n            # Subtract invalid combinations where two problems share the same difficulty\n            total_combinations -= (difficulty_count[difficulty] - 1) * (n - 2)\n            # Add back the over-subtracted cases where both topic and difficulty are the same\n            total_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Each combination is counted three times, so divide by 3\n        results.append(total_combinations // 3)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print the results\n    results = count_valid_combinations(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of topics and difficulties\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Subtract invalid combinations where all three problems have the same topic\n        invalid_topic_combinations = 0\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_topic_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Subtract invalid combinations where all three problems have the same difficulty\n        invalid_difficulty_combinations = 0\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_difficulty_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_topic_combinations - invalid_difficulty_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_selections(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples with topic and difficulty.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid combinations.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        if n < 3:\n            results.append(0)\n            continue\n\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of three problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Subtract invalid combinations where topics or difficulties are the same\n        invalid_combinations = 0\n\n        # Subtract combinations with the same topic\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Subtract combinations with the same difficulty\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Add back combinations that were subtracted twice (same topic and difficulty)\n        for topic, difficulty in problems:\n            if topic_count[topic] > 1 and difficulty_count[difficulty] > 1:\n                invalid_combinations -= (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_selections(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef count_valid_combinations(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the number of valid combinations of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test cases, each containing a list of problems represented as tuples of topic and difficulty.\n\n    Returns:\n        list: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for problems in test_cases:\n        n = len(problems)\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate the number of valid combinations\n        valid_combinations = 0\n\n        # Iterate over all combinations of three problems\n        for comb in combinations(problems, 3):\n            topics = {comb[0][0], comb[1][0], comb[2][0]}\n            difficulties = {comb[0][1], comb[1][1], comb[2][1]}\n            # Check if all topics and difficulties are unique\n            if len(topics) == 3 and len(difficulties) == 3:\n                valid_combinations += 1\n\n        results.append(valid_combinations)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read the number of test cases\n    t = int(input())\n\n    # Initialize a list to store test cases\n    test_cases = []\n\n    # Read each test case\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append(problems)\n\n    # Call the function and store the result\n    results = count_valid_combinations(t, test_cases)\n\n    # Output the results for each test case\n    for result in results:\n        print(result)\n\n# Entry point of the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_combinations(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing topic and difficulty.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        problem_count = defaultdict(int)\n\n        # Count occurrences of each topic, difficulty, and problem pair\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n            problem_count[(topic, difficulty)] += 1\n\n        # Calculate the number of valid combinations\n        total_combinations = 0\n        for topic, difficulty in problems:\n            # Total combinations without considering the current problem\n            total_combinations += (n - 1) - (topic_count[topic] - 1) - (difficulty_count[difficulty] - 1) + (problem_count[(topic, difficulty)] - 1)\n\n        # Each combination is counted three times, so divide by 3\n        results.append(total_combinations // 3)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        problems = [tuple(map(int, input().strip().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_combinations(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid combinations of three problems for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of tuples\n                    representing the topic and difficulty of each problem.\n\n    Returns:\n        A list of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        pair_count = defaultdict(int)\n\n        # Count occurrences of each topic, difficulty, and topic-difficulty pair\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n            pair_count[(topic, difficulty)] += 1\n\n        # Calculate the number of valid combinations\n        total_combinations = 0\n        for topic, difficulty in problems:\n            # Calculate combinations excluding the current problem\n            total_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n            # Subtract invalid combinations where the same topic-difficulty pair is chosen\n            total_combinations -= (pair_count[(topic, difficulty)] - 1)\n\n        # Each combination is counted three times, so divide by 3\n        results.append(total_combinations // 3)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef count_valid_problem_selections(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid ways to select three training problems for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of two integers (topic, difficulty).\n\n    Returns:\n        A list of integers where each integer represents the number of valid combinations for a test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n\n        # Count occurrences of each topic and difficulty\n        for a, b in problems:\n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n\n        # Calculate total combinations of choosing 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n\n        # Subtract combinations where all three problems share the same topic\n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Subtract combinations where all three problems share the same difficulty\n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n\n        # Append the valid combinations to the results\n        results.append(total_combinations - invalid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_selections(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\nfrom math import comb\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid sets of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n        pair_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for a_i, b_i in problems:\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n            pair_count[(a_i, b_i)] += 1\n\n        # Calculate combinations of problems sharing the same topic or difficulty\n        total_combinations = comb(n, 3)\n        topic_combinations = sum(comb(count, 2) for count in topic_count.values())\n        difficulty_combinations = sum(comb(count, 2) for count in difficulty_count.values())\n        pair_combinations = sum(comb(count, 2) for count in pair_count.values())\n\n        # Apply inclusion-exclusion principle\n        valid_sets = total_combinations - topic_combinations - difficulty_combinations + pair_combinations\n        results.append(valid_sets)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_combinations(n: int) -> int:\n    \"\"\"Calculate the number of ways to choose 3 items from n items.\"\"\"\n    if n < 3:\n        return 0\n    return n * (n - 1) * (n - 2) // 6\n\ndef count_valid_combinations(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Count the number of valid combinations of problems for each test case.\"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n\n        # Count occurrences of each topic and difficulty\n        for a, b in problems:\n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n\n            topic_count[a] += 1\n            difficulty_count[b] += 1\n\n        # Calculate total combinations\n        total_combinations = calculate_combinations(n)\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for a, b in problems:\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        problems = []\n\n        for _ in range(n):\n            a, b = int(data[index]), int(data[index + 1])\n            index += 2\n            problems.append((a, b))\n\n        test_cases.append((n, problems))\n\n    results = count_valid_combinations(t, test_cases)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The constraints are high, with up to 50,000 test cases and a total of 200,000 problems across all test cases. The solution must efficiently handle these constraints while ensuring the output format is strictly followed.\nrequirement pool:\n- Efficiently compute the number of valid problem sets for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm to reduce computational complexity.\n- Include comprehensive test cases to validate the solution.\nWe will use a combinatorial approach to efficiently count the number of valid sets of three problems. The key is to ensure that the selected problems meet the criteria of having different topics and difficulties. We will utilize collections from Python's standard library to manage and count occurrences of topics and difficulties.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial approach'\n    Explanation: This refers to using combinatorial mathematics to count the number of ways to select sets of items that meet certain criteria. In this context, it involves selecting sets of three problems with different topics and difficulties.\n\n    'different topics and difficulties'\n    Explanation: This means that each selected set of three problems must have unique topics and unique difficulties, ensuring diversity in the problem set.\n\n# [phrase showing quantity relationship]\n    'three': This indicates that we need to select exactly three problems for each valid set.\n    Explanation: We need to find combinations of three problems that meet the criteria of having different topics and difficulties.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases and details for each test case.\n    2. For each test case, read the number of problems and their respective topics and difficulties.\n    3. Use a combinatorial approach to count the number of valid sets of three problems.\n    4. Ensure that each set has unique topics and difficulties.\n    5. Output the count for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Expected Output: 1\n    Explanation: Only one set of three problems can be formed with unique topics and difficulties.\n\n    Test case with maximum values:\n    Input: 1\n           200000\n           (randomly generated unique pairs of topics and difficulties)\n    Expected Output: Depends on the specific pairs generated, but should be calculated efficiently.\n\n    Test case with all problems having the same topic or difficulty:\n    Input: 1\n           4\n           1 1\n           1 2\n           1 3\n           1 4\n    Expected Output: 0\n    Explanation: No valid set can be formed as all problems have the same topic.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large inputs.\n        - Use data structures like sets or dictionaries to track unique topics and difficulties.\n        - Implement efficient combinatorial counting to handle large numbers of problems without performance issues.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The constraints involve handling up to 50,000 test cases and ensuring the sum of problems across all test cases does not exceed 200,000. The solution must efficiently compute the result for each test case and output the number of valid selections.\nrequirement pool:\n- Efficiently compute the number of valid problem selections for each test case.\n- Ensure the solution handles the maximum input size within acceptable time limits.\n- Provide clear and concise output for each test case.\n- Ensure the problem set is diverse and challenging.\n- Optimize the solution for readability and maintainability.\nWe will use a dictionary to count the occurrences of each topic and difficulty. Then, for each problem, we will calculate the number of valid combinations by considering the other problems that can be paired with it. This approach ensures that we efficiently handle the constraints of large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problemset': A collection of problems that Monocarp wants to use for training.\n    'topic and difficulty': Each problem is characterized by a topic and a difficulty level.\n\n# [phrase showing quantity relationship]\n    'number of testcases': Refers to the number of different scenarios or sets of problems to evaluate.\n    'number of problems': Refers to the total problems available in each testcase.\n    'sum of n over all testcases doesn't exceed 2 \u22c5 10^5': Ensures that the total number of problems across all testcases is within a manageable limit for computation.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the input to get the number of testcases, t.\n2. For each testcase, do the following:\n   - Read the number of problems, n.\n   - Initialize dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the number of valid combinations by iterating over each problem and considering other problems that can be paired with it.\n3. Output the result for each testcase.\n\n# [edge case]\n    Testcase with minimum n (3 problems) = 1\n    Explanation: With only 3 problems, there is exactly one way to select them all.\n\n    Testcase with maximum n (2 \u22c5 10^5 problems) = Computation should be efficient\n    Explanation: The solution should handle this efficiently without exceeding time limits.\n\n    Testcase with all problems having unique topics and difficulties = Combination count based on unique pairings\n    Explanation: Each problem can only pair with others based on unique topic-difficulty combinations.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations based on unique topics and difficulties will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to create a solution that efficiently calculates the number of ways to select three problems from a given set, ensuring diversity and challenge. The solution must handle large input sizes and provide quick feedback.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets\n- Ensure the solution handles large input sizes\n- Provide clear output format as specified\n- Optimize performance for quick feedback\n- Include detailed comments for code clarity\nWe will implement a function that efficiently calculates the number of ways to select three problems from a given set, ensuring diversity and challenge. The function will utilize dictionaries to count occurrences of topics and difficulties, and then use combinatorial logic to determine valid sets of three problems. This approach will handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'challenging yet diverse'\n    Explanation: The requirement is to select problems that are both challenging and diverse, meaning they should cover different topics and difficulties.\n\n# [phrase showing quantity relationship]\n    'number of ways': This refers to calculating the different combinations possible to select three problems from the given set.\n    Implementation: Use combinatorial logic to calculate combinations.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, parse the number of problems and their respective topics and difficulties.\n    3. Use dictionaries to count occurrences of each topic and difficulty.\n    4. Calculate combinations of three problems ensuring they meet the diversity requirement.\n    5. Return the count of valid combinations for each test case.\n\n# [edge case]\n    Input: 3\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) is possible as each problem has a unique topic and difficulty.\n\n    Input: 4\n           4\n           1 1\n           1 2\n           2 1\n           2 2\n    Output: 4\n    Explanation: All combinations of three problems are valid as they cover all topics and difficulties.\n\n    Input: 5\n           5\n           1 1\n           1 2\n           1 3\n           2 1\n           2 2\n    Output: 10\n    Explanation: Multiple combinations are possible due to repeated topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using combinatorial calculations will naturally handle these scenarios.\n", "requirement analysis:\nThe requirements focus on creating a diverse and challenging problem set that covers multiple topics. The input constraints ensure scalability and efficiency in processing up to 50000 test cases with a total of 200000 problems. The output should accurately reflect the number of ways to select three problems meeting the criteria, ensuring educational value and variety.\nrequirement pool:\n- Implement efficient algorithm to count valid problem selections.\n- Ensure problem sets cover diverse topics.\n- Optimize for scalability with large input sizes.\n- Provide clear output format for test case results.\n- Validate input constraints to prevent errors.\nWe will use a combination of combinatorial mathematics and efficient data structures to count the number of valid selections of three problems. The key is to ensure that the selected problems cover different topics and have varying difficulties. We will utilize Python's collections library to efficiently manage and count occurrences of topics and difficulties.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'topics': refers to the different subjects or areas that the problems cover.\n    'difficulty': refers to the level of challenge each problem presents.\n    Explanation: The requirement is to select three problems such that they cover different topics and have varying difficulties.\n\n# [phrase showing quantity relationship]\n    'number of ways': refers to the different combinations possible to select three problems.\n    Explanation: We need to calculate the number of combinations of three problems that meet the criteria.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read the number of problems and their respective topics and difficulties.\n    3. Use combinatorial mathematics to determine valid combinations of three problems.\n    4. Ensure that selected problems have different topics and varying difficulties.\n    5. Count and output the number of valid combinations for each test case.\n\n# [edge case]\n    Case 1: Input with minimum values\n    Input: 1\n           3\n           1 1\n           2 2\n           3 3\n    Expected Output: 1\n    Explanation: Only one combination is possible with three problems having different topics and difficulties.\n\n    Case 2: All problems have the same topic but different difficulties\n    Input: 1\n           4\n           1 1\n           1 2\n           1 3\n           1 4\n    Expected Output: 0\n    Explanation: No valid combination as all problems have the same topic.\n\n    Case 3: All problems have different topics but same difficulty\n    Input: 1\n           4\n           1 2\n           2 2\n           3 2\n           4 2\n    Expected Output: 0\n    Explanation: No valid combination as all problems have the same difficulty.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if n < 3:\n            return 0\n        # Additional logic to ensure different topics and difficulties are selected.\n        # Use sets or dictionaries to track unique topics and difficulties.\n        # Implement combinatorial checks for valid selections.\n", "requirement analysis:\nThe requirement is to create a problem set selection algorithm that ensures diversity in topics and challenges students effectively. The algorithm must efficiently handle up to 50000 test cases with a total of 200000 problems, ensuring no duplicate topic-difficulty pairs.\nrequirement pool:\n- Develop an efficient algorithm to select diverse and challenging problem sets.\n- Ensure the algorithm can handle large datasets up to 200000 problems.\n- Implement a user-friendly interface for input and output.\n- Provide clear documentation for the algorithm and its usage.\n- Include error handling for invalid inputs.\nWe will use a combination of combinatorial mathematics and efficient data structures to solve the problem. The key is to count the number of valid combinations of three problems that meet the criteria. We will utilize Python's collections library to efficiently manage and count occurrences of topics and difficulties.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combination'\n    Explanation: The requirement involves finding combinations of problems that meet certain criteria. This is a common concept in combinatorial mathematics where we need to count the number of ways to select items from a set.\n\n    'topics' and 'difficulty'\n    Explanation: Each problem has a topic and a difficulty level. The requirement is to select problems based on these attributes, ensuring diversity and challenge.\n\n# [phrase showing quantity relationship]\n    'number of ways': This refers to the different combinations possible to select three problems that meet the criteria. In code, this can be implemented using combinatorial functions or loops to iterate through possible selections.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read the number of problems and their respective topic and difficulty.\n    3. Use data structures like dictionaries or lists to store and count occurrences of topics and difficulties.\n    4. Implement logic to find valid combinations of three problems based on the criteria.\n    5. Calculate the number of such combinations for each test case and print the result.\n\n# [edge case]\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one combination (problems 1, 2, and 3) is possible since each problem has unique topic and difficulty.\n\n    Input: \n    1\n    4\n    1 2\n    2 3\n    3 4\n    4 5\n    Output: \n    4\n    Explanation: All combinations of three problems are valid since they all have different topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic should be able to handle these scenarios by iterating through all possible combinations and checking their validity based on the given criteria.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The input constraints are large, so the solution must be efficient. The output should be the number of valid combinations for each test case.\nrequirement pool:\n- Efficiently calculate the number of valid problem combinations.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and correct output for each test case.\n- Optimize the algorithm for better performance.\n- Include comments and documentation for code clarity.\nWe will use a dictionary to count the occurrences of each topic and difficulty. Then, for each problem, we will calculate the number of valid combinations by considering the other problems that can be paired with it. This approach ensures that we efficiently handle the constraints and large input sizes.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problemset': refers to a collection of problems that Monocarp wants to create.\n    'topics': different subjects or areas that the problems cover.\n    'difficulty': the level of challenge each problem presents.\n    Explanation: The requirement is about selecting sets of three problems from a given list, ensuring diversity in topics and difficulty levels.\n\n# [phrase showing quantity relationship]\n    'number of testcases': refers to the total number of different problem sets to evaluate.\n    'number of problems': refers to the total number of problems in each problem set.\n    Explanation: These phrases indicate the scale of input data and the need to iterate over multiple test cases and problems.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case:\n   - Read the number of problems, `n`.\n   - Initialize dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the number of valid combinations by iterating over each problem and considering other problems that can be paired with it.\n3. Output the number of valid combinations for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    1\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one combination is possible with three problems, each having unique topics and difficulties.\n\n    Test case with maximum values:\n    1\n    200000\n    (random unique pairs of topics and difficulties)\n    = (depends on specific input)\n    Explanation: The output will depend on the specific distribution of topics and difficulties.\n\n    Test case with all problems having the same topic or difficulty:\n    1\n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    = 0\n    Explanation: No valid combinations as all problems share the same topic.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of counting combinations based on unique topics and difficulties will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The solution must efficiently handle up to 200,000 problems across multiple test cases, ensuring performance and correctness.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance and scalability.\n- Include comprehensive test cases to validate the solution.\nWe will use a combinatorial approach to solve this problem. The key is to efficiently count the number of valid combinations of three problems that meet the criteria. We will use dictionaries to count occurrences of topics and difficulties, and then calculate the number of valid combinations based on these counts. This approach ensures that we handle the maximum input size efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial approach'\n    Explanation: This refers to using combinatorial mathematics to count the number of ways to select three problems that meet the criteria. It involves calculating combinations based on counts of topics and difficulties.\n\n# [phrase showing quantity relationship]\n    'three': We need to select exactly three problems from the list.\n    Explanation: This means we are looking for combinations of three problems that meet the criteria. In code, this can be implemented using combinations from itertools or manual counting logic.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the number of test cases.\n    2. For each test case, parse the number of problems and their respective topics and difficulties.\n    3. Use dictionaries to count occurrences of each topic and difficulty.\n    4. Calculate the number of valid combinations of three problems based on these counts.\n    5. Output the result for each test case.\n\n# [edge case]\n    Input: 3\n           3\n           1 1\n           2 2\n           3 3\n    Output: 1\n    Explanation: Only one combination (1, 2, 3) is possible since all topics and difficulties are unique.\n\n    Input: 4\n           4\n           1 2\n           2 3\n           3 4\n           4 1\n    Output: 4\n    Explanation: All combinations of three problems are valid since no two problems have the same topic and difficulty.\n\n    Input: 5\n           5\n           1 1\n           1 2\n           1 3\n           2 1\n           2 2\n    Output: 10\n    Explanation: Multiple combinations are possible due to repeated topics and difficulties.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using combinatorial counting will naturally handle these scenarios by considering all possible combinations.\n", "requirement analysis:\nThe requirements focus on creating a problem set that is both challenging and diverse, ensuring students can learn effectively. The solution must handle up to 50,000 test cases efficiently, with each test case containing up to 200,000 problems. The output must accurately reflect the number of ways to select three problems meeting the criteria.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems per test case.\n- Ensure no two problems have the same topic and difficulty simultaneously.\n- Provide accurate output for the number of valid problem selections.\n- Optimize the algorithm to run within time constraints for all test cases.\n- Enhance user understanding with clear output formatting.\nWe will use a combination of combinatorial counting and hash maps to efficiently count the number of valid problem selections. The key is to count the number of problems with the same topic and difficulty separately, and then use these counts to determine the number of valid combinations. This approach ensures that we can handle the large input sizes within the given constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problemset': A collection of problems that Monocarp wants to use for training.\n    'topic and difficulty': Each problem is characterized by a topic and a difficulty level, both represented as integers.\n\n# [phrase showing quantity relationship]\n    'number of ways to select three training problems': This refers to the combinatorial task of selecting subsets of three problems from the given set of problems.\n    'sum of n over all testcases doesn't exceed 2 \u22c5 10^5': This indicates the total number of problems across all test cases, which affects the efficiency requirements for the solution.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case:\n   - Read the number of problems, `n`.\n   - Initialize data structures to count occurrences of each topic and difficulty.\n   - For each problem, update the counts for its topic and difficulty.\n   - Calculate the total number of ways to choose any three problems using combinatorial counting (n choose 3).\n   - Subtract invalid combinations where all three problems share the same topic or difficulty.\n3. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    1\n    Explanation: Only one way to select three problems, as there are exactly three problems.\n\n    Test case with maximum values:\n    Input:\n    1\n    200000\n    (200000 lines with unique topic-difficulty pairs)\n    Output: \n    Large number (depends on specific input)\n    Explanation: The output will be large due to the high number of combinations possible.\n\n    Test case with all problems having the same topic or difficulty:\n    Input:\n    1\n    4\n    1 1\n    1 2\n    1 3\n    1 4\n    Output: \n    0\n    Explanation: No valid combinations as all problems share the same topic.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all problems share the same topic or difficulty.\n    \n```python\ndef count_valid_combinations(t, test_cases):\n    results = []\n    \n    for n, problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        \n        for a, b in problems:\n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n        \n        total_combinations = n * (n - 1) * (n - 2) // 6\n        \n        invalid_combinations = 0\n        \n        for count in topic_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n        \n        for count in difficulty_count.values():\n            if count >= 3:\n                invalid_combinations += count * (count - 1) * (count - 2) // 6\n        \n        results.append(total_combinations - invalid_combinations)\n    \n    return results\n\n# Example usage:\nt = 2\ntest_cases = [\n    (4, [(2, 4), (3, 4), (2, 1), (1, 3)]),\n    (5, [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)])\n]\n\nprint(count_valid_combinations(t, test_cases))\n```\nThis code handles edge cases by ensuring that invalid combinations are subtracted from the total possible combinations.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The input size can be large, so the solution must be efficient. The problems are defined by two attributes: topic and difficulty, and no two problems have the same combination of these attributes.\nrequirement pool:\n- Efficiently calculate the number of valid problem sets.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and concise output as per the format.\n- Optimize the algorithm for performance.\n- Consider edge cases and validate input constraints.\nWe will use a combination of combinatorial counting and hash maps to efficiently calculate the number of valid problem sets. The key is to count combinations of problems that share either the same topic or difficulty, and then use inclusion-exclusion principle to find the number of valid sets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'combinatorial counting'\n    Explanation: This refers to the mathematical technique used to count the number of ways to choose items from a set, often using combinations or permutations.\n\n    'hash maps'\n    Explanation: Hash maps are data structures that store key-value pairs, allowing for efficient data retrieval based on keys.\n\n    'inclusion-exclusion principle'\n    Explanation: A principle used in combinatorics to calculate the size of the union of multiple sets by including and excluding overlapping elements.\n\n# [phrase showing quantity relationship]\n    'three': We need to select exactly three problems that meet the requirements.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Parse the input to get the number of test cases.\n    2. For each test case, read the number of problems and their respective topics and difficulties.\n    3. Use hash maps to count occurrences of each topic and difficulty.\n    4. Calculate combinations of problems sharing the same topic or difficulty using combinatorial counting.\n    5. Apply the inclusion-exclusion principle to find the number of valid sets of three problems.\n    6. Output the result for each test case.\n\n# [edge case]\n    Input: \n    1\n    3\n    1 1\n    2 2\n    3 3\n    Output: \n    0\n    Explanation: No three problems share either the same topic or difficulty, so there are no valid sets.\n\n    Input:\n    1\n    4\n    1 2\n    1 3\n    1 4\n    2 4\n    Output:\n    1\n    Explanation: Only one set (problems 1, 2, and 3) shares the same topic.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using hash maps and combinatorial counting will naturally handle these scenarios.\n", "requirement analysis:\nThe requirement is to determine the number of ways to select three problems from a given set such that they meet specific criteria. The input size can be large, so the solution must be efficient. The output should be the number of valid selections for each test case.\nrequirement pool:\n- Efficiently calculate the number of valid problem selections for each test case.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and correct output for each test case.\n- Optimize the algorithm for better performance.\n- Include comprehensive test cases to validate the solution.\nWe will use a combination of combinatorial counting and hash maps to efficiently calculate the number of valid problem selections. The key is to count the number of problems with the same topic and difficulty separately, and then use these counts to determine the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'problemset': refers to a collection of problems that Monocarp wants to use for training.\n    'topic and difficulty': each problem is characterized by a unique pair of topic and difficulty.\n\n# [phrase showing quantity relationship]\n    'number of testcases': indicates the number of different scenarios to evaluate.\n    'number of problems': refers to the count of problems available in each testcase.\n    'three training problems': implies selecting a combination of three problems from the given set.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Parse the number of test cases, `t`.\n2. For each test case, do the following:\n   - Read the number of problems, `n`.\n   - Initialize two dictionaries to count occurrences of each topic and difficulty.\n   - For each problem, update the topic and difficulty counts.\n   - Calculate the total number of ways to choose any three problems using combinatorial counting: C(n, 3).\n   - Subtract invalid combinations where all three problems share the same topic or difficulty.\n3. Output the result for each test case.\n\n# [edge case]\n    Test case with minimum values:\n    3\n    1 1\n    2 2\n    3 3\n    = 1\n    Explanation: Only one way to select three problems, as all have different topics and difficulties.\n\n    Test case with maximum values:\n    200000\n    (all problems have unique topics and difficulties)\n    = C(200000, 3)\n    Explanation: All combinations are valid since no two problems share the same topic or difficulty.\n\n    Test case with all problems having the same topic:\n    3\n    1 1\n    1 2\n    1 3\n    = 0\n    Explanation: No valid combinations as all problems share the same topic.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all problems share the same topic or difficulty.\n    \n```python\ndef calculate_combinations(n):\n    return n * (n - 1) * (n - 2) // 6\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        topic_count = {}\n        difficulty_count = {}\n        \n        problems = []\n        \n        for _ in range(n):\n            a, b = int(data[index]), int(data[index + 1])\n            index += 2\n            \n            if a not in topic_count:\n                topic_count[a] = 0\n            if b not in difficulty_count:\n                difficulty_count[b] = 0\n            \n            topic_count[a] += 1\n            difficulty_count[b] += 1\n            \n            problems.append((a, b))\n        \n        total_combinations = calculate_combinations(n)\n        \n        invalid_combinations = 0\n        \n        for a, b in problems:\n            invalid_combinations += (topic_count[a] - 1) * (difficulty_count[b] - 1)\n        \n        valid_combinations = total_combinations - invalid_combinations\n        \n        results.append(valid_combinations)\n    \n    for result in results:\n        print(result)\n\n```\n"], "scores": [], "pass_results": [false, false, false, false, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 26, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "add_1_sentence_at_end", "parent_index": 26}
