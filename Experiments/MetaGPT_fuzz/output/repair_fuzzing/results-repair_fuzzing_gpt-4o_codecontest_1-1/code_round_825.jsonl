{"name": "1594_B. Special Numbers", "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, but 9 is not.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "tags": ["bitmasks", "math"], "difficulty": 8, "id": 1594, "sample_io": [{"input": "3\n3 4\n2 12\n105 564\n", "output": ["9\n12\n3595374\n"]}], "test_list": [{"input": "3\n3 4\n2 6\n105 564\n", "output": ["9\n6\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 564\n", "output": ["1\n6\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 564\n", "output": ["0\n6\n3595374\n"]}, {"input": "3\n0 8\n0 6\n105 564\n", "output": ["0\n0\n3595374\n"]}, {"input": "3\n1 8\n0 6\n105 564\n", "output": ["1\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 564\n", "output": ["3\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n105 984\n", "output": ["3\n0\n713307087\n"]}, {"input": "3\n1 10\n0 6\n105 984\n", "output": ["2\n0\n713307087\n"]}, {"input": "3\n6 4\n2 12\n105 564\n", "output": ["36\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n105 564\n", "output": ["9\n1\n3595374\n"]}, {"input": "3\n1 4\n2 6\n105 571\n", "output": ["1\n6\n4742080\n"]}, {"input": "3\n0 4\n2 6\n39 564\n", "output": ["0\n6\n452236824\n"]}, {"input": "3\n0 8\n2 6\n105 713\n", "output": ["0\n6\n257287716\n"]}, {"input": "3\n0 8\n0 6\n105 46\n", "output": ["0\n0\n763984296\n"]}, {"input": "3\n1 8\n0 6\n105 868\n", "output": ["1\n0\n312144741\n"]}, {"input": "3\n1 7\n0 6\n35 564\n", "output": ["3\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 564\n", "output": ["43\n12\n3595374\n"]}, {"input": "3\n3 4\n2 1\n110 564\n", "output": ["9\n1\n745888270\n"]}, {"input": "3\n1 4\n3 6\n105 571\n", "output": ["1\n12\n4742080\n"]}, {"input": "3\n0 4\n0 6\n39 564\n", "output": ["0\n0\n452236824\n"]}, {"input": "3\n0 8\n2 12\n105 713\n", "output": ["0\n12\n257287716\n"]}, {"input": "3\n1 8\n1 6\n105 868\n", "output": ["1\n2\n312144741\n"]}, {"input": "3\n1 4\n0 6\n35 564\n", "output": ["1\n0\n692143895\n"]}, {"input": "3\n6 7\n2 12\n105 276\n", "output": ["43\n12\n456030397\n"]}, {"input": "3\n1 4\n2 6\n105 211\n", "output": ["1\n6\n258462631\n"]}, {"input": "3\n0 8\n2 12\n103 713\n", "output": ["0\n12\n134894835\n"]}, {"input": "3\n0 12\n0 6\n105 28\n", "output": ["0\n0\n122719275\n"]}, {"input": "3\n1 8\n1 6\n105 238\n", "output": ["1\n2\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 984\n", "output": ["18\n0\n713307087\n"]}, {"input": "3\n2 26\n0 10\n105 984\n", "output": ["26\n0\n713307087\n"]}, {"input": "3\n6 7\n2 20\n105 276\n", "output": ["43\n20\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 211\n", "output": ["2\n6\n258462631\n"]}, {"input": "3\n1 8\n2 12\n103 713\n", "output": ["1\n12\n134894835\n"]}, {"input": "3\n1 8\n2 6\n105 238\n", "output": ["1\n6\n900896196\n"]}, {"input": "3\n2 18\n0 2\n105 735\n", "output": ["18\n0\n378849471\n"]}, {"input": "3\n6 7\n2 6\n105 276\n", "output": ["43\n6\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 274\n", "output": ["2\n6\n456019477\n"]}, {"input": "3\n1 10\n2 12\n103 713\n", "output": ["2\n12\n134894835\n"]}, {"input": "3\n6 7\n2 6\n105 255\n", "output": ["43\n6\n22446815\n"]}, {"input": "3\n1 7\n2 6\n105 274\n", "output": ["3\n6\n456019477\n"]}, {"input": "3\n1 4\n3 6\n105 238\n", "output": ["1\n12\n900896196\n"]}, {"input": "3\n6 7\n2 1\n105 255\n", "output": ["43\n1\n22446815\n"]}, {"input": "3\n1 20\n2 4\n103 713\n", "output": ["2\n4\n134894835\n"]}, {"input": "3\n1 4\n4 6\n105 238\n", "output": ["1\n20\n900896196\n"]}, {"input": "3\n1 4\n5 6\n105 238\n", "output": ["1\n30\n900896196\n"]}, {"input": "3\n1 3\n2 4\n165 713\n", "output": ["2\n4\n58081920\n"]}, {"input": "3\n1 3\n2 7\n165 713\n", "output": ["2\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n105 433\n", "output": ["1\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 433\n", "output": ["0\n6\n260115562\n"]}, {"input": "3\n0 2\n2 6\n105 443\n", "output": ["0\n6\n261273292\n"]}, {"input": "3\n0 2\n2 6\n105 583\n", "output": ["0\n6\n214860566\n"]}, {"input": "3\n0 2\n2 7\n105 583\n", "output": ["0\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 583\n", "output": ["0\n12\n214860566\n"]}, {"input": "3\n0 2\n2 12\n23 583\n", "output": ["0\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 583\n", "output": ["1\n12\n300685298\n"]}, {"input": "3\n1 2\n2 12\n23 476\n", "output": ["1\n12\n864138587\n"]}, {"input": "3\n1 2\n3 12\n23 476\n", "output": ["1\n36\n864138587\n"]}, {"input": "3\n1 2\n3 12\n15 476\n", "output": ["1\n36\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 714\n", "output": ["1\n36\n625612499\n"]}, {"input": "3\n1 2\n3 12\n15 657\n", "output": ["1\n36\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 657\n", "output": ["1\n27\n614269110\n"]}, {"input": "3\n1 2\n3 8\n15 224\n", "output": ["1\n27\n183009375\n"]}, {"input": "3\n1 3\n3 8\n15 224\n", "output": ["2\n27\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 224\n", "output": ["2\n1\n183009375\n"]}, {"input": "3\n1 3\n1 8\n15 250\n", "output": ["2\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 564\n", "output": ["9\n17\n3595374\n"]}, {"input": "3\n3 4\n2 6\n88 564\n", "output": ["9\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n105 564\n", "output": ["1\n12\n3595374\n"]}, {"input": "3\n0 4\n2 6\n105 549\n", "output": ["0\n6\n882044757\n"]}, {"input": "3\n0 8\n1 6\n105 564\n", "output": ["0\n2\n3595374\n"]}, {"input": "3\n1 5\n0 6\n105 564\n", "output": ["2\n0\n3595374\n"]}, {"input": "3\n1 7\n0 6\n16 564\n", "output": ["3\n0\n720590628\n"]}, {"input": "3\n1 7\n0 6\n109 984\n", "output": ["3\n0\n669833413\n"]}, {"input": "3\n1 10\n0 10\n137 984\n", "output": ["2\n0\n172328490\n"]}, {"input": "3\n6 4\n2 12\n151 564\n", "output": ["36\n12\n532389654\n"]}, {"input": "3\n3 4\n2 1\n89 564\n", "output": ["9\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 290\n", "output": ["1\n6\n97284386\n"]}, {"input": "3\n0 4\n2 6\n39 1030\n", "output": ["0\n6\n28210319\n"]}, {"input": "3\n0 8\n0 6\n105 75\n", "output": ["0\n0\n96788976\n"]}, {"input": "3\n0 10\n0 2\n105 984\n", "output": ["0\n0\n713307087\n"]}, {"input": "3\n6 7\n2 22\n105 564\n", "output": ["43\n22\n3595374\n"]}, {"input": "3\n1 8\n2 12\n105 713\n", "output": ["1\n12\n257287716\n"]}, {"input": "3\n0 12\n0 6\n209 46\n", "output": ["0\n0\n787390482\n"]}, {"input": "3\n1 8\n1 6\n80 868\n", "output": ["1\n2\n69536402\n"]}, {"input": "3\n1 6\n0 6\n35 564\n", "output": ["2\n0\n692143895\n"]}, {"input": "3\n1 26\n0 10\n105 1003\n", "output": ["3\n0\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 276\n", "output": ["43\n17\n456030397\n"]}, {"input": "3\n3 3\n4 1\n110 564\n", "output": ["4\n1\n745888270\n"]}, {"input": "3\n0 8\n2 16\n103 713\n", "output": ["0\n16\n134894835\n"]}, {"input": "3\n1 8\n1 6\n201 238\n", "output": ["1\n2\n436757470\n"]}, {"input": "3\n2 18\n1 2\n105 984\n", "output": ["18\n1\n713307087\n"]}, {"input": "3\n2 26\n1 10\n105 984\n", "output": ["26\n2\n713307087\n"]}, {"input": "3\n6 7\n4 20\n105 276\n", "output": ["43\n272\n456030397\n"]}, {"input": "3\n1 15\n2 12\n103 713\n", "output": ["4\n12\n134894835\n"]}, {"input": "3\n1 8\n2 4\n105 238\n", "output": ["1\n4\n900896196\n"]}, {"input": "3\n6 7\n0 6\n105 276\n", "output": ["43\n0\n456030397\n"]}, {"input": "3\n1 6\n2 6\n105 176\n", "output": ["2\n6\n925646821\n"]}, {"input": "3\n1 10\n2 12\n50 713\n", "output": ["2\n12\n861447554\n"]}, {"input": "3\n1 4\n2 6\n60 238\n", "output": ["1\n6\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 255\n", "output": ["43\n6\n5380840\n"]}, {"input": "3\n1 7\n2 6\n93 274\n", "output": ["3\n6\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 713\n", "output": ["2\n12\n320033969\n"]}, {"input": "3\n2 4\n3 6\n105 238\n", "output": ["4\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 713\n", "output": ["2\n1\n134894835\n"]}, {"input": "3\n1 7\n4 6\n105 238\n", "output": ["3\n20\n900896196\n"]}, {"input": "3\n6 7\n3 1\n105 389\n", "output": ["43\n1\n375760428\n"]}, {"input": "3\n1 3\n2 4\n103 863\n", "output": ["2\n4\n586977111\n"]}, {"input": "3\n1 3\n2 4\n165 330\n", "output": ["2\n4\n846108753\n"]}, {"input": "3\n2 3\n2 7\n165 713\n", "output": ["3\n7\n58081920\n"]}, {"input": "3\n1 2\n2 6\n192 238\n", "output": ["1\n6\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 433\n", "output": ["1\n6\n6607553\n"]}, {"input": "3\n0 2\n2 6\n134 433\n", "output": ["0\n6\n333298828\n"]}, {"input": "3\n1 2\n2 6\n105 583\n", "output": ["1\n6\n214860566\n"]}, {"input": "3\n1 2\n2 7\n105 583\n", "output": ["1\n7\n214860566\n"]}, {"input": "3\n0 2\n2 12\n105 433\n", "output": ["0\n12\n260115562\n"]}, {"input": "3\n1 2\n2 12\n39 583\n", "output": ["1\n12\n878442964\n"]}, {"input": "3\n1 2\n4 12\n23 476\n", "output": ["1\n80\n864138587\n"]}, {"input": "3\n2 2\n3 12\n23 476\n", "output": ["2\n36\n864138587\n"]}, {"input": "3\n1 2\n4 12\n15 476\n", "output": ["1\n80\n745194836\n"]}, {"input": "3\n1 2\n3 12\n15 156\n", "output": ["1\n36\n170913600\n"]}, {"input": "3\n1 2\n3 16\n15 657\n", "output": ["1\n81\n614269110\n"]}, {"input": "3\n1 2\n5 8\n15 657\n", "output": ["1\n125\n614269110\n"]}, {"input": "3\n1 3\n3 8\n15 216\n", "output": ["2\n27\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 224\n", "output": ["2\n8\n183009375\n"]}, {"input": "3\n1 1\n1 8\n15 250\n", "output": ["1\n1\n183063390\n"]}, {"input": "3\n3 4\n2 17\n105 515\n", "output": ["9\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 564\n", "output": ["3\n6\n950813808\n"]}, {"input": "3\n1 4\n3 6\n27 564\n", "output": ["1\n12\n612312689\n"]}, {"input": "3\n0 4\n3 6\n105 549\n", "output": ["0\n12\n882044757\n"]}, {"input": "3\n0 8\n1 6\n110 564\n", "output": ["0\n2\n745888270\n"]}, {"input": "3\n0 2\n0 6\n105 68\n", "output": ["0\n0\n95642270\n"]}, {"input": "3\n1 5\n0 6\n105 1004\n", "output": ["2\n0\n354583021\n"]}, {"input": "3\n1 7\n0 6\n21 564\n", "output": ["3\n0\n284320046\n"]}, {"input": "3\n1 10\n0 8\n105 1410\n", "output": ["2\n0\n893659373\n"]}, {"input": "3\n6 4\n2 12\n244 564\n", "output": ["36\n12\n472775977\n"]}, {"input": "3\n3 2\n2 1\n89 564\n", "output": ["3\n1\n901799978\n"]}, {"input": "3\n1 4\n2 6\n105 385\n", "output": ["1\n6\n375749403\n"]}, {"input": "3\n0 8\n3 8\n105 713\n", "output": ["0\n27\n257287716\n"]}, {"input": "3\n0 18\n1 10\n105 984\n", "output": ["0\n2\n713307087\n"]}, {"input": "3\n6 4\n2 22\n105 564\n", "output": ["36\n22\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 923\n", "output": ["9\n1\n300692073\n"]}, {"input": "3\n1 2\n6 6\n105 571\n", "output": ["1\n42\n4742080\n"]}, {"input": "3\n1 8\n2 15\n105 713\n", "output": ["1\n15\n257287716\n"]}, {"input": "3\n1 8\n1 6\n80 798\n", "output": ["1\n2\n690210344\n"]}, {"input": "3\n0 18\n0 2\n136 984\n", "output": ["0\n0\n313996483\n"]}, {"input": "3\n1 26\n1 10\n105 1003\n", "output": ["3\n2\n354572102\n"]}, {"input": "3\n6 7\n2 17\n105 194\n", "output": ["43\n17\n136912005\n"]}, {"input": "3\n1 1\n2 6\n105 81\n", "output": ["1\n6\n217181871\n"]}, {"input": "3\n0 8\n2 16\n103 658\n", "output": ["0\n16\n194064920\n"]}, {"input": "3\n1 8\n1 6\n201 445\n", "output": ["1\n2\n708509974\n"]}, {"input": "3\n2 18\n1 3\n105 984\n", "output": ["18\n2\n713307087\n"]}, {"input": "3\n6 10\n4 20\n105 276\n", "output": ["222\n272\n456030397\n"]}, {"input": "3\n1 9\n2 6\n74 211\n", "output": ["2\n6\n516663646\n"]}, {"input": "3\n1 19\n2 12\n103 713\n", "output": ["3\n12\n134894835\n"]}, {"input": "3\n1 8\n4 4\n105 238\n", "output": ["1\n16\n900896196\n"]}, {"input": "3\n9 7\n0 6\n105 276\n", "output": ["91\n0\n456030397\n"]}, {"input": "3\n1 6\n2 2\n105 176\n", "output": ["2\n2\n925646821\n"]}, {"input": "3\n1 10\n0 12\n50 713\n", "output": ["2\n0\n861447554\n"]}, {"input": "3\n1 4\n2 3\n60 238\n", "output": ["1\n3\n793799738\n"]}, {"input": "3\n6 7\n2 6\n9 205\n", "output": ["43\n6\n5315221\n"]}, {"input": "3\n1 7\n3 6\n93 274\n", "output": ["3\n12\n132284969\n"]}, {"input": "3\n1 20\n2 12\n132 818\n", "output": ["2\n12\n838210136\n"]}, {"input": "3\n4 4\n3 6\n105 238\n", "output": ["16\n12\n900896196\n"]}, {"input": "3\n1 20\n2 1\n103 372\n", "output": ["2\n1\n482792581\n"]}, {"input": "3\n1 7\n4 6\n105 182\n", "output": ["3\n20\n925657951\n"]}, {"input": "3\n1 3\n2 2\n165 330\n", "output": ["2\n2\n846108753\n"]}, {"input": "3\n1 1\n5 6\n198 238\n", "output": ["1\n30\n423451933\n"]}, {"input": "3\n2 3\n3 7\n165 713\n", "output": ["3\n13\n58081920\n"]}, {"input": "3\n1 2\n1 6\n192 238\n", "output": ["1\n2\n77020973\n"]}, {"input": "3\n1 2\n2 6\n7 749\n", "output": ["1\n6\n41311999\n"]}, {"input": "3\n0 2\n2 6\n268 433\n", "output": ["0\n6\n974641\n"]}, {"input": "3\n1 2\n2 6\n192 583\n", "output": ["1\n6\n590294341\n"]}, {"input": "3\n1 2\n2 7\n114 583\n", "output": ["1\n7\n365619380\n"]}, {"input": "3\n1 2\n1 12\n39 583\n", "output": ["1\n2\n878442964\n"]}, {"input": "3\n2 2\n3 4\n23 476\n", "output": ["2\n9\n864138587\n"]}, {"input": "3\n1 2\n4 12\n16 476\n", "output": ["1\n80\n580249828\n"]}, {"input": "3\n1 2\n2 12\n15 156\n", "output": ["1\n12\n170913600\n"]}, {"input": "3\n1 2\n3 16\n6 657\n", "output": ["1\n81\n10358929\n"]}, {"input": "3\n1 2\n5 11\n15 657\n", "output": ["1\n131\n614269110\n"]}, {"input": "3\n0 4\n3 8\n15 224\n", "output": ["0\n27\n183009375\n"]}, {"input": "3\n1 3\n6 8\n15 216\n", "output": ["2\n216\n182304000\n"]}, {"input": "3\n1 3\n2 8\n15 378\n", "output": ["2\n8\n575094626\n"]}, {"input": "3\n3 7\n2 17\n105 515\n", "output": ["13\n17\n119218296\n"]}, {"input": "3\n3 2\n2 6\n88 962\n", "output": ["3\n6\n799832816\n"]}, {"input": "3\n1 4\n3 6\n27 107\n", "output": ["1\n12\n401789107\n"]}, {"input": "3\n0 4\n4 6\n105 549\n", "output": ["0\n20\n882044757\n"]}, {"input": "3\n1 2\n0 6\n105 68\n", "output": ["1\n0\n95642270\n"]}, {"input": "3\n2 5\n0 6\n105 1004\n", "output": ["5\n0\n354583021\n"]}, {"input": "3\n4 4\n2 12\n244 564\n", "output": ["16\n12\n472775977\n"]}, {"input": "3\n1 4\n2 4\n105 385\n", "output": ["1\n4\n375749403\n"]}, {"input": "3\n0 2\n0 6\n39 1030\n", "output": ["0\n0\n28210319\n"]}, {"input": "3\n0 8\n3 8\n105 437\n", "output": ["0\n27\n260126587\n"]}, {"input": "3\n1 4\n0 2\n105 984\n", "output": ["1\n0\n713307087\n"]}, {"input": "3\n6 4\n0 22\n105 564\n", "output": ["36\n0\n3595374\n"]}, {"input": "3\n3 4\n3 1\n110 1290\n", "output": ["9\n1\n331570536\n"]}, {"input": "3\n1 2\n10 6\n105 571\n", "output": ["1\n110\n4742080\n"]}, {"input": "3\n1 14\n2 15\n105 713\n", "output": ["3\n15\n257287716\n"]}, {"input": "3\n1 26\n1 10\n129 1003\n", "output": ["3\n2\n286863200\n"]}, {"input": "3\n6 11\n2 17\n105 194\n", "output": ["223\n17\n136912005\n"]}, {"input": "3\n1 1\n0 6\n105 81\n", "output": ["1\n0\n217181871\n"]}], "task_id": "codecontest/52", "prompt": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17. However, the number 9 is not considered special because it cannot be represented in such a way.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. To solve this problem, you need to efficiently generate and sort special numbers based on the given definition.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "repair_prompt": ["Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17. However, the number 9 is not considered special because it cannot be represented in such a way.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. To solve this problem, you need to efficiently generate and sort special numbers based on the given definition.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\n\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17. However, the number 9 is not considered special because it cannot be represented in such a way. The number 9 cannot be written as a sum like required. It lacks a combination of powers of n to make up 9.\n\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. To solve this problem, you need to efficiently generate and sort special numbers based on the given definition.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers. Let's call a positive number special if it can be written as a sum of different non-negative powers of n; for example, for n = 4 number 17 is special, because it can be written as 4^0 + 4^2 = 1 + 16 = 17, however, the number 9 is not considered special because it cannot be represented in such a way. Theofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 10^9+7. To solve this problem, you need to efficiently generate and sort special numbers based on the given definition.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_numbers = generate_special_numbers(n, k)\n        results.append(special_numbers[k - 1] % MODULO)\n    return results\n\ndef generate_special_numbers(n: int, k: int) -> List[int]:\n    \"\"\"Generate special numbers for a given base n up to the k-th number.\n\n    Args:\n        n: The base integer.\n        k: The number of special numbers to generate.\n\n    Returns:\n        A list of special numbers sorted in increasing order.\n    \"\"\"\n    special_numbers = []\n    limit = 1 << k  # 2^k, as we need to consider all combinations of powers up to k\n    for i in range(limit):\n        special_number = 0\n        power = 0\n        while i > 0:\n            if i & 1:\n                special_number += n**power\n            i >>= 1\n            power += 1\n        special_numbers.append(special_number)\n    special_numbers.sort()\n    return special_numbers\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed as a sum\n    of different non-negative powers of a given number n. The k-th special number\n    refers to the k-th number in the sequence of special numbers when sorted in\n    increasing order.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7\n        for the corresponding test case.\n    \"\"\"\n    MOD = 10**9 + 7\n    results = []\n\n    for n, k in test_cases:\n        # Generate special numbers using binary representation\n        special_numbers = []\n        limit = 1 << 60  # A practical limit for binary numbers to generate enough special numbers\n\n        for i in range(limit):\n            special_number = 0\n            power = 1\n            j = i\n            while j > 0:\n                if j & 1:\n                    special_number += power\n                power *= n\n                j >>= 1\n            special_numbers.append(special_number)\n\n            # If we have generated enough special numbers, break early\n            if len(special_numbers) >= k:\n                break\n\n        # Sort the generated special numbers\n        special_numbers.sort()\n\n        # Retrieve the k-th special number and apply modulo\n        results.append(special_numbers[k-1] % MOD)\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    t = int(data[0])\n    test_cases = [(int(data[i]), int(data[i+1])) for i in range(1, len(data), 2)]\n\n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = 0\n        power = 1\n        while k > 0:\n            if k % 2 == 1:\n                special_number = (special_number + power) % MOD\n            power = (power * n) % MOD\n            k //= 2\n        results.append(special_number)\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport heapq\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case using a priority queue.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Use a min-heap to generate special numbers in increasing order\n        min_heap = []\n        seen = set()\n        \n        # Start with the smallest special number, which is n^0 = 1\n        heapq.heappush(min_heap, 1)\n        seen.add(1)\n        \n        # Extract the k-th smallest special number\n        current_special_number = 0\n        for _ in range(k):\n            current_special_number = heapq.heappop(min_heap)\n            next_special_number = current_special_number * n\n            \n            if next_special_number not in seen:\n                heapq.heappush(min_heap, next_special_number)\n                seen.add(next_special_number)\n        \n        results.append(current_special_number % MOD)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Output interface\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Tuple\n\ndef find_kth_special_number(test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of n. This function finds the\n    k-th smallest special number for each test case and returns it modulo 10^9+7.\n\n    Args:\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers, each representing the k-th special number modulo 10^9+7.\n    \"\"\"\n    MOD = 10**9 + 7\n    results = []\n\n    for n, k in test_cases:\n        min_heap = []\n        heapq.heappush(min_heap, 1)\n        seen = set()\n        seen.add(1)\n\n        current_special_number = None\n\n        for _ in range(k):\n            current_special_number = heapq.heappop(min_heap)\n\n            power = current_special_number\n            while power <= MOD:\n                new_special_number = current_special_number + power\n                if new_special_number not in seen:\n                    heapq.heappush(min_heap, new_special_number)\n                    seen.add(new_special_number)\n                power *= n\n\n        results.append(current_special_number % MOD)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport heapq\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n: int, k: int) -> int:\n    \"\"\"Find the k-th special number for a given n.\n\n    A special number is defined as a positive integer that can be expressed\n    as a sum of different non-negative powers of n. This function finds the\n    k-th smallest special number in increasing order.\n\n    Args:\n        n (int): The base number for powers.\n        k (int): The position of the special number to find.\n\n    Returns:\n        int: The k-th special number modulo 10^9+7.\n    \"\"\"\n    # Priority queue to store special numbers\n    pq = []\n    \n    # Generate special numbers using bit manipulation\n    for i in range(k):  # Limit iterations based on k\n        special_number = sum(n**j for j in range(i.bit_length()) if i & (1 << j))\n        heapq.heappush(pq, special_number)\n    \n    # Extract k-th smallest special number\n    for _ in range(k - 1):\n        heapq.heappop(pq)\n    \n    return heapq.heappop(pq) % MOD\n\ndef process_test_cases(test_cases: list) -> list:\n    \"\"\"Process multiple test cases to find k-th special numbers.\n\n    Args:\n        test_cases (list): A list of tuples, each containing (n, k).\n\n    Returns:\n        list: A list of results for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        results.append(find_kth_special_number(n, k))\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        test_cases.append((n, k))\n        index += 2\n    \n    results = process_test_cases(test_cases)\n    \n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Priority queue to store special numbers\n        special_numbers = []\n        # Set to track visited numbers to avoid duplicates\n        visited = set()\n        \n        # Start with the smallest special number, which is always 1 (n^0)\n        heapq.heappush(special_numbers, 1)\n        visited.add(1)\n        \n        # Generate special numbers until we reach the k-th one\n        for _ in range(k):\n            current = heapq.heappop(special_numbers)\n            \n            # Generate new special numbers by adding powers of n\n            power = 1\n            while True:\n                new_special = current + power\n                if new_special not in visited:\n                    heapq.heappush(special_numbers, new_special)\n                    visited.add(new_special)\n                power *= n\n                if power > current:\n                    break\n        \n        # Append the k-th special number modulo 10^9+7\n        results.append(current % MODULO)\n    \n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Call the function and print results\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        results.append(generate_special_number(n, k))\n    return results\n\ndef generate_special_number(n: int, k: int) -> int:\n    \"\"\"Generate the k-th special number for a given base n.\n\n    Args:\n        n: The base number.\n        k: The position of the special number in the sequence.\n\n    Returns:\n        The k-th special number modulo 10^9+7.\n    \"\"\"\n    special_numbers = []\n    i = 0\n    while len(special_numbers) < k:\n        num = sum(n**j for j in range(i+1) if (i >> j) & 1)\n        special_numbers.append(num)\n        i += 1\n    special_numbers.sort()\n    return special_numbers[k-1] % MODULO\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing two integers n and k.\n\n    Returns:\n        A list of integers representing the k-th special number modulo 10^9+7 for each test case.\n    \"\"\"\n    results = []\n    for n, k in test_cases:\n        special_number = compute_kth_special_number(n, k)\n        results.append(special_number % MODULO)\n    return results\n\ndef compute_kth_special_number(n: int, k: int) -> int:\n    \"\"\"Compute the k-th special number for a given base n.\n\n    Args:\n        n: The base number.\n        k: The position of the special number to find.\n\n    Returns:\n        The k-th special number.\n    \"\"\"\n    special_number = 0\n    power = 0\n    while k > 0:\n        if k & 1:\n            special_number += n**power\n        k >>= 1\n        power += 1\n    return special_number\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport heapq\n\nMODULO = 10**9 + 7\n\ndef find_kth_special_number(t: int, test_cases: list[tuple[int, int]]) -> list[int]:\n    \"\"\"Find the k-th special number for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int]]): List of tuples where each tuple contains\n            two integers n and k.\n\n    Returns:\n        list[int]: List of k-th special numbers for each test case modulo 10^9+7.\n    \"\"\"\n    results = []\n    \n    for n, k in test_cases:\n        # Priority queue to store special numbers\n        min_heap = []\n        # Set to track visited numbers to avoid duplicates\n        visited = set()\n        \n        # Start with the smallest power of n, which is n^0 = 1\n        heapq.heappush(min_heap, 1)\n        visited.add(1)\n        \n        # Generate special numbers until we reach the k-th one\n        for _ in range(k):\n            current = heapq.heappop(min_heap)\n            \n            # Generate new special numbers by adding distinct powers of n\n            power = 1\n            while True:\n                new_special_number = current + power\n                if new_special_number not in visited:\n                    heapq.heappush(min_heap, new_special_number)\n                    visited.add(new_special_number)\n                power *= n\n                if power > current:\n                    break\n        \n        # Append the k-th special number modulo 10^9+7\n        results.append(current % MODULO)\n    \n    return results\n\n# Interface using input() and print()\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = find_kth_special_number(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of distinct non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are modulo 10^9+7.\nrequirement pool:\n- Efficiently generate special numbers for large n and k\n- Ensure results are computed modulo 10^9+7\n- Optimize for performance with large input sizes\n- Provide clear and correct output format\n- Handle edge cases and validate input constraints\nWe will use a combination of bit manipulation and mathematical properties to efficiently generate special numbers. The key is to recognize that each special number can be represented as a sum of distinct powers of n, which can be efficiently computed using binary representation. We will leverage Python's built-in capabilities for handling large integers and use modular arithmetic to ensure results are within the specified constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n.\n\n    'modulo 10^9+7'\n    Explanation: This is a common technique used to prevent overflow and ensure the result fits within standard integer limits. It requires taking the remainder of the division of the number by 10^9+7.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented using binary representation to select distinct powers.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The special numbers need to be sorted in ascending order. This means that when generating these numbers, they should be organized from smallest to largest.\n\n# [code logic]\n    - Parse the number of test cases.\n    - For each test case, read n and k.\n    - Generate special numbers using binary representation to select distinct powers of n.\n    - Sort the generated special numbers in increasing order.\n    - Retrieve the k-th special number and apply modulo 10^9+7.\n    - Output the result for each test case.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The smallest special number for any n is always 1 (n^0).\n\n    Input: 2 2\n    Expected Output: 2\n    Explanation: For n=2, the sequence starts as [1, 2, 3, ...]. The second special number is 2.\n\n    Input: 10^9 1\n    Expected Output: 1\n    Explanation: Even for very large n, the first special number is always 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by generating and sorting special numbers correctly.\n", "requirement analysis:\nThe problem requires generating special numbers that can be expressed as sums of distinct powers of n. The challenge lies in efficiently computing these numbers for large values of n and k, ensuring the results are sorted and returned modulo 10^9+7.\nrequirement pool:\n- Efficiently generate special numbers for given n.\n- Sort the special numbers in increasing order.\n- Handle large input values for n and k.\n- Optimize the algorithm for performance.\n- Ensure the solution is easy to understand and maintain.\nWe will use a combination of bit manipulation and mathematical properties to efficiently generate special numbers. The key insight is that each special number can be represented as a sum of distinct powers of n, which can be mapped to binary numbers where each bit represents whether a particular power of n is included in the sum. This allows us to generate special numbers by iterating over binary numbers and calculating the corresponding sum. We will use Python's built-in capabilities to handle large integers and apply modulo operation to ensure results fit within constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given number n.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0 or greater). In code, this can be implemented by iterating over binary numbers and using each bit to decide whether to include a particular power of n in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that the k-th special number is the k-th smallest number in this sorted sequence.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Generate special numbers using binary representation:\n        - Iterate over binary numbers up to a certain limit.\n        - For each binary number, calculate the sum of distinct powers of n where the corresponding bit is set.\n    3. Sort the generated special numbers.\n    4. Retrieve the k-th special number from the sorted list.\n    5. Apply modulo 10^9+7 to the result before outputting.\n\n# [edge case]\n    Edge cases are primarily related to the limits of n and k:\n    - For very large n, ensure that calculations do not exceed time limits.\n    - For very large k, ensure that the sequence generation is efficient enough to handle large indices.\n    \n    Example edge cases:\n    - Input: 2 1\n      Output: 1\n      Explanation: The first special number for n=2 is 2^0 = 1.\n      \n    - Input: 10^9 1\n      Output: 1\n      Explanation: The first special number for a very large n is still 1 (n^0).\n      \n    - Input: 2 10^9\n      Output: (calculated value modulo 10^9+7)\n      Explanation: Ensure efficient calculation for large k.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases related to large values of n and k efficiently.\n    \n```python\ndef find_kth_special_number(t, test_cases):\n    MOD = 10**9 + 7\n    results = []\n    \n    for n, k in test_cases:\n        special_numbers = []\n        limit = min(k, 100)  # Limit based on practical constraints\n        \n        for i in range(limit):\n            special_number = sum(n**j for j in range(i+1) if (i >> j) & 1)\n            special_numbers.append(special_number)\n        \n        special_numbers.sort()\n        results.append(special_numbers[k-1] % MOD)\n    \n    return results\n\n# Example usage:\nt = 3\ntest_cases = [(3, 4), (2, 12), (105, 564)]\nprint(find_kth_special_number(t, test_cases))\n```\n\n", "requirement analysis:\nThe requirement is to generate special numbers efficiently and sort them to find the k-th special number. The solution must handle large values of n and k, and output results modulo 10^9+7.\nrequirement pool:\n- Efficient generation of special numbers\n- Accurate sorting of special numbers\n- Optimization for large inputs\n- Handling multiple test cases\n- User-friendly input/output format\nWe will use a mathematical approach to generate special numbers by leveraging the properties of powers of n. The key is to recognize that each special number can be represented as a sum of distinct powers of n, which is similar to representing numbers in a base-n system. We will use a combination of bit manipulation and mathematical operations to efficiently generate the k-th special number. The solution will be optimized to handle large values of n and k by directly computing the k-th special number without generating all preceding numbers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th smallest special number when all special numbers are sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding together distinct powers of n, where each power is a non-negative integer (e.g., n^0, n^1, n^2, etc.).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The special numbers need to be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the integers n and k.\n2. Recognize that finding the k-th special number is akin to finding the k-th number in a base-n numeral system.\n3. Convert k-1 to its base-n representation, where each digit represents whether a particular power of n is included in the sum.\n4. Calculate the special number by summing the powers of n indicated by the base-n representation.\n5. Return the result modulo 10^9+7.\n\n# [edge case]\n    Test case: (n=2, k=1) = 1\n    Explanation: The first special number for any n is always 1, as it corresponds to n^0.\n\n    Test case: (n=10^9, k=1) = 1\n    Explanation: Even for very large n, the first special number remains 1.\n\n    Test case: (n=2, k=10^9) = (calculated value modulo 10^9+7)\n    Explanation: This tests the upper limit of k and ensures that the calculation handles large numbers efficiently.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of converting k-1 to base-n and summing the corresponding powers inherently handles all cases, including edge cases.\n", "requirement analysis:\nThe problem requires generating special numbers that can be expressed as sums of distinct powers of n. The challenge lies in efficiently computing these numbers for large values of n and k, ensuring the results are within the modulo constraint. The solution must handle up to 10,000 test cases, each with potentially large inputs, necessitating an optimized approach to avoid performance bottlenecks.\nrequirement pool:\n- Efficiently generate special numbers for given n and k.\n- Ensure results are computed modulo 10^9+7.\n- Handle up to 10,000 test cases efficiently.\n- Optimize for large values of n and k.\n- Provide clear and concise output for each test case.\nWe will use a combination of bit manipulation and mathematical properties to efficiently generate special numbers. The key insight is that each special number can be represented as a sum of distinct powers of n, which corresponds to binary representation where each bit represents whether a particular power of n is included in the sum. We will leverage this property to generate special numbers in increasing order and use modulo 10^9+7 for large numbers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th smallest special number when all special numbers are sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, such as n^0, n^1, n^2, etc., without repeating any power in the sum.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The special numbers need to be sorted from smallest to largest.\n\n# [code logic]\n1. For each test case, read the values of n and k.\n2. Use bit manipulation to generate special numbers:\n   - Iterate over possible combinations of powers of n using binary representation.\n   - For each combination, calculate the sum of distinct powers of n.\n3. Store these sums in a list and sort them.\n4. Retrieve the k-th smallest special number from the sorted list.\n5. Return the result modulo 10^9+7 to handle large numbers.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1 = 1\n    Explanation: The smallest special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1 = 1\n    Explanation: Even for a very large n, the smallest special number is always n^0 = 1.\n\n    Edge Case 3: n = 3, k = 5 = 10\n    Explanation: The sequence for n = 3 is [1, 3, 4, 9, 10...]. The fifth special number is 10.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of generating and sorting special numbers inherently handles these cases by considering all possible combinations of powers of n.\n", "requirement analysis:\nThe problem requires generating special numbers that can be expressed as sums of distinct powers of n. The challenge lies in efficiently computing these numbers for large values of n and k, ensuring the results are sorted and returned modulo 10^9+7. The solution must handle up to 10,000 test cases, each with potentially large input values.\nrequirement pool:\n- Efficiently generate special numbers for given n and k.\n- Ensure results are computed modulo 10^9+7.\n- Optimize for large input values of n and k.\n- Handle up to 10,000 test cases efficiently.\n- Provide clear and correct output format.\nWe will use a mathematical approach to generate special numbers by leveraging the properties of powers of n. The key is to recognize that each special number can be represented as a sum of distinct powers of n, which is similar to representing numbers in a base-n system. We will use a priority queue to efficiently generate and sort these numbers. The Python 'heapq' library will be used for this purpose, as it provides an efficient way to manage a priority queue. The challenge is to handle large values of n and k efficiently, so we will generate numbers incrementally and use modulo 10^9+7 to keep the numbers manageable.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th smallest special number when all special numbers are sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This means that a special number is formed by adding distinct powers of n, such as n^0, n^1, n^2, etc., without repeating any power.\n\n# [degree adverb]\n    'increasing order': This indicates that the special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. Initialize a priority queue (min-heap) to store potential special numbers.\n2. Start with the smallest power of n, which is n^0 = 1, and add it to the heap.\n3. Use a loop to extract the smallest element from the heap, which represents the next special number in increasing order.\n4. For each extracted number, generate new potential special numbers by adding the next power of n that hasn't been used yet.\n5. Continue this process until the k-th special number is extracted.\n6. Return the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n = 2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 2, k = 10^9\n    Expected Output: This case tests the efficiency of the algorithm for large k. The output should be calculated using the described logic and returned modulo 10^9+7.\n\n# [extra code for edge case]\n    We need extra code to handle large values of k efficiently. The use of a priority queue (min-heap) and modulo operation will help manage large numbers and ensure efficient computation.\n    \n```python\nimport heapq\n\ndef find_kth_special_number(t, test_cases):\n    MOD = 10**9 + 7\n    results = []\n    \n    for n, k in test_cases:\n        min_heap = []\n        heapq.heappush(min_heap, 1)\n        seen = set()\n        seen.add(1)\n        \n        current_special_number = None\n        \n        for _ in range(k):\n            current_special_number = heapq.heappop(min_heap)\n            \n            power = current_special_number\n            while power <= MOD:\n                new_special_number = current_special_number + power\n                if new_special_number not in seen:\n                    heapq.heappush(min_heap, new_special_number)\n                    seen.add(new_special_number)\n                power *= n\n        \n        results.append(current_special_number % MOD)\n    \n    return results\n\n# Example usage:\nt = 3\ntest_cases = [(3, 4), (2, 12), (105, 564)]\nprint(find_kth_special_number(t, test_cases))\n```\nThis code efficiently generates and finds the k-th special number for each test case using a priority queue and handles large values by using modulo operations.\n", "requirement analysis:\nThe problem requires generating special numbers that can be expressed as sums of distinct powers of n. The challenge lies in efficiently computing these numbers and sorting them to find the k-th special number. Given the constraints, the solution must handle large values of n and k, and output results modulo 10^9+7 to manage large numbers.\nrequirement pool:\n- Efficient algorithm to generate special numbers.\n- Correctly sort special numbers to find the k-th one.\n- Optimize for large inputs and outputs.\n- Ensure output is modulo 10^9+7.\n- Provide clear and concise output format.\nWe will use a combination of bit manipulation and mathematical properties to generate special numbers efficiently. The key observation is that each special number can be represented as a sum of distinct powers of n, which is analogous to representing numbers in a base-n system. We will generate numbers by iterating over all possible combinations of powers of n up to a certain limit, and use a priority queue to efficiently find the k-th smallest special number. The modulo operation will be applied to handle large numbers.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. This is similar to representing numbers in a base-n system.\n\n    'k-th special number'\n    Explanation: The k-th special number refers to the k-th smallest number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This indicates that each special number is formed by adding distinct powers of n, such as n^0, n^1, n^2, etc.\n    Implementation: Use bit manipulation to iterate over combinations of powers of n.\n\n# [degree adverb]\n    'increasing order': The sequence of special numbers should be sorted from smallest to largest.\n    Implementation: Use a priority queue or sorting mechanism to maintain the order.\n\n# [code logic]\n1. Initialize a priority queue to store special numbers.\n2. For each test case, iterate over possible combinations of powers of n using bit manipulation.\n3. Calculate the sum for each combination and add it to the priority queue.\n4. Extract the k-th smallest number from the priority queue.\n5. Apply modulo 10^9+7 to the result before outputting.\n\n# [edge case]\n    Input: 2 1\n    Expected Output: 1\n    Explanation: The smallest special number for n=2 is 2^0 = 1.\n\n    Input: 10^9 1\n    Expected Output: 1\n    Explanation: Even for large n, the smallest special number is always 1 (n^0).\n\n    Input: 3 1000000000\n    Expected Output: (calculated value modulo 10^9+7)\n    Explanation: This tests the upper limit for k, ensuring the algorithm handles large values efficiently.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently due to large values of n and k.\n```python\nimport heapq\n\nMOD = 10**9 + 7\n\ndef find_kth_special_number(n, k):\n    # Priority queue to store special numbers\n    pq = []\n    \n    # Generate special numbers using bit manipulation\n    for i in range(k):  # Limit iterations based on k\n        special_number = sum(n**j for j in range(i.bit_length()) if i & (1 << j))\n        heapq.heappush(pq, special_number)\n    \n    # Extract k-th smallest special number\n    for _ in range(k - 1):\n        heapq.heappop(pq)\n    \n    return heapq.heappop(pq) % MOD\n\ndef process_test_cases(test_cases):\n    results = []\n    for n, k in test_cases:\n        results.append(find_kth_special_number(n, k))\n    return results\n\n# Example usage:\ntest_cases = [(3, 4), (2, 12), (105, 564)]\nprint(process_test_cases(test_cases))\n```\nThis code efficiently handles large values by limiting iterations and using a priority queue to maintain order.\n", "requirement analysis:\nThe task requires generating special numbers that can be expressed as sums of distinct powers of n. The challenge lies in efficiently computing these numbers for large values of n and k, ensuring the results are sorted and returned modulo 10^9+7. The solution must handle up to 10,000 test cases, each with potentially large inputs.\nrequirement pool:\n- Efficiently compute special numbers for large n and k\n- Ensure output is modulo 10^9+7\n- Optimize for multiple test cases\n- Maintain correct order of special numbers\n- Provide clear and formatted output\nWe will use a combination of bit manipulation and mathematical properties to efficiently generate special numbers. The key idea is to represent each special number as a sum of distinct powers of n, which can be achieved using binary representation of numbers. We will use Python's built-in capabilities for handling large integers and leverage the modulo operation to ensure results fit within the required constraints. The algorithm will iterate over possible combinations of powers of n, using a priority queue to maintain the order of special numbers efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th smallest special number when all special numbers are sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This means that a special number is formed by adding together distinct powers of n, such as n^0, n^1, n^2, etc., without repeating any power.\n\n# [degree adverb]\n    'increasing order': This indicates that the special numbers should be sorted from smallest to largest.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read the values of n and k.\n3. Use bit manipulation to generate special numbers:\n   - Iterate over possible combinations of powers of n using binary representation.\n   - For each combination, calculate the sum of distinct powers of n.\n   - Store these sums in a priority queue to maintain order.\n4. Extract the k-th smallest special number from the priority queue.\n5. Apply modulo 10^9+7 to the result to ensure it fits within constraints.\n6. Output the result for each test case.\n\n# [edge case]\n    Test case with smallest values: (n=2, k=1) = 1\n    Explanation: The smallest special number for n=2 is 1 (2^0).\n\n    Test case with large n and small k: (n=10^9, k=1) = 1\n    Explanation: Even with a large n, the smallest special number is always 1 (n^0).\n\n    Test case with large k: (n=2, k=10^9) = <calculated value>\n    Explanation: This tests the efficiency and correctness of the algorithm for large k.\n\n# [extra code for edge case]\n    We need extra code to handle large values of k efficiently.\n    - Use a priority queue or a similar data structure to efficiently manage and retrieve the k-th smallest special number.\n    - Ensure that calculations are performed using modulo 10^9+7 to prevent overflow and adhere to constraints.\n", "requirement analysis:\nThe problem requires generating special numbers that can be expressed as sums of distinct powers of n. The challenge lies in efficiently computing these numbers for large values of n and k, ensuring the results are sorted and returned modulo 10^9+7. The solution must handle up to 10,000 test cases, each with potentially large inputs.\nrequirement pool:\n- Efficiently generate special numbers for given n and k.\n- Ensure results are sorted and returned modulo 10^9+7.\n- Optimize for large input values of n and k.\n- Handle up to 10,000 test cases efficiently.\n- Provide clear and concise output for each test case.\nWe will use a combination of bit manipulation and mathematical properties to efficiently generate special numbers. The key is to recognize that each special number can be represented as a sum of distinct powers of n, which can be efficiently generated using binary representation. We will use Python's built-in capabilities to handle large integers and leverage the modulo operation to ensure results fit within the constraints.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of distinct non-negative powers of a given base n.\n\n    'k-th special number'\n    Explanation: The task is to find the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that each special number is formed by adding distinct powers of n, where each power is non-negative (i.e., 0, 1, 2, ...).\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest.\n\n# [code logic]\n    1. For each test case, read the values of n and k.\n    2. Generate special numbers using combinations of powers of n.\n    3. Use binary representation to efficiently generate combinations of powers.\n    4. Sort the generated special numbers in increasing order.\n    5. Retrieve the k-th special number from the sorted list.\n    6. Apply modulo operation (10^9+7) to the result before outputting.\n\n# [edge case]\n    Edge Case 1: n = 2, k = 1\n    Expected Output: 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Edge Case 2: n = 10^9, k = 1\n    Expected Output: 1\n    Explanation: The first special number for any n is always 1 (n^0).\n\n    Edge Case 3: n = 3, k = 1000\n    Expected Output: (calculated value modulo 10^9+7)\n    Explanation: This tests the ability to handle large k values and ensure the result is correctly modulo'd.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases efficiently, especially for large values of n and k.\n        def generate_special_number(n, k):\n            special_numbers = []\n            i = 0\n            while len(special_numbers) < k:\n                num = sum(n**j for j in range(i+1) if (i >> j) & 1)\n                special_numbers.append(num)\n                i += 1\n            special_numbers.sort()\n            return special_numbers[k-1] % (10**9 + 7)\n\n        # Use this function within the main logic to handle each test case.\n", "requirement analysis:\nThe requirement is to find the k-th special number for given n, where a special number is defined as a sum of different non-negative powers of n. The solution must handle up to 10,000 test cases and large values of n and k efficiently, ensuring results are modulo 10^9+7.\nrequirement pool:\n- Efficiently generate special numbers for given n.\n- Sort special numbers to find the k-th smallest.\n- Ensure results are modulo 10^9+7.\n- Optimize for large values of n and k.\n- Handle up to 10,000 test cases efficiently.\nWe will use a mathematical approach to generate special numbers efficiently. The key is to represent each special number as a sum of distinct powers of n. We will use a combination of bit manipulation and mathematical properties to generate these numbers. Given the constraints, we will leverage Python's ability to handle large integers and use modulo operations to ensure results fit within the specified range. The approach will focus on generating numbers on-the-fly without storing large sequences, thus optimizing for memory usage.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of a given integer n. For example, for n = 4, the number 17 is special because it can be written as 4^0 + 4^2 = 1 + 16 = 17.\n\n    'k-th special number'\n    Explanation: This refers to the k-th number in the sequence of special numbers when sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers'\n    Explanation: This means that a special number is formed by adding distinct powers of n, where each power is a non-negative integer. In code, this can be implemented by iterating over possible powers of n and checking combinations.\n\n# [degree adverb]\n    'increasing order'\n    Explanation: The sequence of special numbers should be sorted from smallest to largest. This implies that when generating or selecting the k-th special number, the sequence must be ordered.\n\n# [code logic]\n1. Parse the input to get the number of test cases.\n2. For each test case, read n and k.\n3. Use bit manipulation to generate special numbers:\n   - Iterate over possible combinations of powers of n.\n   - For each combination, calculate the sum of distinct powers.\n   - Store these sums in a list.\n4. Sort the list of special numbers.\n5. Retrieve the k-th special number from the sorted list.\n6. Output the k-th special number modulo 10^9+7.\n\n# [edge case]\n    Test case 1: (n=2, k=1) = 1\n    Explanation: The first special number for n=2 is 2^0 = 1.\n\n    Test case 2: (n=2, k=2) = 2\n    Explanation: The second special number for n=2 is 2^1 = 2.\n\n    Test case 3: (n=3, k=1) = 1\n    Explanation: The first special number for n=3 is 3^0 = 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic for generating and sorting special numbers inherently handles these cases by considering all possible combinations of powers and sorting them.\n", "requirement analysis:\nThe problem requires generating special numbers that can be expressed as sums of distinct powers of n. The challenge lies in efficiently computing these numbers for large values of n and k, ensuring the results are sorted and returned modulo 10^9+7.\nrequirement pool:\n- Efficiently generate special numbers for given n and k\n- Ensure results are computed modulo 10^9+7\n- Optimize for large input values\n- Handle multiple test cases efficiently\n- Provide clear and concise output\nWe will use a mathematical approach to generate special numbers by leveraging the properties of powers of n. The key is to recognize that each special number can be represented as a sum of distinct powers of n, which is similar to representing numbers in a base-n system. We will use a priority queue to efficiently generate and sort these numbers. The Python 'heapq' library will be used for this purpose, as it provides an efficient way to manage a priority queue. The challenge is to handle large values of n and k efficiently, so we will generate only the necessary numbers and use modulo 10^9+7 to keep the numbers manageable.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'special number'\n    Explanation: A special number is defined as a positive integer that can be expressed as a sum of different non-negative powers of n. This is akin to representing numbers in a base-n system where each digit can be either 0 or 1.\n\n    'k-th special number'\n    Explanation: The task is to find the k-th special number when all special numbers are sorted in increasing order.\n\n# [phrase showing quantity relationship]\n    'sum of different non-negative powers of n': This indicates that each special number is formed by adding distinct powers of n, such as n^0, n^1, n^2, etc.\n\n# [degree adverb]\n    'increasing order': This means the special numbers need to be sorted from smallest to largest.\n\n# [code logic]\n    1. Initialize a priority queue using Python's 'heapq' to store special numbers.\n    2. Start with the smallest power of n, which is n^0 = 1.\n    3. Use a loop to generate special numbers by adding distinct powers of n.\n    4. For each test case, extract the k-th smallest number from the priority queue.\n    5. Apply modulo 10^9+7 to the result before outputting to handle large numbers.\n\n# [edge case]\n    Input: 2 1\n    Output: 1\n    Explanation: The smallest special number for any n is always 1 (n^0).\n\n    Input: 2 2\n    Output: 2\n    Explanation: For n=2, the sequence starts as [1, 2, 3, ...]. The second special number is 2.\n\n    Input: 105 1\n    Output: 1\n    Explanation: Regardless of the value of n, the first special number is always 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic inherently handles these cases by starting with the smallest power (n^0 = 1) and generating subsequent numbers based on distinct powers of n.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 825, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe first and only line of each test case contains two integers n and k (2 \u2264 n \u2264 10^9; 1 \u2264 k \u2264 10^9).\n\nOutput\n\nFor each test case, print one integer \u2014 the k-th special number in increasing order modulo 10^9+7.\n\nExample\n\nInput\n\n\n3\n3 4\n2 12\n105 564\n\n\nOutput\n\n\n9\n12\n3595374\n\nNote\n\nFor n = 3 the sequence is [1,3,4,9...]", "mutate_method": "add_1_sentence_at_end", "parent_index": 483}
