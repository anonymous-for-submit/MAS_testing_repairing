{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "repair_prompt": ["def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "```python\ndef get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, each row may contain a different number of columns. The data is organized in rows and columns, each row can have its own number of columns unlike regular matrices. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''\n```", "def get_row(lst, x):\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, each row may contain a different number of columns; you need to find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order, and also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all coordinates of the integer x in a nested list and returns them sorted.\n\n    This function iterates through each row of the nested list, checking for the presence\n    of the specified integer x. For each occurrence, it stores the coordinates as tuples.\n    After collecting all coordinates, it sorts them first by row in ascending order and\n    then by column in descending order.\n\n    Args:\n        lst: A nested list of integers representing a 2D matrix.\n        x: An integer to search for within the nested list.\n\n    Returns:\n        A list of tuples, where each tuple contains two integers representing the row and\n        column indices of occurrences of x in the list. The list is sorted by row index\n        in ascending order and by column index in descending order within each row.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row and column to find occurrences of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates first by row (ascending) and then by column (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n\n# Example usage:\n# result = get_row([[1, 2], [3, 4], [5, 6]], 2)\n# print(result)  # Output: [(0, 1)]\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate integer positions in a nested list.\n\n    Parameters:\n    lst (List[List[int]]): A list of lists containing integers.\n    x (int): The integer to locate.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates of the integer.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the nested list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If the element matches the given integer x, append its coordinate\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order\n    # For coordinates with the same row index, sort by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all instances of integer x in a nested list and return their coordinates sorted by row and column.\n    \n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row of the matrix.\n    x (int): The integer to locate within the nested list.\n    \n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of x, sorted by row and column.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row of the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row\n        for col_index, value in enumerate(row):\n            # Check if the current element is equal to x\n            if value == x:\n                # Record the coordinates (row index, column index) as a tuple\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of tuples first by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of tuples\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integer positions in nested lists.\n\n    Parameters:\n    lst (list[list[int]]): A list of lists where each sublist represents a row.\n    x (int): The integer to locate within the nested lists.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates (row, column) of the integer x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row and column in the nested list\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            # If the integer x is found, append its coordinates (row, column) to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate integer coordinates in a nested list structure.\n\n    Parameters:\n    lst (List[List[int]]): A 2D list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates of the integer.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_index, element in enumerate(row):\n            # Check if the element matches the given integer x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row index in ascending order,\n    # and by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"Locate the positions of integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists where each sublist represents a row of the matrix.\n        x: The integer to locate within the nested list.\n\n    Returns:\n        A list of tuples, each representing the (row, column) coordinates of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row of the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row\n        for col_index, value in enumerate(row):\n            # Check if the current element is the integer x\n            if value == x:\n                # Record the coordinates (row index, column index) as a tuple\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of tuples first by row index in ascending order,\n    # then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of tuples\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    This function takes a nested list 'lst' and an integer 'x'. It returns a list of tuples,\n    where each tuple contains the row and column indices of 'x' in 'lst'. The tuples are sorted\n    by row in ascending order and by column in descending order.\n\n    Parameters:\n    lst (list[list[int]]): A nested list representing the dataset.\n    x (int): The integer to find in the dataset.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples with the coordinates of 'x'.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Record the coordinate (row_index, col_index)\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates by row in ascending order and by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n\n# Example usage:\n# print(get_row([[1, 1], [1]], 1))  # Output: [(0, 1), (0, 0), (1, 0)]\n# print(get_row([[], [1], [1, 2, 3]], 3))  # Output: [(2, 2)]\n# print(get_row([], 1))  # Output: []\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"Finds the coordinates of a specified integer in a 2D list.\n\n    Args:\n        lst: A list of lists, where each sublist represents a row in a matrix-like structure.\n        x: The integer to find within the 2D list.\n\n    Returns:\n        A list of tuples, where each tuple contains two integers representing the row and column indices of 'x' in 'lst'.\n        The list is sorted by row in ascending order and by column in descending order within each row.\n    \"\"\"\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n\n# Example usage:\n# print(get_row([[1, 1], [1]], 1))  # Output: [(0, 1), (0, 0), (1, 0)]\n# print(get_row([[], [1], [1, 2, 3]], 3))  # Output: [(2, 2)]\n# print(get_row([], 1))  # Output: []\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate positions of integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists containing integers.\n        x: The integer to locate.\n\n    Returns:\n        A list of tuples representing the coordinates (row, column) of integer x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through the elements using an index to track the column number\n        for column_index, element in enumerate(row):\n            # If an element matches integer x, append a tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the coordinates list first by row index in ascending order, then by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Given a 2D list and an integer x, return a list of tuples representing the coordinates of x.\n    Each tuple is a coordinate (row, column), starting with 0.\n    The coordinates are sorted by rows in ascending order and columns in descending order.\n\n    Args:\n        lst: A 2D list of integers.\n        x: An integer to find within the 2D list.\n\n    Returns:\n        A list of tuples, where each tuple represents the coordinates (row, column) of the integer x.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the 2D list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row, column) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row in ascending order and column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n"], "plans": ["requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. The examples provided should clearly demonstrate the expected output format.\nrequirement pool:\n- Implement the main function to locate integer positions.\n- Ensure sorting by rows in ascending order and columns in descending order.\n- Provide clear examples to illustrate functionality.\n- Optimize for performance with large datasets.\n- Consider edge cases such as empty lists.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will store the coordinates as tuples. After collecting all coordinates, we will sort them first by row in ascending order and then by column in descending order. We will use Python's built-in list and sorting functionalities to achieve this, ensuring simplicity and efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, where each row can have a different number of columns. This is represented as nested lists in Python.\n\n    'coordinate'\n    Explanation: A coordinate in this context refers to a tuple (row, column) indicating the position of an integer within the 2D data structure.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting from smallest to largest\n    'descending order': means sorting from largest to smallest\n\n# [code logic]\n    - Iterate through each row of the nested list.\n    - For each row, iterate through each element to check if it matches the integer x.\n    - If a match is found, store the coordinates (row index, column index) as a tuple.\n    - After collecting all coordinates, sort the list of tuples first by row index in ascending order.\n    - Then, sort the tuples within each row by column index in descending order.\n    - Return the sorted list of tuples.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no coordinates to return.\n\n    get_row([[1]], 2) = []\n    Explanation: The integer 2 does not exist in the list, so there are no coordinates to return.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 does not exist in any row, so there are no coordinates to return.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles cases where the integer is not found or the list is empty.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as per the requirements.\nrequirement pool:\n- Implement the main function to locate integer positions.\n- Ensure sorting of output by row and column.\n- Handle varying row lengths efficiently.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using native Python lists to efficiently locate and return the positions of a specified integer within a nested list structure. The function will handle varying row lengths and sort the output as specified. We will use Python's built-in sorting capabilities to achieve the desired order without requiring additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship.\n\n# [degree adverb]\n    'ascending order': Sort rows by their index in increasing order.\n    'descending order': Sort columns within each row in decreasing order.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using its index.\n3. For each row, iterate over each element using its index.\n4. If the element matches the given integer x, append its coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row index in ascending order.\n6. For coordinates with the same row index, sort by column index in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty output list.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The number 3 is found at row index 2 and column index 2. Since there are no other occurrences, the output is a single coordinate.\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The number 1 is found at (0, 0), (0, 1), and (1, 0). The coordinates are sorted by row index first and then by column index in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and sorting the coordinates will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently locate all instances of a given integer within a nested list structure, returning their coordinates sorted by row and column as specified. It must handle varying row lengths and empty lists without errors.\nrequirement pool:\n- Implement the main function to find and sort coordinates.\n- Ensure the function handles empty lists and varying row lengths.\n- Optimize the function for performance with large datasets.\n- Include comprehensive test cases for edge scenarios.\n- Document the function usage and examples clearly.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will record the coordinates as a tuple. The function will then sort these tuples first by row in ascending order and then by column in descending order. We will use Python's built-in list and tuple data structures for simplicity and efficiency, as they are well-suited for this task and do not require additional setup.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, where each row can have a different number of columns. This is represented as nested lists in Python.\n\n    'coordinate'\n    Explanation: The task is to find the integer x in the list and return its position as a tuple of coordinates (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting from smallest to largest\n    'descending order': means sorting from largest to smallest\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row of the nested list using a loop.\n    3. For each row, iterate through its elements to find occurrences of the integer x.\n    4. Record the coordinates (row index, column index) as tuples and add them to the list.\n    5. Sort the list of tuples first by row index in ascending order, then by column index in descending order.\n    6. Return the sorted list of tuples.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no coordinates to return.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2).\n\n    get_row([[1, 1], [1, 1]], 1) = [(0, 1), (0, 0), (1, 1), (1, 0)]\n    Explanation: The integer 1 appears multiple times; coordinates are sorted by rows in ascending order and columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths naturally.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring that the output is sorted by row and column as specified. It must handle varying row lengths and empty lists gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of output by row and column as specified.\n- Handle edge cases such as empty lists and varying row lengths.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using Python's built-in list operations to efficiently locate and return the positions of a specified integer within a nested list structure. The function will handle varying row lengths and empty lists gracefully, ensuring the output is sorted by row in ascending order and by column in descending order. We will use list comprehensions and the sorted function to achieve this.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'nested lists'\n    Explanation: The requirement involves working with a 2D data structure where each row can have a different number of columns, similar to a matrix but with varying row lengths.\n\n    'coordinate'\n    Explanation: The output should be a list of tuples representing the position of the integer x in the form (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting the coordinates by rows from smallest to largest.\n    'descending order': means sorting the coordinates within each row by columns from largest to smallest.\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row and column in the nested list.\n    3. If the integer x is found, append its coordinates (row, column) to the list.\n    4. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n    5. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no coordinates to return.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found only in the third row at column index 2.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any row, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles empty lists and cases where the integer x is not found.\n", "requirement analysis:\nThe function should efficiently locate and sort the coordinates of a specified integer within a nested list structure, accommodating varying row lengths and ensuring correct sorting order.\nrequirement pool:\n- Implement the main function to locate integer coordinates.\n- Ensure sorting by rows in ascending order and columns in descending order.\n- Handle edge cases such as empty lists or rows.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using Python's built-in list operations to efficiently locate and sort the coordinates of a specified integer within a nested list structure. The function will handle varying row lengths and ensure correct sorting order by leveraging Python's sorting capabilities. We will use simple list comprehensions and sorting methods to achieve the desired functionality without the need for complex libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a nested list structure where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the nested list, given as (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships in the requirement.\n\n# [degree adverb]\n    'descending': Indicates that within each row, the column indices should be sorted from highest to lowest.\n    'ascending': Indicates that the row indices should be sorted from lowest to highest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using its index.\n3. For each row, iterate over each element using its index.\n4. If the element matches the given integer x, append its coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[1]], 2) = []\n    Explanation: The input list contains one element which is not equal to 2, so no coordinates are found.\n\n    get_row([[1, 2], [3, 4]], 5) = []\n    Explanation: The integer 5 does not exist in any of the rows, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for matches will naturally handle these cases by returning an empty list when no matches are found.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle varying row lengths and empty lists gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of output by rows and columns as specified.\n- Optimize performance for handling large datasets.\n- Include error handling for invalid inputs.\n- Provide documentation and examples for user understanding.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will record the coordinates as a tuple. The function will then sort these tuples first by row index in ascending order and then by column index in descending order. We will use Python's built-in list and tuple data structures for simplicity and efficiency, as they are well-suited for handling irregular matrices. The function will also handle empty lists gracefully by returning an empty list if no occurrences are found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, but with rows that can have varying numbers of columns. This is represented using nested lists in Python.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order', 'descending order'\n    Explanation: 'Ascending order' means sorting from smallest to largest, while 'descending order' means sorting from largest to smallest. In this requirement, row indices are sorted in ascending order, and column indices within each row are sorted in descending order.\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row of the nested list using a loop.\n    3. For each row, iterate through its elements to find occurrences of the integer x.\n    4. Record the coordinates (row index, column index) as tuples for each occurrence.\n    5. Sort the list of tuples first by row index in ascending order, then by column index in descending order.\n    6. Return the sorted list of tuples.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no occurrences of the integer x, resulting in an empty list.\n    \n    get_row([[1]], 2) = []\n    Explanation: The integer x is not present in the single-element list, so the function returns an empty list.\n    \n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer x is not present in any row of the list, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and non-occurrences naturally by returning an empty list when no coordinates are found.\n", "requirement analysis:\nThe function should efficiently locate all instances of a specified integer within a nested list structure, returning their coordinates sorted by row and column as specified. It must handle varying row lengths and empty datasets without errors.\nrequirement pool:\n- Efficiently find all instances of the integer in the dataset.\n- Return coordinates sorted by row in ascending order and column in descending order.\n- Handle empty datasets gracefully.\n- Optimize for performance with large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using native Python list operations to efficiently find all instances of the specified integer in the dataset. The function will handle varying row lengths and empty datasets gracefully. We will sort the results by row in ascending order and by column in descending order as specified. This approach leverages Python's built-in capabilities for simplicity and performance without the need for additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D data structure, which is represented as nested lists. Each sublist represents a row, similar to a matrix, but with varying numbers of columns.\n\n    'coordinate'\n    Explanation: A coordinate is a tuple representing the position of an element in the 2D data structure, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting from smallest to largest\n    'descending order': means sorting from largest to smallest\n\n# [code logic]\n    - Iterate through each row in the nested list.\n    - For each row, iterate through each element to find occurrences of the integer x.\n    - Record the coordinates (row index, column index) for each occurrence.\n    - Sort the list of coordinates first by row in ascending order, then by column in descending order.\n    - Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no coordinates to return.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2), so the expected output is a single tuple.\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The integer 1 appears at multiple positions. The coordinates are sorted by row in ascending order and by column in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths gracefully.\n", "requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a nested list structure. It must handle varying row lengths and sort the results by row and column as specified. The function should also manage edge cases such as empty lists.\nrequirement pool:\n- Implement the main function to find and return coordinates of integer x.\n- Ensure the function handles empty lists without errors.\n- Optimize the function for performance with large datasets.\n- Include comprehensive test cases to validate functionality.\n- Document the function with clear usage examples.\nWe will implement a simple function using Python's built-in capabilities to traverse the nested list structure. The function will iterate through each row and column, checking for the presence of the specified integer. It will then store the coordinates in a list of tuples, which will be sorted according to the specified criteria. This approach avoids the complexity of external libraries, making it lightweight and easy to understand.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D data, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship.\n\n# [degree adverb] \n    'ascending': Refers to sorting the row indices from smallest to largest.\n    'descending': Refers to sorting the column indices from largest to smallest within each row.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the 2D list using an index to track the row number.\n3. For each row, iterate through each element using an index to track the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found only at position (2, 2), so the output is a single coordinate.\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The integer 1 is found at multiple positions. The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and sorting the coordinates will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle edge cases such as empty lists and varying row lengths.\nrequirement pool:\n- Implement the main function to locate integer positions.\n- Ensure sorting of results by row and column.\n- Handle empty lists gracefully.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using native Python lists to efficiently locate integer positions within a nested list structure. The function will handle empty lists gracefully and sort the results as specified. Given the simplicity of the task, we will avoid using complex libraries like NumPy or Pandas, which are unnecessary for this requirement.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'nested lists'\n    Explanation: The requirement involves working with a 2-dimensional data structure where each row can have a different number of columns, similar to a matrix.\n\n    'coordinate'\n    Explanation: The output should be a list of tuples representing the position of integer x in the nested list, with each tuple indicating the row and column indices.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting the coordinates by rows from smallest to largest index.\n    'descending order': means sorting the coordinates within each row by columns from largest to smallest index.\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row in the nested list using an index to track the row number.\n    3. For each row, iterate through the elements using an index to track the column number.\n    4. If an element matches integer x, append a tuple (row_index, column_index) to the coordinates list.\n    5. Sort the coordinates list first by row index in ascending order, then by column index in descending order within each row.\n    6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input is an empty list, so there are no elements to find, resulting in an empty output list.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found at row index 2 and column index 2. Since there is only one occurrence, sorting does not change the order.\n\n    get_row([[1, 1], [1, 1]], 1) = [(0, 0), (0, 1), (1, 0), (1, 1)]\n    Explanation: The integer 1 appears in all positions of both rows. Sorting by rows in ascending order and columns in descending order results in this order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths naturally.\n", "requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a nested list structure. It must handle varying row lengths and sort the results as specified. Edge cases, such as empty lists, should be managed gracefully.\nrequirement pool:\n- Implement the main function to find and return coordinates of integer x.\n- Ensure the function handles empty lists without errors.\n- Optimize sorting of coordinates for performance.\n- Add error handling for non-integer inputs.\n- Include comprehensive test cases for various scenarios.\nWe will implement a function using pure Python lists to efficiently locate and return the coordinates of a specified integer within a nested list structure. The function will handle varying row lengths and sort the results as specified. Edge cases, such as empty lists, will be managed gracefully. We will not use any external libraries as the task is simple enough to be handled with native Python capabilities.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Sort rows in increasing order based on their index.\n    'descending order': Sort columns within each row in decreasing order based on their index.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using an index to track the row number.\n3. For each row, iterate over each element using an index to track the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (1, 0), (2, 1)]\n    Explanation: The integer 1 is found at (0, 0), (1, 0), and (2, 1). The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths gracefully.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 87, 87, 87, 87], "completion": "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Given a 2D list and an integer x, return a list of tuples representing the coordinates of x.\n    Each tuple is a coordinate (row, column), starting with 0.\n    The coordinates are sorted by rows in ascending order and columns in descending order.\n\n    Args:\n        lst: A 2D list of integers.\n        x: An integer to find within the 2D list.\n\n    Returns:\n        A list of tuples, where each tuple represents the coordinates (row, column) of the integer x.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the 2D list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row, column) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row in ascending order and column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "passed": true, "pass": true, "pass_num": 10, "round": 855, "mutate_method": "condense_two2one", "parent_index": 367}
