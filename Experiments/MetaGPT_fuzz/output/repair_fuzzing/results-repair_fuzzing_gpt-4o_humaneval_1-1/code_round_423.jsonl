{"task_id": "HumanEval/43", "prompt": "def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", "entry_point": "pairs_sum_to_zero", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "test": ["def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 11, -3, 6, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 7, -4, 1, 1, 11]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 11, 0, 3, 6, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 14, 0, 5, 2, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 2, 3, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 2, 9, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 14, 1, 8, 6, 36]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 9, 0, 8, 5, 9]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -6, 7, 1, 32]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, -2, 3]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 10, 0, 6, 5, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 1, -2, 2]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 2, -1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 4, -2, 5, 5, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 5, -3, 3]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 3, -4, 5]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 4, -5, 4, 1, 25]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 6, -4, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 5, 2, 4, 1, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 14, 0, 1, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 8, -5, 3, 7, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 9, -9, 2, 7, 11]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 7, -1, 2, 1, 28]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 6, -7, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 9, 2, 3, 4, 30]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 6, 1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 1, 3, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 5, 8, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 7, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, 10, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 13, -5, 7, 7, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 5, -10, 2, 10, 9]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 1, 8]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 7, 4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 9, -5, 4, 6, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 6, 2, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 2, 1, 11]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 2, 7, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 5, 2, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 14, -2, 8, 2, 35]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 5, 0]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 8, 4, 3, 7, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 12, 1, 9, 6, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 11, 1, 6, 6, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 11, -3, 8, 7, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 10, -4, 8, 6, 26]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 7, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, -4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 12, -4, 7, 1, 36]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 12, 1, 6, 7, 25]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 11, -3, 6, 2, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 13, -2, 7, 3, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -10, 5, 10, 9]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 1, 3, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 8, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 14, 2, 4, 6, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, 1, 12]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 5, -6, 8, 1, 33]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 7, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 14, -6, 5, 1, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 4, -1, 5, 10, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 13, -2, 4, 4, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 2, 6, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 4, -1, 5, 3, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 3, 1, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([7, 5, -1, 1, 8, 10]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 4, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 7, 3, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 12, -3, 2, 6, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 9, -3, 6, 7, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 7, -9, 5, 4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 6, 0, 6, 3, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 7, 8, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -1, 8, 8, 12]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 8, 1, 1, 6, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 14, 1, 8, 2, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 6, -5, 7, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 4, -7, 1, 2, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 11, -6, 5, 7, 36]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 14, 0, 5, 1, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 9, -1, 7, 4, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 3, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 10, 2, 9, 3, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 4, 1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, -2, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 10, -2, 2, 4, 33]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 9, -8, 6, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 7, -4, 4, 2, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 4, 10, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([7, 8, -10, 7, 2, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 8, 0, 4, 5, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 14, -4, 5, 6, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 12, 1, 8, 6, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 12, -6, 6, 7, 29]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, 1, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 8, -4, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 2, 1, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 4, 3, 6, 2, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 11, -4, 3, 5, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 9, 2, 1, 6, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 13, -4, 6, 3, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, 0, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 5, -2, 3, 1, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, -1, 8, 8, 4]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 2, 2, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, 1, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 6, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 14, 3, 6, 2, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 13, -2, 8, 7, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, 3, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 8, -1, 7, 6, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 12, 0, 1, 7, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 3, 6, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 6, -8, 1, 2, 8]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 8, -3, 9, 5, 29]) == False"], "test_case_list": ["assert pairs_sum_to_zero([1, 11, -3, 6, 7, 30]) == False", "assert pairs_sum_to_zero([3, 7, -4, 1, 1, 11]) == False", "assert pairs_sum_to_zero([-8, 11, 0, 3, 6, 26]) == False", "assert pairs_sum_to_zero([1, 14, 0, 5, 2, 34]) == False", "assert pairs_sum_to_zero([1, 2, 3, 7]) == False", "assert pairs_sum_to_zero([4, 2, 9, 3]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]) == False", "assert pairs_sum_to_zero([3]) == False", "assert pairs_sum_to_zero([-1, 14, 1, 8, 6, 36]) == True", "assert pairs_sum_to_zero([3, 9, 0, 8, 5, 9]) == False", "assert pairs_sum_to_zero([1, 4, -6, 7, 1, 32]) == False", "assert pairs_sum_to_zero([2, 8, -2, 3]) == True", "assert pairs_sum_to_zero([-2, 10, 0, 6, 5, 30]) == False", "assert pairs_sum_to_zero([3, 1, -2, 2]) == True", "assert pairs_sum_to_zero([3, 2, -1, 2]) == False", "assert pairs_sum_to_zero([-1, 4, -2, 5, 5, 27]) == False", "assert pairs_sum_to_zero([1]) == False", "assert pairs_sum_to_zero([6, 5, -3, 3]) == True", "assert pairs_sum_to_zero([4, 3, -4, 5]) == True", "assert pairs_sum_to_zero([-2, 4, -5, 4, 1, 25]) == False", "assert pairs_sum_to_zero([2, 6, -4, 5]) == False", "assert pairs_sum_to_zero([-7, 5, 2, 4, 1, 26]) == False", "assert pairs_sum_to_zero([-8, 14, 0, 1, 7, 30]) == False", "assert pairs_sum_to_zero([1, 8, -5, 3, 7, 35]) == False", "assert pairs_sum_to_zero([6, 9, -9, 2, 7, 11]) == True", "assert pairs_sum_to_zero([-8, 7, -1, 2, 1, 28]) == True", "assert pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]) == True", "assert pairs_sum_to_zero([6, 6, -7, 6]) == False", "assert pairs_sum_to_zero([-4, 9, 2, 3, 4, 30]) == True", "assert pairs_sum_to_zero([1, 6, 1, 2]) == False", "assert pairs_sum_to_zero([5, 1, 3, 5]) == False", "assert pairs_sum_to_zero([4, 5, 8, 3]) == False", "assert pairs_sum_to_zero([6, 7, 2, 5]) == False", "assert pairs_sum_to_zero([2, 8, 10, 3]) == False", "assert pairs_sum_to_zero([1, 13, -5, 7, 7, 27]) == False", "assert pairs_sum_to_zero([4, 5, -10, 2, 10, 9]) == True", "assert pairs_sum_to_zero([2, 3, 1, 8]) == False", "assert pairs_sum_to_zero([1, 7, 4, 6]) == False", "assert pairs_sum_to_zero([2, 9, -5, 4, 6, 30]) == False", "assert pairs_sum_to_zero([4, 6, 2, 4]) == False", "assert pairs_sum_to_zero([5, 2, 1, 11]) == False", "assert pairs_sum_to_zero([5, 2, 7, 3]) == False", "assert pairs_sum_to_zero([5, 5, 2, 2]) == False", "assert pairs_sum_to_zero([-8, 14, -2, 8, 2, 35]) == True", "assert pairs_sum_to_zero([1, 3, 5, 0]) == False", "assert pairs_sum_to_zero([-1, 8, 4, 3, 7, 29]) == False", "assert pairs_sum_to_zero([2, 12, 1, 9, 6, 33]) == False", "assert pairs_sum_to_zero([-4, 11, 1, 6, 6, 28]) == False", "assert pairs_sum_to_zero([0, 11, -3, 8, 7, 26]) == False", "assert pairs_sum_to_zero([-8, 10, -4, 8, 6, 26]) == True", "assert pairs_sum_to_zero([2]) == False", "assert pairs_sum_to_zero([2, 3, 7, 1]) == False", "assert pairs_sum_to_zero([6, 1, -4, 6]) == False", "assert pairs_sum_to_zero([-2, 12, -4, 7, 1, 36]) == False", "assert pairs_sum_to_zero([2, 12, 1, 6, 7, 25]) == False", "assert pairs_sum_to_zero([-4, 11, -3, 6, 2, 27]) == False", "assert pairs_sum_to_zero([0, 13, -2, 7, 3, 31]) == False", "assert pairs_sum_to_zero([1, 4, -10, 5, 10, 9]) == True", "assert pairs_sum_to_zero([4, 1, 3, 7]) == False", "assert pairs_sum_to_zero([6, 8, 2, 5]) == False", "assert pairs_sum_to_zero([-7, 14, 2, 4, 6, 30]) == False", "assert pairs_sum_to_zero([1, 5, 1, 12]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]) == True", "assert pairs_sum_to_zero([-1, 5, -6, 8, 1, 33]) == True", "assert pairs_sum_to_zero([2, 3, 7, 4]) == False", "assert pairs_sum_to_zero([0, 14, -6, 5, 1, 35]) == False", "assert pairs_sum_to_zero([5, 4, -1, 5, 10, 6]) == False", "assert pairs_sum_to_zero([0, 13, -2, 4, 4, 28]) == False", "assert pairs_sum_to_zero([2, 2, 6, 4]) == False", "assert pairs_sum_to_zero([0, 4, -1, 5, 3, 33]) == False", "assert pairs_sum_to_zero([3, 3, 1, 4]) == False", "assert pairs_sum_to_zero([7, 5, -1, 1, 8, 10]) == True", "assert pairs_sum_to_zero([1, 3, 4, 3]) == False", "assert pairs_sum_to_zero([5, 7, 3, 4]) == False", "assert pairs_sum_to_zero([-7, 12, -3, 2, 6, 29]) == False", "assert pairs_sum_to_zero([-4, 9, -3, 6, 7, 31]) == False", "assert pairs_sum_to_zero([4, 7, -9, 5, 4, 6]) == False", "assert pairs_sum_to_zero([-4, 6, 0, 6, 3, 26]) == False", "assert pairs_sum_to_zero([4]) == False", "assert pairs_sum_to_zero([2, 7, 8, 5]) == False", "assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True", "assert pairs_sum_to_zero([1, 4, -1, 8, 8, 12]) == True", "assert pairs_sum_to_zero([-3, 8, 1, 1, 6, 31]) == False", "assert pairs_sum_to_zero([-6, 14, 1, 8, 2, 28]) == False", "assert pairs_sum_to_zero([-3, 6, -5, 7, 7, 30]) == False", "assert pairs_sum_to_zero([3, 4, -7, 1, 2, 3]) == False", "assert pairs_sum_to_zero([-8, 11, -6, 5, 7, 36]) == False", "assert pairs_sum_to_zero([-7, 14, 0, 5, 1, 28]) == False", "assert pairs_sum_to_zero([-5, 9, -1, 7, 4, 34]) == False", "assert pairs_sum_to_zero([1, 3, 3, 5]) == False", "assert pairs_sum_to_zero([-5, 10, 2, 9, 3, 33]) == False", "assert pairs_sum_to_zero([2, 4, 1, 2]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]) == False", "assert pairs_sum_to_zero([1, 3, -2, 1]) == False", "assert pairs_sum_to_zero([2, 10, -2, 2, 4, 33]) == True", "assert pairs_sum_to_zero([3, 9, -8, 6, 2, 5]) == False", "assert pairs_sum_to_zero([-6, 7, -4, 4, 2, 32]) == True", "assert pairs_sum_to_zero([3, 4, 10, 1]) == False", "assert pairs_sum_to_zero([7, 8, -10, 7, 2, 4]) == False", "assert pairs_sum_to_zero([-6, 8, 0, 4, 5, 27]) == False", "assert pairs_sum_to_zero([-6, 14, -4, 5, 6, 32]) == True", "assert pairs_sum_to_zero([-5, 12, 1, 8, 6, 31]) == False", "assert pairs_sum_to_zero([-3, 12, -6, 6, 7, 29]) == True", "assert pairs_sum_to_zero([1, 5, 1, 3]) == False", "assert pairs_sum_to_zero([5, 8, -4, 5]) == False", "assert pairs_sum_to_zero([3, 2, 1, 6]) == False", "assert pairs_sum_to_zero([-5, 4, 3, 6, 2, 27]) == False", "assert pairs_sum_to_zero([-1, 11, -4, 3, 5, 28]) == False", "assert pairs_sum_to_zero([-7, 9, 2, 1, 6, 34]) == False", "assert pairs_sum_to_zero([-1, 13, -4, 6, 3, 28]) == False", "assert pairs_sum_to_zero([6, 1, 0, 3]) == False", "assert pairs_sum_to_zero([-5, 5, -2, 3, 1, 32]) == True", "assert pairs_sum_to_zero([1, 5, -1, 8, 8, 4]) == True", "assert pairs_sum_to_zero([1, 2, 2, 2]) == False", "assert pairs_sum_to_zero([6]) == False", "assert pairs_sum_to_zero([2, 8, 1, 4]) == False", "assert pairs_sum_to_zero([2, 6, 2, 5]) == False", "assert pairs_sum_to_zero([2, 14, 3, 6, 2, 29]) == False", "assert pairs_sum_to_zero([-5, 13, -2, 8, 7, 35]) == False", "assert pairs_sum_to_zero([6, 1, 3, 2]) == False", "assert pairs_sum_to_zero([5]) == False", "assert pairs_sum_to_zero([-4, 8, -1, 7, 6, 26]) == False", "assert pairs_sum_to_zero([-4, 12, 0, 1, 7, 28]) == False", "assert pairs_sum_to_zero([5, 3, 6, 7]) == False", "assert pairs_sum_to_zero([4, 6, -8, 1, 2, 8]) == True", "assert pairs_sum_to_zero([-4, 8, -3, 9, 5, 29]) == False"], "nl": "\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    ", "func": "def pairs_sum_to_zero(l):", "examples": ">>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    ", "repair_prompt": ["def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", "def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input. It will then return True if there are two distinct elements in the list that sum to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", "def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input and returns True if there are two distinct elements in the list that sum to zero, otherwise it returns False.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if there are two distinct elements that sum to zero, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of the numbers we have seen\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negation of the current number is already in the set\n        if -number in seen_numbers:\n            # If found, return True as we have found two distinct elements that sum to zero\n            return True\n        # If not found, add the current number to the set\n        seen_numbers.add(number)\n\n    # If the loop completes without finding such a pair, return False\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"Checks if there are two distinct elements in the list that sum to zero.\n\n    This function takes a list of integers as input and returns True if there\n    are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Args:\n        l (list[int]): A list of integers.\n\n    Returns:\n        bool: True if there are two distinct elements that sum to zero, False otherwise.\n    \"\"\"\n    seen_numbers = set()\n\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n\n    return False\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test cases\n    print(pairs_sum_to_zero([0, 0]))  # Expected output: True\n    print(pairs_sum_to_zero([-1, 1]))  # Expected output: True\n    print(pairs_sum_to_zero([1]))  # Expected output: False\n    print(pairs_sum_to_zero([2, -3, 4, -2]))  # Expected output: True\n    print(pairs_sum_to_zero([5, 7, 9]))  # Expected output: False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"Check if there are two distinct elements in the list that sum to zero.\n\n    Args:\n        l (list[int]): A list of integers.\n\n    Returns:\n        bool: True if there are two distinct elements that sum to zero, False otherwise.\n\n    Examples:\n        pairs_sum_to_zero([0, 0]) -> True\n        pairs_sum_to_zero([1]) -> False\n        pairs_sum_to_zero([-1, 1]) -> True\n    \"\"\"\n    seen_numbers = set()\n\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n\n    return False\n\n# Example usage:\nif __name__ == \"__main__\":\n    print(pairs_sum_to_zero([0, 0]))  # Expected output: True\n    print(pairs_sum_to_zero([1]))     # Expected output: False\n    print(pairs_sum_to_zero([-1, 1])) # Expected output: True\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers as input and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Args:\n        l (list[int]): List of integers.\n\n    Returns:\n        bool: Boolean indicating if any two numbers sum to zero.\n    \"\"\"\n    # Initialize an empty set to keep track of numbers seen so far.\n    seen_numbers = set()\n\n    # Iterate through each number in the list.\n    for number in l:\n        # Check if the negation of the current number is present in the set.\n        if -number in seen_numbers:\n            # If found, return True as a pair summing to zero exists.\n            return True\n        # If not found, add the current number to the set.\n        seen_numbers.add(number)\n\n    # If no such pair is found after iterating through the list, return False.\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input. It returns True if there are two distinct elements\n    in the list that sum to zero, and False otherwise.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if there are two distinct elements that sum to zero, False otherwise.\n\n    Examples:\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    \"\"\"\n    # Initialize an empty set to keep track of numbers we have seen\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            return True\n        # Add the current number to the set\n        seen_numbers.add(number)\n\n    # If no pairs are found after checking all numbers, return False\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"Checks if there are two distinct elements in the list that sum to zero.\n\n    This function uses a set to track numbers that have been seen. For each\n    number in the list, it checks if the negative of that number has already\n    been seen. If so, it returns True, indicating a pair that sums to zero\n    exists. If the loop completes without finding such a pair, it returns False.\n\n    Args:\n        l: A list of integers.\n\n    Returns:\n        A boolean indicating if a zero-sum pair exists.\n    \"\"\"\n    seen_numbers = set()\n    \n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n    \n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input and returns True if there are two distinct elements in the list that sum to zero, otherwise it returns False.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if there are two distinct elements that sum to zero, False otherwise.\n\n    Example:\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    \"\"\"\n    # Initialize an empty set to keep track of numbers seen so far\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            # If found, return True as a pair summing to zero exists\n            return True\n        # If not found, add the current number to the set\n        seen_numbers.add(number)\n\n    # If the loop completes without finding such a pair, return False\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers and returns True if there are two distinct elements that sum to zero, otherwise returns False.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if there are two distinct elements that sum to zero, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of elements seen so far\n    seen_elements = set()\n\n    # Iterate through each element in the list\n    for element in l:\n        # Check if the negative counterpart of the current element is already in the set\n        if -element in seen_elements:\n            # If found, return True as a pair exists that sums to zero\n            return True\n        # If not found, add the current element to the set\n        seen_elements.add(element)\n\n    # After iterating through all elements, if no pair is found, return False\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers and returns True if there are two distinct elements that sum to zero, otherwise returns False.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if a pair sums to zero, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of numbers we have seen\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            # If found, return True as a pair summing to zero exists\n            return True\n        # Add the current number to the set\n        seen_numbers.add(number)\n\n    # If the loop completes without finding such a pair, return False\n    return False\n\n# Example usage:\n# print(pairs_sum_to_zero([0, 0]))  # Expected output: True\n# print(pairs_sum_to_zero([-1, 1]))  # Expected output: True\n# print(pairs_sum_to_zero([1]))      # Expected output: False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if there are two distinct elements that sum to zero, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of numbers seen so far\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            # If found, return True as a pair summing to zero exists\n            return True\n        # If not found, add the current number to the set\n        seen_numbers.add(number)\n\n    # After iterating through the list, if no pair is found, return False\n    return False\n"], "plans": ["requirement analysis:\nThe function should efficiently check for pairs of numbers that sum to zero, handle edge cases, and be easy to integrate into larger systems. It should be well-documented and optimized for performance.\nrequirement pool:\n- Implement the main function logic to find pairs summing to zero.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles edge cases like empty or single-element lists.\n- Provide comprehensive documentation and examples.\n- Create unit tests to verify function correctness.\nWe will implement a function that efficiently checks for pairs of numbers that sum to zero using a set for fast look-up operations. This approach will ensure the function is optimized for performance, especially with large datasets. The function will handle edge cases such as empty lists or lists with a single element by returning False immediately.\nPlease read and understand the following inteperation before coding\n## Answer 3:\n\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements that sum to zero must be different from each other.\n\n# [phrase showing quantity relationship]\n    'sum to zero': means that the sum of two distinct elements should be equal to zero.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of the numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negation (i.e., -number) is already in the set.\n    4. If the negation is found, return True as we have found two distinct elements that sum to zero.\n    5. If not found, add the current number to the set.\n    6. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: Although both elements are zero, they are distinct elements, and their sum is zero.\n    \n    pairs_sum_to_zero([]) = False\n    Explanation: The list is empty, so there are no elements to form a pair.\n\n    pairs_sum_to_zero([1]) = False\n    Explanation: The list contains only one element, so it's impossible to form a pair.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles cases like empty lists or lists with a single element by returning False immediately.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets, and clear documentation will aid in user understanding and integration.\nrequirement pool:\n- Implement the main function logic to find pairs summing to zero\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation and examples\n- Ensure compatibility with various Python versions\n- Include error handling for invalid inputs\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. To optimize performance, we will use a set to track the numbers we have seen so far, which allows for O(1) average time complexity for lookups. This approach will handle large lists efficiently. We will also include comprehensive documentation and examples to ensure ease of understanding and integration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements that sum to zero must be different from each other, i.e., they cannot be the same element.\n\n# [phrase showing quantity relationship]\n    'sum to zero': means that the sum of two distinct elements should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Initialize an empty set to keep track of numbers seen so far.\n    - Iterate through each number in the list.\n    - For each number, check if its negative is already in the set.\n    - If found, return True as a pair exists that sums to zero.\n    - If not found, add the number to the set.\n    - After iterating through the list, if no such pair is found, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: The two distinct elements 0 and 0 sum to zero.\n    \n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 are distinct and sum to zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one element, so no pair can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track seen numbers and checking for their negatives will handle these cases correctly.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring accuracy and performance. Documentation should be clear to facilitate user understanding and integration.\nrequirement pool:\n- Implement the main algorithm to find pairs summing to zero\n- Optimize the algorithm for performance with large lists\n- Provide comprehensive documentation\n- Include examples and edge cases in documentation\n- Ensure compatibility with different Python versions\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. The approach will use a set to track the numbers we have seen so far, which allows for O(1) average time complexity for lookups. This will optimize performance for large input lists. We will also provide comprehensive documentation with examples and edge cases to ensure clarity and ease of integration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different from each other, i.e., they cannot be the same element.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of the two distinct elements should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If the negative is found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If no such pair is found by the end of the list, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: The list contains two zeros, which are distinct elements and sum to zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: A single element cannot form a pair, so it cannot sum to zero with another distinct element.\n    \n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The list contains -1 and 1, which are distinct elements and sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track seen numbers and checking for their negatives inherently handles these cases.\n", "requirement analysis:\nThe function should efficiently check for pairs of numbers that sum to zero, handle edge cases, and be easy to integrate into larger systems. It should be optimized for performance and provide clear documentation.\nrequirement pool:\n- Implement the main function to check for pairs summing to zero.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles edge cases like empty or single-element lists.\n- Provide comprehensive documentation and examples.\n- Create unit tests to verify the function's correctness.\nWe will implement a function that iterates through the list of integers and uses a set to track the numbers we have seen so far. For each number, we will check if its negation is already in the set, which would indicate that a pair summing to zero exists. This approach is efficient with a time complexity of O(n) and is suitable for large datasets. We will use Python's built-in data structures to keep the implementation simple and easy to integrate.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different from each other in terms of their position in the list.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of two distinct elements in the list should equal zero. In code, this can be implemented by checking if the negation of a number exists in a set of previously seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers seen so far.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negation is present in the set.\n    4. If the negation is found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If no such pair is found after iterating through the list, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: The two zeros are distinct elements and their sum is zero.\n    \n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 are distinct and their sum is zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one element, so no pair can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track seen numbers and checking for negations inherently handles these cases.\n", "requirement analysis:\nThe function should efficiently determine if any two distinct integers in a list sum to zero. It must handle edge cases such as empty lists or lists with a single element. The implementation should be straightforward for easy integration.\nrequirement pool:\n- Implement the main function logic\n- Optimize for large input lists\n- Document the function with examples\n- Handle edge cases like empty or single-element lists\n- Write unit tests for various scenarios\nWe will implement a function that efficiently checks for pairs of integers that sum to zero using a set for quick lookup. This approach ensures the function handles large lists efficiently by leveraging the average O(1) time complexity for set operations. We will also document the function with examples and handle edge cases such as empty lists or lists with a single element.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements that sum to zero must be different from each other.\n\n# [phrase showing quantity relationship]\n    'sum to zero': means that the sum of two distinct elements should be equal to zero. In code, this can be implemented by checking if the negative of a number exists in the list.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If the negative is found, return True.\n    5. If not found, add the number to the set.\n    6. If no pairs are found after checking all numbers, return False.\n\n# [edge case] \n    pairs_sum_to_zero([]) = False\n    Explanation: The list is empty, so there are no elements to form pairs.\n    \n    pairs_sum_to_zero([0]) = False\n    Explanation: The list contains only one element, so it's impossible to form a pair.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains two distinct elements that sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles cases like empty lists or lists with a single element by returning False when no pairs are found.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets.\nrequirement pool:\n- Implement the main function logic to find zero-sum pairs\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation and examples\n- Ensure compatibility with various Python versions\n- Include error handling for invalid inputs\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. The function will utilize a set to track seen numbers, allowing for O(n) time complexity, which is optimal for large lists. This approach ensures that we can quickly determine if the negative of a current number has been seen before, indicating a zero-sum pair.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different elements in the list, not the same element used twice.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative counterpart is already in the set.\n    4. If it is, return True because a pair that sums to zero has been found.\n    5. If not, add the current number to the set.\n    6. If the loop completes without finding a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: The two zeros are distinct elements and their sum is zero.\n    \n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The numbers -1 and 1 are distinct and their sum is zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one element, so no pair can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track seen numbers and checking for their negative counterparts will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets.\nrequirement pool:\n- Implement the main function logic to identify pairs summing to zero\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation for user understanding\n- Ensure compatibility with various Python versions\n- Include unit tests to verify functionality\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. To optimize performance for large lists, we will use a set to track seen numbers, allowing for O(n) complexity. This approach ensures that the function handles edge cases such as empty lists or lists with a single element. Comprehensive documentation will be provided to facilitate user understanding.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different from each other in terms of their indices in the list.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of the two distinct elements should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers seen so far.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([]) = False\n    Explanation: An empty list has no elements, so no pairs can exist.\n    \n    pairs_sum_to_zero([0]) = False\n    Explanation: A single element cannot form a pair with itself, so no pairs can sum to zero.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains a pair (1, -1) that sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using a set to track seen numbers and checking for their negatives inherently handles these cases.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets.\nrequirement pool:\n- Implement the main function logic to find zero-sum pairs\n- Optimize the function for performance with large lists\n- Include comprehensive test cases and examples\n- Document the function usage and edge cases\n- Ensure compatibility with different Python versions\nWe will implement a function that efficiently checks for pairs of integers that sum to zero using a set for quick lookup. This approach ensures optimal performance even for large lists. We will use Python's built-in data structures and libraries to maintain simplicity and compatibility across different Python versions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements that sum to zero must be different from each other, i.e., they cannot be the same element.\n\n# [phrase showing quantity relationship]\n    'sum to zero': means that the sum of two distinct elements should equal zero. In code, this can be implemented by checking if the negative of an element exists in the list.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of elements seen so far.\n    2. Iterate through each element in the list.\n    3. For each element, check if its negative counterpart is already in the set.\n    4. If found, return True as a pair exists that sums to zero.\n    5. If not found, add the current element to the set.\n    6. After iterating through all elements, if no pair is found, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: The two distinct elements 0 and 0 sum to zero.\n    \n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 are distinct and sum to zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one element, so no pair can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track seen elements and checking for their negative counterparts will handle these cases correctly.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases like empty lists or lists with a single element. Performance optimization is crucial for handling large datasets, and clear documentation with examples will aid user understanding.\nrequirement pool:\n- Implement the main function logic to find pairs summing to zero\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation and examples\n- Ensure compatibility with various Python versions\n- Include error handling for invalid inputs\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. To optimize performance, we will use a set to track the numbers we have seen, allowing for O(1) average time complexity for lookups. This approach will handle large lists efficiently. Comprehensive documentation and examples will be provided to ensure usability and understanding.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different from each other in terms of their indices in the list.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of two distinct elements in the list should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: The two zeros are distinct elements and their sum is zero.\n    \n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 are distinct and their sum is zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one element, so no pair can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track seen numbers and checking for their negatives will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check for pairs of numbers that sum to zero, handle edge cases, and be easy to integrate into larger systems. It should be optimized for performance and provide clear documentation.\nrequirement pool:\n- Implement the main function logic to find pairs summing to zero.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles edge cases like empty or single-element lists.\n- Provide comprehensive documentation and examples.\n- Create unit tests to verify function correctness.\nWe will implement a function that uses a set to track the numbers we have seen so far. This allows us to efficiently check if the negative of the current number exists in the set, which would mean a pair summing to zero has been found. This approach is efficient with a time complexity of O(n) and handles large datasets well. We will also handle edge cases such as empty lists or lists with a single element by returning False immediately.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements that sum to zero must be different from each other.\n\n# [phrase showing quantity relationship]\n    'sum to zero': means that the sum of two distinct elements should be equal to zero. In code, this can be implemented by checking if the negative of a current element exists in a set of previously seen elements.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers seen so far.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. After iterating through the list, if no pair is found, return False.\n\n# [edge case] \n    pairs_sum_to_zero([]) = False\n    Explanation: The list is empty, so there are no elements to form a pair.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: The list contains only one element, so it's impossible to form a pair.\n\n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: Although both elements are zero, they are distinct and their sum is zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles cases like empty lists or lists with a single element by returning False immediately.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [126, 126, 126, 126, 126, 126, 126, 126, 126, 126], "completion": "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if there are two distinct elements that sum to zero, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of numbers seen so far\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            # If found, return True as a pair summing to zero exists\n            return True\n        # If not found, add the current number to the set\n        seen_numbers.add(number)\n\n    # After iterating through the list, if no pair is found, return False\n    return False\n", "passed": true, "pass": true, "pass_num": 10, "round": 423, "mutate_method": "condense_two2one", "parent_index": 210}
