{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. Ensure the solution handles edge cases where x is not present in any row or the list is empty.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "repair_prompt": ["def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. Ensure the solution handles edge cases where x is not present in any row or the list is empty.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists. It is similar to a matrix. However, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. Ensure the solution handles edge cases where x is not present in any row or the list is empty.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, each row may contain a different number of columns and unlike matrices. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. Ensure the solution handles edge cases where x is not present in any row or the list is empty.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a 2D list and an integer x, return a list of tuples representing the coordinates of x.\n    Each tuple is (row, column), sorted by row in ascending order and column in descending order.\n\n    Args:\n        lst: A 2D list of integers.\n        x: An integer to find in the 2D list.\n\n    Returns:\n        A list of tuples where each tuple is a coordinate (row_index, column_index) of x in the 2D list.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the 2D list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order\n    # For coordinates with the same row index, sort by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds all occurrences of integer x in a nested list and returns a list of tuples representing the coordinates.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist can have a different number of columns.\n    x (int): The integer to find in the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples where each tuple is a coordinate (row, column) of the integer x.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row, column) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row in ascending order and column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate integer positions in nested lists and return their coordinates.\n\n    Args:\n        lst: A list of lists containing integers, representing a 2D dataset.\n        x: An integer to locate within the dataset.\n\n    Returns:\n        A list of tuples, where each tuple contains the row and column indices\n        of the integer x, sorted by rows in ascending order and columns in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the 2D list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using its index\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row index, column index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order\n    # For coordinates with the same row index, sort them by column index in descending order\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return sorted_coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integer coordinates in a nested list.\n\n    Parameters:\n    lst (list[list[int]]): A 2D list where each sublist represents a row.\n    x (int): The integer to locate within the list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of x, \n    sorted by row in ascending order and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the nested list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using its index\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate to the list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of coordinates first by row index in ascending order\n    # For coordinates with the same row index, sort by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Given a 2D list and an integer x, return a list of tuples representing the coordinates of x in the list.\n    Each tuple is a coordinate (row, column), sorted by rows in ascending order and columns in descending order.\n\n    Args:\n        lst: A 2D list of integers.\n        x: An integer to find in the 2D list.\n\n    Returns:\n        A list of tuples where each tuple is a coordinate (row, column) of the integer x in the list.\n        The list is sorted by rows in ascending order and columns in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # For each row, iterate over each element using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate (row, column) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Given a nested list 'lst' and an integer 'x', return a list of tuples representing the coordinates of 'x'.\n    Each tuple is in the form (row, column), sorted by row in ascending order and column in descending order.\n    \n    Args:\n        lst: A list of lists where each sublist contains integers.\n        x: An integer to find in the nested list.\n    \n    Returns:\n        A list of tuples, each representing the coordinates (row_index, column_index) of 'x' in the nested list.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of integer x\n    coordinates = []\n\n    # Iterate over each row in the 2D list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If an element equals x, append its coordinate (row_index, column_index) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order\n    # For coordinates with the same row index, sort by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate and return the positions of integer x within a nested list structure.\n\n    Args:\n        lst: A list of lists containing integers.\n        x: The integer to locate.\n\n    Returns:\n        A list of tuples representing the coordinates of x, sorted by row in ascending order\n        and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of integer x\n    coordinates = []\n\n    # Iterate over each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # If the element matches x, append the coordinate (row, column) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"Finds the coordinates of occurrences of integer x in a 2D list.\n\n    Args:\n        lst: A 2D list of integers.\n        x: An integer to find in the 2D list.\n\n    Returns:\n        A list of tuples, where each tuple contains the row and column indices\n        of occurrences of x in the list. The list is sorted by rows in ascending\n        order and by columns in descending order within each row.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the 2D list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row index, column index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order,\n    # then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"Finds the coordinates of a specified integer in a 2D list.\n\n    This function iterates over each row of the nested list, checking for the\n    presence of the specified integer. For each occurrence, it stores the\n    coordinates as a tuple. The function then sorts these tuples first by row\n    in ascending order and then by column in descending order.\n\n    Args:\n        lst: A nested list of integers where each sublist represents a row.\n        x: An integer to find within the nested list.\n\n    Returns:\n        A list of tuples, where each tuple contains the row and column indices\n        of occurrences of x.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate as a tuple (row_index, col_index)\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates: first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integer positions in a nested list structure.\n\n    Parameters:\n    lst (list[list[int]]): A 2D list where each sublist may have different lengths.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of the integer x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of integer x\n    coordinates = []\n\n    # Iterate through each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n"], "plans": ["requirement analysis:\nThe function should efficiently find and return the coordinates of a given integer in a nested list, handling cases where the integer is not present or the list is empty. It should sort the results by row in ascending order and by column in descending order within each row.\nrequirement pool:\n- Implement the main function to find coordinates of integer x\n- Handle edge cases such as empty lists or missing integers\n- Optimize sorting of coordinates\n- Ensure code readability and maintainability\n- Test function with various input sizes and edge cases\nWe will use pure Python to implement the function, leveraging list comprehensions for concise and efficient data processing. This approach ensures simplicity and readability while maintaining performance for large datasets. We will handle edge cases by checking for empty lists and missing integers before processing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data'\n    Explanation: This refers to a list of lists, where each sublist represents a row, similar to a matrix but with potentially varying numbers of columns.\n\n    'coordinate'\n    Explanation: A tuple representing the position of an element in the 2D data, with the format (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order'\n    Explanation: Sort the coordinates by row index in increasing order.\n\n    'descending order'\n    Explanation: Sort the coordinates within each row by column index in decreasing order.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the 2D list using its index.\n3. For each row, iterate over each element using its index.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row index in ascending order.\n6. For coordinates with the same row index, sort by column index in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to find, resulting in an empty list.\n\n    get_row([[1, 2], [], [3, 4]], 5) = []\n    Explanation: The integer 5 is not present in any row, so the result is an empty list.\n\n    get_row([[1, 1], [1], [1, 2, 1]], 1) = [(0, 1), (0, 0), (1, 0), (2, 2), (2, 0)]\n    Explanation: The integer 1 is found at multiple positions. The coordinates are sorted by rows in ascending order and columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty lists and missing integers by naturally resulting in an empty list when no matches are found.\n", "requirement analysis:\nThe function should efficiently find and return the coordinates of a given integer in a nested list. It must handle cases where the list is empty or the integer is not present. Sorting by row and then by column is crucial for the output format.\nrequirement pool:\n- Implement the main function to find coordinates of integer x in nested lists.\n- Ensure the function handles empty lists and missing integers gracefully.\n- Optimize the function for performance with large datasets.\n- Add comprehensive test cases to validate functionality.\n- Document the code for better understanding and maintenance.\nWe will implement a simple Python function using pure Python to find the coordinates of a given integer in a nested list. The function will handle edge cases such as empty lists and missing integers. Sorting will be done using Python's built-in sorting capabilities to ensure the output is in the required order. This approach ensures simplicity and readability while maintaining adequate performance for moderately sized datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, where each row can have a different number of columns. This is represented using nested lists in Python.\n\n    'coordinate'\n    Explanation: A coordinate in this context refers to a tuple (row, column) indicating the position of an integer within the nested list.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb]\n    'ascending order': means sorting from smallest to largest\n    'descending order': means sorting from largest to smallest\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate through the elements using an index to keep track of the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no coordinates to return.\n\n    get_row([[1, 2], [3, 4], []], 5) = []\n    Explanation: The integer 5 is not present in any row, so the function returns an empty list.\n\n    get_row([[1, 1], [1, 1], [1, 1]], 1) = [(0, 1), (0, 0), (1, 1), (1, 0), (2, 1), (2, 0)]\n    Explanation: All occurrences of 1 are found and sorted by row in ascending order and column in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty lists and missing integers by returning an empty list when no coordinates are found.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle cases where the integer is not present or the list is empty without errors.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of output by rows and columns as specified.\n- Handle edge cases such as empty lists or missing integers.\n- Optimize for performance with large datasets.\n- Provide clear documentation and examples.\nWe will implement a simple function using Python's built-in list operations to locate integer positions in nested lists. The function will iterate through each row and column, collecting coordinates of the specified integer. Sorting will be done using Python's sorted function, ensuring the output meets the specified order requirements. Edge cases such as empty lists or missing integers will be handled gracefully by returning an empty list.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D data, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Sort rows in increasing order based on their index.\n    'descending order': Sort columns within each row in decreasing order based on their index.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the 2D list using its index.\n3. For each row, iterate through each element using its index.\n4. If the element matches the integer x, append its coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row index in ascending order.\n6. For coordinates with the same row index, sort them by column index in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[1, 2], [], [3, 4]], 5) = []\n    Explanation: The integer 5 is not present in any row, so the function returns an empty list.\n\n    get_row([[1, 2, 3], [4, 5], [6]], 6) = [(2, 0)]\n    Explanation: The integer 6 is found at row index 2 and column index 0. Since it's the only occurrence, it is returned as is.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for matches will naturally handle cases where the list is empty or the integer is not present.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle cases where the integer is not present or the list is empty without errors.\nrequirement pool:\n- Implement the main function to locate integer coordinates.\n- Ensure sorting of output by row and column.\n- Handle edge cases such as empty lists.\n- Optimize for performance with large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using Python's built-in list operations to efficiently locate and return coordinates of a specified integer within a nested list structure. The function will handle edge cases such as empty lists and ensure the output is sorted by row in ascending order and by column in descending order. We will use simple list comprehensions and sorting methods to achieve this, avoiding the complexity of external libraries since the task is straightforward.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship.\n\n# [degree adverb]\n    'ascending order': Sort rows in increasing order based on their index.\n    'descending order': Sort columns in decreasing order based on their index within each row.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using its index.\n3. For each row, iterate over each element using its index.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row index in ascending order.\n6. For coordinates with the same row index, sort by column index in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any row, so the result is an empty list of coordinates.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles cases where the list is empty or the integer x is not present by returning an empty list.\n", "requirement analysis:\nThe function should efficiently find all occurrences of a given integer in a nested list, returning their coordinates sorted by row and column. It must handle edge cases such as empty lists or missing values gracefully.\nrequirement pool:\n- Implement the main function to find coordinates of a given integer in a nested list.\n- Ensure the function handles empty lists and missing values without errors.\n- Optimize the function for performance with large datasets.\n- Maintain code readability and simplicity for ease of understanding.\n- Include comprehensive test cases to cover various scenarios.\nWe will implement a function using pure Python to find all occurrences of a given integer in a nested list. The function will handle edge cases such as empty lists or missing values gracefully. We will use list comprehensions for concise and efficient iteration, ensuring the solution is optimized for performance with large datasets while maintaining readability.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': This refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships are present in the requirement.\n\n# [degree adverb]\n    'ascending order': This means sorting from smallest to largest.\n    'descending order': This means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate over each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to find, resulting in an empty list.\n\n    get_row([[1, 2], [], [3, 4]], 5) = []\n    Explanation: The integer 5 is not present in any row, so the result is an empty list.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any row, so the result is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for cases where the list is empty or the integer x is not present by returning an empty list if no coordinates are found.\n", "requirement analysis:\nThe function should efficiently find and return the coordinates of a specified integer in a nested list. It must handle edge cases such as empty lists or the absence of the integer. The output should be sorted by row in ascending order and by column in descending order within each row.\nrequirement pool:\n- Implement the main function to find coordinates of integer x in a nested list\n- Ensure the function handles empty lists and missing integers gracefully\n- Optimize sorting of coordinates for performance\n- Add comprehensive test cases to validate functionality\n- Document the function with clear examples and edge cases\nWe will use native Python list comprehensions and sorting functions to efficiently find and sort the coordinates of the integer x in the nested list. This approach is simple and effective for handling the given requirements, including edge cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': This refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships are present in the requirement.\n\n# [degree adverb]\n    'ascending order': This means sorting from smallest to largest.\n    'descending order': This means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates of integer x.\n2. Iterate over each row in the 2D list using its index.\n3. For each row, iterate over each element using its index.\n4. If an element equals x, append its coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row index in ascending order.\n6. For coordinates with the same row index, sort by column index in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[1, 2], [], [3, 4]], 5) = []\n    Explanation: The integer 5 is not present in any row, so the result is an empty list.\n\n    get_row([[1, 1], [1], [1, 2, 3]], 1) = [(0, 1), (0, 0), (1, 0), (2, 0)]\n    Explanation: The integer 1 is found at multiple positions. The coordinates are sorted by row index first and then by column index in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles cases where the list is empty or x is not present by returning an empty list.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring that results are sorted by row and column as described. It must handle edge cases such as empty lists or the absence of the integer gracefully.\nrequirement pool:\n- Implement the main function to retrieve coordinates of integer x.\n- Ensure sorting by row in ascending and column in descending order.\n- Handle edge cases like empty lists or missing integer.\n- Optimize for performance with large datasets.\n- Provide detailed documentation and examples.\nWe will implement a function using native Python lists to efficiently locate and return the positions of a specified integer within a nested list structure. The function will handle edge cases such as empty lists or the absence of the integer gracefully. Sorting will be done using Python's built-in sorting capabilities, ensuring results are sorted by row in ascending order and column in descending order.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship.\n\n# [degree adverb]\n    No explicit degree adverb.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates of integer x.\n2. Iterate over each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate over each element using an index to keep track of the column number.\n4. If the element matches x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to search for, resulting in an empty list.\n\n    get_row([[1, 2], [], [3, 4]], 5) = []\n    Explanation: The integer 5 is not present in any row, so the function returns an empty list.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any row, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles cases where the list is empty or the integer is not present by returning an empty list.\n", "requirement analysis:\nThe function should efficiently find all occurrences of a given integer in a 2D list and return their coordinates sorted by specified criteria. It must handle edge cases such as empty lists or absence of the integer.\nrequirement pool:\n- Implement the main function to find and sort coordinates.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles edge cases like empty lists.\n- Add comprehensive test cases to validate functionality.\n- Document the function with clear examples and edge cases.\nWe will implement a function using pure Python loops to iterate over the 2D list and find the occurrences of the integer. This approach is simple and easy to understand, which aligns with the user stories. We will ensure the function handles edge cases such as empty lists or when the integer is not present. Sorting will be done using Python's built-in sorting capabilities to maintain performance and simplicity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D list structure, similar to a matrix, where each row can have a different number of columns. This is important for understanding how to iterate over the data and locate elements.\n\n    'coordinate'\n    Explanation: The requirement asks for the positions of the integer x in the form of coordinates (row, column), which are essential for returning the correct output.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order', 'descending order'\n    Explanation: The requirement specifies sorting the coordinates by rows in ascending order and columns in descending order, which affects how the final list of tuples should be organized.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the 2D list using a loop.\n3. For each row, iterate over each element to check if it matches the integer x.\n4. If a match is found, append the coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no coordinates to return.\n\n    get_row([[2, 3], [4, 5]], 1) = []\n    Explanation: The integer 1 is not present in any row, so the function should return an empty list.\n\n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (1, 0), (2, 1)]\n    Explanation: The integer 1 appears in multiple rows; coordinates are sorted by rows in ascending order and columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty lists and cases where the integer is not present.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, handling varying row lengths and empty datasets. The output should be sorted by row and column as specified.\nrequirement pool:\n- Implement the main function to find integer positions.\n- Ensure the function handles empty lists without errors.\n- Sort the output by row in ascending order and column in descending order.\n- Optimize for performance with large datasets.\n- Provide comprehensive documentation and examples.\nWe will implement a function that iterates over each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will store the coordinates as a tuple. The function will then sort these tuples first by row in ascending order and then by column in descending order. We will use Python's built-in list and tuple data structures to achieve this, as they are flexible and efficient for this task. The function will handle edge cases such as empty lists or rows gracefully by returning an empty list if no occurrences are found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data'\n    Explanation: This refers to a list of lists, where each inner list represents a row, similar to a matrix but with potentially varying numbers of columns.\n\n    'coordinate'\n    Explanation: A pair of integers representing the position of an element in the 2D data, with the first integer indicating the row and the second indicating the column.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting from smallest to largest.\n    'descending order': means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using an index to track the row number.\n3. For each row, iterate over each element using an index to track the column number.\n4. If the element matches the integer x, append a tuple (row_index, column_index) to the coordinates list.\n5. Sort the coordinates list first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any row, so the result is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through each element and checking for matches will naturally handle these cases by returning an empty list when no matches are found.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring that the output is sorted by row and column as specified. It must handle edge cases such as empty lists or absence of the integer gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions.\n- Ensure sorting of output by row and column.\n- Handle edge cases like empty lists.\n- Optimize for performance with large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using Python's built-in list and tuple data structures to efficiently locate and return the positions of a specified integer within a nested list structure. The function will handle edge cases such as empty lists or absence of the integer gracefully. Sorting will be done using Python's built-in sorting capabilities, ensuring the output is sorted by row in ascending order and by column in descending order.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a nested list structure where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the nested list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships are present in the requirement.\n\n# [degree adverb]\n    No degree adverbs are present in the requirement.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates of integer x.\n2. Iterate through each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to search for, resulting in an empty list.\n\n    get_row([[1, 2], [], [3, 4]], 5) = []\n    Explanation: The integer 5 is not present in any row, so the function returns an empty list.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 6) = [(2, 1)]\n    Explanation: The integer 6 is found at row 2, column 1. Since it's the only occurrence, it is returned as a single coordinate.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty lists and absence of the integer by returning an empty list when no coordinates are found.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 87, 87, 87, 87], "completion": "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integer positions in a nested list structure.\n\n    Parameters:\n    lst (list[list[int]]): A 2D list where each sublist may have different lengths.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of the integer x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of integer x\n    coordinates = []\n\n    # Iterate through each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "passed": true, "pass": true, "pass_num": 10, "round": 588, "mutate_method": "add_1_sentence_at_end", "parent_index": 325}
