{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are provided with a two-dimensional dataset in the form of nested lists, resembling a matrix, but unlike matrices, each row can have a varying number of columns. Given lst and integer x, locate integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "repair_prompt": ["def get_row(lst, x):\t\n'''You are provided with a two-dimensional dataset in the form of nested lists, resembling a matrix, but unlike matrices, each row can have a varying number of columns. Given lst and integer x, locate integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "def get_row(lst, x):\t\n'''You are provided with a two-dimensional dataset in the form of nested lists. This dataset resembles a matrix, but unlike matrices, each row can have a varying number of columns. Given lst and integer x, locate integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "def get_row(lst, x):\t\n'''You are provided with a two-dimensional dataset in the form of nested lists, resembling a matrix, but each row can have a varying number of columns. Given lst and integer x, locate integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integer x in a two-dimensional list and return a list of tuples representing the coordinates.\n    Each tuple is in the form (row, column). The output is sorted by row in ascending order and by column\n    in descending order within each row.\n\n    Parameters:\n    lst (list[list[int]]): A two-dimensional list where each sublist represents a row.\n    x (int): The integer to locate within the list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples with the coordinates of x.\n    \"\"\"\n    coordinates = []\n\n    # Iterate through each row and column to find occurrences of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates by row index in ascending order\n    # and by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n\n# Example usage:\n# result = get_row([[1], [1, 1], [1]], 1)\n# print(result)  # Output: [(0, 0), (1, 1), (1, 0), (2, 0)]\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate integers x in the nested list and return a list of tuples representing coordinates.\n\n    Parameters:\n    lst (List[List[int]]): A two-dimensional list with varying row lengths.\n    x (int): The integer to locate within the list.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples with coordinates sorted by row in ascending order and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the dataset using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate (row, column) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integers x in the nested list lst and return a list of tuples representing coordinates (row, column).\n    The coordinates are sorted by rows in ascending order and columns in descending order.\n\n    Parameters:\n    lst (list[list[int]]): A two-dimensional list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples where each tuple is a coordinate (row, column).\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the dataset using its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using its index\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate to the list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of coordinates first by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integers x in the nested list lst and return a list of tuples representing coordinates (row, column).\n    The output is sorted by rows in ascending order and by columns in descending order within each row.\n    \n    Parameters:\n    lst (list[list[int]]): A two-dimensional list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n    \n    Returns:\n    list[tuple[int, int]]: A list of tuples where each tuple is a coordinate (row, column).\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the dataset using its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using its index\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate to the list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate occurrences of integer x in a nested list structure.\n\n    Parameters:\n    lst (List[List[int]]): A two-dimensional list where each sublist can have varying lengths.\n    x (int): The integer to locate within the list.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates (row, column) of each\n    occurrence of x, sorted by row in ascending order and column in descending order.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates by row index in ascending order\n    # and by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n\n# Example usage:\n# print(get_row([[1, 1], [1, 1]], 1))  # Output: [(0, 1), (0, 0), (1, 1), (1, 0)]\n# print(get_row([[], [1], [1, 2, 3]], 3))  # Output: [(2, 2)]\n# print(get_row([], 1))  # Output: []\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate integer x in the nested list lst and return a list of tuples representing coordinates.\n    Each tuple is a coordinate (row, column), sorted by rows in ascending order and columns in descending order.\n\n    Parameters:\n    lst (List[List[int]]): A two-dimensional list where each sublist can have varying lengths.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates of integer x.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the dataset\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for column_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row_index, column_index) to the list\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integers x in the nested list and return a list of tuples representing coordinates.\n\n    Parameters:\n    lst (list[list[int]]): A two-dimensional list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples where each tuple contains the row and column index of the integer x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # For each row, iterate over each element using an index to keep track of the column number\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate (row_index, column_index) to the list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integers x in the list and return a list of tuples representing coordinates.\n\n    Parameters:\n    lst (list[list[int]]): A two-dimensional list representing the matrix.\n    x (int): The integer to locate within the matrix.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples where each tuple is a coordinate (row, column).\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order,\n    # then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integers x in the nested list lst and return a list of tuples representing the coordinates (row, column).\n    The coordinates are sorted by row in ascending order and by column in descending order.\n\n    Parameters:\n    lst (list[list[int]]): A two-dimensional list where each sublist represents a row of the matrix.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples where each tuple contains the row and column indices of the integer x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinates (row index, column index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate integer x in a nested list and return a list of tuples representing coordinates.\n    \n    Args:\n        lst: List of lists containing integers.\n        x: Integer to locate.\n    \n    Returns:\n        List of tuples with coordinates (row, column).\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the dataset using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # For each row, iterate through each element using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate (row, column) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n"], "plans": ["requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a two-dimensional list, handling varying row lengths. The output must be sorted by row in ascending order and by column in descending order within each row.\nrequirement pool:\n- Implement the main function to locate integer x in the dataset.\n- Ensure the function handles varying row lengths.\n- Optimize the function for performance with large datasets.\n- Sort the output as specified in the requirements.\n- Provide comprehensive test cases to validate functionality.\nWe will implement a function using native Python list operations to locate the integer x in a two-dimensional list with varying row lengths. The function will iterate through each row and column, collect the coordinates of x, and then sort the results as specified. This approach leverages Python's built-in capabilities for list manipulation and sorting, ensuring simplicity and efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset'\n    Explanation: This refers to a list of lists, where each sublist represents a row in a matrix-like structure. However, unlike a traditional matrix, the number of columns (elements) in each row can vary.\n\n    'coordinate'\n    Explanation: A tuple representing the position of an element in the dataset, with the first value being the row index and the second value being the column index.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order'\n    Explanation: Sorting the coordinates by rows in increasing order, meaning from the smallest row index to the largest.\n\n    'descending order'\n    Explanation: Sorting the coordinates within each row by columns in decreasing order, meaning from the largest column index to the smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row of the dataset using its index.\n3. For each row, iterate through each element using its index.\n4. If the element matches x, append its coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row index in ascending order.\n6. For coordinates with the same row index, sort them by column index in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The dataset is empty, so there are no elements to find, resulting in an empty list of coordinates.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The number 3 is found at row 2, column 2. Since there are no other occurrences, the result is a single coordinate.\n\n    get_row([[1], [1, 1], [1]], 1) = [(0, 0), (1, 1), (1, 0), (2, 0)]\n    Explanation: The number 1 is found at multiple positions. The coordinates are sorted by row index first and then by column index within each row in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through rows and columns and sorting coordinates will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle varying row lengths and empty datasets gracefully.\nrequirement pool:\n- Implement the main function to locate integer coordinates.\n- Ensure sorting of coordinates by row and column.\n- Optimize performance for large datasets.\n- Handle edge cases such as empty lists.\n- Provide clear documentation and examples.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. We will use list comprehension to efficiently gather the coordinates and then sort them as required. The function will handle empty lists gracefully and will be optimized for performance using Python's built-in sorting capabilities.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the dataset, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Sorts the coordinates by rows from smallest to largest.\n    'descending order': Sorts the coordinates within each row by columns from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the dataset using an index to track the row number.\n3. For each row, iterate through each element using an index to track the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order.\n6. For each row, sort the coordinates by column in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The dataset is empty, so there are no coordinates to return.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no occurrences of x to find.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 does not exist in the dataset, so no coordinates are returned.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles empty datasets and cases where x is not found.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring results are sorted by row and column as specified. It should handle varying row lengths and empty datasets gracefully.\nrequirement pool:\n- Implement the main function to locate integer coordinates.\n- Ensure sorting of results by row and column as specified.\n- Handle edge cases such as empty lists and varying row lengths.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using Python's built-in list operations to efficiently locate and return coordinates of a specified integer within a nested list structure. The function will handle varying row lengths and empty datasets gracefully. Sorting will be done using Python's sorted function, ensuring results are sorted by row in ascending order and by column in descending order. We will avoid using complex libraries to maintain simplicity and usability.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an integer in the dataset, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Sort rows in increasing order based on their index.\n    'descending order': Sort columns in decreasing order based on their index within each row.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the dataset using its index.\n3. For each row, iterate through each element using its index.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The dataset is empty, so there are no coordinates to return.\n    \n    get_row([[1, 2], [], [3, 1]], 1) = [(0, 0), (2, 1)]\n    Explanation: The integer 1 is found at (0, 0) and (2, 1). The empty row does not affect the result.\n\n    get_row([[1], [1, 2], [1, 2, 3]], 2) = [(1, 1), (2, 1)]\n    Explanation: The integer 2 is found at (1, 1) and (2, 1). The coordinates are sorted by row in ascending order and by column in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty datasets and varying row lengths naturally.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle varying row lengths and empty datasets gracefully.\nrequirement pool:\n- Implement the main function to locate integer coordinates.\n- Ensure sorting of coordinates by row and column.\n- Optimize performance for large datasets.\n- Handle edge cases like empty lists.\n- Provide clear documentation and examples.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will record the coordinates as a tuple (row_index, column_index). After collecting all coordinates, we will sort them first by row in ascending order and then by column in descending order. Python's built-in list and tuple data structures will be used for simplicity and efficiency. No additional libraries are needed as the task involves basic list operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset'\n    Explanation: This refers to a list of lists, where each inner list represents a row in a matrix-like structure.\n\n    'coordinate'\n    Explanation: A tuple representing the position of an element in the dataset, with the format (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting from smallest to largest.\n    'descending order': means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the dataset using its index.\n3. For each row, iterate through each element using its index.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The dataset is empty, so there are no coordinates to return.\n\n    get_row([[1, 2], [], [3, 1]], 1) = [(0, 0), (2, 1)]\n    Explanation: The integer 1 appears at (0, 0) and (2, 1). The coordinates are sorted by row in ascending order.\n\n    get_row([[1], [1, 2], [1, 2, 3]], 2) = [(1, 1), (2, 1)]\n    Explanation: The integer 2 appears at (1, 1) and (2, 1). The coordinates are sorted by row in ascending order and column in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty datasets and varying row lengths.\n", "requirement analysis:\nThe function should efficiently locate and sort occurrences of a given integer within a nested list structure. It must handle varying row lengths and ensure the output is sorted by row and column as specified. Edge cases, such as empty lists, should be addressed to prevent errors.\nrequirement pool:\n- Implement efficient search and retrieval of integer occurrences.\n- Ensure sorting by row in ascending order and column in descending order.\n- Handle edge cases like empty lists gracefully.\n- Provide clear documentation and examples for user understanding.\n- Optimize performance for large datasets.\nWe will implement a function using Python's built-in list operations to efficiently search for occurrences of a given integer within a nested list structure. The function will handle varying row lengths and sort the results by row in ascending order and column in descending order. We will ensure edge cases like empty lists are handled gracefully. The function will be documented with clear examples to enhance usability.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset'\n    Explanation: This refers to a list of lists, where each inner list represents a row in a matrix-like structure.\n\n    'coordinate'\n    Explanation: A pair of values (row, column) indicating the position of an element within the two-dimensional dataset.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Sort rows from smallest to largest index.\n    'descending order': Sort columns from largest to smallest index within each row.\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row in the dataset using its index.\n    3. For each row, iterate through each element using its index.\n    4. If the element matches the integer x, append the coordinate (row index, column index) to the list.\n    5. Sort the list of coordinates first by row index in ascending order.\n    6. Within each row, sort the coordinates by column index in descending order.\n    7. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The dataset is empty, so there are no coordinates to return.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found only in the third row at column index 2.\n\n    get_row([[1, 1], [1, 1]], 1) = [(0, 1), (0, 0), (1, 1), (1, 0)]\n    Explanation: The integer 1 appears in both rows at all column indices. The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths gracefully.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. The examples provided should clearly demonstrate the expected output format.\nrequirement pool:\n- Implement the main function to locate integer x in the dataset.\n- Ensure output is sorted by rows in ascending order and columns in descending order.\n- Provide clear examples to illustrate the function's output.\n- Optimize for performance with large datasets.\n- Consider edge cases such as empty lists or non-integer values.\nWe will implement a function using Python's built-in list operations to efficiently locate and return coordinates of a specified integer within a nested list structure. The function will sort the output by rows in ascending order and columns in descending order. We will use simple list comprehensions and sorting techniques to achieve this, ensuring the function is easy to understand and integrate into larger systems.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset': This refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the dataset, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending': This means sorting from smallest to largest.\n    'descending': This means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the dataset using its index.\n3. For each row, iterate over each element using its index.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The dataset is empty, so there are no coordinates to return.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no coordinates to return.\n\n    get_row([[1, 2], [3, 1], [1]], 1) = [(0, 0), (1, 1), (2, 0)]\n    Explanation: The integer 1 is found at (0, 0), (1, 1), and (2, 0). The coordinates are already sorted by row in ascending order and by column in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty datasets and rows naturally by not finding any matches and returning an empty list.\n", "requirement analysis:\nThe function should efficiently locate and sort the specified integer within a nested list structure, ensuring that the results are both accurate and easy to interpret. It should handle varying row lengths and return sorted coordinates as specified.\nrequirement pool:\n- Implement the main function to locate and sort integer coordinates.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles varying row lengths without errors.\n- Provide clear documentation for ease of use.\n- Include examples to demonstrate functionality.\nWe will implement a function that iterates over each row and column of the nested list to locate the specified integer. The function will store the coordinates in a list of tuples, which will then be sorted first by row in ascending order and then by column in descending order. Given the simplicity of the task, we will use Python's built-in capabilities without additional libraries to ensure ease of use and maintainability.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset': This refers to a list of lists, where each inner list represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the matrix, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb]\n    'ascending': This means sorting from smallest to largest.\n    'descending': This means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate over each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 does not exist in any row, so there are no coordinates to return.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles cases where the list is empty or the integer is not found.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a matrix, ensuring the output is sorted by rows and columns as specified. It should handle matrices with varying row lengths and return results in a clear format.\nrequirement pool:\n- Accurate retrieval of integer coordinates from matrix\n- Sorting of coordinates by rows and columns\n- Handling of matrices with varying row lengths\n- Optimization for large datasets\n- User-friendly output format\nWe will implement a function using Python's built-in list operations to efficiently locate and return coordinates of a specified integer within a matrix. The function will handle matrices with varying row lengths and ensure the output is sorted by rows in ascending order and columns in descending order. Given the simplicity of the task, we will not use any external libraries, as Python's native capabilities are sufficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset': This refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the matrix, with the format (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships are present in the requirement.\n\n# [degree adverb]\n    No degree adverbs are present in the requirement.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the list using its index.\n3. For each row, iterate over each element using its index.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (2, 1), (1, 0)]\n    Explanation: The integer 1 is found at coordinates (0, 0), (1, 0), and (2, 1). After sorting by rows and then by columns in descending order within each row, the result is [(0, 0), (2, 1), (1, 0)].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the matrix and sorting the results will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle varying row lengths and empty datasets gracefully.\nrequirement pool:\n- Implement the main function to locate integer coordinates.\n- Ensure sorting of coordinates by row and column.\n- Optimize performance for large datasets.\n- Handle edge cases such as empty lists.\n- Provide clear documentation and examples.\nWe will implement a function that iterates through each row and column of the nested list to locate the specified integer. The function will collect the coordinates of the integer in tuples, sort them by row in ascending order, and by column in descending order. We will use Python's built-in list and tuple data structures for simplicity and efficiency, as they are well-suited for this task. The function will handle edge cases such as empty lists gracefully by returning an empty list.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset': refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': refers to the position of an element in the matrix, represented as a tuple (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb]\n    'ascending order': means sorting from smallest to largest.\n    'descending order': means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using a loop.\n3. For each row, iterate through each element using another loop.\n4. If the element matches the integer x, append its coordinates (row index, column index) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to search for, resulting in an empty list.\n    \n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found at row index 2 and column index 2. Since there are no other occurrences, the result is a single tuple.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 does not exist in any row, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles cases like empty lists or non-existent integers by returning an empty list when no matches are found.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle varying row lengths and empty datasets gracefully.\nrequirement pool:\n- Implement the main function to locate integer coordinates.\n- Ensure sorting of coordinates by row and column.\n- Optimize performance for large datasets.\n- Handle edge cases like empty lists and varying row lengths.\n- Provide comprehensive documentation and examples.\nWe will implement a function using native Python lists to handle varying row lengths efficiently. The function will iterate through the nested list structure to locate the specified integer and store its coordinates. Sorting will be done using Python's built-in sorting capabilities, ensuring the output is sorted by rows in ascending order and columns in descending order. This approach leverages Python's flexibility with lists and avoids unnecessary complexity from external libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'two-dimensional dataset': This refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the dataset, with the format (row, column).\n    'sort coordinates': The requirement to order the coordinates first by row in ascending order, then by column in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the dataset using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The dataset is empty, so there are no coordinates to return.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no occurrences of the integer x.\n\n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (1, 0), (2, 1)]\n    Explanation: The integer 1 appears at (0, 0), (1, 0), and (2, 1). The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty datasets and varying row lengths naturally.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 87, 87, 87, 87], "completion": "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate integer x in a nested list and return a list of tuples representing coordinates.\n    \n    Args:\n        lst: List of lists containing integers.\n        x: Integer to locate.\n    \n    Returns:\n        List of tuples with coordinates (row, column).\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the dataset using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # For each row, iterate through each element using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate (row, column) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "passed": true, "pass": true, "pass_num": 10, "round": 75, "mutate_method": "rephrase_one", "parent_index": 75}
