{"task_id": "HumanEval/21", "prompt": "def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1. Ensure that all transformed values maintain relative proportions to each other.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''", "entry_point": "rescale_to_unit", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "test": ["def check(rescale_to_unit):\n\tassert rescale_to_unit([99.9, 47.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.2, 51.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.7, 49.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.7, 51.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.8, 4.8, 4.5, 1.8, 1.7]) == [0.3548387096774194, 1.0, 0.903225806451613, 0.032258064516129066, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.5, 1.4, 8.1, 4.2, 6.7]) == [0.014925373134328374, 0.0, 1.0, 0.4179104477611941, 0.7910447761194032]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.2, 8.7, 11.8, 16.6, 14.9]) == [0.0, 0.15957446808510625, 0.4893617021276595, 1.0, 0.8191489361702126]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.2, 54.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([15.4, 13.2, 13.8, 17.0, 17.9]) == [0.468085106382979, 0.0, 0.12765957446808543, 0.8085106382978726, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([101.4, 46.5]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 6.9, 8.3, 7.9, 6.9]) == [0.0, 0.5757575757575757, 1.0, 0.8787878787878787, 0.5757575757575757]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([104.6, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.3, 46.5]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.2, 52.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 54.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.2, 47.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.6, 9.8, 13.5, 15.4, 15.5]) == [0.14035087719298228, 0.0, 0.6491228070175438, 0.9824561403508772, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([103.9, 51.6]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.3, 9.9, 18.2, 18.6, 15.0]) == [0.04597701149425291, 0.0, 0.9540229885057468, 1.0, 0.586206896551724]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.1, 5.6, 7.5, 4.7, 2.2]) == [0.5471698113207546, 0.6415094339622641, 1.0, 0.4716981132075472, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.2, 49.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([99.6, 50.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.8, 50.6]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([13.5, 11.1, 16.3, 15.7, 14.2]) == [0.4615384615384615, 0.0, 1.0, 0.8846153846153844, 0.5961538461538459]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([11.4, 11.3, 14.4, 18.1, 9.6]) == [0.211764705882353, 0.2000000000000001, 0.5647058823529412, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([103.9, 44.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.9, 1.1, 1.7, 7.1, 4.6]) == [0.3, 0.0, 0.09999999999999998, 1.0, 0.5833333333333333]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.5, 4.5, 8.2, 6.4, 10.1]) == [0.35714285714285715, 0.0, 0.6607142857142856, 0.33928571428571436, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.5, 5.1, 8.1, 7.0, 8.3]) == [0.0, 0.15789473684210514, 0.9473684210526313, 0.6578947368421051, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.9, 4.1, 7.1, 9.3, 10.0]) == [0.13559322033898316, 0.0, 0.5084745762711864, 0.8813559322033899, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.6, 3.9, 10.6, 3.8, 9.3]) == [0.0, 0.16249999999999998, 1.0, 0.14999999999999997, 0.8375000000000001]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.3, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.4, 49.3]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.9, 5.9, 10.7, 3.0, 3.1]) == [0.0, 0.38461538461538475, 1.0, 0.012820512820512834, 0.025641025641025668]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.5, 1.1, 2.9, 7.4, 5.1]) == [1.0, 0.0, 0.28124999999999994, 0.9843750000000001, 0.6249999999999999]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.3, 5.8, 7.5, 4.0, 9.7]) == [0.4035087719298246, 0.3157894736842105, 0.6140350877192983, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.7, 53.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.5, 2.9, 6.4, 6.8, 1.0]) == [0.9482758620689655, 0.3275862068965517, 0.9310344827586208, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.6, 3.4, 5.5, 9.4, 7.2]) == [0.0, 0.23076923076923073, 0.49999999999999994, 1.0, 0.7179487179487178]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 5.9, 2.8, 5.2, 11.0]) == [0.21951219512195122, 0.378048780487805, 0.0, 0.2926829268292684, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.2, 3.3, 2.1, 1.5, 5.7]) == [1.0, 0.38297872340425526, 0.12765957446808512, 0.0, 0.8936170212765957]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([16.2, 16.6, 16.6, 12.8, 18.2]) == [0.6296296296296295, 0.703703703703704, 0.703703703703704, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.4, 48.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.4, 7.5, 6.4, 5.1, 10.6]) == [0.0, 0.5694444444444444, 0.4166666666666668, 0.2361111111111111, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.7, 1.2, 6.7, 3.4, 8.2]) == [0.3571428571428572, 0.0, 0.7857142857142858, 0.31428571428571433, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 4.5, 5.5, 2.4, 5.1]) == [0.7096774193548386, 0.6774193548387097, 1.0, 0.0, 0.8709677419354838]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.5, 17.0, 13.4, 10.5, 15.8]) == [1.0, 0.9285714285714286, 0.4142857142857143, 0.0, 0.7571428571428572]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.8, 6.5, 5.7, 1.4, 9.9]) == [0.5176470588235295, 0.6, 0.5058823529411766, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.1, 4.6, 6.9, 5.1, 4.6]) == [1.0, 0.0, 0.9200000000000003, 0.2, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.2, 53.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.5, 44.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([11.6, 9.7, 12.4, 18.9, 9.4]) == [0.23157894736842102, 0.03157894736842095, 0.31578947368421056, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.3, 5.4, 1.8, 4.3, 8.7]) == [0.0, 0.5540540540540542, 0.06756756756756757, 0.40540540540540543, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.7, 2.2, 4.7, 8.7, 7.8]) == [0.5384615384615385, 0.0, 0.3846153846153847, 1.0, 0.8615384615384616]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.6, 1.6, 4.7, 8.8, 6.6]) == [0.0, 0.0, 0.4305555555555555, 1.0, 0.6944444444444443]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.1, 51.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.1, 50.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([97.0, 52.7]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.1, 3.9, 4.9, 8.0, 3.4]) == [0.0, 0.30508474576271183, 0.4745762711864407, 1.0, 0.22033898305084743]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.8, 52.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.9, 2.9, 8.4, 9.6, 6.9]) == [0.4477611940298509, 0.0, 0.8208955223880597, 1.0, 0.5970149253731344]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 7.5, 19.8, 18.8, 12.9]) == [0.0, 0.016000000000000014, 1.0, 0.92, 0.44800000000000006]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 1.6, 9.0, 8.2, 7.2]) == [0.45945945945945943, 0.0, 1.0, 0.8918918918918918, 0.7567567567567567]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.5, 2.8, 8.2, 9.8, 6.8]) == [0.10000000000000002, 0.0, 0.7714285714285712, 1.0, 0.5714285714285714]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([8.0, 9.3, 17.1, 18.5, 10.5]) == [0.0, 0.12380952380952388, 0.8666666666666668, 1.0, 0.23809523809523808]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.6, 1.6, 1.3, 6.9, 2.3]) == [0.9464285714285713, 0.053571428571428575, 0.0, 1.0, 0.17857142857142852]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.4, 45.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.3, 2.5, 1.2, 4.0, 8.5]) == [0.4246575342465753, 0.17808219178082194, 0.0, 0.3835616438356164, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.9, 50.7]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.9, 46.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.4, 2.6, 2.1, 7.0, 2.4]) == [0.46938775510204084, 0.1020408163265306, 0.0, 1.0, 0.061224489795918324]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([14.6, 6.7, 19.2, 13.8, 13.5]) == [0.632, 0.0, 1.0, 0.5680000000000001, 0.544]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.6, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 5.5, 10.2, 3.9, 4.4]) == [0.0, 0.38961038961038963, 1.0, 0.18181818181818182, 0.24675324675324684]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.4, 8.1, 15.5, 14.4, 15.1]) == [0.5810810810810811, 0.0, 1.0, 0.8513513513513514, 0.9459459459459459]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.5, 53.2]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.1, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.1, 6.1, 8.0, 6.4, 8.7]) == [0.0, 0.0, 0.7307692307692311, 0.11538461538461567, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.2, 12.9, 12.4, 11.6, 16.9]) == [0.11320754716981128, 0.24528301886792472, 0.15094339622641526, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.9, 13.2, 20.2, 11.2, 11.2]) == [0.0, 0.24731182795698917, 1.0, 0.03225806451612892, 0.03225806451612892]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([96.2, 53.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.4, 48.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.7, 44.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.0, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.4, 51.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([16.1, 13.0, 15.9, 9.1, 15.3]) == [1.0, 0.557142857142857, 0.9714285714285713, 0.0, 0.8857142857142857]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 2.1, 4.3, 7.7, 9.7]) == [0.05263157894736841, 0.0, 0.28947368421052627, 0.7368421052631579, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.0, 48.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.6, 6.9, 7.0, 2.7, 4.9]) == [1.0, 0.8571428571428573, 0.8775510204081634, 0.0, 0.4489795918367348]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.5, 5.6, 3.1, 8.0, 9.4]) == [0.3809523809523809, 0.3968253968253967, 0.0, 0.7777777777777778, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.4, 3.2, 3.7, 8.2, 1.1]) == [0.18309859154929575, 0.295774647887324, 0.36619718309859156, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 1.5, 9.5, 4.6, 1.2]) == [0.7349397590361445, 0.03614457831325302, 1.0, 0.40963855421686735, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.8, 45.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([9.7, 7.6, 13.7, 8.1, 10.3]) == [0.34426229508196715, 0.0, 1.0, 0.0819672131147541, 0.44262295081967235]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([15.7, 12.5, 16.1, 8.7, 9.6]) == [0.9459459459459457, 0.5135135135135135, 1.0, 0.0, 0.12162162162162163]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.1, 14.1, 14.5, 9.1, 9.5]) == [0.18518518518518517, 0.9259259259259258, 1.0, 0.0, 0.07407407407407414]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.7, 47.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.9, 4.4, 1.4, 3.4, 2.8]) == [1.0, 0.6666666666666667, 0.0, 0.4444444444444444, 0.3111111111111111]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.1, 6.8, 5.3, 5.4, 5.5]) == [0.0, 1.0, 0.5945945945945945, 0.6216216216216217, 0.6486486486486487]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.1, 51.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 3.8, 8.2, 3.9, 1.1]) == [0.5492957746478874, 0.38028169014084506, 1.0, 0.39436619718309857, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.9, 4.8, 3.2, 4.3, 1.4]) == [0.14705882352941177, 1.0, 0.5294117647058825, 0.8529411764705882, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.1, 12.6, 10.2, 16.8, 11.1]) == [0.0, 0.3731343283582089, 0.014925373134328302, 1.0, 0.14925373134328357]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 5.7, 10.7, 5.4, 4.4]) == [0.03174603174603164, 0.20634920634920637, 1.0, 0.15873015873015875, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.0, 52.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.1, 46.8]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.4, 50.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.5, 46.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.2, 2.1, 1.6, 6.4, 3.7]) == [0.3333333333333333, 0.10416666666666666, 0.0, 1.0, 0.43749999999999994]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.0, 51.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.9, 44.8]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.3, 4.4, 8.8, 2.9, 1.7]) == [0.22535211267605632, 0.38028169014084506, 1.0, 0.16901408450704222, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.6, 14.9, 12.4, 9.6, 14.2]) == [1.0, 0.6625, 0.35000000000000003, 0.0, 0.5749999999999998]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.4, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.3, 14.5, 18.1, 18.3, 10.4]) == [0.24050632911392408, 0.5189873417721518, 0.9746835443037976, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.8, 45.3]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.4, 1.8, 4.4, 7.7, 2.8]) == [0.6101694915254238, 0.0, 0.44067796610169496, 1.0, 0.16949152542372878]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.7, 3.9, 1.2, 4.6, 7.1]) == [0.42372881355932207, 0.45762711864406785, 0.0, 0.5762711864406779, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([9.7, 13.8, 18.7, 15.3, 14.7]) == [0.0, 0.4555555555555557, 1.0, 0.6222222222222223, 0.5555555555555556]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.6, 8.7, 12.8, 9.2, 17.0]) == [1.0, 0.0, 0.46067415730337086, 0.05617977528089886, 0.9325842696629212]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 4.4, 8.0, 3.4, 10.2]) == [0.0, 0.24675324675324684, 0.7142857142857143, 0.11688311688311688, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.3, 3.4, 7.0, 6.8, 4.4]) == [0.0, 0.23404255319148937, 1.0, 0.9574468085106382, 0.44680851063829796]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.3, 4.4, 6.1, 8.4, 1.2]) == [0.43055555555555547, 0.4444444444444445, 0.6805555555555555, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 7.4, 16.1, 10.7, 18.0]) == [0.0, 0.009345794392523414, 0.8224299065420562, 0.3177570093457944, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.3, 47.4]) == [1.0, 0.0]"], "test_case_list": ["assert rescale_to_unit([99.9, 47.9]) == [1.0, 0.0]", "assert rescale_to_unit([3.2, 51.8]) == [0.0, 1.0]", "assert rescale_to_unit([100.7, 49.1]) == [1.0, 0.0]", "assert rescale_to_unit([4.7, 51.3]) == [0.0, 1.0]", "assert rescale_to_unit([2.8, 4.8, 4.5, 1.8, 1.7]) == [0.3548387096774194, 1.0, 0.903225806451613, 0.032258064516129066, 0.0]", "assert rescale_to_unit([1.5, 1.4, 8.1, 4.2, 6.7]) == [0.014925373134328374, 0.0, 1.0, 0.4179104477611941, 0.7910447761194032]", "assert rescale_to_unit([7.2, 8.7, 11.8, 16.6, 14.9]) == [0.0, 0.15957446808510625, 0.4893617021276595, 1.0, 0.8191489361702126]", "assert rescale_to_unit([4.2, 54.2]) == [0.0, 1.0]", "assert rescale_to_unit([15.4, 13.2, 13.8, 17.0, 17.9]) == [0.468085106382979, 0.0, 0.12765957446808543, 0.8085106382978726, 1.0]", "assert rescale_to_unit([101.4, 46.5]) == [1.0, 0.0]", "assert rescale_to_unit([5.0, 6.9, 8.3, 7.9, 6.9]) == [0.0, 0.5757575757575757, 1.0, 0.8787878787878787, 0.5757575757575757]", "assert rescale_to_unit([104.6, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([1.3, 46.5]) == [0.0, 1.0]", "assert rescale_to_unit([1.2, 52.9]) == [0.0, 1.0]", "assert rescale_to_unit([2.5, 54.9]) == [0.0, 1.0]", "assert rescale_to_unit([4.2, 47.3]) == [0.0, 1.0]", "assert rescale_to_unit([10.6, 9.8, 13.5, 15.4, 15.5]) == [0.14035087719298228, 0.0, 0.6491228070175438, 0.9824561403508772, 1.0]", "assert rescale_to_unit([103.9, 51.6]) == [1.0, 0.0]", "assert rescale_to_unit([10.3, 9.9, 18.2, 18.6, 15.0]) == [0.04597701149425291, 0.0, 0.9540229885057468, 1.0, 0.586206896551724]", "assert rescale_to_unit([5.1, 5.6, 7.5, 4.7, 2.2]) == [0.5471698113207546, 0.6415094339622641, 1.0, 0.4716981132075472, 0.0]", "assert rescale_to_unit([7.2, 49.3]) == [0.0, 1.0]", "assert rescale_to_unit([99.6, 50.1]) == [1.0, 0.0]", "assert rescale_to_unit([98.8, 50.6]) == [1.0, 0.0]", "assert rescale_to_unit([13.5, 11.1, 16.3, 15.7, 14.2]) == [0.4615384615384615, 0.0, 1.0, 0.8846153846153844, 0.5961538461538459]", "assert rescale_to_unit([11.4, 11.3, 14.4, 18.1, 9.6]) == [0.211764705882353, 0.2000000000000001, 0.5647058823529412, 1.0, 0.0]", "assert rescale_to_unit([103.9, 44.1]) == [1.0, 0.0]", "assert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([2.9, 1.1, 1.7, 7.1, 4.6]) == [0.3, 0.0, 0.09999999999999998, 1.0, 0.5833333333333333]", "assert rescale_to_unit([6.5, 4.5, 8.2, 6.4, 10.1]) == [0.35714285714285715, 0.0, 0.6607142857142856, 0.33928571428571436, 1.0]", "assert rescale_to_unit([4.5, 5.1, 8.1, 7.0, 8.3]) == [0.0, 0.15789473684210514, 0.9473684210526313, 0.6578947368421051, 1.0]", "assert rescale_to_unit([4.9, 4.1, 7.1, 9.3, 10.0]) == [0.13559322033898316, 0.0, 0.5084745762711864, 0.8813559322033899, 1.0]", "assert rescale_to_unit([2.6, 3.9, 10.6, 3.8, 9.3]) == [0.0, 0.16249999999999998, 1.0, 0.14999999999999997, 0.8375000000000001]", "assert rescale_to_unit([98.3, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([100.4, 49.3]) == [1.0, 0.0]", "assert rescale_to_unit([2.9, 5.9, 10.7, 3.0, 3.1]) == [0.0, 0.38461538461538475, 1.0, 0.012820512820512834, 0.025641025641025668]", "assert rescale_to_unit([7.5, 1.1, 2.9, 7.4, 5.1]) == [1.0, 0.0, 0.28124999999999994, 0.9843750000000001, 0.6249999999999999]", "assert rescale_to_unit([6.3, 5.8, 7.5, 4.0, 9.7]) == [0.4035087719298246, 0.3157894736842105, 0.6140350877192983, 0.0, 1.0]", "assert rescale_to_unit([95.7, 53.0]) == [1.0, 0.0]", "assert rescale_to_unit([6.5, 2.9, 6.4, 6.8, 1.0]) == [0.9482758620689655, 0.3275862068965517, 0.9310344827586208, 1.0, 0.0]", "assert rescale_to_unit([1.6, 3.4, 5.5, 9.4, 7.2]) == [0.0, 0.23076923076923073, 0.49999999999999994, 1.0, 0.7179487179487178]", "assert rescale_to_unit([4.6, 5.9, 2.8, 5.2, 11.0]) == [0.21951219512195122, 0.378048780487805, 0.0, 0.2926829268292684, 1.0]", "assert rescale_to_unit([6.2, 3.3, 2.1, 1.5, 5.7]) == [1.0, 0.38297872340425526, 0.12765957446808512, 0.0, 0.8936170212765957]", "assert rescale_to_unit([16.2, 16.6, 16.6, 12.8, 18.2]) == [0.6296296296296295, 0.703703703703704, 0.703703703703704, 0.0, 1.0]", "assert rescale_to_unit([100.4, 48.1]) == [1.0, 0.0]", "assert rescale_to_unit([3.4, 7.5, 6.4, 5.1, 10.6]) == [0.0, 0.5694444444444444, 0.4166666666666668, 0.2361111111111111, 1.0]", "assert rescale_to_unit([3.7, 1.2, 6.7, 3.4, 8.2]) == [0.3571428571428572, 0.0, 0.7857142857142858, 0.31428571428571433, 1.0]", "assert rescale_to_unit([4.6, 4.5, 5.5, 2.4, 5.1]) == [0.7096774193548386, 0.6774193548387097, 1.0, 0.0, 0.8709677419354838]", "assert rescale_to_unit([17.5, 17.0, 13.4, 10.5, 15.8]) == [1.0, 0.9285714285714286, 0.4142857142857143, 0.0, 0.7571428571428572]", "assert rescale_to_unit([5.8, 6.5, 5.7, 1.4, 9.9]) == [0.5176470588235295, 0.6, 0.5058823529411766, 0.0, 1.0]", "assert rescale_to_unit([7.1, 4.6, 6.9, 5.1, 4.6]) == [1.0, 0.0, 0.9200000000000003, 0.2, 0.0]", "assert rescale_to_unit([6.2, 53.8]) == [0.0, 1.0]", "assert rescale_to_unit([1.5, 44.9]) == [0.0, 1.0]", "assert rescale_to_unit([11.6, 9.7, 12.4, 18.9, 9.4]) == [0.23157894736842102, 0.03157894736842095, 0.31578947368421056, 1.0, 0.0]", "assert rescale_to_unit([1.3, 5.4, 1.8, 4.3, 8.7]) == [0.0, 0.5540540540540542, 0.06756756756756757, 0.40540540540540543, 1.0]", "assert rescale_to_unit([5.7, 2.2, 4.7, 8.7, 7.8]) == [0.5384615384615385, 0.0, 0.3846153846153847, 1.0, 0.8615384615384616]", "assert rescale_to_unit([1.6, 1.6, 4.7, 8.8, 6.6]) == [0.0, 0.0, 0.4305555555555555, 1.0, 0.6944444444444443]", "assert rescale_to_unit([2.1, 51.4]) == [0.0, 1.0]", "assert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([6.1, 50.2]) == [0.0, 1.0]", "assert rescale_to_unit([97.0, 52.7]) == [1.0, 0.0]", "assert rescale_to_unit([2.1, 3.9, 4.9, 8.0, 3.4]) == [0.0, 0.30508474576271183, 0.4745762711864407, 1.0, 0.22033898305084743]", "assert rescale_to_unit([7.8, 52.2]) == [0.0, 1.0]", "assert rescale_to_unit([5.9, 2.9, 8.4, 9.6, 6.9]) == [0.4477611940298509, 0.0, 0.8208955223880597, 1.0, 0.5970149253731344]", "assert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "assert rescale_to_unit([7.3, 7.5, 19.8, 18.8, 12.9]) == [0.0, 0.016000000000000014, 1.0, 0.92, 0.44800000000000006]", "assert rescale_to_unit([5.0, 1.6, 9.0, 8.2, 7.2]) == [0.45945945945945943, 0.0, 1.0, 0.8918918918918918, 0.7567567567567567]", "assert rescale_to_unit([3.5, 2.8, 8.2, 9.8, 6.8]) == [0.10000000000000002, 0.0, 0.7714285714285712, 1.0, 0.5714285714285714]", "assert rescale_to_unit([8.0, 9.3, 17.1, 18.5, 10.5]) == [0.0, 0.12380952380952388, 0.8666666666666668, 1.0, 0.23809523809523808]", "assert rescale_to_unit([6.6, 1.6, 1.3, 6.9, 2.3]) == [0.9464285714285713, 0.053571428571428575, 0.0, 1.0, 0.17857142857142852]", "assert rescale_to_unit([7.4, 45.9]) == [0.0, 1.0]", "assert rescale_to_unit([4.3, 2.5, 1.2, 4.0, 8.5]) == [0.4246575342465753, 0.17808219178082194, 0.0, 0.3835616438356164, 1.0]", "assert rescale_to_unit([7.9, 50.7]) == [0.0, 1.0]", "assert rescale_to_unit([4.9, 46.2]) == [0.0, 1.0]", "assert rescale_to_unit([4.4, 2.6, 2.1, 7.0, 2.4]) == [0.46938775510204084, 0.1020408163265306, 0.0, 1.0, 0.061224489795918324]", "assert rescale_to_unit([14.6, 6.7, 19.2, 13.8, 13.5]) == [0.632, 0.0, 1.0, 0.5680000000000001, 0.544]", "assert rescale_to_unit([95.6, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([2.5, 5.5, 10.2, 3.9, 4.4]) == [0.0, 0.38961038961038963, 1.0, 0.18181818181818182, 0.24675324675324684]", "assert rescale_to_unit([12.4, 8.1, 15.5, 14.4, 15.1]) == [0.5810810810810811, 0.0, 1.0, 0.8513513513513514, 0.9459459459459459]", "assert rescale_to_unit([105.5, 53.2]) == [1.0, 0.0]", "assert rescale_to_unit([102.1, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([6.1, 6.1, 8.0, 6.4, 8.7]) == [0.0, 0.0, 0.7307692307692311, 0.11538461538461567, 1.0]", "assert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "assert rescale_to_unit([12.2, 12.9, 12.4, 11.6, 16.9]) == [0.11320754716981128, 0.24528301886792472, 0.15094339622641526, 0.0, 1.0]", "assert rescale_to_unit([10.9, 13.2, 20.2, 11.2, 11.2]) == [0.0, 0.24731182795698917, 1.0, 0.03225806451612892, 0.03225806451612892]", "assert rescale_to_unit([96.2, 53.9]) == [1.0, 0.0]", "assert rescale_to_unit([95.4, 48.0]) == [1.0, 0.0]", "assert rescale_to_unit([5.7, 44.3]) == [0.0, 1.0]", "assert rescale_to_unit([102.0, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([2.4, 51.4]) == [0.0, 1.0]", "assert rescale_to_unit([16.1, 13.0, 15.9, 9.1, 15.3]) == [1.0, 0.557142857142857, 0.9714285714285713, 0.0, 0.8857142857142857]", "assert rescale_to_unit([2.5, 2.1, 4.3, 7.7, 9.7]) == [0.05263157894736841, 0.0, 0.28947368421052627, 0.7368421052631579, 1.0]", "assert rescale_to_unit([1.0, 48.4]) == [0.0, 1.0]", "assert rescale_to_unit([7.6, 6.9, 7.0, 2.7, 4.9]) == [1.0, 0.8571428571428573, 0.8775510204081634, 0.0, 0.4489795918367348]", "assert rescale_to_unit([5.5, 5.6, 3.1, 8.0, 9.4]) == [0.3809523809523809, 0.3968253968253967, 0.0, 0.7777777777777778, 1.0]", "assert rescale_to_unit([2.4, 3.2, 3.7, 8.2, 1.1]) == [0.18309859154929575, 0.295774647887324, 0.36619718309859156, 1.0, 0.0]", "assert rescale_to_unit([7.3, 1.5, 9.5, 4.6, 1.2]) == [0.7349397590361445, 0.03614457831325302, 1.0, 0.40963855421686735, 0.0]", "assert rescale_to_unit([105.8, 45.9]) == [1.0, 0.0]", "assert rescale_to_unit([9.7, 7.6, 13.7, 8.1, 10.3]) == [0.34426229508196715, 0.0, 1.0, 0.0819672131147541, 0.44262295081967235]", "assert rescale_to_unit([15.7, 12.5, 16.1, 8.7, 9.6]) == [0.9459459459459457, 0.5135135135135135, 1.0, 0.0, 0.12162162162162163]", "assert rescale_to_unit([10.1, 14.1, 14.5, 9.1, 9.5]) == [0.18518518518518517, 0.9259259259259258, 1.0, 0.0, 0.07407407407407414]", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert rescale_to_unit([6.7, 47.3]) == [0.0, 1.0]", "assert rescale_to_unit([5.9, 4.4, 1.4, 3.4, 2.8]) == [1.0, 0.6666666666666667, 0.0, 0.4444444444444444, 0.3111111111111111]", "assert rescale_to_unit([3.1, 6.8, 5.3, 5.4, 5.5]) == [0.0, 1.0, 0.5945945945945945, 0.6216216216216217, 0.6486486486486487]", "assert rescale_to_unit([4.1, 51.2]) == [0.0, 1.0]", "assert rescale_to_unit([5.0, 3.8, 8.2, 3.9, 1.1]) == [0.5492957746478874, 0.38028169014084506, 1.0, 0.39436619718309857, 0.0]", "assert rescale_to_unit([1.9, 4.8, 3.2, 4.3, 1.4]) == [0.14705882352941177, 1.0, 0.5294117647058825, 0.8529411764705882, 0.0]", "assert rescale_to_unit([10.1, 12.6, 10.2, 16.8, 11.1]) == [0.0, 0.3731343283582089, 0.014925373134328302, 1.0, 0.14925373134328357]", "assert rescale_to_unit([4.6, 5.7, 10.7, 5.4, 4.4]) == [0.03174603174603164, 0.20634920634920637, 1.0, 0.15873015873015875, 0.0]", "assert rescale_to_unit([7.0, 52.8]) == [0.0, 1.0]", "assert rescale_to_unit([98.1, 46.8]) == [1.0, 0.0]", "assert rescale_to_unit([4.4, 50.9]) == [0.0, 1.0]", "assert rescale_to_unit([5.5, 46.2]) == [0.0, 1.0]", "assert rescale_to_unit([3.2, 2.1, 1.6, 6.4, 3.7]) == [0.3333333333333333, 0.10416666666666666, 0.0, 1.0, 0.43749999999999994]", "assert rescale_to_unit([7.0, 51.8]) == [0.0, 1.0]", "assert rescale_to_unit([102.9, 44.8]) == [1.0, 0.0]", "assert rescale_to_unit([3.3, 4.4, 8.8, 2.9, 1.7]) == [0.22535211267605632, 0.38028169014084506, 1.0, 0.16901408450704222, 0.0]", "assert rescale_to_unit([17.6, 14.9, 12.4, 9.6, 14.2]) == [1.0, 0.6625, 0.35000000000000003, 0.0, 0.5749999999999998]", "assert rescale_to_unit([102.4, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([12.3, 14.5, 18.1, 18.3, 10.4]) == [0.24050632911392408, 0.5189873417721518, 0.9746835443037976, 1.0, 0.0]", "assert rescale_to_unit([105.8, 45.3]) == [1.0, 0.0]", "assert rescale_to_unit([5.4, 1.8, 4.4, 7.7, 2.8]) == [0.6101694915254238, 0.0, 0.44067796610169496, 1.0, 0.16949152542372878]", "assert rescale_to_unit([3.7, 3.9, 1.2, 4.6, 7.1]) == [0.42372881355932207, 0.45762711864406785, 0.0, 0.5762711864406779, 1.0]", "assert rescale_to_unit([9.7, 13.8, 18.7, 15.3, 14.7]) == [0.0, 0.4555555555555557, 1.0, 0.6222222222222223, 0.5555555555555556]", "assert rescale_to_unit([17.6, 8.7, 12.8, 9.2, 17.0]) == [1.0, 0.0, 0.46067415730337086, 0.05617977528089886, 0.9325842696629212]", "assert rescale_to_unit([2.5, 4.4, 8.0, 3.4, 10.2]) == [0.0, 0.24675324675324684, 0.7142857142857143, 0.11688311688311688, 1.0]", "assert rescale_to_unit([2.3, 3.4, 7.0, 6.8, 4.4]) == [0.0, 0.23404255319148937, 1.0, 0.9574468085106382, 0.44680851063829796]", "assert rescale_to_unit([4.3, 4.4, 6.1, 8.4, 1.2]) == [0.43055555555555547, 0.4444444444444445, 0.6805555555555555, 1.0, 0.0]", "assert rescale_to_unit([7.3, 7.4, 16.1, 10.7, 18.0]) == [0.0, 0.009345794392523414, 0.8224299065420562, 0.3177570093457944, 1.0]", "assert rescale_to_unit([102.3, 47.4]) == [1.0, 0.0]"], "nl": " Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    ", "func": "def rescale_to_unit(numbers: List[float]) -> List[float]:", "examples": ">>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    ", "repair_prompt": ["def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1. Ensure that all transformed values maintain relative proportions to each other.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''", "def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given list of numbers (of at least two elements), apply a linear transform to that list. The smallest number will become 0, and the largest will become 1. Ensure that all transformed values maintain relative proportions to each other.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''", "def rescale_to_unit(numbers: List[float]) -> List[float]:\n'''Given list of numbers (of at least two elements), apply a linear transform so that the smallest number becomes 0 and the largest becomes 1, ensuring all transformed values maintain relative proportions to each other.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1. Ensure that all\n    transformed values maintain relative proportions to each other. If all elements are identical,\n    return a list of zeros.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    List[float]: A list of rescaled numbers between 0 and 1.\n    \"\"\"\n    # Identify the minimum and maximum values in the list\n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    # Check if all elements are identical\n    if min_value == max_value:\n        # Return a list of zeros if all elements are identical\n        return [0.0] * len(numbers)\n    \n    # Apply the linear transformation formula to each number in the list\n    transformed_values = [(num - min_value) / (max_value - min_value) for num in numbers]\n    \n    # Return the list of transformed values\n    return transformed_values\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transforms a list of numbers such that the smallest number becomes 0 and the largest becomes 1.\n    Maintains relative proportions of the numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers with at least two elements.\n\n    Returns:\n    List[float]: A list of rescaled numbers.\n    \"\"\"\n    # Check if all numbers are the same\n    if len(set(numbers)) == 1:\n        return [0.0] * len(numbers)\n    \n    # Identify the minimum and maximum values in the list\n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    # Calculate the range (difference between maximum and minimum)\n    range_val = max_val - min_val\n    \n    # Apply the transformation to each number in the list\n    return [(num - min_val) / range_val for num in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transforms a list of numbers to a unit scale where the smallest number becomes 0 and the largest becomes 1.\n    If all numbers are identical, returns a list of zeros.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers with at least two elements.\n\n    Returns:\n    List[float]: A list of numbers rescaled to the unit range [0, 1].\n    \"\"\"\n    # Check if all elements in the list are identical\n    if len(set(numbers)) == 1:\n        return [0.0] * len(numbers)\n    \n    # Identify the smallest and largest numbers in the list\n    min_num = min(numbers)\n    max_num = max(numbers)\n    \n    # Calculate the range of the list\n    range_num = max_num - min_num\n    \n    # Apply the linear transformation to each number in the list\n    return [(num - min_num) / range_num for num in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Rescale a list of numbers such that the smallest number becomes 0 and the largest becomes 1.\n    Maintain relative proportions of the numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    List[float]: A list of rescaled numbers.\n    \"\"\"\n    if not numbers:\n        return []\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # Handle the edge case where all numbers are the same\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n\n    # Apply the linear transformation\n    rescaled_numbers = [(number - min_value) / (max_value - min_value) for number in numbers]\n\n    return rescaled_numbers\n\n# Example usage\nif __name__ == \"__main__\":\n    example_list = [0.0, 1000000.0, -5.0, 5.0]\n    print(rescale_to_unit(example_list))  # Output: [0.0, 1.0, 0.0, 1.0]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Transforms a list of numbers such that the smallest number becomes 0 \n    and the largest becomes 1, maintaining relative proportions.\n\n    Args:\n        numbers (List[float]): A list of at least two float numbers.\n\n    Returns:\n        List[float]: A list of rescaled float numbers.\n\n    Raises:\n        ValueError: If the list contains fewer than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / (max_val - min_val) for x in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transforms a list of numbers to a unit range [0, 1].\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers with at least two elements.\n\n    Returns:\n    List[float]: A list of numbers rescaled to the range [0, 1].\n    \"\"\"\n    # Identify the smallest and largest numbers in the list\n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    # Handle the edge case where all numbers are identical\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    \n    # Apply the transformation formula to each number in the list\n    return [(num - min_value) / (max_value - min_value) for num in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transforms a list of numbers so that the smallest number becomes 0 and the largest becomes 1.\n    Maintains the relative proportions of the numbers.\n    \n    Parameters:\n    numbers (List[float]): A list of floating-point numbers with at least two elements.\n    \n    Returns:\n    List[float]: A list of rescaled floating-point numbers.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must contain at least two elements.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    # Handle the edge case where all elements are the same\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    \n    # Apply the linear transformation\n    rescaled_numbers = [\n        (num - min_value) / (max_value - min_value) for num in numbers\n    ]\n    \n    return rescaled_numbers\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given a list of numbers (of at least two elements), apply a linear transform so that the smallest number becomes 0\n    and the largest becomes 1, ensuring all transformed values maintain relative proportions to each other.\n\n    Args:\n        numbers: List of float numbers to be rescaled.\n\n    Returns:\n        List of rescaled float numbers.\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n\n    # Convert the list to a NumPy array for efficient computation\n    num_array = np.array(numbers)\n\n    # Calculate the minimum and maximum values of the list\n    min_value = np.min(num_array)\n    max_value = np.max(num_array)\n\n    # Handle the edge case where all elements are equal\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n\n    # Apply the linear transformation formula: (x - min) / (max - min)\n    rescaled_array = (num_array - min_value) / (max_value - min_value)\n\n    # Convert the NumPy array back to a list and return\n    return rescaled_array.tolist()\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Rescale a list of numbers so that the smallest number becomes 0 and the largest becomes 1.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        List[float]: A list of rescaled numbers.\n    \"\"\"\n    if not numbers:\n        return []\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # Handle the edge case where all elements are identical\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n\n    # Apply the linear transformation\n    rescaled_numbers = [(num - min_value) / (max_value - min_value) for num in numbers]\n\n    return rescaled_numbers\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transform a list of numbers to a unit scale where the smallest number becomes 0 and the largest becomes 1.\n    \n    Args:\n        numbers: List of float numbers.\n        \n    Returns:\n        List of float numbers rescaled between 0 and 1.\n    \"\"\"\n    if not numbers:\n        return []\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # Handle edge case where all elements are identical\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n\n    # Apply linear transformation\n    transformed_numbers = [(number - min_value) / (max_value - min_value) for number in numbers]\n    \n    return transformed_numbers\n"], "plans": ["requirement analysis:\nThe function should take a list of floats and apply a linear transformation to scale the values between 0 and 1. The smallest value should map to 0 and the largest to 1, maintaining the relative proportions of the original values. The function should handle lists with at least two elements and provide clear documentation for users.\nrequirement pool:\n- Implement the rescale_to_unit function to transform data as specified.\n- Ensure the function handles edge cases, such as lists with identical elements.\n- Provide comprehensive documentation and examples for users.\n- Optimize the function for performance with large datasets.\n- Include unit tests to verify the correctness of the function.\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and ease of use. The function will handle edge cases, such as lists with identical elements, by returning a list of zeros since the transformation is not meaningful in such cases. We will provide clear documentation and examples to guide users.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales and shifts numbers in a list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions of the other numbers.\n\n    'relative proportions'\n    Explanation: This means that the differences between numbers in the list should remain consistent after transformation.\n\n# [phrase showing quantity relationship]\n    'smallest number will become 0': This indicates that the minimum value in the list should be transformed to 0.\n    'largest will become 1': This indicates that the maximum value in the list should be transformed to 1.\n\n# [degree adverb]\n    'smallest': Refers to the minimum value in the list.\n    'largest': Refers to the maximum value in the list.\n\n# [code logic]\n1. Identify the minimum and maximum values in the list.\n2. If all elements are identical, return a list of zeros.\n3. For each number in the list, apply the transformation formula: \n   \\[\n   \\text{transformed\\_value} = \\frac{\\text{number} - \\text{min\\_value}}{\\text{max\\_value} - \\text{min\\_value}}\n   \\]\n4. Return the list of transformed values.\n\n# [edge case]\n    rescale_to_unit([5.0, 5.0, 5.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are identical, so transforming them results in a list of zeros.\n    \n    rescale_to_unit([1.0, 1.0, 2.0]) = [0.0, 0.0, 1.0]\n    Explanation: The smallest value is 1.0 and appears twice, so both instances are transformed to 0. The largest value is 2.0, which is transformed to 1.\n\n    rescale_to_unit([2.0, 3.0]) = [0.0, 1.0]\n    Explanation: The smallest value is 2.0 and is transformed to 0, while the largest value is 3.0 and is transformed to 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are identical.\n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    \n    return [(num - min_value) / (max_value - min_value) for num in numbers]\n```\n", "requirement analysis:\nThe function should efficiently transform a list of numbers such that the smallest number becomes 0 and the largest becomes 1, maintaining relative proportions. It should handle lists with at least two elements and optimize performance for larger datasets.\nrequirement pool:\n- Implement linear transformation to rescale numbers\n- Ensure relative proportions are maintained\n- Optimize for large datasets\n- Handle edge cases with minimum and maximum values\n- Provide clear documentation and examples\nWe will implement a simple function using Python's built-in capabilities to perform a linear transformation on a list of numbers. This will ensure that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions of the numbers. We will handle edge cases where all numbers are the same by returning a list of zeros. The function will be optimized for performance by using efficient list comprehensions.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales and shifts numbers in a list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative distances between numbers.\n\n    'relative proportions'\n    Explanation: This means that the differences between numbers in the original list should be preserved in the transformed list, just scaled to fit within the range from 0 to 1.\n\n# [phrase showing quantity relationship]\n    'at least two elements': This indicates that the input list must contain a minimum of two numbers for the transformation to be meaningful.\n\n# [degree adverb]\n    'smallest': This refers to the minimum value in the list, which will be transformed to 0.\n    'largest': This refers to the maximum value in the list, which will be transformed to 1.\n\n# [code logic]\n1. Identify the minimum and maximum values in the list.\n2. Calculate the range (difference between maximum and minimum).\n3. For each number in the list, apply the transformation: (number - minimum) / range.\n4. Return the transformed list.\n\n# [edge case]\n    rescale_to_unit([5.0, 5.0]) = [0.0, 0.0]\n    Explanation: All numbers are the same, so they are all transformed to 0.\n    \n    rescale_to_unit([1.0, 1.0, 2.0]) = [0.0, 0.0, 1.0]\n    Explanation: The smallest number is 1.0 and appears twice, both are transformed to 0, while 2.0 is transformed to 1.\n\n    rescale_to_unit([2.0, 3.0]) = [0.0, 1.0]\n    Explanation: The smallest number is 2.0 and is transformed to 0, while 3.0 is transformed to 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all numbers are the same.\n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(set(numbers)) == 1:\n        return [0.0] * len(numbers)\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    \n    return [(num - min_val) / range_val for num in numbers]\n```\n", "requirement analysis:\nThe function should efficiently transform a list of numbers to a unit scale, ensuring the smallest number becomes 0 and the largest becomes 1. It should maintain the relative proportions of the numbers and handle edge cases, such as lists with identical elements, gracefully.\nrequirement pool:\n- Implement the main rescaling function\n- Ensure the function handles edge cases\n- Provide comprehensive documentation\n- Optimize for performance with large datasets\n- Include unit tests for validation\nWe will implement a simple Python function that rescales a list of numbers to a unit range using basic arithmetic operations. This approach avoids the overhead of importing large libraries like NumPy or Pandas, making it lightweight and efficient for small to medium-sized datasets. The function will handle edge cases, such as lists with identical elements, by returning a list of zeros, as the transformation is not meaningful in such cases.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales the numbers in the list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions between the numbers.\n\n    'relative proportions'\n    Explanation: This means that the differences between the numbers should remain consistent after the transformation. If one number is twice as large as another before the transformation, it should remain twice as large after.\n\n# [phrase showing quantity relationship]\n    'at least two elements': This indicates that the input list must contain a minimum of two numbers for the transformation to be meaningful.\n\n# [degree adverb]\n    'smallest': This refers to the minimum value in the list, which should be transformed to 0.\n    \n    'largest': This refers to the maximum value in the list, which should be transformed to 1.\n\n# [code logic]\n1. Identify the smallest and largest numbers in the list.\n2. Calculate the range of the list by subtracting the smallest number from the largest.\n3. For each number in the list, apply the transformation: (number - smallest) / range.\n4. Return the transformed list.\n\n# [edge case]\n    rescale_to_unit([5.0, 5.0]) = [0.0, 0.0]\n    Explanation: Since all elements are identical, they are both the smallest and largest, resulting in a range of 0. The transformation is not meaningful, so we return a list of zeros.\n\n    rescale_to_unit([1.0, 1.0, 1.0]) = [0.0, 0.0, 0.0]\n    Explanation: Similar to the previous case, all elements are identical, resulting in a range of 0 and a list of zeros.\n\n    rescale_to_unit([1.0, 2.0]) = [0.0, 1.0]\n    Explanation: The smallest number is 1.0 and the largest is 2.0, so they are transformed directly to 0 and 1 respectively.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    \n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(set(numbers)) == 1:\n        return [0.0] * len(numbers)\n    \n    min_num = min(numbers)\n    max_num = max(numbers)\n    range_num = max_num - min_num\n    \n    return [(num - min_num) / range_num for num in numbers]\n```\n", "requirement analysis:\nThe function should accurately transform a list of numbers such that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions of the other numbers. It should be efficient enough to handle large datasets without compromising performance.\nrequirement pool:\n- Implement linear transformation to rescale numbers\n- Ensure smallest number becomes 0 and largest becomes 1\n- Maintain relative proportions of numbers\n- Optimize for performance with large datasets\n- Provide clear documentation and examples\nWe will implement a function that performs a linear transformation on a list of numbers using basic Python operations. The function will identify the minimum and maximum values in the list and apply a formula to rescale each number to a value between 0 and 1. This approach ensures that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions of the other numbers. We will use NumPy for efficient handling of large datasets, as it provides optimized operations for numerical computations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to the process of scaling the numbers in the list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions of the other numbers.\n\n# [phrase showing quantity relationship]\n    'smallest': The number with the lowest value in the list.\n    'largest': The number with the highest value in the list.\n    Implementation: Use Python's `min()` and `max()` functions to find these values.\n\n# [degree adverb]\n    'smallest': Indicates the minimum value in the list.\n    'largest': Indicates the maximum value in the list.\n    Implementation: Use `min()` to find the smallest and `max()` to find the largest.\n\n# [code logic]\n    1. Identify the minimum and maximum values in the list using `min()` and `max()`.\n    2. Apply the formula `(number - min_value) / (max_value - min_value)` to each number in the list to rescale it between 0 and 1.\n    3. Return the transformed list.\n\n# [edge case]\n    rescale_to_unit([1.0, 1.0]) = [0.0, 0.0]\n    Explanation: Both numbers are equal, so they are both transformed to 0.\n    \n    rescale_to_unit([0.0, 1000000.0]) = [0.0, 1.0]\n    Explanation: The smallest number becomes 0 and the largest becomes 1, maintaining relative proportions.\n    \n    rescale_to_unit([-5.0, 5.0]) = [0.0, 1.0]\n    Explanation: The transformation correctly handles negative numbers, scaling them between 0 and 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all numbers are equal.\n        if min_value == max_value:\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should accurately transform a list of numbers such that the smallest number becomes 0 and the largest becomes 1, maintaining relative proportions. It should handle lists with at least two elements and perform efficiently even with large datasets.\nrequirement pool:\n- Implement the rescale_to_unit function\n- Ensure the function handles edge cases\n- Optimize performance for large datasets\n- Include comprehensive documentation\n- Test the function with various datasets\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will calculate the minimum and maximum of the list, then apply a linear transformation to scale the numbers between 0 and 1. We will handle edge cases such as lists with identical elements by returning a list of zeros, as the transformation would be undefined otherwise. We will not use any external libraries to keep the function lightweight and easy to integrate.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales numbers in a list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions of the other numbers.\n\n# [phrase showing quantity relationship]\n    'at least two elements': This indicates that the input list must contain a minimum of two numbers to perform the transformation.\n    Implementation: Check if the length of the list is at least 2 before proceeding with the transformation.\n\n# [degree adverb]\n    'smallest': Refers to the minimum value in the list, which will be transformed to 0.\n    Implementation: Use Python's `min()` function to find this value.\n    \n    'largest': Refers to the maximum value in the list, which will be transformed to 1.\n    Implementation: Use Python's `max()` function to find this value.\n\n# [code logic]\n1. Check if the list has at least two elements.\n2. Find the minimum and maximum values in the list.\n3. If all elements are identical, return a list of zeros.\n4. Apply the linear transformation formula: `(x - min) / (max - min)` for each element `x` in the list.\n5. Return the transformed list.\n\n# [edge case]\n    rescale_to_unit([1.0, 1.0]) = [0.0, 0.0]\n    Explanation: All elements are identical, so they are transformed to zeros.\n\n    rescale_to_unit([0.0, 100.0]) = [0.0, 1.0]\n    Explanation: The smallest number (0.0) becomes 0, and the largest (100.0) becomes 1.\n\n    rescale_to_unit([5.0, 5.0, 5.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are identical, so they are transformed to zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    \n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / (max_val - min_val) for x in numbers]\n```\n", "requirement analysis:\nThe function should take a list of floats and apply a linear transformation such that the smallest number becomes 0 and the largest becomes 1. All other numbers should be proportionally adjusted. The function must handle at least two elements and maintain the relative proportions of the input numbers.\nrequirement pool:\n- Implement the rescale_to_unit function to transform data to a unit range.\n- Ensure the function handles edge cases, such as lists with identical elements.\n- Provide comprehensive documentation and examples for users.\n- Optimize the function for performance with large datasets.\n- Include unit tests to verify the correctness of the function.\nWe will implement a simple function using Python's built-in capabilities to rescale a list of numbers to a unit range. The function will handle edge cases such as lists with identical elements by returning a list of zeros, as the transformation is not meaningful in such cases. We will ensure the function is efficient and easy to use, with clear documentation provided.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales numbers in a list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions of the other numbers.\n\n    'relative proportions'\n    Explanation: This means that the differences between numbers in the original list should be preserved in the transformed list.\n\n# [phrase showing quantity relationship]\n    'smallest': Refers to the minimum value in the list.\n    'largest': Refers to the maximum value in the list.\n\n# [degree adverb] \n    'smallest': Indicates the minimum value in the list, which will be transformed to 0.\n    'largest': Indicates the maximum value in the list, which will be transformed to 1.\n\n# [code logic]\n1. Identify the smallest and largest numbers in the list.\n2. If all numbers are identical, return a list of zeros.\n3. For each number in the list, apply the transformation formula: \n   \\[\n   \\text{transformed\\_value} = \\frac{\\text{number} - \\text{min\\_value}}{\\text{max\\_value} - \\text{min\\_value}}\n   \\]\n4. Return the list of transformed values.\n\n# [edge case] \n    rescale_to_unit([5.0, 5.0, 5.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are identical, so transforming them results in a list of zeros.\n    \n    rescale_to_unit([1.0, 1.0, 2.0]) = [0.0, 0.0, 1.0]\n    Explanation: The smallest value is 1.0 and appears twice, so both are transformed to 0. The largest value is 2.0, transformed to 1.\n\n    rescale_to_unit([2.0, 3.0]) = [0.0, 1.0]\n    Explanation: The smallest value is 2.0 and is transformed to 0, while the largest value is 3.0 and is transformed to 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are identical.\n    \n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    \n    return [(num - min_value) / (max_value - min_value) for num in numbers]\n```\n", "requirement analysis:\nThe function should accurately transform a list of numbers such that the smallest number becomes 0 and the largest becomes 1, maintaining the relative proportions of the numbers. It should handle lists with at least two elements and perform efficiently even with large datasets.\nrequirement pool:\n- Implement the rescale_to_unit function\n- Ensure the function handles edge cases\n- Optimize performance for large datasets\n- Provide comprehensive documentation\n- Include unit tests for validation\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will calculate the minimum and maximum of the list, then apply a linear transformation to rescale the numbers. We will handle edge cases such as lists with negative numbers and zeros by ensuring the transformation logic is robust. NumPy is not necessary for this task as the operations are straightforward and can be efficiently handled with basic Python.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to the process of scaling the numbers in the list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions between all numbers.\n\n# [phrase showing quantity relationship]\n    'smallest number becomes 0': This means that the minimum value in the list will be transformed to 0.\n    'largest becomes 1': This means that the maximum value in the list will be transformed to 1.\n\n# [degree adverb]\n    'smallest': Refers to the minimum value in the list.\n    'largest': Refers to the maximum value in the list.\n\n# [code logic]\n    1. Calculate the minimum and maximum values of the list.\n    2. Apply the linear transformation formula: transformed_value = (original_value - min_value) / (max_value - min_value).\n    3. Return the list of transformed values.\n\n# [edge case]\n    rescale_to_unit([0.0, 0.0, 0.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are the same, so they all transform to 0.\n    \n    rescale_to_unit([1.0, 1.0, 2.0]) = [0.0, 0.0, 1.0]\n    Explanation: The smallest value is 1.0, which transforms to 0, and the largest is 2.0, which transforms to 1.\n    \n    rescale_to_unit([-1.0, 0.0, 1.0]) = [0.0, 0.5, 1.0]\n    Explanation: The smallest value is -1.0, which transforms to 0, and the largest is 1.0, which transforms to 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n        if min_value == max_value:\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should accurately transform a list of numbers such that the smallest number becomes 0 and the largest becomes 1, maintaining the relative proportions of the numbers. It should be efficient and handle large datasets without performance degradation.\nrequirement pool:\n- Implement the rescale_to_unit function\n- Ensure the function maintains relative proportions\n- Optimize for performance with large datasets\n- Include error handling for invalid inputs\n- Provide documentation and examples\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will calculate the minimum and maximum values of the list and apply a linear transformation to rescale the numbers. We will use NumPy for efficient handling of large datasets, as it provides optimized operations for numerical data.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to the process of adjusting the values in the list so that they fit within a specified range (0 to 1 in this case) while maintaining their relative proportions.\n\n# [phrase showing quantity relationship]\n    'smallest number becomes 0': This means that the minimum value in the list will be transformed to 0.\n    'largest becomes 1': This means that the maximum value in the list will be transformed to 1.\n\n# [degree adverb] \n    'smallest': Refers to the minimum value in the list.\n    'largest': Refers to the maximum value in the list.\n\n# [code logic]\n    1. Calculate the minimum and maximum values of the list.\n    2. Apply the linear transformation formula: (x - min) / (max - min) for each element x in the list.\n    3. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([1.0, 1.0]) = [0.0, 0.0]\n    Explanation: Both elements are equal, so they are both transformed to 0.\n    \n    rescale_to_unit([5.0, 5.0, 5.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are equal, so they are all transformed to 0.\n    \n    rescale_to_unit([1.0, 2.0]) = [0.0, 1.0]\n    Explanation: The smallest number (1.0) becomes 0 and the largest number (2.0) becomes 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are equal.\n        if min_value == max_value:\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should accurately transform a list of numbers such that the smallest number becomes 0 and the largest becomes 1, maintaining the relative proportions of the numbers. It should be efficient and handle large datasets without performance degradation.\nrequirement pool:\n- Implement the rescale_to_unit function\n- Ensure the function handles edge cases like negative numbers\n- Optimize for performance with large datasets\n- Include error handling for invalid inputs\n- Provide documentation and examples for users\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will calculate the minimum and maximum values of the list and apply a linear transformation to rescale the numbers. We will use NumPy for handling large datasets efficiently, as it provides optimized operations for numerical data.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to the process of applying a mathematical operation to each element in the list to change its scale while maintaining the relative proportions between elements.\n\n    'relative proportions'\n    Explanation: This means that after transformation, the ratio between any two numbers in the list should remain the same as before the transformation.\n\n# [phrase showing quantity relationship]\n    'smallest': The smallest number in the list should be transformed to 0.\n    'largest': The largest number in the list should be transformed to 1.\n\n# [degree adverb]\n    'smallest': Refers to the minimum value in the list.\n    'largest': Refers to the maximum value in the list.\n\n# [code logic]\n    1. Calculate the minimum and maximum values of the list.\n    2. Apply the linear transformation formula: transformed_value = (original_value - min_value) / (max_value - min_value).\n    3. Return the transformed list.\n\n# [edge case]\n    rescale_to_unit([1.0, 1.0]) = [0.0, 0.0]\n    Explanation: Both numbers are the same, so they are both transformed to 0.\n    \n    rescale_to_unit([0.0, 5.0]) = [0.0, 1.0]\n    Explanation: The smallest number is 0 and the largest is 5, so they are transformed to 0 and 1 respectively.\n    \n    rescale_to_unit([-5.0, -1.0]) = [0.0, 1.0]\n    Explanation: The smallest number is -5 and the largest is -1, so they are transformed to 0 and 1 respectively.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n        if min_value == max_value:\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should efficiently transform a list of numbers to a unit scale, ensuring the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions of the numbers. It should handle edge cases such as lists with identical elements or very large datasets.\nrequirement pool:\n- Implement linear transformation to unit scale\n- Ensure performance optimization for large datasets\n- Handle edge cases gracefully\n- Provide clear documentation and examples\n- Integrate with existing data analysis tools\nWe will implement a function that performs a linear transformation on a list of numbers to rescale them between 0 and 1. The function will use basic Python operations to ensure simplicity and efficiency. We will handle edge cases such as lists with identical elements by returning a list of zeros, as the transformation would not be meaningful otherwise. For performance optimization, we will ensure the function operates in O(n) time complexity, suitable for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to the process of scaling the numbers in the list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative proportions between the numbers.\n\n# [phrase showing quantity relationship]\n    'smallest': This indicates that we need to identify the minimum value in the list.\n    'largest': This indicates that we need to identify the maximum value in the list.\n\n# [degree adverb]\n    'smallest': Refers to the minimum value in the list.\n    'largest': Refers to the maximum value in the list.\n\n# [code logic]\n    1. Identify the smallest and largest numbers in the list.\n    2. If all numbers are identical, return a list of zeros.\n    3. Apply the linear transformation formula: (number - min) / (max - min) for each number in the list.\n    4. Return the transformed list.\n\n# [edge case]\n    rescale_to_unit([5.0, 5.0, 5.0]) = [0.0, 0.0, 0.0]\n    Explanation: Since all elements are identical, the transformation results in a list of zeros.\n    \n    rescale_to_unit([1.0, 1.0, 2.0]) = [0.0, 0.0, 1.0]\n    Explanation: The smallest number is 1.0 and the largest is 2.0, so 1.0 transforms to 0 and 2.0 transforms to 1.\n    \n    rescale_to_unit([2.0, 3.0]) = [0.0, 1.0]\n    Explanation: The smallest number is 2.0 and the largest is 3.0, so 2.0 transforms to 0 and 3.0 transforms to 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n        if min(numbers) == max(numbers):\n            return [0.0] * len(numbers)\n        (other code)\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [130, 130, 130, 130, 130, 130, 130, 130, 130, 130], "completion": "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transform a list of numbers to a unit scale where the smallest number becomes 0 and the largest becomes 1.\n    \n    Args:\n        numbers: List of float numbers.\n        \n    Returns:\n        List of float numbers rescaled between 0 and 1.\n    \"\"\"\n    if not numbers:\n        return []\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # Handle edge case where all elements are identical\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n\n    # Apply linear transformation\n    transformed_numbers = [(number - min_value) / (max_value - min_value) for number in numbers]\n    \n    return transformed_numbers\n", "passed": true, "pass": true, "pass_num": 10, "round": 918, "mutate_method": "add_1_sentence_at_end", "parent_index": 19}
