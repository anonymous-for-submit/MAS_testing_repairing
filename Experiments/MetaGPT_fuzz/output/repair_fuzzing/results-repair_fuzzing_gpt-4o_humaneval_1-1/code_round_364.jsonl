{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix. However, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Furthermore, ensure that the coordinates within each row are sorted by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "repair_prompt": ["def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix. However, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Furthermore, ensure that the coordinates within each row are sorted by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "```python\ndef get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix. However, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list. Return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Furthermore, ensure that the coordinates within each row are sorted by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''\n```", "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, but each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Furthermore, ensure that the coordinates within each row are sorted by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds all occurrences of the integer x in a nested list (matrix) and returns their coordinates.\n\n    Args:\n        lst: A nested list of integers representing the matrix.\n        x: An integer to find within the matrix.\n\n    Returns:\n        A list of tuples, where each tuple contains the row and column indices of occurrences of x,\n        sorted by row in ascending order and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row of the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append its coordinate (row, column) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Parameters:\n    lst: A list of lists where each sublist represents a row of integers.\n    x: An integer to find within the nested list.\n    \n    Returns:\n    A list of tuples, where each tuple contains the row and column indices of occurrences of x,\n    sorted by row in ascending order and by column in descending order within each row.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # Check if the current element is equal to x\n            if value == x:\n                # Record the coordinate as a tuple (row_index, col_index)\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates first by row index in ascending order\n    # and then by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate the positions of integer x in a nested list structure.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of x, \n    sorted by row in ascending order and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using an index to keep track of the column number\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the coordinates list first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integer positions in nested lists.\n\n    Parameters:\n    lst (list[list[int]]): A 2D list where each sublist represents a row.\n    x (int): The integer to locate within the nested lists.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates (row, column) of the integer x,\n    sorted by row in ascending order and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If the element matches the given integer x, append its coordinate to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Locate positions of integer x in a nested list structure.\n\n    Parameters:\n    lst (List[List[int]]): A 2D list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates (row, column) of integer x,\n    sorted by row in ascending order and column in descending order.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_index, element in enumerate(row):\n            # Check if the element matches x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates: first by row index in ascending order,\n    # then by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integer positions in nested lists.\n\n    Parameters:\n    lst (list[list[int]]): A 2D list where each sublist represents a row.\n    x (int): The integer to locate within the nested lists.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates (row, column) of the integer x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through the elements using an index to keep track of the column number\n        for column_index, element in enumerate(row):\n            # If an element matches the integer x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the coordinates list first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Given a 2D list 'lst' and an integer 'x', return a list of tuples representing the coordinates of 'x' in the list.\n    Each tuple is a coordinate (row, column), starting with 0.\n    The coordinates are sorted by rows in ascending order and columns in descending order.\n    \n    Args:\n        lst: A 2D list of integers representing the matrix.\n        x: An integer to find within the matrix.\n    \n    Returns:\n        A list of tuples where each tuple contains the row and column indices of occurrences of 'x'.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of occurrences of the integer x.\n    coordinates = []\n\n    # Iterate through each row of the matrix using an index to keep track of the row number.\n    for row_index, row in enumerate(lst):\n        # For each row, iterate through each element using an index to keep track of the column number.\n        for col_index, element in enumerate(row):\n            # If the element matches x, append the tuple (row_index, column_index) to the list.\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of tuples first by row in ascending order and then by column in descending order.\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of tuples.\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate integer positions in nested lists.\n\n    Parameters:\n    lst (list[list[int]]): A 2D list where each sublist represents a row.\n    x (int): The integer to locate within the nested lists.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of the integer.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of integer x\n    coordinates = []\n\n    # Iterate through each row in the 2D list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # Check if the element matches x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate the positions of integer x in a nested list structure.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row of the matrix.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples where each tuple contains the row and column indices of x,\n    sorted by row in ascending order and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using an index to keep track of the column number\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append a tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the coordinates list first by row index in ascending order and then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate the positions of integer x in a nested list structure.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of x, \n    sorted by row in ascending order and by column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using its index\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of coordinates first by row index in ascending order\n    # and then by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n"], "plans": ["requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring results are sorted by row and column as described. It must handle varying row lengths and empty matrices without errors.\nrequirement pool:\n- Implement the main function to find coordinates of a given integer.\n- Ensure sorting of results by row and column as specified.\n- Handle varying row lengths in the input matrix.\n- Optimize performance for large datasets.\n- Provide clear error handling for empty matrices.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will store the coordinates as a tuple. The results will be sorted first by row in ascending order and then by column in descending order. We will use Python's built-in sorting capabilities to achieve this. The function will handle empty matrices and varying row lengths gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, where each row can have a different number of columns. This is represented as nested lists in Python.\n\n    'coordinate'\n    Explanation: A coordinate in this context refers to a tuple indicating the position of an element in the 2D structure, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting the rows from smallest to largest index.\n    'descending order': means sorting the columns from largest to smallest index within each row.\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row of the nested list using an index to track the row number.\n    3. For each row, iterate through its elements using an index to track the column number.\n    4. If an element matches the integer x, append its coordinate (row, column) to the list.\n    5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n    6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input is an empty list, so there are no elements to find, resulting in an empty output list.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2), so the output is a single tuple with this coordinate.\n\n    get_row([[1, 1], [1, 1]], 1) = [(0, 1), (0, 0), (1, 1), (1, 0)]\n    Explanation: The integer 1 appears multiple times across different rows and columns. The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths gracefully.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle edge cases like empty lists and varying row lengths.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of output by row and column as specified.\n- Handle edge cases such as empty lists and varying row lengths.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will record the coordinates as a tuple. The function will then sort these tuples first by row in ascending order and then by column in descending order. We will use Python's built-in list and tuple data structures for simplicity and efficiency, as they are well-suited for this task. The function will handle edge cases such as empty lists and varying row lengths gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, where each row can have a different number of columns. This is represented using nested lists in Python.\n\n    'coordinate'\n    Explanation: A coordinate in this context refers to a tuple (row, column) indicating the position of an integer within the 2D data structure.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order', 'descending order'\n    Explanation: 'Ascending order' means sorting from smallest to largest, while 'descending order' means sorting from largest to smallest. In this requirement, rows are sorted in ascending order, and columns within each row are sorted in descending order.\n\n# [code logic]\n    - Iterate through each row of the nested list.\n    - For each row, iterate through its elements to find occurrences of the integer x.\n    - Record the coordinates (row index, column index) for each occurrence.\n    - Sort the list of coordinates first by row index in ascending order.\n    - Within each row, sort the coordinates by column index in descending order.\n    - Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no occurrences of the integer 1, resulting in an empty list of coordinates.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2), so the expected output is a single tuple with this coordinate.\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The integer 1 appears at positions (0, 0), (0, 1), and (1, 0). After sorting by rows and then by columns within each row, the expected output is [(0, 1), (0, 0), (1, 0)].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths gracefully.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle edge cases like empty lists gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of output by rows and columns as specified.\n- Optimize performance for large datasets.\n- Handle edge cases such as empty lists.\n- Provide clear documentation and examples.\nWe will implement a function that iterates over each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will record the coordinates as a tuple. The function will then sort these tuples first by row in ascending order and then by column in descending order. We will use Python's built-in list and tuple data structures for simplicity and efficiency, as they are well-suited for this task. The function will handle edge cases such as empty lists by returning an empty list immediately.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': This refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D data, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'descending': This indicates that within each row, the column indices should be sorted from highest to lowest.\n    'ascending': This indicates that the row indices should be sorted from lowest to highest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate over each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the tuple (row_index, column_index) to the coordinates list.\n5. Sort the coordinates list first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (1, 0), (2, 1)]\n    Explanation: The integer 1 is found at (0, 0), (1, 0), and (2, 1). The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles empty lists and varying row lengths appropriately.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle edge cases like empty lists and varying row lengths gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of output by rows and columns as specified.\n- Handle edge cases such as empty lists and varying row lengths.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using Python's built-in list operations to efficiently locate and return the positions of a specified integer within a nested list structure. The function will handle edge cases like empty lists and varying row lengths gracefully. Sorting will be done using Python's sorted function, which is efficient for small to medium-sized datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a nested list structure where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the nested list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Means sorting from smallest to largest.\n    'descending order': Means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using its index.\n3. For each row, iterate through each element using its index.\n4. If the element matches the given integer x, append its coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (2, 2), (2, 0)]\n    Explanation: The integer 1 is found at coordinates (0, 0), (2, 2), and (2, 0). The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths gracefully.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and then by column in descending order. It must handle varying row lengths and empty datasets gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions.\n- Ensure the function handles empty lists without errors.\n- Optimize sorting to maintain performance with large datasets.\n- Include comprehensive test cases for various input scenarios.\n- Document the function with clear usage examples.\nWe will implement a function using Python's built-in capabilities to efficiently locate integer positions within a nested list structure. The function will handle varying row lengths and empty datasets gracefully. We will use list comprehensions and sorting methods to ensure performance and clarity. No external libraries are required for this task, as Python's native functionalities are sufficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'nested lists'\n    Explanation: The requirement involves working with a 2-dimensional data structure where each sublist represents a row, similar to a matrix but with varying column counts.\n\n    'coordinate'\n    Explanation: The task is to return the positions of integer x in the form of tuples representing (row, column) indices.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting the rows in increasing order based on their indices.\n    'descending order': means sorting the columns within each row in decreasing order based on their indices.\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate over each row in the nested list using its index.\n    3. For each row, iterate over each element using its index.\n    4. If the element matches x, append the tuple (row_index, column_index) to the coordinates list.\n    5. Sort the coordinates list first by row index in ascending order.\n    6. Within each row, sort the column indices in descending order.\n    7. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty output list.\n    \n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found only in the third row at column index 2, resulting in a single coordinate tuple.\n\n    get_row([[1, 1], [1, 1]], 1) = [(0, 1), (0, 0), (1, 1), (1, 0)]\n    Explanation: The integer 1 appears multiple times across two rows. The coordinates are sorted by rows first and then by columns within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through rows and columns and sorting the results will naturally handle these scenarios.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring that the output is sorted by row and column as specified. It must handle varying row lengths and empty lists gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure the function handles empty lists without errors.\n- Optimize sorting to maintain performance with large datasets.\n- Include comprehensive test cases for various input scenarios.\n- Document the function with clear usage examples.\nWe will implement a function using native Python capabilities to efficiently locate integer positions in nested lists. The function will handle varying row lengths and empty lists gracefully. Sorting will be optimized using Python's built-in sorting capabilities to ensure performance with large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'nested lists'\n    Explanation: The requirement involves working with a 2D data structure where each row can have a different number of columns, similar to a matrix but not strictly uniform in shape.\n\n    'coordinate'\n    Explanation: The output should be a list of tuples representing the position of the integer x in the form (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order'\n    Explanation: The coordinates should be sorted by rows in increasing order.\n\n    'descending order'\n    Explanation: Within each row, the coordinates should be sorted by columns in decreasing order.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate through the elements using an index to keep track of the column number.\n4. If an element matches the integer x, append the tuple (row_index, column_index) to the coordinates list.\n5. Sort the coordinates list first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no coordinates to return.\n\n    get_row([[1]], 2) = []\n    Explanation: The integer 2 does not exist in the list, so there are no coordinates to return.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 does not exist in any row, so there are no coordinates to return.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles cases where the integer x is not found or when the input list is empty.\n", "requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a matrix-like structure, ensuring results are sorted by row and column as described. It must handle varying row lengths and empty matrices without errors.\nrequirement pool:\n- Implement the main function to find coordinates of the integer.\n- Ensure sorting of results by row and column as specified.\n- Handle matrices with varying row lengths.\n- Optimize performance for large datasets.\n- Provide clear error handling for empty matrices.\nWe will implement a function that iterates through each row of the matrix, checking for the presence of the target integer. For each occurrence, we will store the coordinates in a list of tuples. The list will then be sorted first by row in ascending order and then by column in descending order. We will use Python's built-in sorting capabilities to achieve this efficiently. The function will handle empty matrices gracefully by returning an empty list if no occurrences are found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the matrix, given as (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Means sorting from smallest to largest.\n    'descending order': Means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates of occurrences of the integer x.\n2. Iterate through each row of the matrix using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches x, append the tuple (row_index, column_index) to the list.\n5. Sort the list of tuples first by row in ascending order and then by column in descending order.\n6. Return the sorted list of tuples.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The matrix is empty, so there are no occurrences of 1, resulting in an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no occurrences of 1, resulting in an empty list.\n    \n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (1, 0), (2, 1)]\n    Explanation: The integer 1 appears at (0, 0), (1, 0), and (2, 1). The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty matrices and varying row lengths gracefully.\n", "requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle varying row lengths and empty lists gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of coordinates by row and column as specified.\n- Optimize performance for large datasets.\n- Handle edge cases such as empty lists or rows.\n- Provide clear documentation and examples.\nWe will implement a function using native Python lists to handle nested lists efficiently. The function will iterate through each row and column to find the specified integer, storing its coordinates. Sorting will be done using Python's built-in sorting capabilities, ensuring the output is sorted by rows in ascending order and columns in descending order. This approach leverages Python's simplicity and efficiency for handling irregular matrices without the need for complex libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D data, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Means sorting from smallest to largest.\n    'descending order': Means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates of integer x.\n2. Iterate through each row in the 2D list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no coordinates to return.\n    \n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The number 3 appears only once at position (2, 2), so it is the only coordinate returned.\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The number 1 appears at positions (0, 0), (0, 1), and (1, 0). The coordinates are sorted by row and then by column in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and sorting the coordinates will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle edge cases like empty lists and varying row lengths gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure the output is sorted by rows in ascending order and columns in descending order.\n- Handle edge cases such as empty lists and varying row lengths.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will record the coordinates as a tuple (row_index, column_index). After collecting all coordinates, we will sort them first by row index in ascending order and then by column index in descending order. This approach leverages Python's built-in list capabilities, which are efficient for this type of task, and avoids the overhead of more complex libraries like NumPy or Pandas.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': This refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D data, with the format (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'descending': This means that within each row, the column indices should be sorted from highest to lowest.\n    'ascending': This means that the row indices should be sorted from lowest to highest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches the integer x, append a tuple (row_index, column_index) to the coordinates list.\n5. Sort the coordinates list first by row index in ascending order and then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list of coordinates.\n    \n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found at row index 2 and column index 2. Since there are no other occurrences, this is the only coordinate returned.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 does not exist in any of the rows, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles cases where the list is empty or where the integer x is not found.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle edge cases such as empty lists and varying row lengths.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of output by rows and columns as specified.\n- Handle edge cases like empty lists and varying row lengths.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will record the coordinates as a tuple (row_index, column_index). After collecting all coordinates, we will sort them first by row index in ascending order and then by column index in descending order. The function will handle edge cases such as empty lists and varying row lengths by simply returning an empty list if no occurrences are found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D data, given as (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Sorts from smallest to largest.\n    'descending order': Sorts from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using its index.\n3. For each row, iterate through each element using its index.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row index in ascending order.\n6. Within each row, sort the coordinates by column index in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (1, 0), (2, 1)]\n    Explanation: The integer 1 is found at (0, 0), (1, 0), and (2, 1). The coordinates are sorted by row index in ascending order and by column index in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles empty lists and varying row lengths by iterating through all elements and returning an empty list if no matches are found.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 87, 87, 87, 87], "completion": "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate the positions of integer x in a nested list structure.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of x, \n    sorted by row in ascending order and by column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using its index\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of coordinates first by row index in ascending order\n    # and then by column index in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "passed": true, "pass": true, "pass_num": 10, "round": 364, "mutate_method": "expand_one2two", "parent_index": 75}
