{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list. Iterate through the list to locate all occurrences of the integer x. And return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "repair_prompt": ["def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list. Iterate through the list to locate all occurrences of the integer x. And return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list. Iterate through the list to locate all occurrences of the integer x. You should then compile a list of tuples to represent all found coordinates. And return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "def get_row(lst, x):\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns; given lst, and integer x, find integers x in the list. Iterate through the list to locate all occurrences of the integer x and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"Locate all occurrences of integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists containing integers.\n        x: The integer to locate within the nested lists.\n\n    Returns:\n        A list of tuples representing the coordinates (row, column) of each occurrence of x.\n        The list is sorted by rows in ascending order and columns in descending order.\n    \"\"\"\n    coordinates = []\n\n    # Iterate through each row in the 2D list\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row, column) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row in ascending order and column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists containing integers.\n        x: The integer to locate.\n\n    Returns:\n        A list of tuples representing the coordinates (row, column) of each occurrence of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row and column in the nested list\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            # If the integer x is found, append its coordinates to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order,\n    # then by column index in descending order\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return sorted_coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list and return their coordinates.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of x, \n    sorted by row ascending and column descending.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element is equal to x\n            if element == x:\n                # Append the coordinate as a tuple (row_index, col_index)\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates first by row index in ascending order\n    # and then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists where each sublist represents a row of integers.\n        x: The integer to locate within the nested list.\n\n    Returns:\n        A list of tuples, each representing the coordinates (row, column) of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row of the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # For each row, iterate through each element using an index to keep track of the column number\n        for column_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate (row_index, column_index) to the list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists containing integers.\n        x: The integer to locate.\n\n    Returns:\n        A list of tuples representing the coordinates of occurrences of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of occurrences of integer x\n    coordinates = []\n\n    # Iterate through each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # For each row, iterate through each element using an index to keep track of the column number\n        for column_index, element in enumerate(row):\n            # If the element matches x, append the tuple (row_index, column_index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the coordinates list first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list lst.\n\n    Args:\n        lst: A list of lists where each sublist represents a row of varying lengths.\n        x: The integer to locate within the nested list.\n\n    Returns:\n        A list of tuples, each representing the coordinates (row, column) of x,\n        sorted by row in ascending order and by column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Within each row, iterate through each element using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the tuple (row index, column index) to the coordinates list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates list first by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"Locate all occurrences of integer x in a nested list and return a list of tuples representing the coordinates.\n\n    Args:\n        lst: A list of lists where each sublist represents a row of varying lengths.\n        x: The integer to locate within the nested list.\n\n    Returns:\n        A list of tuples, each representing the (row, column) coordinates of x, sorted by row ascending and column descending.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_index, element in enumerate(row):\n            # Check if the current element matches x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates first by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list and return their coordinates.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row.\n    x (int): The integer to find in the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of x, sorted by row and column as specified.\n    \"\"\"\n    # Initialize an empty list to store the coordinates of occurrences of integer x\n    coordinates = []\n\n    # Iterate through each row of the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # For each row, iterate through each element using an index to keep track of the column number\n        for column_index, element in enumerate(row):\n            # If the current element equals x, append a tuple (row_index, column_index) to the list of coordinates\n            if element == x:\n                coordinates.append((row_index, column_index))\n\n    # Sort the list of tuples first by row in ascending order and then by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list and return sorted coordinates.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples representing the coordinates of x, \n    sorted by row in ascending order and column in descending order.\n    \"\"\"\n    coordinates = []\n\n    # Iterate through each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row with its index\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists containing integers.\n        x: The integer to locate.\n\n    Returns:\n        A list of tuples representing the coordinates of occurrences of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the 2D list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append its coordinate\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order,\n    # then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n\n# Example usage:\n# print(get_row([[1, 1], [1]], 1))  # Output: [(0, 1), (0, 0), (1, 0)]\n# print(get_row([[], [1], [1, 2, 3]], 3))  # Output: [(2, 2)]\n# print(get_row([], 1))  # Output: []\n"], "plans": ["requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle edge cases like empty lists and varying row lengths.\nrequirement pool:\n- Implement the main function to locate integer x in nested lists.\n- Ensure the output is sorted by rows in ascending order and columns in descending order.\n- Handle edge cases such as empty lists and varying row lengths.\n- Optimize performance for large datasets.\n- Provide clear documentation and examples.\nWe will implement a function using native Python lists to efficiently locate and return the coordinates of a specified integer within a nested list structure. The function will handle edge cases like empty lists and varying row lengths, and sort the output as required. Python's built-in sorting capabilities will be utilized to achieve the desired order of coordinates.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship.\n\n# [degree adverb]\n    'descending': Indicates that within each row, the column indices should be sorted from highest to lowest.\n    'ascending': Indicates that the row indices should be sorted from lowest to highest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the 2D list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to search for, resulting in an empty list of coordinates.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found at row 2, column 2. Since there are no other occurrences, the result is a single coordinate.\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The integer 1 is found at multiple positions. The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty lists and varying row lengths.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle varying row lengths and empty lists gracefully.\nrequirement pool:\n- Implement the main function to locate integer positions in nested lists.\n- Ensure sorting of output by row in ascending order and column in descending order.\n- Optimize performance for large datasets.\n- Handle edge cases such as empty lists and varying row lengths.\n- Provide clear documentation and examples.\nWe will implement a function using Python's built-in list operations to efficiently locate integer positions in nested lists. The function will iterate through each row and column, collecting coordinates of the specified integer. Sorting will be handled using Python's sorted function, ensuring the output is sorted by row in ascending order and column in descending order. This approach leverages Python's native capabilities for simplicity and performance.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, where each row can have a different number of columns. This is represented using nested lists in Python.\n\n    'coordinate'\n    Explanation: The requirement asks for the positions of the integer x in the form of coordinates, which are tuples indicating the row and column indices.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order', 'descending order'\n    Explanation: The coordinates need to be sorted first by rows in ascending order, and then by columns in descending order within each row.\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row and column in the nested list.\n    3. If the integer x is found, append its coordinates (row index, column index) to the list.\n    4. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n    5. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no occurrences of the integer x, resulting in an empty list.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2), so the expected output is a list with this single coordinate.\n\n    get_row([[1, 1], [1, 1]], 1) = [(0, 1), (0, 0), (1, 1), (1, 0)]\n    Explanation: The integer 1 appears multiple times across different rows and columns. The coordinates are sorted by rows in ascending order and columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and sorting the coordinates will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It should handle varying row lengths and empty lists gracefully.\nrequirement pool:\n- Implement the main function to locate integer occurrences.\n- Ensure sorting of results by row and column.\n- Optimize performance for large datasets.\n- Handle edge cases like empty lists.\n- Provide detailed documentation and examples.\nWe will implement a function that iterates through each row of the nested list, checking for occurrences of the specified integer. For each occurrence, we will store the coordinates as a tuple in a list. After collecting all coordinates, we will sort the list first by row in ascending order and then by column in descending order. Python's built-in list and tuple data structures will be used for simplicity and efficiency. No additional libraries are needed as the task is straightforward and does not require complex data manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'nested lists'\n    Explanation: The requirement involves working with a 2-dimensional data structure, where each sublist represents a row, similar to a matrix but with varying column counts.\n\n    'coordinate'\n    Explanation: The output should be a list of tuples representing the position of the integer x in the nested list, with each tuple containing the row and column indices.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb]\n    'ascending order'\n    Explanation: The coordinates should be sorted by rows in increasing order, meaning from the smallest row index to the largest.\n\n    'descending order'\n    Explanation: Within each row, the coordinates should be sorted by columns in decreasing order, meaning from the largest column index to the smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using a loop.\n3. For each row, iterate through its elements to find occurrences of the integer x.\n4. If x is found, append a tuple (row_index, column_index) to the coordinates list.\n5. After collecting all coordinates, sort the list first by row index in ascending order and then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no occurrences of x, resulting in an empty output list.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2), so the output is a single tuple with this coordinate.\n\n    get_row([[1, 1], [1], [1, 2]], 1) = [(0, 1), (0, 0), (1, 0), (2, 0)]\n    Explanation: The integer 1 appears multiple times across different rows. The output is sorted first by row index and then by column index within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and sorting the coordinates will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently locate all occurrences of a specified integer within a nested list structure, handling varying row lengths. The output must be sorted by row in ascending order and by column in descending order within each row.\nrequirement pool:\n- Accurate identification of integer occurrences\n- Efficient handling of varying row lengths\n- Sorting output by row and column\n- Optimizing performance for large datasets\n- User-friendly output format\nWe will implement a function that iterates through each row and column of the nested list to find occurrences of the specified integer. We will then store the coordinates in a list of tuples. The list will be sorted first by row in ascending order and then by column in descending order. Python's built-in list and tuple data structures will be used for simplicity and efficiency, as they are well-suited for handling non-uniform row lengths.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data'\n    Explanation: This refers to a list of lists, where each sublist represents a row, similar to a matrix but with potentially varying numbers of columns.\n\n    'coordinates'\n    Explanation: A tuple representing the position of an element in the 2D list, with the format (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'descending'\n    Explanation: When sorting the coordinates by columns, they should be ordered from highest to lowest within each row.\n\n    'ascending'\n    Explanation: When sorting the coordinates by rows, they should be ordered from lowest to highest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row of the nested list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list of coordinates.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found at row 2, column 2. Since there are no other occurrences, the result is a single coordinate.\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The integer 1 is found at multiple positions. The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty lists and varying row lengths.\n", "requirement analysis:\nThe function should efficiently locate all occurrences of a given integer in a nested list structure, ensuring that the output is sorted by row and column as specified. It must handle varying row lengths and return results in a clear format.\nrequirement pool:\n- Implement the main function to locate integer occurrences.\n- Ensure sorting of results by row and column.\n- Optimize for performance with large datasets.\n- Handle edge cases such as empty lists.\n- Provide comprehensive documentation and examples.\nWe will implement a function using native Python lists to efficiently locate occurrences of a given integer in a nested list structure. The function will iterate through each row and column, compile a list of coordinates, and sort them as specified. Python's built-in sorting capabilities will be utilized to ensure the output is sorted by row in ascending order and by column in descending order. This approach leverages Python's flexibility with lists and avoids unnecessary complexity from external libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a nested list structure where each sublist represents a row, similar to a matrix.\n    'coordinates': Refers to the position of an element in the nested list, represented as a tuple (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'descending': Indicates that the columns within each row should be sorted from highest to lowest.\n    'ascending': Indicates that the rows should be sorted from lowest to highest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates of occurrences of integer x.\n2. Iterate through each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches x, append the tuple (row_index, column_index) to the coordinates list.\n5. Sort the coordinates list first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no occurrences of 1, resulting in an empty list.\n    \n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The number 3 appears only once at position (2, 2), so the output is a single tuple.\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The number 1 appears at positions (0, 0), (0, 1), and (1, 0). The output is sorted by row and then by column in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty lists and varying row lengths.\n", "requirement analysis:\nThe function should efficiently locate all instances of a specified integer within a nested list structure, regardless of row length variations. The output should be a list of tuples representing the coordinates of each occurrence, sorted by row and then by column in descending order.\nrequirement pool:\n- Implement the main function to locate integer occurrences.\n- Ensure the function handles varying row lengths.\n- Sort the output coordinates as specified.\n- Optimize for performance with large datasets.\n- Include error handling for non-integer inputs.\nWe will implement a simple Python function using pure Python to locate all occurrences of a specified integer in a nested list. The function will handle varying row lengths and return a sorted list of coordinates. We will not use any external libraries as the task is straightforward and does not require complex matrix operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'nested lists'\n    Explanation: The requirement involves working with a 2-dimensional data structure where each sublist can have a different number of elements, similar to a matrix but with varying row lengths.\n\n    'coordinates'\n    Explanation: The task requires identifying the position of elements within the nested lists, represented as tuples of (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'descending'\n    Explanation: The coordinates within each row should be sorted by columns in descending order, meaning from highest to lowest column index.\n\n    'ascending'\n    Explanation: The rows should be sorted in ascending order, meaning from lowest to highest row index.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using an index to keep track of the row number.\n3. Within each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the tuple (row index, column index) to the coordinates list.\n5. Sort the coordinates list first by row index in ascending order, then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no occurrences of the integer x, resulting in an empty list.\n\n    get_row([[1]], 2) = []\n    Explanation: The integer x is not present in the nested list, so the function returns an empty list.\n\n    get_row([[1, 2], [2, 1]], 1) = [(0, 0), (1, 1)]\n    Explanation: The integer 1 appears at (0, 0) and (1, 1). The coordinates are sorted by rows in ascending order and columns in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles cases where the list is empty or where the integer x is not found.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle varying row lengths and empty lists gracefully.\nrequirement pool:\n- Implement the main function to locate integer occurrences\n- Ensure sorting of results by row and column\n- Optimize performance for large datasets\n- Handle edge cases like empty lists\n- Provide clear documentation and examples\nWe will implement a function that iterates through each row and column of the nested list to find occurrences of the specified integer. The function will then collect these occurrences as tuples representing their coordinates. We will use Python's built-in sorting capabilities to sort the results first by row in ascending order and then by column in descending order. Given the simplicity of the task, we will rely on Python's native list operations without the need for additional libraries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data'\n    Explanation: This refers to a list of lists, where each sublist represents a row, similar to a matrix but with potentially varying numbers of columns.\n\n    'coordinate'\n    Explanation: A tuple representing the position of an element in the 2D list, with the format (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order'\n    Explanation: Sort the coordinates by row index in increasing order.\n\n    'descending order'\n    Explanation: Sort the coordinates by column index in decreasing order within each row.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row of the nested list using an index to track the row number.\n3. For each row, iterate through each element using an index to track the column number.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no occurrences of the integer 1.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2).\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The integer 1 appears at positions (0, 0), (0, 1), and (1, 0). After sorting by row and then by column in descending order within each row, the result is [(0, 1), (0, 0), (1, 0)].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for empty lists and varying row lengths.\n", "requirement analysis:\nThe function should efficiently locate all occurrences of a specified integer in a nested list structure, returning their coordinates sorted by row and column as specified. It should handle edge cases such as empty lists and varying row lengths.\nrequirement pool:\n- Implement the main function to find and sort coordinates.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles empty datasets without errors.\n- Add additional test cases for edge scenarios.\n- Document the function with clear usage examples.\nWe will implement a function that iterates through each row and column of the nested list to find occurrences of the specified integer. The function will then collect these occurrences as tuples of coordinates, sort them by row in ascending order, and by column in descending order within each row. We will use Python's built-in list and tuple data structures for simplicity and efficiency, as they are well-suited for this task and do not require additional dependencies.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a nested list structure where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the nested list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No explicit phrases showing quantity relationships are present in the requirement.\n\n# [degree adverb]\n    No degree adverbs are present in the requirement.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates of occurrences of integer x.\n2. Iterate through each row of the nested list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the current element equals x, append a tuple (row_index, column_index) to the list of coordinates.\n5. After collecting all coordinates, sort the list of tuples first by row in ascending order and then by column in descending order within each row.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no occurrences of 1, resulting in an empty list.\n    \n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2), so the output is a single tuple with that coordinate.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 does not appear in any row, so the output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for occurrences naturally handles these cases.\n", "requirement analysis:\nThe function should efficiently locate all occurrences of a given integer in a nested list structure, handling varying row lengths and empty lists. The output should be sorted by row and column as specified.\nrequirement pool:\n- Efficiently locate integer occurrences in nested lists\n- Handle varying row lengths and empty lists\n- Sort output by row and column\n- Optimize for large datasets\n- Provide clear error messages for invalid inputs\nWe will use native Python list comprehensions and sorting functions to efficiently locate and sort occurrences of the integer in the nested list. This approach is simple and leverages Python's built-in capabilities for handling lists and sorting, ensuring that the function is both efficient and easy to understand.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': This refers to a list of lists, where each sublist can be thought of as a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D data, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'descending': This indicates that the columns within each row should be sorted from highest to lowest when returning the coordinates.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to search for, resulting in an empty list of coordinates.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to search for, resulting in an empty list of coordinates.\n    \n    get_row([[1], [1, 2], [3, 1]], 1) = [(0, 0), (1, 0), (2, 1)]\n    Explanation: The integer 1 is found at (0, 0), (1, 0), and (2, 1). The coordinates are sorted by row and then by column in descending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic naturally handles empty lists and varying row lengths.\n", "requirement analysis:\nThe function should efficiently locate all occurrences of a given integer in a nested list structure, returning their coordinates sorted by specified criteria. It should handle edge cases such as empty lists and varying row lengths.\nrequirement pool:\n- Implement the main function to find and return coordinates of integer occurrences.\n- Ensure the function handles empty lists without errors.\n- Optimize sorting of coordinates for performance.\n- Include comprehensive test cases for various scenarios.\n- Document the function with clear usage examples.\nWe will implement a function using native Python list operations and nested loops to efficiently locate occurrences of the integer in the nested list structure. Sorting will be handled using Python's built-in sort functionality, which is efficient for the given task. The function will be designed to handle empty lists gracefully and will include comprehensive test cases to ensure robustness.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Sort rows in increasing order based on their index.\n    'descending order': Sort columns in decreasing order within each row.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the 2D list using its index.\n3. For each row, iterate through each element using its index.\n4. If the element matches the integer x, append its coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no occurrences of the integer 1.\n    \n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 appears only once at position (2, 2).\n\n    get_row([[1, 1], [1]], 1) = [(0, 1), (0, 0), (1, 0)]\n    Explanation: The integer 1 appears at positions (0, 0), (0, 1), and (1, 0). After sorting by rows and then by columns in descending order within each row, the result is [(0, 1), (0, 0), (1, 0)].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and varying row lengths naturally.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 87, 87, 87, 87], "completion": "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate all occurrences of integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists containing integers.\n        x: The integer to locate.\n\n    Returns:\n        A list of tuples representing the coordinates of occurrences of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the 2D list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append its coordinate\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order,\n    # then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n\n# Example usage:\n# print(get_row([[1, 1], [1]], 1))  # Output: [(0, 1), (0, 0), (1, 0)]\n# print(get_row([[], [1], [1, 2, 3]], 3))  # Output: [(2, 2)]\n# print(get_row([], 1))  # Output: []\n", "passed": true, "pass": true, "pass_num": 10, "round": 713, "mutate_method": "expand_one2two", "parent_index": 367}
