{"task_id": "HumanEval/81", "prompt": "def numerical_letter_grade(grades):\t\n'''It is the last week of the semester and the teacher has to give the grades to students but she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\nExample:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    '''", "entry_point": "numerical_letter_grade", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "test": ["def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.367]) == ['A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.709]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.501]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.042, 3, 5.935, 5, 5.423]) == ['A', 'B', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.511]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6, 4.502, 2.77, 6.757, 4.66]) == ['A', 'A', 'B', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.309, 3, 3.031, 4, 3.721]) == ['A', 'B', 'B+', 'A+', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 1.067, 5.544, 2.104, 6.994]) == ['D', 'D+', 'A', 'C+', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 3.93, 1.74, 2.791, 2.576]) == ['B', 'A', 'C', 'B', 'B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.799]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.104]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6, 2.642, 5.179, 5.542, 7.925]) == ['A', 'B-', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([7.75, 2, 6.21, 4, 7.481]) == ['A', 'C', 'A', 'A+', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 1.608, 4.584, 1.801, 5.528]) == ['B', 'C-', 'A', 'C', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.259]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4, 2.626, 2.824, 7.424, 5.83]) == ['A+', 'B-', 'B', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.84, 4, 4.974, 6, 5.319]) == ['A', 'A+', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.033]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.516]) == ['B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([9.54, 5, 6.671, 1, 5.784]) == ['A', 'A', 'A', 'D', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 5.293, 4.749, 7.907, 5.656]) == ['D', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.463, 2, 3.954, 5, 7.145]) == ['A', 'C', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.826]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 3.758, 2.783, 2.733, 7.605]) == ['B', 'A', 'B', 'B', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.597]) == ['B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4, 1.435, 5.824, 1.539, 7.492]) == ['A+', 'C-', 'A', 'C-', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.423]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.143]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.891]) == ['C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.065, 4, 5.911, 2, 4.43]) == ['A', 'A+', 'A', 'C', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.477, 7, 6.699, 6, 7.022]) == ['A', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5, 2.658, 2.151, 6.268, 5.527]) == ['A', 'B-', 'C+', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 4.558, 2.072, 3.712, 5.809]) == ['B', 'A', 'C+', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 4.425, 6.207, 4.631, 3.821]) == ['B', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.878]) == ['C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.81]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.976, 4, 1.433, 7, 3.077]) == ['A', 'A+', 'C-', 'A', 'B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.226]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.364]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.946]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4, 3.251, 2.546, 1.98, 3.082]) == ['A+', 'B+', 'B-', 'C', 'B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.189]) == ['B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.618]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.835]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.356]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.612]) == ['A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.601]) == ['B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.978]) == ['C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5, 3.231, 4.961, 5.91, 4.348]) == ['A', 'B+', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([0.5]) == ['D-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.412]) == ['B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.699]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([9.553, 3, 1.754, 7, 7.712]) == ['A', 'B', 'C', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.909, 4, 3.917, 4, 2.236]) == ['A', 'A+', 'A', 'A+', 'C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5, 4.675, 6.301, 3.928, 5.804]) == ['A', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.845]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.091]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.822]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 1.556, 6.189, 3.588, 1.625]) == ['D', 'C-', 'A', 'A-', 'C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.134, 3, 6.155, 3, 2.084]) == ['A', 'B', 'A', 'B', 'C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5, 3.839, 3.698, 4.34, 1.955]) == ['A', 'A', 'A-', 'A', 'C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.813]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.266, 7, 4.913, 2, 1.115]) == ['D+', 'A', 'A', 'C', 'D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.381]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.985]) == ['B']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.314]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([9.317, 8, 3.7, 6, 2.483]) == ['A', 'A', 'A-', 'A', 'B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.169]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.925]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.275]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.076]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.906]) == ['C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6, 5.144, 4.622, 7.362, 8.196]) == ['A', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.778]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.012]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([0.0]) == ['E']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.873, 3, 2.438, 6, 5.365]) == ['A', 'B', 'B-', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.169]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.454]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 1.181, 4.176, 7.002, 5.356]) == ['D', 'D+', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.412]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.054]) == ['B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.401]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.559]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.454, 8, 1.163, 2, 3.831]) == ['B-', 'A', 'D+', 'C', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.288]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.516]) == ['A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.111]) == ['B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.411]) == ['A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.415]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.682]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.152, 7, 2.102, 5, 8.879]) == ['A', 'A', 'C+', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6, 2.172, 3.849, 1.272, 6.298]) == ['A', 'C+', 'A', 'D+', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.697]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.86]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.2]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.363]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.886]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.202]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([8.911, 1, 5.562, 6, 1.001]) == ['A', 'D', 'A', 'A', 'D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.442]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.32, 8, 4.236, 1, 5.296]) == ['C-', 'A', 'A', 'D', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.058, 4, 5.349, 2, 4.304]) == ['D+', 'A+', 'A', 'C', 'A']"], "test_case_list": ["assert numerical_letter_grade([3.367]) == ['A-']", "assert numerical_letter_grade([3.709]) == ['A']", "assert numerical_letter_grade([1.501]) == ['C-']", "assert numerical_letter_grade([6.042, 3, 5.935, 5, 5.423]) == ['A', 'B', 'A', 'A', 'A']", "assert numerical_letter_grade([1.511]) == ['C-']", "assert numerical_letter_grade([6, 4.502, 2.77, 6.757, 4.66]) == ['A', 'A', 'B', 'A', 'A']", "assert numerical_letter_grade([5.309, 3, 3.031, 4, 3.721]) == ['A', 'B', 'B+', 'A+', 'A']", "assert numerical_letter_grade([1, 1.067, 5.544, 2.104, 6.994]) == ['D', 'D+', 'A', 'C+', 'A']", "assert numerical_letter_grade([3, 3.93, 1.74, 2.791, 2.576]) == ['B', 'A', 'C', 'B', 'B-']", "assert numerical_letter_grade([4.799]) == ['A']", "assert numerical_letter_grade([4.104]) == ['A']", "assert numerical_letter_grade([6, 2.642, 5.179, 5.542, 7.925]) == ['A', 'B-', 'A', 'A', 'A']", "assert numerical_letter_grade([7.75, 2, 6.21, 4, 7.481]) == ['A', 'C', 'A', 'A+', 'A']", "assert numerical_letter_grade([3, 1.608, 4.584, 1.801, 5.528]) == ['B', 'C-', 'A', 'C', 'A']", "assert numerical_letter_grade([2.259]) == ['C+']", "assert numerical_letter_grade([4, 2.626, 2.824, 7.424, 5.83]) == ['A+', 'B-', 'B', 'A', 'A']", "assert numerical_letter_grade([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.", "assert numerical_letter_grade([4.84, 4, 4.974, 6, 5.319]) == ['A', 'A+', 'A', 'A', 'A']", "assert numerical_letter_grade([2.033]) == ['C+']", "assert numerical_letter_grade([2.516]) == ['B-']", "assert numerical_letter_grade([9.54, 5, 6.671, 1, 5.784]) == ['A', 'A', 'A', 'D', 'A']", "assert numerical_letter_grade([1, 5.293, 4.749, 7.907, 5.656]) == ['D', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([6.463, 2, 3.954, 5, 7.145]) == ['A', 'C', 'A', 'A', 'A']", "assert numerical_letter_grade([3.826]) == ['A']", "assert numerical_letter_grade([3, 3.758, 2.783, 2.733, 7.605]) == ['B', 'A', 'B', 'B', 'A']", "assert numerical_letter_grade([2.597]) == ['B-']", "assert numerical_letter_grade([4, 1.435, 5.824, 1.539, 7.492]) == ['A+', 'C-', 'A', 'C-', 'A']", "assert numerical_letter_grade([6.423]) == ['A']", "assert numerical_letter_grade([1.143]) == ['D+']", "assert numerical_letter_grade([1.891]) == ['C']", "assert numerical_letter_grade([5.065, 4, 5.911, 2, 4.43]) == ['A', 'A+', 'A', 'C', 'A']", "assert numerical_letter_grade([4.477, 7, 6.699, 6, 7.022]) == ['A', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([5, 2.658, 2.151, 6.268, 5.527]) == ['A', 'B-', 'C+', 'A', 'A']", "assert numerical_letter_grade([3, 4.558, 2.072, 3.712, 5.809]) == ['B', 'A', 'C+', 'A', 'A']", "assert numerical_letter_grade([3, 4.425, 6.207, 4.631, 3.821]) == ['B', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([1.878]) == ['C']", "assert numerical_letter_grade([3.81]) == ['A']", "assert numerical_letter_grade([5.976, 4, 1.433, 7, 3.077]) == ['A', 'A+', 'C-', 'A', 'B+']", "assert numerical_letter_grade([2.226]) == ['C+']", "assert numerical_letter_grade([5.364]) == ['A']", "assert numerical_letter_grade([4.946]) == ['A']", "assert numerical_letter_grade([4, 3.251, 2.546, 1.98, 3.082]) == ['A+', 'B+', 'B-', 'C', 'B+']", "assert numerical_letter_grade([3.189]) == ['B+']", "assert numerical_letter_grade([6.618]) == ['A']", "assert numerical_letter_grade([4.835]) == ['A']", "assert numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']", "assert numerical_letter_grade([5.356]) == ['A']", "assert numerical_letter_grade([3.612]) == ['A-']", "assert numerical_letter_grade([2.601]) == ['B-']", "assert numerical_letter_grade([1.978]) == ['C']", "assert numerical_letter_grade([5, 3.231, 4.961, 5.91, 4.348]) == ['A', 'B+', 'A', 'A', 'A']", "assert numerical_letter_grade([0.5]) == ['D-']", "assert numerical_letter_grade([2.412]) == ['B-']", "assert numerical_letter_grade([1.699]) == ['C-']", "assert numerical_letter_grade([9.553, 3, 1.754, 7, 7.712]) == ['A', 'B', 'C', 'A', 'A']", "assert numerical_letter_grade([5.909, 4, 3.917, 4, 2.236]) == ['A', 'A+', 'A', 'A+', 'C+']", "assert numerical_letter_grade([5, 4.675, 6.301, 3.928, 5.804]) == ['A', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([4.845]) == ['A']", "assert numerical_letter_grade([2.091]) == ['C+']", "assert numerical_letter_grade([4.822]) == ['A']", "assert numerical_letter_grade([1, 1.556, 6.189, 3.588, 1.625]) == ['D', 'C-', 'A', 'A-', 'C-']", "assert numerical_letter_grade([6.134, 3, 6.155, 3, 2.084]) == ['A', 'B', 'A', 'B', 'C+']", "assert numerical_letter_grade([5, 3.839, 3.698, 4.34, 1.955]) == ['A', 'A', 'A-', 'A', 'C']", "assert numerical_letter_grade([4.813]) == ['A']", "assert numerical_letter_grade([1.266, 7, 4.913, 2, 1.115]) == ['D+', 'A', 'A', 'C', 'D+']", "assert numerical_letter_grade([4.381]) == ['A']", "assert numerical_letter_grade([2.985]) == ['B']", "assert numerical_letter_grade([4.314]) == ['A']", "assert numerical_letter_grade([9.317, 8, 3.7, 6, 2.483]) == ['A', 'A', 'A-', 'A', 'B-']", "assert numerical_letter_grade([2.169]) == ['C+']", "assert numerical_letter_grade([3.925]) == ['A']", "assert numerical_letter_grade([1.275]) == ['D+']", "assert numerical_letter_grade([1.076]) == ['D+']", "assert numerical_letter_grade([1.906]) == ['C']", "assert numerical_letter_grade([6, 5.144, 4.622, 7.362, 8.196]) == ['A', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([5.778]) == ['A']", "assert numerical_letter_grade([5.012]) == ['A']", "assert numerical_letter_grade([0.0]) == ['E']", "assert numerical_letter_grade([4.873, 3, 2.438, 6, 5.365]) == ['A', 'B', 'B-', 'A', 'A']", "assert numerical_letter_grade([1.169]) == ['D+']", "assert numerical_letter_grade([4.454]) == ['A']", "assert numerical_letter_grade([1, 1.181, 4.176, 7.002, 5.356]) == ['D', 'D+', 'A', 'A', 'A']", "assert numerical_letter_grade([1.412]) == ['C-']", "assert numerical_letter_grade([3.054]) == ['B+']", "assert numerical_letter_grade([5.401]) == ['A']", "assert numerical_letter_grade([5.559]) == ['A']", "assert numerical_letter_grade([2.454, 8, 1.163, 2, 3.831]) == ['B-', 'A', 'D+', 'C', 'A']", "assert numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']", "assert numerical_letter_grade([5.288]) == ['A']", "assert numerical_letter_grade([3.516]) == ['A-']", "assert numerical_letter_grade([3.111]) == ['B+']", "assert numerical_letter_grade([3.411]) == ['A-']", "assert numerical_letter_grade([1.415]) == ['C-']", "assert numerical_letter_grade([4.682]) == ['A']", "assert numerical_letter_grade([4.152, 7, 2.102, 5, 8.879]) == ['A', 'A', 'C+', 'A', 'A']", "assert numerical_letter_grade([6, 2.172, 3.849, 1.272, 6.298]) == ['A', 'C+', 'A', 'D+', 'A']", "assert numerical_letter_grade([4.697]) == ['A']", "assert numerical_letter_grade([4.86]) == ['A']", "assert numerical_letter_grade([1.2]) == ['D+']", "assert numerical_letter_grade([6.363]) == ['A']", "assert numerical_letter_grade([5.886]) == ['A']", "assert numerical_letter_grade([4.202]) == ['A']", "assert numerical_letter_grade([8.911, 1, 5.562, 6, 1.001]) == ['A', 'D', 'A', 'A', 'D+']", "assert numerical_letter_grade([5.442]) == ['A']", "assert numerical_letter_grade([1.32, 8, 4.236, 1, 5.296]) == ['C-', 'A', 'A', 'D', 'A']", "assert numerical_letter_grade([1.058, 4, 5.349, 2, 4.304]) == ['D+', 'A+', 'A', 'C', 'A']"], "nl": "It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    ", "func": "def numerical_letter_grade(grades):", "examples": "Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    ", "repair_prompt": ["def numerical_letter_grade(grades):\t\n'''It is the last week of the semester and the teacher has to give the grades to students but she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\nExample:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    '''", "```python\ndef numerical_letter_grade(grades):\t\n    '''It is the last week of the semester. The teacher is required to give the grades to students but she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\nExample:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    '''\n```", "def numerical_letter_grade(grades):\t\n'''It is the last week of the semester and the teacher has to give the grades to students, but she has lost the code she used for grading. She's given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\nExample:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    '''"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    \"\"\"\n    Convert a list of GPAs to letter grades based on a predefined scale.\n    \n    Args:\n        grades (List[float]): List of GPAs.\n        \n    Returns:\n        List[str]: List of corresponding letter grades.\n    \"\"\"\n    # Define the mapping of GPA ranges to letter grades\n    gpa_to_letter = [\n        (4.0, 'A+'),\n        (3.7, 'A'),\n        (3.3, 'A-'),\n        (3.0, 'B+'),\n        (2.7, 'B'),\n        (2.3, 'B-'),\n        (2.0, 'C+'),\n        (1.7, 'C'),\n        (1.3, 'C-'),\n        (1.0, 'D+'),\n        (0.7, 'D'),\n        (0.0, 'E')\n    ]\n\n    def get_letter_grade(gpa: float) -> str:\n        \"\"\"Determine the letter grade for a given GPA.\"\"\"\n        for threshold, letter in gpa_to_letter:\n            if gpa >= threshold:\n                return letter\n        return 'E'  # Default to 'E' if GPA is below all thresholds\n\n    # Process each GPA and convert to letter grade\n    letter_grades = [get_letter_grade(gpa) for gpa in grades]\n    \n    return letter_grades\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPA values to their corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the GPA values.\n    \"\"\"\n    # Define the mapping of GPA ranges to letter grades\n    gpa_to_letter_grade = {\n        (4.0,): 'A+',\n        (3.7, 4.0): 'A',\n        (3.3, 3.7): 'A-',\n        (3.0, 3.3): 'B+',\n        (2.7, 3.0): 'B',\n        (2.3, 2.7): 'B-',\n        (2.0, 2.3): 'C+',\n        (1.7, 2.0): 'C',\n        (1.3, 1.7): 'C-',\n        (1.0, 1.3): 'D+',\n        (0.7, 1.0): 'D-',\n        (0.0, 0.7): 'E'\n    }\n\n    # Initialize the list to store letter grades\n    letter_grades = []\n\n    # Iterate through each GPA in the list\n    for gpa in grades:\n        # Check for invalid GPA values\n        if gpa < 0.0 or gpa > 4.0:\n            raise ValueError(f\"Invalid GPA value: {gpa}. GPA must be between 0.0 and 4.0.\")\n\n        # Determine the corresponding letter grade\n        for gpa_range, letter_grade in gpa_to_letter_grade.items():\n            if gpa_range[0] <= gpa < gpa_range[-1]:\n                letter_grades.append(letter_grade)\n                break\n            elif gpa == gpa_range[-1]:  # Handle edge case where GPA is exactly on the boundary\n                letter_grades.append(letter_grade)\n                break\n\n    return letter_grades\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPA values to their corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the GPA values.\n    \"\"\"\n    # Define the GPA to letter grade mapping\n    gpa_to_letter = [\n        (4.0, 'A+'),\n        (3.7, 'A'),\n        (3.3, 'A-'),\n        (3.0, 'B+'),\n        (2.7, 'B'),\n        (2.3, 'B-'),\n        (2.0, 'C+'),\n        (1.7, 'C'),\n        (1.3, 'C-'),\n        (1.0, 'D+'),\n        (0.7, 'D'),\n        (0.0, 'E')\n    ]\n\n    # Initialize an empty list to store the letter grades\n    letter_grades = []\n\n    # Iterate through each GPA value in the input list\n    for gpa in grades:\n        # Determine the corresponding letter grade\n        for boundary, letter in gpa_to_letter:\n            if gpa >= boundary:\n                letter_grades.append(letter)\n                break\n\n    return letter_grades\n\n# Example usage:\n# print(numerical_letter_grade([4.0, 0.0]))  # Output: ['A+', 'E']\n# print(numerical_letter_grade([3.7, 3.3, 3.0]))  # Output: ['A', 'A-', 'B+']\n# print(numerical_letter_grade([2.3, 1.0, 0.7]))  # Output: ['B-', 'D+', 'D']\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    \"\"\"\n    Convert a list of GPA values to their corresponding letter grades.\n\n    Parameters:\n    grades (List[float]): A list of GPA values.\n\n    Returns:\n    List[str]: A list of letter grades corresponding to the GPA values.\n    \"\"\"\n    letter_grades = []\n    \n    for gpa in grades:\n        if gpa >= 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    \n    return letter_grades\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to their corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the input GPAs.\n    \"\"\"\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to a list of letter grades based on a predefined scale.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of corresponding letter grades.\n    \"\"\"\n    # Define the mapping of GPA ranges to letter grades\n    grade_scale = [\n        (4.0, 'A+'),\n        (3.7, 'A'),\n        (3.3, 'A-'),\n        (3.0, 'B+'),\n        (2.7, 'B'),\n        (2.3, 'B-'),\n        (2.0, 'C+'),\n        (1.7, 'C'),\n        (1.3, 'C-'),\n        (1.0, 'D+'),\n        (0.7, 'D'),\n        (0.0, 'D-'),\n    ]\n\n    # Initialize the result list\n    result = []\n\n    # Iterate over each GPA in the input list\n    for gpa in grades:\n        # Determine the corresponding letter grade\n        for threshold, letter_grade in grade_scale:\n            if gpa >= threshold:\n                result.append(letter_grade)\n                break\n        else:\n            # If GPA is exactly 0.0, it should map to 'E'\n            result.append('E')\n\n    return result\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPA values to their corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the GPA values.\n    \"\"\"\n    letter_grades = []\n\n    for gpa in grades:\n        if gpa >= 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        else:\n            letter_grades.append('E')\n\n    return letter_grades\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    \"\"\"\n    Convert a list of GPAs to letter grades based on the specified scale.\n\n    Args:\n        grades (List[float]): A list of GPA scores.\n\n    Returns:\n        List[str]: A list of corresponding letter grades.\n    \"\"\"\n    # Dictionary mapping GPA ranges to letter grades\n    gpa_to_letter = {\n        (4.0,): 'A+',\n        (3.7, 4.0): 'A',\n        (3.3, 3.7): 'A-',\n        (3.0, 3.3): 'B+',\n        (2.7, 3.0): 'B',\n        (2.3, 2.7): 'B-',\n        (2.0, 2.3): 'C+',\n        (1.7, 2.0): 'C',\n        (1.3, 1.7): 'C-',\n        (1.0, 1.3): 'D+',\n        (0.7, 1.0): 'D',\n        (0.0, 0.7): 'E'\n    }\n\n    # Result list to store letter grades\n    result = []\n\n    # Iterate over the list of GPAs\n    for gpa in grades:\n        # Determine the corresponding letter grade using conditional logic\n        for gpa_range, letter in gpa_to_letter.items():\n            if gpa_range[0] <= gpa < gpa_range[-1]:\n                result.append(letter)\n                break\n            elif gpa == gpa_range[0] and len(gpa_range) == 1:\n                result.append(letter)\n                break\n\n    # Return the result list\n    return result\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to their corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the input GPAs.\n    \"\"\"\n    letter_grades = []\n\n    for gpa in grades:\n        if gpa >= 4.0:\n            letter_grades.append('A+')\n        elif gpa >= 3.7:\n            letter_grades.append('A')\n        elif gpa >= 3.3:\n            letter_grades.append('A-')\n        elif gpa >= 3.0:\n            letter_grades.append('B+')\n        elif gpa >= 2.7:\n            letter_grades.append('B')\n        elif gpa >= 2.3:\n            letter_grades.append('B-')\n        elif gpa >= 2.0:\n            letter_grades.append('C+')\n        elif gpa >= 1.7:\n            letter_grades.append('C')\n        elif gpa >= 1.3:\n            letter_grades.append('C-')\n        elif gpa >= 1.0:\n            letter_grades.append('D+')\n        elif gpa >= 0.7:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n\n    return letter_grades\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    \"\"\"\n    Convert a list of GPAs to their corresponding letter grades.\n\n    Parameters:\n    grades (List[float]): A list of GPA values.\n\n    Returns:\n    List[str]: A list of letter grades corresponding to the GPAs.\n    \"\"\"\n    # Dictionary mapping GPA ranges to letter grades\n    gpa_to_letter = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'E'\n    }\n\n    # Result list to store letter grades\n    result = []\n\n    # Iterate over the list of GPAs\n    for gpa in grades:\n        # Determine the corresponding letter grade using conditional logic\n        if gpa >= 4.0:\n            result.append('A+')\n        elif gpa >= 3.7:\n            result.append('A')\n        elif gpa >= 3.3:\n            result.append('A-')\n        elif gpa >= 3.0:\n            result.append('B+')\n        elif gpa >= 2.7:\n            result.append('B')\n        elif gpa >= 2.3:\n            result.append('B-')\n        elif gpa >= 2.0:\n            result.append('C+')\n        elif gpa >= 1.7:\n            result.append('C')\n        elif gpa >= 1.3:\n            result.append('C-')\n        elif gpa >= 1.0:\n            result.append('D+')\n        elif gpa >= 0.7:\n            result.append('D')\n        elif gpa > 0.0:\n            result.append('D-')\n        else:\n            result.append('E')\n\n    # Return the result list\n    return result\n"], "plans": ["requirement analysis:\nThe function should accurately convert GPAs to letter grades based on the provided scale. It should handle edge cases such as exact GPA values and large lists efficiently.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design a user-friendly interface for input and output\n- Optimize performance for handling large datasets\n- Include error handling for invalid GPA inputs\n- Provide customization options for grading scales\nWe will implement a simple function to convert GPAs to letter grades using a predefined scale. The function will handle large datasets efficiently by leveraging Python's list comprehension for quick processing. We will use error handling to manage invalid GPA inputs. The standard grading scale will be used unless customization is explicitly required.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates a greater-than relationship between GPA values and their corresponding letter grades. For example, a GPA greater than 3.7 corresponds to an 'A'.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Define a mapping of GPA ranges to letter grades.\n    2. Iterate through the list of GPAs.\n    3. For each GPA, determine the corresponding letter grade using the predefined scale.\n    4. Append the letter grade to the result list.\n    5. Return the list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.0, 0.0]) = ['A+', 'E']\n    Explanation: 4.0 corresponds to 'A+' and 0.0 corresponds to 'E'.\n    \n    numerical_letter_grade([3.7, 3.3, 3.0]) = ['A', 'A-', 'B+']\n    Explanation: Each GPA falls into its respective range for letter grades.\n\n    numerical_letter_grade([2.7, 1.7, 0.7]) = ['B', 'C', 'D']\n    Explanation: Each GPA falls into its respective range for letter grades.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of mapping GPA ranges to letter grades will naturally handle these cases.\n", "requirement analysis:\nThe function needs to accurately map GPA values to their corresponding letter grades based on the provided scale. It should handle edge cases and ensure that the conversion is intuitive and efficient.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design a user-friendly interface for input and output\n- Optimize performance for handling large datasets\n- Include error handling for invalid GPA values\n- Provide documentation for usage and edge cases\nWe will implement a function that maps GPA values to their corresponding letter grades using a predefined scale. The function will handle edge cases by ensuring that GPA values exactly on the boundary are correctly mapped to the higher grade. We will use Python's built-in capabilities to efficiently process large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates that a GPA must be greater than a certain value to qualify for a specific letter grade.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Create a mapping of GPA ranges to letter grades.\n    2. Iterate through the list of GPAs.\n    3. For each GPA, determine the corresponding letter grade using the mapping.\n    4. Handle edge cases where GPA is exactly on the boundary.\n    5. Return the list of letter grades.\n\n# [edge case] \n    numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.7]) = ['A+', 'A', 'A-', 'B+', 'B']\n    Explanation: Each GPA is exactly on the boundary of its respective grade.\n    \n    numerical_letter_grade([0.0, 0.7, 1.0, 1.3, 1.7]) = ['E', 'D-', 'D+', 'C-', 'C']\n    Explanation: Each GPA is exactly on the boundary of its respective grade.\n    \n    numerical_letter_grade([2.3, 2.0, 1.7, 1.3, 1.0]) = ['B-', 'C+', 'C', 'C-', 'D+']\n    Explanation: Each GPA is exactly on the boundary of its respective grade.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the original logic already considers exact boundary values in the mapping process.\n", "requirement analysis:\nThe function needs to accurately map GPA values to letter grades based on the provided scale. It should handle edge cases and ensure performance efficiency for large datasets.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design user-friendly interface for input\n- Optimize performance for large datasets\n- Handle edge cases and exact GPA values\n- Ensure reliability and consistency in grading\nWe will implement a simple function to convert GPA values to letter grades based on the provided scale. The function will handle edge cases by using precise conditional checks for GPA boundaries. We will use Python's built-in capabilities without any additional libraries, as the task is straightforward and does not require complex data processing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates a greater than relationship between GPA values and corresponding letter grades. For example, a GPA greater than 3.7 corresponds to an 'A' grade.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Create a function that takes a list of GPA values as input.\n    2. Initialize an empty list to store the letter grades.\n    3. Iterate through each GPA value in the input list.\n    4. Use conditional statements to determine the corresponding letter grade based on the provided scale.\n    5. Append the determined letter grade to the list of letter grades.\n    6. Return the list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.0, 0.0]) = ['A+', 'E']\n    Explanation: The GPA 4.0 corresponds to 'A+' and 0.0 corresponds to 'E'.\n    \n    numerical_letter_grade([3.7, 3.3, 3.0]) = ['A', 'A-', 'B+']\n    Explanation: The GPA 3.7 corresponds to 'A', 3.3 corresponds to 'A-', and 3.0 corresponds to 'B+'.\n    \n    numerical_letter_grade([2.3, 1.0, 0.7]) = ['B-', 'D+', 'D']\n    Explanation: The GPA 2.3 corresponds to 'B-', 1.0 corresponds to 'D+', and 0.7 corresponds to 'D'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic with conditional checks for each GPA boundary will handle all cases correctly.\n", "requirement analysis:\nThe function needs to accurately map GPA values to letter grades based on the provided scale. It should handle edge cases and ensure performance efficiency for large datasets.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design a user-friendly interface for grade input\n- Optimize performance for handling large lists of grades\n- Include error handling for invalid GPA values\n- Provide detailed documentation for users\nWe will implement a function that maps GPA values to letter grades using a simple conditional structure. The function will handle edge cases by ensuring that GPA values exactly on the boundary are correctly mapped to the higher grade. We will use Python's built-in capabilities to efficiently process large lists of grades.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA'\n    Explanation: GPA stands for Grade Point Average, a standard way of measuring academic achievement in the U.S. It is typically on a scale from 0.0 to 4.0.\n\n    'Letter grade'\n    Explanation: Letter grades are a way of representing academic performance, typically ranging from A+ to E, with A+ being the highest and E being the lowest.\n\n# [phrase showing quantity relationship]\n    '>': This symbol indicates a greater than relationship between GPA values and their corresponding letter grades. For example, a GPA greater than 3.7 corresponds to an 'A' grade.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    - Create a function that takes a list of GPAs as input.\n    - Initialize an empty list to store the letter grades.\n    - Iterate through each GPA in the list.\n    - Use conditional statements to map each GPA to its corresponding letter grade based on the provided table.\n    - Append the letter grade to the list.\n    - Return the list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.0]) = ['A+']\n    Explanation: A GPA of 4.0 corresponds to the highest letter grade, A+.\n\n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: A GPA of 0.0 corresponds to the lowest letter grade, E.\n\n    numerical_letter_grade([3.7]) = ['A']\n    Explanation: A GPA of exactly 3.7 corresponds to an 'A' grade, as it is greater than 3.3 but not greater than 3.7.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using conditional statements will correctly map GPAs to their respective letter grades, including edge cases.\n", "requirement analysis:\nThe requirement is to develop a function that converts a list of GPAs into corresponding letter grades based on a predefined scale. The function should be efficient and capable of handling large datasets, providing accurate and clear outputs.\nrequirement pool:\n- Develop the main function to convert GPA to letter grades.\n- Design a user-friendly interface for inputting GPAs.\n- Ensure the function can handle large lists efficiently.\n- Provide detailed documentation for the grading scale.\n- Implement error handling for invalid GPA inputs.\nWe will implement a simple Python function that maps GPA values to letter grades using a predefined scale. The function will iterate over the list of GPAs and use conditional statements to determine the corresponding letter grade for each GPA. We will ensure the function is efficient and can handle large lists by using list comprehensions. We will also use the built-in Python capabilities, avoiding the need for additional libraries, to keep the implementation straightforward and efficient.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA'\n    Explanation: Grade Point Average, a standard way of measuring academic achievement in the U.S. It is typically measured on a scale of 0 to 4.0.\n\n    'Letter grade'\n    Explanation: A system of grading students' academic performance using letters such as A, B, C, D, and E, often with pluses and minuses to indicate slight variations in performance.\n\n# [phrase showing quantity relationship]\n    '>': This symbol is used to define the threshold for each letter grade. For example, a GPA greater than 3.7 is an 'A', and a GPA greater than 3.3 is an 'A-'.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function `numerical_letter_grade` that takes a list of GPAs as input.\n    2. Create a list to store the corresponding letter grades.\n    3. Iterate over each GPA in the input list.\n    4. Use conditional statements to determine the letter grade based on the GPA:\n        - If GPA is 4.0, append 'A+' to the list.\n        - If GPA is greater than 3.7, append 'A'.\n        - If GPA is greater than 3.3, append 'A-'.\n        - If GPA is greater than 3.0, append 'B+'.\n        - If GPA is greater than 2.7, append 'B'.\n        - If GPA is greater than 2.3, append 'B-'.\n        - If GPA is greater than 2.0, append 'C+'.\n        - If GPA is greater than 1.7, append 'C'.\n        - If GPA is greater than 1.3, append 'C-'.\n        - If GPA is greater than 1.0, append 'D+'.\n        - If GPA is greater than 0.7, append 'D'.\n        - If GPA is greater than 0.0, append 'D-'.\n        - Otherwise, append 'E'.\n    5. Return the list of letter grades.\n\n# [edge case] \n    numerical_letter_grade([4.0]) = ['A+']\n    Explanation: A GPA of exactly 4.0 corresponds to an 'A+'.\n\n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: A GPA of exactly 0.0 corresponds to an 'E'.\n\n    numerical_letter_grade([3.7]) = ['A']\n    Explanation: A GPA of exactly 3.7 corresponds to an 'A'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the original logic already covers all possible GPA values and their corresponding letter grades through conditional statements.\n", "requirement analysis:\nThe function should take a list of GPAs and return a corresponding list of letter grades based on a predefined scale. It should handle edge cases such as GPAs exactly on the boundary between two grades and ensure that the output is consistent with the provided examples.\nrequirement pool:\n- Implement the main conversion logic from GPA to letter grade.\n- Ensure the function handles edge cases and boundary values correctly.\n- Provide clear documentation and examples for users.\n- Optimize the function for performance with large lists.\n- Include unit tests to verify the accuracy of the conversion.\nWe will implement a simple function that maps GPA values to letter grades using a predefined scale. The function will handle edge cases by using a series of conditional checks to ensure that GPAs exactly on the boundary are correctly assigned to the higher grade. We will use Python's built-in capabilities without any additional libraries, as the task is straightforward and does not require complex data manipulation.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '> 3.7': Means GPA greater than 3.7 corresponds to an 'A'.\n    '> 3.3': Means GPA greater than 3.3 corresponds to an 'A-'.\n    '> 3.0': Means GPA greater than 3.0 corresponds to a 'B+'.\n    '> 2.7': Means GPA greater than 2.7 corresponds to a 'B'.\n    '> 2.3': Means GPA greater than 2.3 corresponds to a 'B-'.\n    '> 2.0': Means GPA greater than 2.0 corresponds to a 'C+'.\n    '> 1.7': Means GPA greater than 1.7 corresponds to a 'C'.\n    '> 1.3': Means GPA greater than 1.3 corresponds to a 'C-'.\n    '> 1.0': Means GPA greater than 1.0 corresponds to a 'D+'.\n    '> 0.7': Means GPA greater than 0.7 corresponds to a 'D'.\n    '> 0.0': Means GPA greater than 0.0 corresponds to a 'D-'.\n    '0.0': Exactly 0.0 corresponds to an 'E'.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n1. Define a function `numerical_letter_grade(grades)`.\n2. Create a list or dictionary mapping GPA ranges to letter grades.\n3. Iterate over each GPA in the input list.\n4. For each GPA, use conditional statements to determine the corresponding letter grade based on the predefined scale.\n5. Append the determined letter grade to a result list.\n6. Return the result list.\n\n# [edge case] \n    numerical_letter_grade([4.0]) = ['A+']\n    Explanation: A GPA of exactly 4.0 should map to an 'A+'.\n    \n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: A GPA of exactly 0.0 should map to an 'E'.\n    \n    numerical_letter_grade([3.7]) = ['A']\n    Explanation: A GPA of exactly 3.7 should map to an 'A', as it is the boundary for an 'A'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the original logic using conditional checks will correctly handle GPAs on the boundary by assigning them to the higher grade when necessary.\n\n", "requirement analysis:\nThe function needs to accurately map GPA values to letter grades based on the provided scale. It should handle edge cases such as exact GPA values and ensure performance efficiency for large datasets.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design a user-friendly interface for grade input\n- Optimize performance for large datasets\n- Include error handling for invalid GPA values\n- Provide documentation for users\nWe will implement a function that maps GPA values to letter grades using a simple if-elif-else structure. This approach ensures clarity and efficiency, especially for large datasets. We will use Python's built-in capabilities without any additional libraries, as the task is straightforward and does not require complex data manipulation. The function will handle edge cases by using inclusive and exclusive conditions to ensure accurate mapping at grade boundaries.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    'greater than': Used to determine the range for each letter grade. For example, GPA > 3.7 corresponds to an 'A'.\n    'greater than or equal to': Used for inclusive conditions at grade boundaries, such as GPA >= 4.0 for 'A+'.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Define a function that takes a list of GPAs as input.\n    2. Initialize an empty list to store the corresponding letter grades.\n    3. Iterate through each GPA in the input list.\n    4. Use if-elif-else statements to map each GPA to its corresponding letter grade based on the given table.\n    5. Append the mapped letter grade to the list.\n    6. Return the list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.0]) = ['A+']\n    Explanation: The GPA is exactly 4.0, which corresponds to an 'A+'.\n    \n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: The GPA is exactly 0.0, which corresponds to an 'E'.\n    \n    numerical_letter_grade([3.7, 3.3, 3.0]) = ['A', 'A-', 'B+']\n    Explanation: Each GPA falls within its respective range for letter grades.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using if-elif-else statements will correctly map GPAs to letter grades, including edge cases at grade boundaries.\n", "requirement analysis:\nThe function should accurately convert GPAs to letter grades based on the provided scale. It should handle edge cases and ensure performance efficiency for large datasets.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design a user-friendly interface for input and output\n- Optimize performance for handling large lists of GPAs\n- Include error handling for invalid GPA inputs\n- Provide documentation for usage and edge cases\nWe will implement a simple function to convert GPAs to letter grades using a dictionary for mapping. The function will iterate over the list of GPAs and use conditional logic to determine the corresponding letter grade. We will use Python's built-in capabilities to handle large datasets efficiently.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA'\n    Explanation: GPA stands for Grade Point Average, a standard way of measuring academic achievement in the U.S. It is typically on a scale from 0.0 to 4.0.\n\n    'Letter grade'\n    Explanation: Letter grades are a way of representing academic performance using letters, such as A+, A, B, etc., often associated with specific GPA ranges.\n\n# [phrase showing quantity relationship]\n    '>': This symbol indicates that one value is greater than another. In the requirement, it is used to define the GPA ranges for each letter grade. For example, a GPA greater than 3.7 corresponds to an 'A' grade.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Create a dictionary mapping GPA ranges to letter grades.\n    2. Iterate over the list of GPAs.\n    3. For each GPA, use conditional logic to determine the corresponding letter grade based on the dictionary.\n    4. Append the letter grade to a result list.\n    5. Return the result list.\n\n# [edge case]\n    numerical_letter_grade([4.0, 0.0]) = ['A+', 'E']\n    Explanation: A GPA of 4.0 corresponds to an 'A+' grade, and a GPA of 0.0 corresponds to an 'E' grade.\n\n    numerical_letter_grade([3.7, 3.3, 3.0]) = ['A', 'A-', 'B+']\n    Explanation: Each GPA falls into its respective range: 3.7 is 'A', 3.3 is 'A-', and 3.0 is 'B+'.\n\n    numerical_letter_grade([2.7, 1.7, 0.7]) = ['B', 'C', 'D']\n    Explanation: Each GPA falls into its respective range: 2.7 is 'B', 1.7 is 'C', and 0.7 is 'D'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as they are covered by the conditional logic mapping GPAs to letter grades in the original plan.\n", "requirement analysis:\nThe function should accurately map GPAs to letter grades based on the provided scale. It should handle edge cases such as exact GPA values and ensure performance efficiency for large datasets.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design user-friendly interface for grade input\n- Optimize performance for processing large lists\n- Include error handling for invalid GPA values\n- Provide documentation for grade conversion process\nWe will implement a function that maps GPAs to letter grades using a simple if-elif structure. This approach ensures clarity and efficiency, especially for large lists. We will use Python's built-in capabilities without additional libraries, as the task is straightforward and does not require complex data manipulation. We will handle edge cases by ensuring that GPA values exactly on the boundary are correctly mapped to the higher grade.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates that a GPA must be greater than a certain value to qualify for a specific letter grade.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Define a function `numerical_letter_grade` that takes a list of GPAs as input.\n    2. Initialize an empty list to store the letter grades.\n    3. Iterate over each GPA in the input list.\n    4. Use a series of if-elif statements to map each GPA to its corresponding letter grade based on the given table.\n    5. Append the mapped letter grade to the list.\n    6. Return the list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.7]) = ['A+', 'A', 'A-', 'B+', 'B']\n    Explanation: Each GPA is exactly on the boundary of its respective grade category.\n    \n    numerical_letter_grade([0.0, 0.7, 1.0, 1.3, 1.7]) = ['E', 'D-', 'D+', 'C-', 'C']\n    Explanation: Each GPA is exactly on the boundary of its respective grade category.\n\n    numerical_letter_grade([2.0, 2.3, 2.7, 3.0, 3.3]) = ['C+', 'B-', 'B', 'B+', 'A-']\n    Explanation: Each GPA is exactly on the boundary of its respective grade category.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the original logic using if-elif statements will correctly map boundary values to their respective grades.\n", "requirement analysis:\nThe function needs to accurately map GPAs to letter grades based on the provided scale. It should handle edge cases such as exact GPA values and ensure performance efficiency for large datasets.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design a user-friendly interface for grade input\n- Optimize performance for processing large lists of grades\n- Include error handling for invalid GPA inputs\n- Provide documentation for the grading scale used\nWe will implement a simple function to convert GPAs to letter grades using a dictionary for mapping. The function will iterate over the list of GPAs and use conditional logic to determine the corresponding letter grade. We will use Python's built-in capabilities to handle the conversion efficiently, ensuring performance even for large lists.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '> 3.7': GPA greater than 3.7 corresponds to an 'A' grade.\n    '> 3.3': GPA greater than 3.3 corresponds to an 'A-' grade.\n    '> 3.0': GPA greater than 3.0 corresponds to a 'B+' grade.\n    '> 2.7': GPA greater than 2.7 corresponds to a 'B' grade.\n    '> 2.3': GPA greater than 2.3 corresponds to a 'B-' grade.\n    '> 2.0': GPA greater than 2.0 corresponds to a 'C+' grade.\n    '> 1.7': GPA greater than 1.7 corresponds to a 'C' grade.\n    '> 1.3': GPA greater than 1.3 corresponds to a 'C-' grade.\n    '> 1.0': GPA greater than 1.0 corresponds to a 'D+' grade.\n    '> 0.7': GPA greater than 0.7 corresponds to a 'D' grade.\n    '> 0.0': GPA greater than 0.0 corresponds to a 'D-' grade.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n1. Create a dictionary mapping GPA ranges to letter grades.\n2. Iterate over the list of GPAs.\n3. For each GPA, use conditional logic to determine the corresponding letter grade based on the dictionary.\n4. Append the letter grade to the result list.\n5. Return the result list.\n\n# [edge case]\n    numerical_letter_grade([4.0]) = ['A+']\n    Explanation: A GPA of exactly 4.0 corresponds to an 'A+' grade.\n\n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: A GPA of exactly 0.0 corresponds to an 'E' grade.\n\n    numerical_letter_grade([3.7, 3.3, 2.7, 2.3, 1.7, 1.3, 1.0, 0.7, 0.0]) = ['A', 'A-', 'B', 'B-', 'C', 'C-', 'D+', 'D', 'E']\n    Explanation: Each GPA falls into its respective range according to the grading table.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the original logic covers all possible GPA values and their corresponding letter grades based on the given table.\n\n"], "scores": [0.3491, 0.3585, 0.3491, 0.3962, 1.0, 0.3491, 0.3679, 0.3491, 0.3585, 0.3585], "pass_results": [false, false, false, false, true, false, false, false, false, false], "pass_test_cases_num": [37, 38, 37, 42, 106, 37, 39, 37, 38, 38], "completion": "from typing import List\n## main.py\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    \"\"\"\n    Convert a list of GPAs to their corresponding letter grades.\n\n    Parameters:\n    grades (List[float]): A list of GPA values.\n\n    Returns:\n    List[str]: A list of letter grades corresponding to the GPAs.\n    \"\"\"\n    # Dictionary mapping GPA ranges to letter grades\n    gpa_to_letter = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'E'\n    }\n\n    # Result list to store letter grades\n    result = []\n\n    # Iterate over the list of GPAs\n    for gpa in grades:\n        # Determine the corresponding letter grade using conditional logic\n        if gpa >= 4.0:\n            result.append('A+')\n        elif gpa >= 3.7:\n            result.append('A')\n        elif gpa >= 3.3:\n            result.append('A-')\n        elif gpa >= 3.0:\n            result.append('B+')\n        elif gpa >= 2.7:\n            result.append('B')\n        elif gpa >= 2.3:\n            result.append('B-')\n        elif gpa >= 2.0:\n            result.append('C+')\n        elif gpa >= 1.7:\n            result.append('C')\n        elif gpa >= 1.3:\n            result.append('C-')\n        elif gpa >= 1.0:\n            result.append('D+')\n        elif gpa >= 0.7:\n            result.append('D')\n        elif gpa > 0.0:\n            result.append('D-')\n        else:\n            result.append('E')\n\n    # Return the result list\n    return result\n", "passed": true, "pass": true, "pass_num": 1, "round": 71, "mutate_method": "condense_two2one", "parent_index": 71}
