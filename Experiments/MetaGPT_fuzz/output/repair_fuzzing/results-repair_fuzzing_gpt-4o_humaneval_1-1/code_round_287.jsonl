{"task_id": "HumanEval/43", "prompt": "def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input, and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", "entry_point": "pairs_sum_to_zero", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "test": ["def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 11, -3, 6, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 7, -4, 1, 1, 11]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 11, 0, 3, 6, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 14, 0, 5, 2, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 2, 3, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 2, 9, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 14, 1, 8, 6, 36]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 9, 0, 8, 5, 9]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -6, 7, 1, 32]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, -2, 3]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 10, 0, 6, 5, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 1, -2, 2]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 2, -1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 4, -2, 5, 5, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 5, -3, 3]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 3, -4, 5]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 4, -5, 4, 1, 25]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 6, -4, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 5, 2, 4, 1, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 14, 0, 1, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 8, -5, 3, 7, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 9, -9, 2, 7, 11]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 7, -1, 2, 1, 28]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 6, -7, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 9, 2, 3, 4, 30]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 6, 1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 1, 3, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 5, 8, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 7, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, 10, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 13, -5, 7, 7, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 5, -10, 2, 10, 9]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 1, 8]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 7, 4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 9, -5, 4, 6, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 6, 2, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 2, 1, 11]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 2, 7, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 5, 2, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 14, -2, 8, 2, 35]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 5, 0]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 8, 4, 3, 7, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 12, 1, 9, 6, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 11, 1, 6, 6, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 11, -3, 8, 7, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 10, -4, 8, 6, 26]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 7, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, -4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-2, 12, -4, 7, 1, 36]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 12, 1, 6, 7, 25]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 11, -3, 6, 2, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 13, -2, 7, 3, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -10, 5, 10, 9]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 1, 3, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 8, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 14, 2, 4, 6, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, 1, 12]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 5, -6, 8, 1, 33]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 3, 7, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 14, -6, 5, 1, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 4, -1, 5, 10, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 13, -2, 4, 4, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 2, 6, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([0, 4, -1, 5, 3, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 3, 1, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([7, 5, -1, 1, 8, 10]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 4, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 7, 3, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 12, -3, 2, 6, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 9, -3, 6, 7, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 7, -9, 5, 4, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 6, 0, 6, 3, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 7, 8, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 4, -1, 8, 8, 12]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 8, 1, 1, 6, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 14, 1, 8, 2, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 6, -5, 7, 7, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 4, -7, 1, 2, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-8, 11, -6, 5, 7, 36]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 14, 0, 5, 1, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 9, -1, 7, 4, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, 3, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 10, 2, 9, 3, 33]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 4, 1, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 3, -2, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 10, -2, 2, 4, 33]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 9, -8, 6, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 7, -4, 4, 2, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 4, 10, 1]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([7, 8, -10, 7, 2, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 8, 0, 4, 5, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-6, 14, -4, 5, 6, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 12, 1, 8, 6, 31]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-3, 12, -6, 6, 7, 29]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, 1, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 8, -4, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([3, 2, 1, 6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 4, 3, 6, 2, 27]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 11, -4, 3, 5, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-7, 9, 2, 1, 6, 34]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-1, 13, -4, 6, 3, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, 0, 3]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 5, -2, 3, 1, 32]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 5, -1, 8, 8, 4]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([1, 2, 2, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 8, 1, 4]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 6, 2, 5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([2, 14, 3, 6, 2, 29]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-5, 13, -2, 8, 7, 35]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([6, 1, 3, 2]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 8, -1, 7, 6, 26]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 12, 0, 1, 7, 28]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([5, 3, 6, 7]) == False", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([4, 6, -8, 1, 2, 8]) == True", "def check(pairs_sum_to_zero):\n\tassert pairs_sum_to_zero([-4, 8, -3, 9, 5, 29]) == False"], "test_case_list": ["assert pairs_sum_to_zero([1, 11, -3, 6, 7, 30]) == False", "assert pairs_sum_to_zero([3, 7, -4, 1, 1, 11]) == False", "assert pairs_sum_to_zero([-8, 11, 0, 3, 6, 26]) == False", "assert pairs_sum_to_zero([1, 14, 0, 5, 2, 34]) == False", "assert pairs_sum_to_zero([1, 2, 3, 7]) == False", "assert pairs_sum_to_zero([4, 2, 9, 3]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]) == False", "assert pairs_sum_to_zero([3]) == False", "assert pairs_sum_to_zero([-1, 14, 1, 8, 6, 36]) == True", "assert pairs_sum_to_zero([3, 9, 0, 8, 5, 9]) == False", "assert pairs_sum_to_zero([1, 4, -6, 7, 1, 32]) == False", "assert pairs_sum_to_zero([2, 8, -2, 3]) == True", "assert pairs_sum_to_zero([-2, 10, 0, 6, 5, 30]) == False", "assert pairs_sum_to_zero([3, 1, -2, 2]) == True", "assert pairs_sum_to_zero([3, 2, -1, 2]) == False", "assert pairs_sum_to_zero([-1, 4, -2, 5, 5, 27]) == False", "assert pairs_sum_to_zero([1]) == False", "assert pairs_sum_to_zero([6, 5, -3, 3]) == True", "assert pairs_sum_to_zero([4, 3, -4, 5]) == True", "assert pairs_sum_to_zero([-2, 4, -5, 4, 1, 25]) == False", "assert pairs_sum_to_zero([2, 6, -4, 5]) == False", "assert pairs_sum_to_zero([-7, 5, 2, 4, 1, 26]) == False", "assert pairs_sum_to_zero([-8, 14, 0, 1, 7, 30]) == False", "assert pairs_sum_to_zero([1, 8, -5, 3, 7, 35]) == False", "assert pairs_sum_to_zero([6, 9, -9, 2, 7, 11]) == True", "assert pairs_sum_to_zero([-8, 7, -1, 2, 1, 28]) == True", "assert pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]) == True", "assert pairs_sum_to_zero([6, 6, -7, 6]) == False", "assert pairs_sum_to_zero([-4, 9, 2, 3, 4, 30]) == True", "assert pairs_sum_to_zero([1, 6, 1, 2]) == False", "assert pairs_sum_to_zero([5, 1, 3, 5]) == False", "assert pairs_sum_to_zero([4, 5, 8, 3]) == False", "assert pairs_sum_to_zero([6, 7, 2, 5]) == False", "assert pairs_sum_to_zero([2, 8, 10, 3]) == False", "assert pairs_sum_to_zero([1, 13, -5, 7, 7, 27]) == False", "assert pairs_sum_to_zero([4, 5, -10, 2, 10, 9]) == True", "assert pairs_sum_to_zero([2, 3, 1, 8]) == False", "assert pairs_sum_to_zero([1, 7, 4, 6]) == False", "assert pairs_sum_to_zero([2, 9, -5, 4, 6, 30]) == False", "assert pairs_sum_to_zero([4, 6, 2, 4]) == False", "assert pairs_sum_to_zero([5, 2, 1, 11]) == False", "assert pairs_sum_to_zero([5, 2, 7, 3]) == False", "assert pairs_sum_to_zero([5, 5, 2, 2]) == False", "assert pairs_sum_to_zero([-8, 14, -2, 8, 2, 35]) == True", "assert pairs_sum_to_zero([1, 3, 5, 0]) == False", "assert pairs_sum_to_zero([-1, 8, 4, 3, 7, 29]) == False", "assert pairs_sum_to_zero([2, 12, 1, 9, 6, 33]) == False", "assert pairs_sum_to_zero([-4, 11, 1, 6, 6, 28]) == False", "assert pairs_sum_to_zero([0, 11, -3, 8, 7, 26]) == False", "assert pairs_sum_to_zero([-8, 10, -4, 8, 6, 26]) == True", "assert pairs_sum_to_zero([2]) == False", "assert pairs_sum_to_zero([2, 3, 7, 1]) == False", "assert pairs_sum_to_zero([6, 1, -4, 6]) == False", "assert pairs_sum_to_zero([-2, 12, -4, 7, 1, 36]) == False", "assert pairs_sum_to_zero([2, 12, 1, 6, 7, 25]) == False", "assert pairs_sum_to_zero([-4, 11, -3, 6, 2, 27]) == False", "assert pairs_sum_to_zero([0, 13, -2, 7, 3, 31]) == False", "assert pairs_sum_to_zero([1, 4, -10, 5, 10, 9]) == True", "assert pairs_sum_to_zero([4, 1, 3, 7]) == False", "assert pairs_sum_to_zero([6, 8, 2, 5]) == False", "assert pairs_sum_to_zero([-7, 14, 2, 4, 6, 30]) == False", "assert pairs_sum_to_zero([1, 5, 1, 12]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]) == True", "assert pairs_sum_to_zero([-1, 5, -6, 8, 1, 33]) == True", "assert pairs_sum_to_zero([2, 3, 7, 4]) == False", "assert pairs_sum_to_zero([0, 14, -6, 5, 1, 35]) == False", "assert pairs_sum_to_zero([5, 4, -1, 5, 10, 6]) == False", "assert pairs_sum_to_zero([0, 13, -2, 4, 4, 28]) == False", "assert pairs_sum_to_zero([2, 2, 6, 4]) == False", "assert pairs_sum_to_zero([0, 4, -1, 5, 3, 33]) == False", "assert pairs_sum_to_zero([3, 3, 1, 4]) == False", "assert pairs_sum_to_zero([7, 5, -1, 1, 8, 10]) == True", "assert pairs_sum_to_zero([1, 3, 4, 3]) == False", "assert pairs_sum_to_zero([5, 7, 3, 4]) == False", "assert pairs_sum_to_zero([-7, 12, -3, 2, 6, 29]) == False", "assert pairs_sum_to_zero([-4, 9, -3, 6, 7, 31]) == False", "assert pairs_sum_to_zero([4, 7, -9, 5, 4, 6]) == False", "assert pairs_sum_to_zero([-4, 6, 0, 6, 3, 26]) == False", "assert pairs_sum_to_zero([4]) == False", "assert pairs_sum_to_zero([2, 7, 8, 5]) == False", "assert pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) == True", "assert pairs_sum_to_zero([1, 4, -1, 8, 8, 12]) == True", "assert pairs_sum_to_zero([-3, 8, 1, 1, 6, 31]) == False", "assert pairs_sum_to_zero([-6, 14, 1, 8, 2, 28]) == False", "assert pairs_sum_to_zero([-3, 6, -5, 7, 7, 30]) == False", "assert pairs_sum_to_zero([3, 4, -7, 1, 2, 3]) == False", "assert pairs_sum_to_zero([-8, 11, -6, 5, 7, 36]) == False", "assert pairs_sum_to_zero([-7, 14, 0, 5, 1, 28]) == False", "assert pairs_sum_to_zero([-5, 9, -1, 7, 4, 34]) == False", "assert pairs_sum_to_zero([1, 3, 3, 5]) == False", "assert pairs_sum_to_zero([-5, 10, 2, 9, 3, 33]) == False", "assert pairs_sum_to_zero([2, 4, 1, 2]) == False", "assert pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]) == False", "assert pairs_sum_to_zero([1, 3, -2, 1]) == False", "assert pairs_sum_to_zero([2, 10, -2, 2, 4, 33]) == True", "assert pairs_sum_to_zero([3, 9, -8, 6, 2, 5]) == False", "assert pairs_sum_to_zero([-6, 7, -4, 4, 2, 32]) == True", "assert pairs_sum_to_zero([3, 4, 10, 1]) == False", "assert pairs_sum_to_zero([7, 8, -10, 7, 2, 4]) == False", "assert pairs_sum_to_zero([-6, 8, 0, 4, 5, 27]) == False", "assert pairs_sum_to_zero([-6, 14, -4, 5, 6, 32]) == True", "assert pairs_sum_to_zero([-5, 12, 1, 8, 6, 31]) == False", "assert pairs_sum_to_zero([-3, 12, -6, 6, 7, 29]) == True", "assert pairs_sum_to_zero([1, 5, 1, 3]) == False", "assert pairs_sum_to_zero([5, 8, -4, 5]) == False", "assert pairs_sum_to_zero([3, 2, 1, 6]) == False", "assert pairs_sum_to_zero([-5, 4, 3, 6, 2, 27]) == False", "assert pairs_sum_to_zero([-1, 11, -4, 3, 5, 28]) == False", "assert pairs_sum_to_zero([-7, 9, 2, 1, 6, 34]) == False", "assert pairs_sum_to_zero([-1, 13, -4, 6, 3, 28]) == False", "assert pairs_sum_to_zero([6, 1, 0, 3]) == False", "assert pairs_sum_to_zero([-5, 5, -2, 3, 1, 32]) == True", "assert pairs_sum_to_zero([1, 5, -1, 8, 8, 4]) == True", "assert pairs_sum_to_zero([1, 2, 2, 2]) == False", "assert pairs_sum_to_zero([6]) == False", "assert pairs_sum_to_zero([2, 8, 1, 4]) == False", "assert pairs_sum_to_zero([2, 6, 2, 5]) == False", "assert pairs_sum_to_zero([2, 14, 3, 6, 2, 29]) == False", "assert pairs_sum_to_zero([-5, 13, -2, 8, 7, 35]) == False", "assert pairs_sum_to_zero([6, 1, 3, 2]) == False", "assert pairs_sum_to_zero([5]) == False", "assert pairs_sum_to_zero([-4, 8, -1, 7, 6, 26]) == False", "assert pairs_sum_to_zero([-4, 12, 0, 1, 7, 28]) == False", "assert pairs_sum_to_zero([5, 3, 6, 7]) == False", "assert pairs_sum_to_zero([4, 6, -8, 1, 2, 8]) == True", "assert pairs_sum_to_zero([-4, 8, -3, 9, 5, 29]) == False"], "nl": "\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    ", "func": "def pairs_sum_to_zero(l):", "examples": ">>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    ", "repair_prompt": ["def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input, and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", "def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input. The function checks if there are two distinct elements in the list that sum to zero, and returns True if such elements are found. If no such elements exist, it returns False.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''", "def pairs_sum_to_zero(l):\t\n'''pairs_sum_to_zero takes a list of integers as an input, returning True if there are two distinct elements in the list that sum to zero, and False otherwise.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"Checks if there are two distinct elements in the list that sum to zero.\n\n    This function takes a list of integers as input and returns True if there\n    are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Args:\n        l: A list of integers.\n\n    Returns:\n        A boolean indicating if a zero-sum pair exists.\n    \"\"\"\n    seen_numbers = set()\n\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n\n    return False\n\n# Example usage:\n# print(pairs_sum_to_zero([1, 2, 3, -2]))  # Output: True\n# print(pairs_sum_to_zero([1, 2, 3]))      # Output: False\n# print(pairs_sum_to_zero([]))             # Output: False\n# print(pairs_sum_to_zero([0]))            # Output: False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"Check if there are two distinct elements in the list that sum to zero.\n\n    This function takes a list of integers as input and returns True if there\n    are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Args:\n        l (list[int]): A list of integers.\n\n    Returns:\n        bool: True if there are two distinct elements in the list that sum to zero, False otherwise.\n\n    Example:\n        >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n    \"\"\"\n    seen_numbers = set()  # Initialize an empty set to track numbers seen so far\n\n    for number in l:\n        if -number in seen_numbers:\n            return True  # A pair summing to zero is found\n        seen_numbers.add(number)  # Add the current number to the set\n\n    return False  # No pair summing to zero was found\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers as input and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Args:\n        l (list[int]): List of integers.\n\n    Returns:\n        bool: Boolean indicating if any two distinct numbers sum to zero.\n    \"\"\"\n    seen_numbers = set()\n\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n\n    return False\n\n# Example usage:\n# print(pairs_sum_to_zero([]))  # Output: False\n# print(pairs_sum_to_zero([0]))  # Output: False\n# print(pairs_sum_to_zero([1, -1]))  # Output: True\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers as input and returns True if there are two distinct elements that sum to zero,\n    otherwise returns False.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if a pair summing to zero is found, False otherwise.\n\n    Raises:\n    TypeError: If the input is not a list of integers.\n    \"\"\"\n    if not isinstance(l, list) or not all(isinstance(x, int) for x in l):\n        raise TypeError(\"Input must be a list of integers.\")\n\n    seen_numbers = set()\n\n    for number in l:\n        if -number in seen_numbers:\n            return True\n        seen_numbers.add(number)\n\n    return False\n\n# Example usage:\n# print(pairs_sum_to_zero([1, -1, 2, 3]))  # Output: True\n# print(pairs_sum_to_zero([1, 2, 3]))      # Output: False\n# print(pairs_sum_to_zero([0]))            # Output: False\n# print(pairs_sum_to_zero([-3, 3, 3]))     # Output: True\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers and returns True if there are two distinct elements that sum to zero, otherwise returns False.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if a pair summing to zero exists, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of numbers seen so far\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Calculate the complement of the current number\n        complement = -number\n\n        # Check if the complement is already in the set\n        if complement in seen_numbers:\n            # If found, return True as a pair summing to zero exists\n            return True\n\n        # If not found, add the current number to the set\n        seen_numbers.add(number)\n\n    # If the loop completes without finding any such pair, return False\n    return False\n\n# Example usage:\n# print(pairs_sum_to_zero([0, 0]))  # Expected output: True\n# print(pairs_sum_to_zero([1, -1])) # Expected output: True\n# print(pairs_sum_to_zero([1]))     # Expected output: False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    The function checks if there are two distinct elements in the list that sum to zero,\n    and returns True if such elements are found. If no such elements exist, it returns False.\n    \n    Parameters:\n    l (list[int]): A list of integers.\n    \n    Returns:\n    bool: True if there are two distinct elements that sum to zero, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of numbers seen so far\n    seen_numbers = set()\n    \n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            # If found, return True as a pair summing to zero exists\n            return True\n        # If not found, add the current number to the set\n        seen_numbers.add(number)\n    \n    # If the loop completes without finding such a pair, return False\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers as input and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n    \n    Parameters:\n    l (list[int]): A list of integers.\n    \n    Returns:\n    bool: True if any two distinct numbers sum to zero, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of numbers seen so far\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            # If found, return True as a pair summing to zero exists\n            return True\n        # If not found, add the current number to the set\n        seen_numbers.add(number)\n\n    # If the loop completes without finding such a pair, return False\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers and returns True if there are two distinct elements that sum to zero, False otherwise.\n\n    Args:\n        l: List of integers\n\n    Returns:\n        Boolean indicating if a pair summing to zero exists\n    \"\"\"\n    # Initialize an empty set to keep track of numbers we have seen\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            # If found, return True as we have found a pair that sums to zero\n            return True\n        # Add the current number to the set\n        seen_numbers.add(number)\n\n    # If no such pair is found by the end of the list, return False\n    return False\n\n# Example usage:\n# print(pairs_sum_to_zero([0, 0]))  # Expected output: True\n# print(pairs_sum_to_zero([-1, 1]))  # Expected output: True\n# print(pairs_sum_to_zero([1]))      # Expected output: False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"\n    Takes a list of integers as input and returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n\n    Parameters:\n    l (list[int]): A list of integers.\n\n    Returns:\n    bool: True if there are two distinct elements that sum to zero, False otherwise.\n    \"\"\"\n    # Initialize an empty set to keep track of numbers we have seen\n    seen_numbers = set()\n\n    # Iterate through each number in the list\n    for number in l:\n        # Check if the negative of the current number is already in the set\n        if -number in seen_numbers:\n            return True\n        # Add the current number to the set\n        seen_numbers.add(number)\n\n    # If no pair is found by the end of the list, return False\n    return False\n", "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"Check if there are two distinct elements in the list that sum to zero.\n\n    This function takes a list of integers as input and returns True if there\n    are two distinct elements in the list whose sum is zero. Otherwise, it\n    returns False.\n\n    Args:\n        l (list[int]): A list of integers.\n\n    Returns:\n        bool: True if there are two distinct elements that sum to zero, False otherwise.\n\n    Examples:\n        >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n        >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n        >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n        >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n        >>> pairs_sum_to_zero([1])\n        False\n    \"\"\"\n    seen = set()\n    for number in l:\n        if -number in seen:\n            return True\n        seen.add(number)\n    return False\n"], "plans": ["requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets.\nrequirement pool:\n- Implement the main algorithm to find pairs that sum to zero\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation for users\n- Ensure compatibility with various data types\n- Include unit tests to verify functionality\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. To optimize performance, we will use a set to track the numbers we have seen so far, which allows for O(1) average time complexity for lookups. This approach will handle large lists efficiently. We will also ensure the function handles edge cases such as empty lists or lists with a single element.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different elements in the list, not the same element used twice.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of two distinct elements in the list should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers seen so far.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If no such pair is found by the end of the list, return False.\n\n# [edge case] \n    pairs_sum_to_zero([]) = False\n    Explanation: An empty list has no elements, so no pairs can sum to zero.\n    \n    pairs_sum_to_zero([0]) = False\n    Explanation: A single element cannot form a pair, so it cannot sum to zero with another distinct element.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains two distinct elements that sum to zero (1 and -1).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already accounts for lists with fewer than two elements by returning False when no pair is found.\n", "requirement analysis:\nThe function should efficiently determine if any two distinct integers in a list sum to zero. It must handle edge cases such as empty lists or lists with a single element. The implementation should prioritize performance and clarity.\nrequirement pool:\n- Implement the main function logic\n- Optimize for large input lists\n- Ensure clear and comprehensive documentation\n- Handle edge cases effectively\n- Maintain readability and simplicity\nWe will use a set to track the numbers we have seen so far. This allows us to efficiently check if the negative of the current number exists in the set, which would mean a pair summing to zero has been found. This approach is optimal for large lists as it provides O(n) time complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements that sum to zero must be different from each other, not the same element used twice.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of two distinct elements in the list should equal zero. In code, this can be implemented by checking if the negative of a current element exists in a set of seen elements.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers seen so far.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: The two distinct elements are both zero, and their sum is zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one element, so no pair can be formed.\n\n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 are distinct and their sum is zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using a set to track seen numbers and checking for their negatives will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check for pairs of numbers that sum to zero, handle edge cases, and be easy to integrate into larger systems. It should be optimized for performance and provide clear documentation.\nrequirement pool:\n- Implement the main function to check for pairs summing to zero.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles edge cases like empty or single-element lists.\n- Provide comprehensive documentation and examples.\n- Create unit tests to verify function correctness.\nWe will implement a function that iterates through the list and uses a set to track the numbers we have seen so far. For each number, we will check if its negation is already in the set, which would mean a pair summing to zero exists. This approach ensures the function is efficient, with a time complexity of O(n), and handles edge cases like empty or single-element lists gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements that sum to zero must be different from each other, i.e., they cannot be the same element.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of two distinct elements in the list should equal zero. In code, this can be implemented by checking if the negation of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negation is already in the set.\n    4. If the negation is found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If no such pair is found after iterating through the list, return False.\n\n# [edge case] \n    pairs_sum_to_zero([]) = False\n    Explanation: An empty list has no elements, so no pairs can sum to zero.\n    \n    pairs_sum_to_zero([0]) = False\n    Explanation: A single-element list cannot have two distinct elements that sum to zero.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains two distinct elements, 1 and -1, which sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles cases like empty or single-element lists by returning False when no valid pairs are found.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets, and clear documentation will aid in user understanding and integration.\nrequirement pool:\n- Implement the main function to detect pairs summing to zero\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation\n- Include error handling for invalid inputs\n- Test the function with various edge cases\nWe will implement a function that efficiently checks for pairs of integers that sum to zero using a set for fast look-up operations. This approach will optimize performance for large lists. We will also include error handling for invalid inputs and provide comprehensive documentation with examples.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different from each other, i.e., they cannot be the same element.\n\n# [phrase showing quantity relationship]\n    'sum to zero': means that the sum of two distinct elements should equal zero. In code, this can be implemented by checking if the negative of a number exists in the list.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Initialize an empty set to store elements for quick lookup.\n    - Iterate through each element in the list.\n    - For each element, check if its negative counterpart exists in the set.\n    - If found, return True as a pair summing to zero exists.\n    - If not found, add the element to the set for future checks.\n    - After iterating through all elements, if no pair is found, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0]) = False\n    Explanation: A single element cannot form a pair, so even though 0 sums to zero with itself, it does not meet the requirement of distinct elements.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains two distinct elements that sum to zero (1 and -1), so the expected output is True.\n    \n    pairs_sum_to_zero([-3, 3, 3]) = True\n    Explanation: The list contains two distinct elements (-3 and 3) that sum to zero, so the expected output is True.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to check for pairs efficiently handles these scenarios.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets, and clear documentation will aid in user understanding and integration.\nrequirement pool:\n- Implement the main function logic to detect pairs summing to zero\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation and examples\n- Ensure compatibility with various Python versions\n- Include unit tests for edge cases\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. To optimize performance, especially for large datasets, we will use a set to track the numbers we have seen so far. This allows us to check for the existence of the complement of each number in constant time. The function will be simple to integrate and will include comprehensive documentation and examples.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different from each other in terms of their position in the list, even if they have the same value.\n\n    'sum to zero'\n    Explanation: This means that the sum of the two distinct elements should equal zero.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers seen so far.\n    2. Iterate through each number in the list.\n    3. For each number, calculate its complement (i.e., the number that when added to it results in zero).\n    4. Check if the complement is already in the set.\n    5. If the complement is found, return True as a pair summing to zero exists.\n    6. If not found, add the current number to the set.\n    7. If the loop completes without finding any such pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: Two zeros are distinct elements and their sum is zero.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The numbers 1 and -1 are distinct and their sum is zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: A single element cannot form a pair, so it cannot sum to zero with another element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track complements will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check for pairs of numbers that sum to zero, handle edge cases, and be easy to integrate into larger systems. It should be well-documented and optimized for performance.\nrequirement pool:\n- Implement the main function logic to find pairs summing to zero.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles edge cases like empty or single-element lists.\n- Provide comprehensive documentation and examples.\n- Test the function with a variety of input scenarios.\nWe will implement a function using built-in Python functions to efficiently check for pairs of numbers that sum to zero. The function will handle edge cases such as empty lists or lists with a single element. We will use a set to track seen numbers for optimal performance, ensuring the function is easy to integrate into larger systems.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different elements in the list, not the same element used twice.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of the two distinct elements should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers seen so far.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([]) = False\n    Explanation: An empty list has no elements, so no pairs can exist.\n    \n    pairs_sum_to_zero([0]) = False\n    Explanation: A single element cannot form a pair with itself, so no pairs can sum to zero.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains a pair (1, -1) that sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track seen numbers and checking for their negatives inherently handles these cases.\n", "requirement analysis:\nThe function should efficiently check for pairs of numbers that sum to zero, handle edge cases, and be easy to use and integrate. It should be optimized for performance, especially with large datasets, and provide clear documentation for ease of use.\nrequirement pool:\n- Implement the main function to check for pairs summing to zero.\n- Optimize the function for performance with large lists.\n- Ensure the function handles edge cases like empty or single-element lists.\n- Provide comprehensive documentation and examples.\n- Test the function with a variety of datasets to ensure reliability.\nWe will implement a function that efficiently checks for pairs of numbers that sum to zero using a set for fast look-up operations. This approach will ensure the function is optimized for performance, especially with large datasets. The function will handle edge cases such as empty or single-element lists by returning False immediately. We will use Python's built-in data structures to maintain simplicity and ease of integration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different from each other in terms of their position in the list, even if they have the same value.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of the two distinct elements should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of numbers already seen.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers seen so far.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If found, return True as a pair summing to zero exists.\n    5. If not found, add the current number to the set.\n    6. If the loop completes without finding such a pair, return False.\n\n# [edge case] \n    pairs_sum_to_zero([]) = False\n    Explanation: An empty list has no elements, so no pairs can exist.\n    \n    pairs_sum_to_zero([0]) = False\n    Explanation: A single element cannot form a pair, so it cannot sum to zero with another distinct element.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The list contains two distinct elements that sum to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles cases like empty lists and single-element lists by returning False immediately.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets, and documentation should provide clear usage instructions and examples.\nrequirement pool:\n- Implement the main function logic to find pairs summing to zero\n- Optimize the function for performance with large lists\n- Provide comprehensive documentation with examples\n- Ensure compatibility with various Python versions\n- Include error handling for invalid inputs\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. To optimize performance for large lists, we will use a set to track the numbers we have seen, allowing for O(1) average time complexity for lookups. This approach will ensure the function runs quickly even for large datasets. Comprehensive documentation will be provided with examples to illustrate usage.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different from each other in terms of their indices in the list.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of the two distinct elements should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If the negative is found, return True as we have found a pair that sums to zero.\n    5. If not, add the current number to the set.\n    6. If no such pair is found by the end of the list, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: Two zeros sum to zero, and they are distinct elements.\n    \n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: -1 and 1 are distinct elements and their sum is zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: A single element cannot form a pair, so it cannot sum to zero with another distinct element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of using a set to track seen numbers and checking for their negatives will naturally handle these cases.\n", "requirement analysis:\nThe function should efficiently check for pairs of numbers that sum to zero, handle edge cases, and be easy to use and integrate. It should be optimized for performance, especially with large datasets.\nrequirement pool:\n- The function must return True if two distinct elements sum to zero.\n- The function should handle edge cases like empty lists or single-element lists.\n- The function should be optimized for performance with large datasets.\n- The function should have clear and concise documentation.\n- The function should be easy to integrate into larger systems.\nWe will implement a function using Python's built-in set data structure to efficiently check for pairs of numbers that sum to zero. This approach leverages the average O(1) time complexity for set operations, making it suitable for large datasets. The function will handle edge cases such as empty lists or single-element lists by returning False immediately.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements that sum to zero must be different from each other.\n\n# [phrase showing quantity relationship]\n    'sum to zero': means that the sum of two distinct elements should be equal to zero. This can be implemented by checking if the negative of a number exists in the list.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If the negative is found, return True.\n    5. If not found, add the number to the set.\n    6. If no pair is found by the end of the list, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0]) = False\n    Explanation: There is only one element, so no pair can be formed.\n    \n    pairs_sum_to_zero([]) = False\n    Explanation: The list is empty, so no pair can be formed.\n    \n    pairs_sum_to_zero([1, -1]) = True\n    Explanation: The pair (1, -1) sums to zero.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles cases like empty lists or single-element lists by returning False immediately.\n", "requirement analysis:\nThe function should efficiently identify pairs of integers that sum to zero, ensuring it handles edge cases such as empty lists or lists with a single element. Performance optimization is crucial for handling large datasets, and clear documentation will aid in user understanding and integration.\nrequirement pool:\n- Implement the main algorithm to find pairs summing to zero\n- Optimize the algorithm for performance with large lists\n- Provide comprehensive documentation and examples\n- Ensure compatibility with various Python versions\n- Include error handling for invalid inputs\nWe will implement a function that efficiently checks for pairs of integers in a list that sum to zero. The function will utilize a set to track the numbers we have seen so far, which allows for O(1) average time complexity for lookups. This approach ensures that the function can handle large lists efficiently. We will also include comprehensive documentation and examples to aid user understanding and integration.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'distinct elements'\n    Explanation: In the requirement, it means that the two elements being considered for summing to zero must be different elements in the list, not the same element used twice.\n\n# [phrase showing quantity relationship]\n    'sum to zero': This means that the sum of two distinct elements in the list should equal zero. In code, this can be implemented by checking if the negative of a number exists in the set of seen numbers.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Initialize an empty set to keep track of numbers we have seen.\n    2. Iterate through each number in the list.\n    3. For each number, check if its negative is already in the set.\n    4. If it is, return True because a pair that sums to zero has been found.\n    5. If not, add the current number to the set.\n    6. If no such pair is found by the end of the list, return False.\n\n# [edge case] \n    pairs_sum_to_zero([0, 0]) = True\n    Explanation: The two zeros are distinct elements and their sum is zero.\n    \n    pairs_sum_to_zero([-1, 1]) = True\n    Explanation: The elements -1 and 1 are distinct and their sum is zero.\n    \n    pairs_sum_to_zero([1]) = False\n    Explanation: There is only one element, so no pair can be formed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of checking for a negative counterpart in a set will naturally handle these cases.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [126, 126, 126, 126, 126, 126, 126, 126, 126, 126], "completion": "from typing import List\n## main.py\n\ndef pairs_sum_to_zero(l: list[int]) -> bool:\n    \"\"\"Check if there are two distinct elements in the list that sum to zero.\n\n    This function takes a list of integers as input and returns True if there\n    are two distinct elements in the list whose sum is zero. Otherwise, it\n    returns False.\n\n    Args:\n        l (list[int]): A list of integers.\n\n    Returns:\n        bool: True if there are two distinct elements that sum to zero, False otherwise.\n\n    Examples:\n        >>> pairs_sum_to_zero([1, 3, 5, 0])\n        False\n        >>> pairs_sum_to_zero([1, 3, -2, 1])\n        False\n        >>> pairs_sum_to_zero([1, 2, 3, 7])\n        False\n        >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n        True\n        >>> pairs_sum_to_zero([1])\n        False\n    \"\"\"\n    seen = set()\n    for number in l:\n        if -number in seen:\n            return True\n        seen.add(number)\n    return False\n", "passed": true, "pass": true, "pass_num": 10, "round": 287, "mutate_method": "condense_two2one", "parent_index": 145}
