{"task_id": "HumanEval/21", "prompt": "def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given a list of numbers (comprising at least two elements), apply a linear transform to that list, so that the minimum number becomes 0 and the maximum becomes 1.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''", "entry_point": "rescale_to_unit", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "test": ["def check(rescale_to_unit):\n\tassert rescale_to_unit([99.9, 47.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.2, 51.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.7, 49.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.7, 51.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.8, 4.8, 4.5, 1.8, 1.7]) == [0.3548387096774194, 1.0, 0.903225806451613, 0.032258064516129066, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.5, 1.4, 8.1, 4.2, 6.7]) == [0.014925373134328374, 0.0, 1.0, 0.4179104477611941, 0.7910447761194032]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.2, 8.7, 11.8, 16.6, 14.9]) == [0.0, 0.15957446808510625, 0.4893617021276595, 1.0, 0.8191489361702126]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.2, 54.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([15.4, 13.2, 13.8, 17.0, 17.9]) == [0.468085106382979, 0.0, 0.12765957446808543, 0.8085106382978726, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([101.4, 46.5]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 6.9, 8.3, 7.9, 6.9]) == [0.0, 0.5757575757575757, 1.0, 0.8787878787878787, 0.5757575757575757]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([104.6, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.3, 46.5]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.2, 52.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 54.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.2, 47.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.6, 9.8, 13.5, 15.4, 15.5]) == [0.14035087719298228, 0.0, 0.6491228070175438, 0.9824561403508772, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([103.9, 51.6]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.3, 9.9, 18.2, 18.6, 15.0]) == [0.04597701149425291, 0.0, 0.9540229885057468, 1.0, 0.586206896551724]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.1, 5.6, 7.5, 4.7, 2.2]) == [0.5471698113207546, 0.6415094339622641, 1.0, 0.4716981132075472, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.2, 49.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([99.6, 50.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.8, 50.6]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([13.5, 11.1, 16.3, 15.7, 14.2]) == [0.4615384615384615, 0.0, 1.0, 0.8846153846153844, 0.5961538461538459]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([11.4, 11.3, 14.4, 18.1, 9.6]) == [0.211764705882353, 0.2000000000000001, 0.5647058823529412, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([103.9, 44.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.9, 1.1, 1.7, 7.1, 4.6]) == [0.3, 0.0, 0.09999999999999998, 1.0, 0.5833333333333333]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.5, 4.5, 8.2, 6.4, 10.1]) == [0.35714285714285715, 0.0, 0.6607142857142856, 0.33928571428571436, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.5, 5.1, 8.1, 7.0, 8.3]) == [0.0, 0.15789473684210514, 0.9473684210526313, 0.6578947368421051, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.9, 4.1, 7.1, 9.3, 10.0]) == [0.13559322033898316, 0.0, 0.5084745762711864, 0.8813559322033899, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.6, 3.9, 10.6, 3.8, 9.3]) == [0.0, 0.16249999999999998, 1.0, 0.14999999999999997, 0.8375000000000001]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.3, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.4, 49.3]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.9, 5.9, 10.7, 3.0, 3.1]) == [0.0, 0.38461538461538475, 1.0, 0.012820512820512834, 0.025641025641025668]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.5, 1.1, 2.9, 7.4, 5.1]) == [1.0, 0.0, 0.28124999999999994, 0.9843750000000001, 0.6249999999999999]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.3, 5.8, 7.5, 4.0, 9.7]) == [0.4035087719298246, 0.3157894736842105, 0.6140350877192983, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.7, 53.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.5, 2.9, 6.4, 6.8, 1.0]) == [0.9482758620689655, 0.3275862068965517, 0.9310344827586208, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.6, 3.4, 5.5, 9.4, 7.2]) == [0.0, 0.23076923076923073, 0.49999999999999994, 1.0, 0.7179487179487178]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 5.9, 2.8, 5.2, 11.0]) == [0.21951219512195122, 0.378048780487805, 0.0, 0.2926829268292684, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.2, 3.3, 2.1, 1.5, 5.7]) == [1.0, 0.38297872340425526, 0.12765957446808512, 0.0, 0.8936170212765957]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([16.2, 16.6, 16.6, 12.8, 18.2]) == [0.6296296296296295, 0.703703703703704, 0.703703703703704, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.4, 48.1]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.4, 7.5, 6.4, 5.1, 10.6]) == [0.0, 0.5694444444444444, 0.4166666666666668, 0.2361111111111111, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.7, 1.2, 6.7, 3.4, 8.2]) == [0.3571428571428572, 0.0, 0.7857142857142858, 0.31428571428571433, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 4.5, 5.5, 2.4, 5.1]) == [0.7096774193548386, 0.6774193548387097, 1.0, 0.0, 0.8709677419354838]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.5, 17.0, 13.4, 10.5, 15.8]) == [1.0, 0.9285714285714286, 0.4142857142857143, 0.0, 0.7571428571428572]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.8, 6.5, 5.7, 1.4, 9.9]) == [0.5176470588235295, 0.6, 0.5058823529411766, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.1, 4.6, 6.9, 5.1, 4.6]) == [1.0, 0.0, 0.9200000000000003, 0.2, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.2, 53.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.5, 44.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([11.6, 9.7, 12.4, 18.9, 9.4]) == [0.23157894736842102, 0.03157894736842095, 0.31578947368421056, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.3, 5.4, 1.8, 4.3, 8.7]) == [0.0, 0.5540540540540542, 0.06756756756756757, 0.40540540540540543, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.7, 2.2, 4.7, 8.7, 7.8]) == [0.5384615384615385, 0.0, 0.3846153846153847, 1.0, 0.8615384615384616]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.6, 1.6, 4.7, 8.8, 6.6]) == [0.0, 0.0, 0.4305555555555555, 1.0, 0.6944444444444443]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.1, 51.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.1, 50.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([97.0, 52.7]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.1, 3.9, 4.9, 8.0, 3.4]) == [0.0, 0.30508474576271183, 0.4745762711864407, 1.0, 0.22033898305084743]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.8, 52.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.9, 2.9, 8.4, 9.6, 6.9]) == [0.4477611940298509, 0.0, 0.8208955223880597, 1.0, 0.5970149253731344]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 7.5, 19.8, 18.8, 12.9]) == [0.0, 0.016000000000000014, 1.0, 0.92, 0.44800000000000006]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 1.6, 9.0, 8.2, 7.2]) == [0.45945945945945943, 0.0, 1.0, 0.8918918918918918, 0.7567567567567567]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.5, 2.8, 8.2, 9.8, 6.8]) == [0.10000000000000002, 0.0, 0.7714285714285712, 1.0, 0.5714285714285714]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([8.0, 9.3, 17.1, 18.5, 10.5]) == [0.0, 0.12380952380952388, 0.8666666666666668, 1.0, 0.23809523809523808]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.6, 1.6, 1.3, 6.9, 2.3]) == [0.9464285714285713, 0.053571428571428575, 0.0, 1.0, 0.17857142857142852]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.4, 45.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.3, 2.5, 1.2, 4.0, 8.5]) == [0.4246575342465753, 0.17808219178082194, 0.0, 0.3835616438356164, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.9, 50.7]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.9, 46.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.4, 2.6, 2.1, 7.0, 2.4]) == [0.46938775510204084, 0.1020408163265306, 0.0, 1.0, 0.061224489795918324]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([14.6, 6.7, 19.2, 13.8, 13.5]) == [0.632, 0.0, 1.0, 0.5680000000000001, 0.544]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.6, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 5.5, 10.2, 3.9, 4.4]) == [0.0, 0.38961038961038963, 1.0, 0.18181818181818182, 0.24675324675324684]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.4, 8.1, 15.5, 14.4, 15.1]) == [0.5810810810810811, 0.0, 1.0, 0.8513513513513514, 0.9459459459459459]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.5, 53.2]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.1, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.1, 6.1, 8.0, 6.4, 8.7]) == [0.0, 0.0, 0.7307692307692311, 0.11538461538461567, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.2, 12.9, 12.4, 11.6, 16.9]) == [0.11320754716981128, 0.24528301886792472, 0.15094339622641526, 0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.9, 13.2, 20.2, 11.2, 11.2]) == [0.0, 0.24731182795698917, 1.0, 0.03225806451612892, 0.03225806451612892]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([96.2, 53.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([95.4, 48.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.7, 44.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.0, 48.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.4, 51.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([16.1, 13.0, 15.9, 9.1, 15.3]) == [1.0, 0.557142857142857, 0.9714285714285713, 0.0, 0.8857142857142857]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 2.1, 4.3, 7.7, 9.7]) == [0.05263157894736841, 0.0, 0.28947368421052627, 0.7368421052631579, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.0, 48.4]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.6, 6.9, 7.0, 2.7, 4.9]) == [1.0, 0.8571428571428573, 0.8775510204081634, 0.0, 0.4489795918367348]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.5, 5.6, 3.1, 8.0, 9.4]) == [0.3809523809523809, 0.3968253968253967, 0.0, 0.7777777777777778, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.4, 3.2, 3.7, 8.2, 1.1]) == [0.18309859154929575, 0.295774647887324, 0.36619718309859156, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 1.5, 9.5, 4.6, 1.2]) == [0.7349397590361445, 0.03614457831325302, 1.0, 0.40963855421686735, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.8, 45.9]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([9.7, 7.6, 13.7, 8.1, 10.3]) == [0.34426229508196715, 0.0, 1.0, 0.0819672131147541, 0.44262295081967235]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([15.7, 12.5, 16.1, 8.7, 9.6]) == [0.9459459459459457, 0.5135135135135135, 1.0, 0.0, 0.12162162162162163]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.1, 14.1, 14.5, 9.1, 9.5]) == [0.18518518518518517, 0.9259259259259258, 1.0, 0.0, 0.07407407407407414]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([6.7, 47.3]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.9, 4.4, 1.4, 3.4, 2.8]) == [1.0, 0.6666666666666667, 0.0, 0.4444444444444444, 0.3111111111111111]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.1, 6.8, 5.3, 5.4, 5.5]) == [0.0, 1.0, 0.5945945945945945, 0.6216216216216217, 0.6486486486486487]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.1, 51.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.0, 3.8, 8.2, 3.9, 1.1]) == [0.5492957746478874, 0.38028169014084506, 1.0, 0.39436619718309857, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([1.9, 4.8, 3.2, 4.3, 1.4]) == [0.14705882352941177, 1.0, 0.5294117647058825, 0.8529411764705882, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([10.1, 12.6, 10.2, 16.8, 11.1]) == [0.0, 0.3731343283582089, 0.014925373134328302, 1.0, 0.14925373134328357]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.6, 5.7, 10.7, 5.4, 4.4]) == [0.03174603174603164, 0.20634920634920637, 1.0, 0.15873015873015875, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.0, 52.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([98.1, 46.8]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.4, 50.9]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.5, 46.2]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.2, 2.1, 1.6, 6.4, 3.7]) == [0.3333333333333333, 0.10416666666666666, 0.0, 1.0, 0.43749999999999994]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.0, 51.8]) == [0.0, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.9, 44.8]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.3, 4.4, 8.8, 2.9, 1.7]) == [0.22535211267605632, 0.38028169014084506, 1.0, 0.16901408450704222, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.6, 14.9, 12.4, 9.6, 14.2]) == [1.0, 0.6625, 0.35000000000000003, 0.0, 0.5749999999999998]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.4, 46.0]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([12.3, 14.5, 18.1, 18.3, 10.4]) == [0.24050632911392408, 0.5189873417721518, 0.9746835443037976, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([105.8, 45.3]) == [1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([5.4, 1.8, 4.4, 7.7, 2.8]) == [0.6101694915254238, 0.0, 0.44067796610169496, 1.0, 0.16949152542372878]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([3.7, 3.9, 1.2, 4.6, 7.1]) == [0.42372881355932207, 0.45762711864406785, 0.0, 0.5762711864406779, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([9.7, 13.8, 18.7, 15.3, 14.7]) == [0.0, 0.4555555555555557, 1.0, 0.6222222222222223, 0.5555555555555556]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([17.6, 8.7, 12.8, 9.2, 17.0]) == [1.0, 0.0, 0.46067415730337086, 0.05617977528089886, 0.9325842696629212]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.5, 4.4, 8.0, 3.4, 10.2]) == [0.0, 0.24675324675324684, 0.7142857142857143, 0.11688311688311688, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([2.3, 3.4, 7.0, 6.8, 4.4]) == [0.0, 0.23404255319148937, 1.0, 0.9574468085106382, 0.44680851063829796]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([4.3, 4.4, 6.1, 8.4, 1.2]) == [0.43055555555555547, 0.4444444444444445, 0.6805555555555555, 1.0, 0.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([7.3, 7.4, 16.1, 10.7, 18.0]) == [0.0, 0.009345794392523414, 0.8224299065420562, 0.3177570093457944, 1.0]", "def check(rescale_to_unit):\n\tassert rescale_to_unit([102.3, 47.4]) == [1.0, 0.0]"], "test_case_list": ["assert rescale_to_unit([99.9, 47.9]) == [1.0, 0.0]", "assert rescale_to_unit([3.2, 51.8]) == [0.0, 1.0]", "assert rescale_to_unit([100.7, 49.1]) == [1.0, 0.0]", "assert rescale_to_unit([4.7, 51.3]) == [0.0, 1.0]", "assert rescale_to_unit([2.8, 4.8, 4.5, 1.8, 1.7]) == [0.3548387096774194, 1.0, 0.903225806451613, 0.032258064516129066, 0.0]", "assert rescale_to_unit([1.5, 1.4, 8.1, 4.2, 6.7]) == [0.014925373134328374, 0.0, 1.0, 0.4179104477611941, 0.7910447761194032]", "assert rescale_to_unit([7.2, 8.7, 11.8, 16.6, 14.9]) == [0.0, 0.15957446808510625, 0.4893617021276595, 1.0, 0.8191489361702126]", "assert rescale_to_unit([4.2, 54.2]) == [0.0, 1.0]", "assert rescale_to_unit([15.4, 13.2, 13.8, 17.0, 17.9]) == [0.468085106382979, 0.0, 0.12765957446808543, 0.8085106382978726, 1.0]", "assert rescale_to_unit([101.4, 46.5]) == [1.0, 0.0]", "assert rescale_to_unit([5.0, 6.9, 8.3, 7.9, 6.9]) == [0.0, 0.5757575757575757, 1.0, 0.8787878787878787, 0.5757575757575757]", "assert rescale_to_unit([104.6, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([1.3, 46.5]) == [0.0, 1.0]", "assert rescale_to_unit([1.2, 52.9]) == [0.0, 1.0]", "assert rescale_to_unit([2.5, 54.9]) == [0.0, 1.0]", "assert rescale_to_unit([4.2, 47.3]) == [0.0, 1.0]", "assert rescale_to_unit([10.6, 9.8, 13.5, 15.4, 15.5]) == [0.14035087719298228, 0.0, 0.6491228070175438, 0.9824561403508772, 1.0]", "assert rescale_to_unit([103.9, 51.6]) == [1.0, 0.0]", "assert rescale_to_unit([10.3, 9.9, 18.2, 18.6, 15.0]) == [0.04597701149425291, 0.0, 0.9540229885057468, 1.0, 0.586206896551724]", "assert rescale_to_unit([5.1, 5.6, 7.5, 4.7, 2.2]) == [0.5471698113207546, 0.6415094339622641, 1.0, 0.4716981132075472, 0.0]", "assert rescale_to_unit([7.2, 49.3]) == [0.0, 1.0]", "assert rescale_to_unit([99.6, 50.1]) == [1.0, 0.0]", "assert rescale_to_unit([98.8, 50.6]) == [1.0, 0.0]", "assert rescale_to_unit([13.5, 11.1, 16.3, 15.7, 14.2]) == [0.4615384615384615, 0.0, 1.0, 0.8846153846153844, 0.5961538461538459]", "assert rescale_to_unit([11.4, 11.3, 14.4, 18.1, 9.6]) == [0.211764705882353, 0.2000000000000001, 0.5647058823529412, 1.0, 0.0]", "assert rescale_to_unit([103.9, 44.1]) == [1.0, 0.0]", "assert rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([2.9, 1.1, 1.7, 7.1, 4.6]) == [0.3, 0.0, 0.09999999999999998, 1.0, 0.5833333333333333]", "assert rescale_to_unit([6.5, 4.5, 8.2, 6.4, 10.1]) == [0.35714285714285715, 0.0, 0.6607142857142856, 0.33928571428571436, 1.0]", "assert rescale_to_unit([4.5, 5.1, 8.1, 7.0, 8.3]) == [0.0, 0.15789473684210514, 0.9473684210526313, 0.6578947368421051, 1.0]", "assert rescale_to_unit([4.9, 4.1, 7.1, 9.3, 10.0]) == [0.13559322033898316, 0.0, 0.5084745762711864, 0.8813559322033899, 1.0]", "assert rescale_to_unit([2.6, 3.9, 10.6, 3.8, 9.3]) == [0.0, 0.16249999999999998, 1.0, 0.14999999999999997, 0.8375000000000001]", "assert rescale_to_unit([98.3, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([100.4, 49.3]) == [1.0, 0.0]", "assert rescale_to_unit([2.9, 5.9, 10.7, 3.0, 3.1]) == [0.0, 0.38461538461538475, 1.0, 0.012820512820512834, 0.025641025641025668]", "assert rescale_to_unit([7.5, 1.1, 2.9, 7.4, 5.1]) == [1.0, 0.0, 0.28124999999999994, 0.9843750000000001, 0.6249999999999999]", "assert rescale_to_unit([6.3, 5.8, 7.5, 4.0, 9.7]) == [0.4035087719298246, 0.3157894736842105, 0.6140350877192983, 0.0, 1.0]", "assert rescale_to_unit([95.7, 53.0]) == [1.0, 0.0]", "assert rescale_to_unit([6.5, 2.9, 6.4, 6.8, 1.0]) == [0.9482758620689655, 0.3275862068965517, 0.9310344827586208, 1.0, 0.0]", "assert rescale_to_unit([1.6, 3.4, 5.5, 9.4, 7.2]) == [0.0, 0.23076923076923073, 0.49999999999999994, 1.0, 0.7179487179487178]", "assert rescale_to_unit([4.6, 5.9, 2.8, 5.2, 11.0]) == [0.21951219512195122, 0.378048780487805, 0.0, 0.2926829268292684, 1.0]", "assert rescale_to_unit([6.2, 3.3, 2.1, 1.5, 5.7]) == [1.0, 0.38297872340425526, 0.12765957446808512, 0.0, 0.8936170212765957]", "assert rescale_to_unit([16.2, 16.6, 16.6, 12.8, 18.2]) == [0.6296296296296295, 0.703703703703704, 0.703703703703704, 0.0, 1.0]", "assert rescale_to_unit([100.4, 48.1]) == [1.0, 0.0]", "assert rescale_to_unit([3.4, 7.5, 6.4, 5.1, 10.6]) == [0.0, 0.5694444444444444, 0.4166666666666668, 0.2361111111111111, 1.0]", "assert rescale_to_unit([3.7, 1.2, 6.7, 3.4, 8.2]) == [0.3571428571428572, 0.0, 0.7857142857142858, 0.31428571428571433, 1.0]", "assert rescale_to_unit([4.6, 4.5, 5.5, 2.4, 5.1]) == [0.7096774193548386, 0.6774193548387097, 1.0, 0.0, 0.8709677419354838]", "assert rescale_to_unit([17.5, 17.0, 13.4, 10.5, 15.8]) == [1.0, 0.9285714285714286, 0.4142857142857143, 0.0, 0.7571428571428572]", "assert rescale_to_unit([5.8, 6.5, 5.7, 1.4, 9.9]) == [0.5176470588235295, 0.6, 0.5058823529411766, 0.0, 1.0]", "assert rescale_to_unit([7.1, 4.6, 6.9, 5.1, 4.6]) == [1.0, 0.0, 0.9200000000000003, 0.2, 0.0]", "assert rescale_to_unit([6.2, 53.8]) == [0.0, 1.0]", "assert rescale_to_unit([1.5, 44.9]) == [0.0, 1.0]", "assert rescale_to_unit([11.6, 9.7, 12.4, 18.9, 9.4]) == [0.23157894736842102, 0.03157894736842095, 0.31578947368421056, 1.0, 0.0]", "assert rescale_to_unit([1.3, 5.4, 1.8, 4.3, 8.7]) == [0.0, 0.5540540540540542, 0.06756756756756757, 0.40540540540540543, 1.0]", "assert rescale_to_unit([5.7, 2.2, 4.7, 8.7, 7.8]) == [0.5384615384615385, 0.0, 0.3846153846153847, 1.0, 0.8615384615384616]", "assert rescale_to_unit([1.6, 1.6, 4.7, 8.8, 6.6]) == [0.0, 0.0, 0.4305555555555555, 1.0, 0.6944444444444443]", "assert rescale_to_unit([2.1, 51.4]) == [0.0, 1.0]", "assert rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]", "assert rescale_to_unit([6.1, 50.2]) == [0.0, 1.0]", "assert rescale_to_unit([97.0, 52.7]) == [1.0, 0.0]", "assert rescale_to_unit([2.1, 3.9, 4.9, 8.0, 3.4]) == [0.0, 0.30508474576271183, 0.4745762711864407, 1.0, 0.22033898305084743]", "assert rescale_to_unit([7.8, 52.2]) == [0.0, 1.0]", "assert rescale_to_unit([5.9, 2.9, 8.4, 9.6, 6.9]) == [0.4477611940298509, 0.0, 0.8208955223880597, 1.0, 0.5970149253731344]", "assert rescale_to_unit([2.0, 49.9]) == [0.0, 1.0]", "assert rescale_to_unit([7.3, 7.5, 19.8, 18.8, 12.9]) == [0.0, 0.016000000000000014, 1.0, 0.92, 0.44800000000000006]", "assert rescale_to_unit([5.0, 1.6, 9.0, 8.2, 7.2]) == [0.45945945945945943, 0.0, 1.0, 0.8918918918918918, 0.7567567567567567]", "assert rescale_to_unit([3.5, 2.8, 8.2, 9.8, 6.8]) == [0.10000000000000002, 0.0, 0.7714285714285712, 1.0, 0.5714285714285714]", "assert rescale_to_unit([8.0, 9.3, 17.1, 18.5, 10.5]) == [0.0, 0.12380952380952388, 0.8666666666666668, 1.0, 0.23809523809523808]", "assert rescale_to_unit([6.6, 1.6, 1.3, 6.9, 2.3]) == [0.9464285714285713, 0.053571428571428575, 0.0, 1.0, 0.17857142857142852]", "assert rescale_to_unit([7.4, 45.9]) == [0.0, 1.0]", "assert rescale_to_unit([4.3, 2.5, 1.2, 4.0, 8.5]) == [0.4246575342465753, 0.17808219178082194, 0.0, 0.3835616438356164, 1.0]", "assert rescale_to_unit([7.9, 50.7]) == [0.0, 1.0]", "assert rescale_to_unit([4.9, 46.2]) == [0.0, 1.0]", "assert rescale_to_unit([4.4, 2.6, 2.1, 7.0, 2.4]) == [0.46938775510204084, 0.1020408163265306, 0.0, 1.0, 0.061224489795918324]", "assert rescale_to_unit([14.6, 6.7, 19.2, 13.8, 13.5]) == [0.632, 0.0, 1.0, 0.5680000000000001, 0.544]", "assert rescale_to_unit([95.6, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([2.5, 5.5, 10.2, 3.9, 4.4]) == [0.0, 0.38961038961038963, 1.0, 0.18181818181818182, 0.24675324675324684]", "assert rescale_to_unit([12.4, 8.1, 15.5, 14.4, 15.1]) == [0.5810810810810811, 0.0, 1.0, 0.8513513513513514, 0.9459459459459459]", "assert rescale_to_unit([105.5, 53.2]) == [1.0, 0.0]", "assert rescale_to_unit([102.1, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([6.1, 6.1, 8.0, 6.4, 8.7]) == [0.0, 0.0, 0.7307692307692311, 0.11538461538461567, 1.0]", "assert rescale_to_unit([100.0, 49.9]) == [1.0, 0.0]", "assert rescale_to_unit([12.2, 12.9, 12.4, 11.6, 16.9]) == [0.11320754716981128, 0.24528301886792472, 0.15094339622641526, 0.0, 1.0]", "assert rescale_to_unit([10.9, 13.2, 20.2, 11.2, 11.2]) == [0.0, 0.24731182795698917, 1.0, 0.03225806451612892, 0.03225806451612892]", "assert rescale_to_unit([96.2, 53.9]) == [1.0, 0.0]", "assert rescale_to_unit([95.4, 48.0]) == [1.0, 0.0]", "assert rescale_to_unit([5.7, 44.3]) == [0.0, 1.0]", "assert rescale_to_unit([102.0, 48.9]) == [1.0, 0.0]", "assert rescale_to_unit([2.4, 51.4]) == [0.0, 1.0]", "assert rescale_to_unit([16.1, 13.0, 15.9, 9.1, 15.3]) == [1.0, 0.557142857142857, 0.9714285714285713, 0.0, 0.8857142857142857]", "assert rescale_to_unit([2.5, 2.1, 4.3, 7.7, 9.7]) == [0.05263157894736841, 0.0, 0.28947368421052627, 0.7368421052631579, 1.0]", "assert rescale_to_unit([1.0, 48.4]) == [0.0, 1.0]", "assert rescale_to_unit([7.6, 6.9, 7.0, 2.7, 4.9]) == [1.0, 0.8571428571428573, 0.8775510204081634, 0.0, 0.4489795918367348]", "assert rescale_to_unit([5.5, 5.6, 3.1, 8.0, 9.4]) == [0.3809523809523809, 0.3968253968253967, 0.0, 0.7777777777777778, 1.0]", "assert rescale_to_unit([2.4, 3.2, 3.7, 8.2, 1.1]) == [0.18309859154929575, 0.295774647887324, 0.36619718309859156, 1.0, 0.0]", "assert rescale_to_unit([7.3, 1.5, 9.5, 4.6, 1.2]) == [0.7349397590361445, 0.03614457831325302, 1.0, 0.40963855421686735, 0.0]", "assert rescale_to_unit([105.8, 45.9]) == [1.0, 0.0]", "assert rescale_to_unit([9.7, 7.6, 13.7, 8.1, 10.3]) == [0.34426229508196715, 0.0, 1.0, 0.0819672131147541, 0.44262295081967235]", "assert rescale_to_unit([15.7, 12.5, 16.1, 8.7, 9.6]) == [0.9459459459459457, 0.5135135135135135, 1.0, 0.0, 0.12162162162162163]", "assert rescale_to_unit([10.1, 14.1, 14.5, 9.1, 9.5]) == [0.18518518518518517, 0.9259259259259258, 1.0, 0.0, 0.07407407407407414]", "assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]", "assert rescale_to_unit([6.7, 47.3]) == [0.0, 1.0]", "assert rescale_to_unit([5.9, 4.4, 1.4, 3.4, 2.8]) == [1.0, 0.6666666666666667, 0.0, 0.4444444444444444, 0.3111111111111111]", "assert rescale_to_unit([3.1, 6.8, 5.3, 5.4, 5.5]) == [0.0, 1.0, 0.5945945945945945, 0.6216216216216217, 0.6486486486486487]", "assert rescale_to_unit([4.1, 51.2]) == [0.0, 1.0]", "assert rescale_to_unit([5.0, 3.8, 8.2, 3.9, 1.1]) == [0.5492957746478874, 0.38028169014084506, 1.0, 0.39436619718309857, 0.0]", "assert rescale_to_unit([1.9, 4.8, 3.2, 4.3, 1.4]) == [0.14705882352941177, 1.0, 0.5294117647058825, 0.8529411764705882, 0.0]", "assert rescale_to_unit([10.1, 12.6, 10.2, 16.8, 11.1]) == [0.0, 0.3731343283582089, 0.014925373134328302, 1.0, 0.14925373134328357]", "assert rescale_to_unit([4.6, 5.7, 10.7, 5.4, 4.4]) == [0.03174603174603164, 0.20634920634920637, 1.0, 0.15873015873015875, 0.0]", "assert rescale_to_unit([7.0, 52.8]) == [0.0, 1.0]", "assert rescale_to_unit([98.1, 46.8]) == [1.0, 0.0]", "assert rescale_to_unit([4.4, 50.9]) == [0.0, 1.0]", "assert rescale_to_unit([5.5, 46.2]) == [0.0, 1.0]", "assert rescale_to_unit([3.2, 2.1, 1.6, 6.4, 3.7]) == [0.3333333333333333, 0.10416666666666666, 0.0, 1.0, 0.43749999999999994]", "assert rescale_to_unit([7.0, 51.8]) == [0.0, 1.0]", "assert rescale_to_unit([102.9, 44.8]) == [1.0, 0.0]", "assert rescale_to_unit([3.3, 4.4, 8.8, 2.9, 1.7]) == [0.22535211267605632, 0.38028169014084506, 1.0, 0.16901408450704222, 0.0]", "assert rescale_to_unit([17.6, 14.9, 12.4, 9.6, 14.2]) == [1.0, 0.6625, 0.35000000000000003, 0.0, 0.5749999999999998]", "assert rescale_to_unit([102.4, 46.0]) == [1.0, 0.0]", "assert rescale_to_unit([12.3, 14.5, 18.1, 18.3, 10.4]) == [0.24050632911392408, 0.5189873417721518, 0.9746835443037976, 1.0, 0.0]", "assert rescale_to_unit([105.8, 45.3]) == [1.0, 0.0]", "assert rescale_to_unit([5.4, 1.8, 4.4, 7.7, 2.8]) == [0.6101694915254238, 0.0, 0.44067796610169496, 1.0, 0.16949152542372878]", "assert rescale_to_unit([3.7, 3.9, 1.2, 4.6, 7.1]) == [0.42372881355932207, 0.45762711864406785, 0.0, 0.5762711864406779, 1.0]", "assert rescale_to_unit([9.7, 13.8, 18.7, 15.3, 14.7]) == [0.0, 0.4555555555555557, 1.0, 0.6222222222222223, 0.5555555555555556]", "assert rescale_to_unit([17.6, 8.7, 12.8, 9.2, 17.0]) == [1.0, 0.0, 0.46067415730337086, 0.05617977528089886, 0.9325842696629212]", "assert rescale_to_unit([2.5, 4.4, 8.0, 3.4, 10.2]) == [0.0, 0.24675324675324684, 0.7142857142857143, 0.11688311688311688, 1.0]", "assert rescale_to_unit([2.3, 3.4, 7.0, 6.8, 4.4]) == [0.0, 0.23404255319148937, 1.0, 0.9574468085106382, 0.44680851063829796]", "assert rescale_to_unit([4.3, 4.4, 6.1, 8.4, 1.2]) == [0.43055555555555547, 0.4444444444444445, 0.6805555555555555, 1.0, 0.0]", "assert rescale_to_unit([7.3, 7.4, 16.1, 10.7, 18.0]) == [0.0, 0.009345794392523414, 0.8224299065420562, 0.3177570093457944, 1.0]", "assert rescale_to_unit([102.3, 47.4]) == [1.0, 0.0]"], "nl": " Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    ", "func": "def rescale_to_unit(numbers: List[float]) -> List[float]:", "examples": ">>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    ", "repair_prompt": ["def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given a list of numbers (comprising at least two elements), apply a linear transform to that list, so that the minimum number becomes 0 and the maximum becomes 1.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''", "def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given a list of numbers (comprising at least two elements), apply a linear transform to that list. The goal of this transform is to make sure the minimum number becomes 0 and the maximum becomes 1.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''", "def rescale_to_unit(numbers: List[float]) -> List[float]:\t\n'''Given a list of numbers, apply a linear transform so that the minimum number becomes 0 and the maximum becomes 1.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    '''"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transform a list of numbers such that the minimum becomes 0 and the maximum becomes 1.\n    If all elements are identical, return a list of zeros.\n    \n    Args:\n        numbers: List of float numbers to be rescaled.\n        \n    Returns:\n        List of rescaled float numbers.\n    \"\"\"\n    if not numbers:\n        return []\n\n    # Convert the list to a NumPy array for efficient operations\n    num_array = np.array(numbers)\n\n    # Identify the minimum and maximum values in the list\n    min_val = np.min(num_array)\n    max_val = np.max(num_array)\n\n    # Handle the edge case where all elements are identical\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n\n    # Apply the linear transformation formula\n    rescaled_array = (num_array - min_val) / (max_val - min_val)\n\n    # Convert the NumPy array back to a list and return\n    return rescaled_array.tolist()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Rescale a list of numbers to a unit scale where the minimum becomes 0 and the maximum becomes 1.\n\n    Given a list of numbers (comprising at least two elements), apply a linear transform to that list,\n    so that the minimum number becomes 0 and the maximum becomes 1.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        List[float]: A list of rescaled numbers where the minimum is 0 and the maximum is 1.\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    if min_val == max_val:\n        # All numbers are the same, return a list of zeros\n        return [0.0] * len(numbers)\n\n    # Apply the linear transformation\n    return [(x - min_val) / (max_val - min_val) for x in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transform a list of numbers such that the minimum becomes 0 and the maximum becomes 1.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    List[float]: A list of rescaled numbers.\n    \"\"\"\n    if not numbers:\n        return []\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # Handle the edge case where all elements are identical\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n\n    # Apply the linear transformation formula\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n# Example usage:\n# print(rescale_to_unit([5.0, 5.0, 5.0]))  # Output: [0.0, 0.0, 0.0]\n# print(rescale_to_unit([1.0, 1.0, 2.0]))  # Output: [0.0, 0.0, 1.0]\n# print(rescale_to_unit([2.0, 3.0]))       # Output: [0.0, 1.0]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transform a list of numbers such that the minimum value becomes 0 and the maximum becomes 1.\n    If all elements are identical, return a list of zeros.\n\n    Args:\n        numbers: List of float numbers to be rescaled.\n\n    Returns:\n        List of rescaled float numbers.\n\n    Raises:\n        ValueError: If the list contains fewer than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / (max_val - min_val) for x in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transforms a list of numbers such that the minimum becomes 0 and the maximum becomes 1.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers with at least two elements.\n\n    Returns:\n    List[float]: A list of rescaled numbers where the minimum is 0 and the maximum is 1.\n\n    Example:\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    \n    if range_val == 0:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / range_val for x in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transforms a list of numbers such that the minimum value becomes 0 and the maximum becomes 1.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers with at least two elements.\n\n    Returns:\n    List[float]: A list of numbers rescaled to the unit interval [0, 1].\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n\n    min_value = min(numbers)\n    max_value = max(numbers)\n\n    # Handle edge case where all elements are identical\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n\n    range_value = max_value - min_value\n\n    # Apply linear transformation\n    rescaled_numbers = [(number - min_value) / range_value for number in numbers]\n\n    return rescaled_numbers\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Rescale a list of numbers to a unit scale where the minimum value becomes 0 and the maximum becomes 1.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    List[float]: A list of rescaled numbers.\n\n    Example:\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        return []\n\n    # Find the minimum and maximum values in the list\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    # If all values are identical, return a list of zeros\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n\n    # Apply the linear transformation formula: (x - min) / (max - min)\n    rescaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n\n    return rescaled_numbers\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Rescales a list of numbers to a unit range [0, 1].\n\n    This function takes a list of floating-point numbers and rescales them\n    such that the smallest number becomes 0 and the largest becomes 1,\n    maintaining the relative distances between numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers to be rescaled.\n\n    Returns:\n    List[float]: A list of numbers rescaled to the range [0, 1].\n\n    Edge Cases:\n    - If the list is empty, return an empty list.\n    - If all numbers in the list are the same, return a list of zeros.\n    \"\"\"\n    if not numbers:\n        return []\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n\n    return [(number - min_val) / (max_val - min_val) for number in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Rescale a list of numbers to a 0-1 range.\n\n    This function takes a list of floating-point numbers and rescales them\n    so that the minimum number becomes 0 and the maximum becomes 1. If the\n    list is empty, it returns an empty list. If all numbers in the list are\n    identical, it returns a list of zeros.\n\n    Args:\n        numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n        List[float]: A list of numbers rescaled to the 0-1 range.\n\n    Edge Cases:\n        - Returns an empty list if the input list is empty.\n        - Returns a list of zeros if all numbers in the list are identical.\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        return []\n\n    # Find the minimum and maximum values in the list\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    # If all values are identical, return a list of zeros\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n\n    # Apply the linear transformation formula to each element in the list\n    return [(x - min_val) / (max_val - min_val) for x in numbers]\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Transform a list of numbers such that the minimum becomes 0 and the maximum becomes 1.\n    If all elements are identical, return a list of zeros.\n\n    Args:\n        numbers: List of float numbers to be rescaled.\n\n    Returns:\n        List of rescaled float numbers.\n\n    Raises:\n        ValueError: If the list contains fewer than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    # Using NumPy for efficient computation\n    numbers_array = np.array(numbers)\n    rescaled_array = (numbers_array - min_val) / (max_val - min_val)\n    \n    return rescaled_array.tolist()\n"], "plans": ["requirement analysis:\nThe function should take a list of floating-point numbers and apply a linear transformation such that the minimum value becomes 0 and the maximum value becomes 1. This requires calculating the range of the list and adjusting each element accordingly. The function must handle lists with more than two elements and should be optimized for performance.\nrequirement pool:\n- Implement the rescale_to_unit function to transform data as specified.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles edge cases, such as lists with identical elements.\n- Provide comprehensive documentation and examples for users.\n- Include unit tests to verify the function's correctness.\nWe will implement the rescale_to_unit function using Python's built-in capabilities to handle lists and mathematical operations. For performance optimization, especially with large datasets, we will utilize NumPy, which is known for its efficient array operations. NumPy will help in handling edge cases like lists with identical elements by providing robust mathematical functions that avoid division by zero errors.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to the process of scaling the numbers in the list so that the minimum value becomes 0 and the maximum value becomes 1, while maintaining the relative distances between the numbers.\n\n# [phrase showing quantity relationship]\n    'minimum number becomes 0': This means that the smallest number in the list should be transformed to 0.\n    'maximum becomes 1': This means that the largest number in the list should be transformed to 1.\n\n# [degree adverb]\n    'minimum': Refers to the smallest value in the list.\n    'maximum': Refers to the largest value in the list.\n\n# [code logic]\n    1. Identify the minimum and maximum values in the list.\n    2. Apply the linear transformation formula: (number - min) / (max - min) to each element in the list.\n    3. Return the transformed list.\n\n# [edge case]\n    rescale_to_unit([1.0, 1.0, 1.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are identical, so they all transform to 0 because max equals min.\n    \n    rescale_to_unit([5.0, 5.0, 10.0]) = [0.0, 0.0, 1.0]\n    Explanation: The minimum is 5 and maximum is 10, so elements are transformed accordingly.\n    \n    rescale_to_unit([10.0, 5.0]) = [1.0, 0.0]\n    Explanation: The minimum is 5 and maximum is 10, so elements are transformed accordingly.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical to avoid division by zero.\n        if min == max:\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should efficiently transform a list of numbers such that the minimum value becomes 0 and the maximum becomes 1, ensuring the transformation is linear and accurate. It should handle edge cases like negative numbers and large datasets.\nrequirement pool:\n- Implement the rescale_to_unit function\n- Optimize for performance with large datasets\n- Ensure accurate transformation for edge cases\n- Provide comprehensive documentation\n- Integrate with existing data processing systems\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will handle edge cases such as negative numbers and large datasets by leveraging list comprehensions and basic arithmetic operations. We will avoid using complex libraries to maintain ease of integration and use.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales the numbers in the list so that the smallest number becomes 0 and the largest becomes 1, while maintaining the relative distances between numbers.\n\n# [phrase showing quantity relationship]\n    'at least two elements': This indicates that the input list must contain a minimum of two numbers to perform the transformation.\n\n# [degree adverb] \n    'minimum': This refers to the smallest number in the list.\n    'maximum': This refers to the largest number in the list.\n\n# [code logic]\n1. Identify the minimum and maximum values in the list.\n2. Apply the linear transformation formula: \n   \\[\n   \\text{rescaled\\_value} = \\frac{\\text{original\\_value} - \\text{min}}{\\text{max} - \\text{min}}\n   \\]\n3. Return the list of rescaled values.\n\n# [edge case] \n    rescale_to_unit([1.0, 1.0, 1.0]) = [0.0, 0.0, 0.0]\n    Explanation: All numbers are the same, so they all become 0 after rescaling.\n    \n    rescale_to_unit([1.0, 2.0]) = [0.0, 1.0]\n    Explanation: The simplest case with two elements, where the first becomes 0 and the second becomes 1.\n    \n    rescale_to_unit([-1.0, 0.0, 1.0]) = [0.0, 0.5, 1.0]\n    Explanation: The range includes negative numbers, and they are rescaled accordingly.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all numbers are the same.\n    \n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]\n```\n", "requirement analysis:\nThe function should efficiently transform a list of numbers such that the minimum value becomes 0 and the maximum becomes 1, ensuring the transformation is linear. It should handle lists with varying lengths and values, including negative numbers and zero.\nrequirement pool:\n- Implement the rescale_to_unit function\n- Ensure the function handles edge cases\n- Optimize for performance with large datasets\n- Provide comprehensive documentation\n- Include unit tests for validation\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will handle edge cases such as lists with identical elements or all elements being the same value by returning a list of zeros, as the transformation is undefined in such cases. We will avoid using complex libraries like NumPy or Pandas to keep the solution lightweight and focused on the task.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that adjusts the values in the list so that they fit within a specified range, in this case, between 0 and 1.\n\n# [phrase showing quantity relationship]\n    'minimum number becomes 0': This means the smallest number in the list should be transformed to 0.\n    'maximum becomes 1': This means the largest number in the list should be transformed to 1.\n\n# [degree adverb] \n    'minimum': Refers to the smallest value in the list.\n    'maximum': Refers to the largest value in the list.\n\n# [code logic]\n    1. Identify the minimum and maximum values in the list.\n    2. If all elements are identical, return a list of zeros.\n    3. Apply the linear transformation formula: (x - min) / (max - min) for each element x in the list.\n    4. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([5.0, 5.0, 5.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are identical, so the transformation results in a list of zeros.\n    \n    rescale_to_unit([1.0, 1.0, 2.0]) = [0.0, 0.0, 1.0]\n    Explanation: The minimum value is 1.0 and maximum is 2.0, so 1.0 transforms to 0 and 2.0 transforms to 1.\n    \n    rescale_to_unit([2.0, 3.0]) = [0.0, 1.0]\n    Explanation: The minimum value is 2.0 and maximum is 3.0, so 2.0 transforms to 0 and 3.0 transforms to 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n        if min(numbers) == max(numbers):\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should efficiently transform a list of numbers such that the minimum value becomes 0 and the maximum becomes 1. It should handle lists with more than two elements and manage edge cases like lists with identical values.\nrequirement pool:\n- Implement the rescale_to_unit function to transform data as specified.\n- Ensure the function handles edge cases, such as lists with identical values.\n- Optimize the function for performance with large datasets.\n- Provide comprehensive documentation and examples for users.\n- Include unit tests to verify the function's correctness.\nWe will implement the rescale_to_unit function using Python's built-in capabilities to efficiently transform a list of numbers. The function will handle edge cases, such as lists with identical values, by returning a list of zeros if all elements are identical. We will use NumPy for performance optimization when dealing with large datasets, as it provides efficient array operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales and shifts the numbers in the list so that the minimum value becomes 0 and the maximum value becomes 1.\n\n# [phrase showing quantity relationship]\n    'at least two elements': This indicates that the input list must contain two or more numbers. In code, this can be checked using a condition like `if len(numbers) < 2`.\n\n# [degree adverb] \n    'minimum': Refers to the smallest number in the list. In code, this can be found using `min(numbers)`.\n    'maximum': Refers to the largest number in the list. In code, this can be found using `max(numbers)`.\n\n# [code logic]\n1. Check if the list has at least two elements.\n2. Find the minimum and maximum values in the list.\n3. If all elements are identical (i.e., min equals max), return a list of zeros.\n4. Otherwise, apply the linear transformation: for each number `x` in the list, compute `(x - min) / (max - min)`.\n5. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([1.0, 1.0]) = [0.0, 0.0]\n    Explanation: All elements are identical, so the function returns a list of zeros.\n    \n    rescale_to_unit([0.0, 1.0]) = [0.0, 1.0]\n    Explanation: The minimum is already 0 and the maximum is already 1, so no transformation is needed.\n    \n    rescale_to_unit([5.0, 5.0, 5.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are identical, so the function returns a list of zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    \n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / (max_val - min_val) for x in numbers]\n```\n", "requirement analysis:\nThe function should efficiently transform a list of numbers such that the minimum becomes 0 and the maximum becomes 1, ensuring the transformation is linear and handles edge cases like identical numbers.\nrequirement pool:\n- Implement the rescale_to_unit function\n- Optimize for performance with large datasets\n- Include comprehensive documentation\n- Handle edge cases gracefully\n- Provide examples for common use cases\nWe will implement the rescale_to_unit function using basic Python operations to ensure simplicity and efficiency. The function will handle edge cases such as lists with identical elements by returning a list of zeros, as the range would be zero. We will avoid using heavy libraries like NumPy or Pandas to keep the function lightweight and easy to integrate.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: In the context of this requirement, a linear transform is a mathematical operation that adjusts the values in a list so that the minimum value becomes 0 and the maximum value becomes 1, with all other values proportionally adjusted between these two extremes.\n\n# [phrase showing quantity relationship]\n    'at least two elements': This indicates that the input list must contain a minimum of two numbers to perform the transformation. In code, this can be checked using a condition like `if len(numbers) < 2`.\n\n# [degree adverb] \n    'minimum': Refers to the smallest number in the list, which should be transformed to 0.\n    'maximum': Refers to the largest number in the list, which should be transformed to 1.\n\n# [code logic]\n1. Check if the list has at least two elements. If not, raise an error or handle it appropriately.\n2. Find the minimum and maximum values in the list.\n3. Calculate the range (difference between maximum and minimum).\n4. If the range is zero (all elements are identical), return a list of zeros.\n5. Otherwise, apply the linear transformation: for each number `x` in the list, calculate `(x - min) / range`.\n6. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([5.0, 5.0]) = [0.0, 0.0]\n    Explanation: Since all elements are identical, the range is zero, and thus all transformed values should be 0.\n    \n    rescale_to_unit([1.0, 1.0, 2.0]) = [0.0, 0.0, 1.0]\n    Explanation: The minimum value is 1.0 and maximum is 2.0, so 1.0 transforms to 0 and 2.0 transforms to 1.\n\n    rescale_to_unit([2.0, 3.0]) = [0.0, 1.0]\n    Explanation: The minimum value is 2.0 and maximum is 3.0, so they transform directly to 0 and 1 respectively.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    \n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    \n    if range_val == 0:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / range_val for x in numbers]\n```\n", "requirement analysis:\nThe function should efficiently transform a list of numbers such that the minimum value becomes 0 and the maximum becomes 1, ensuring the transformation is linear and consistent across different datasets.\nrequirement pool:\n- Implement the rescale_to_unit function\n- Optimize for performance with large lists\n- Ensure accurate handling of edge cases\n- Provide comprehensive documentation\n- Test integration with existing data processing pipelines\nWe will implement the rescale_to_unit function using basic Python operations to ensure simplicity and efficiency. The function will handle edge cases such as lists with identical elements by returning a list of zeros, as the range would be zero. We will avoid using complex libraries like NumPy or Pandas to keep the function lightweight and easy to integrate.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales and shifts the numbers in the list so that the minimum value becomes 0 and the maximum value becomes 1.\n\n# [phrase showing quantity relationship]\n    'minimum number becomes 0': This means that the smallest number in the list should be transformed to 0.\n    'maximum becomes 1': This means that the largest number in the list should be transformed to 1.\n\n# [degree adverb] \n    'minimum': Refers to the smallest value in the list.\n    'maximum': Refers to the largest value in the list.\n\n# [code logic]\n    1. Identify the minimum and maximum values in the list.\n    2. Calculate the range of the list (max - min).\n    3. If the range is zero (all elements are identical), return a list of zeros.\n    4. Otherwise, apply the linear transformation: (number - min) / range for each number in the list.\n    5. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([5.0, 5.0, 5.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are identical, so the range is zero, resulting in a list of zeros.\n    \n    rescale_to_unit([1.0, 1.0, 2.0]) = [0.0, 0.0, 1.0]\n    Explanation: The minimum is 1.0 and maximum is 2.0, so 1.0 transforms to 0 and 2.0 transforms to 1.\n    \n    rescale_to_unit([2.0, 3.0]) = [0.0, 1.0]\n    Explanation: The minimum is 2.0 and maximum is 3.0, so 2.0 transforms to 0 and 3.0 transforms to 1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n        if max(numbers) == min(numbers):\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should efficiently rescale a list of numbers to a unit scale, ensuring the minimum value is 0 and the maximum is 1. It should handle edge cases such as lists with identical numbers or empty lists.\nrequirement pool:\n- Implement the rescale_to_unit function to transform data accurately.\n- Ensure the function handles edge cases like empty lists or identical values.\n- Optimize the function for performance with large datasets.\n- Provide clear documentation and examples for user understanding.\n- Integrate error handling for invalid inputs.\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will handle edge cases such as empty lists and lists with identical values by returning an appropriate result. We will use error handling to manage non-numeric inputs gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to the process of scaling the numbers in the list so that they fit within a specified range, in this case, between 0 and 1.\n\n# [phrase showing quantity relationship]\n    'minimum number becomes 0': This means that the smallest number in the list should be transformed to 0.\n    'maximum becomes 1': This means that the largest number in the list should be transformed to 1.\n\n# [degree adverb] \n    'maximum': Refers to the largest value in the list.\n    'minimum': Refers to the smallest value in the list.\n\n# [code logic]\n    1. Check if the list is empty. If it is, return an empty list.\n    2. Find the minimum and maximum values in the list.\n    3. If all values are identical, return a list of zeros since all values are equal to the minimum.\n    4. Apply the linear transformation formula: (x - min) / (max - min) for each number x in the list.\n    5. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([]) = []\n    Explanation: The list is empty, so there are no numbers to transform.\n    \n    rescale_to_unit([3.0, 3.0, 3.0]) = [0.0, 0.0, 0.0]\n    Explanation: All numbers are identical, so they are all equal to the minimum, resulting in a transformation to zero.\n\n    rescale_to_unit([1.0]) = [0.0]\n    Explanation: With only one number, it is both the minimum and maximum, resulting in a transformation to zero.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not numbers:\n            return []\n        min_val = min(numbers)\n        max_val = max(numbers)\n        if min_val == max_val:\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should take a list of floats and apply a linear transformation to rescale the values such that the minimum becomes 0 and the maximum becomes 1. It should handle edge cases like empty lists or lists with a single repeated value. The implementation should be efficient and easy to understand, with clear documentation and examples.\nrequirement pool:\n- Implement the rescale_to_unit function to transform data to a unit range.\n- Ensure the function handles edge cases like empty or single-element lists.\n- Provide comprehensive documentation and examples for users.\n- Optimize the function for performance with large datasets.\n- Include unit tests to verify the function's correctness.\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will handle edge cases such as empty lists and lists with a single repeated value by returning an empty list or a list of zeros, respectively. We will avoid using complex libraries like NumPy or Pandas to keep the solution lightweight and easy to understand.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales the numbers in a list so that the smallest number becomes 0 and the largest becomes 1, maintaining the relative distances between numbers.\n\n# [phrase showing quantity relationship]\n    'minimum number becomes 0': This means the smallest number in the list should be transformed to 0.\n    'maximum becomes 1': This means the largest number in the list should be transformed to 1.\n\n# [degree adverb] \n    'minimum': Refers to the smallest value in the list.\n    'maximum': Refers to the largest value in the list.\n\n# [code logic]\n1. Check if the list is empty. If it is, return an empty list.\n2. Find the minimum and maximum values in the list.\n3. If all numbers are the same (min equals max), return a list of zeros.\n4. For each number in the list, apply the transformation: (number - min) / (max - min).\n5. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([]) = []\n    Explanation: The list is empty, so there are no numbers to transform.\n    \n    rescale_to_unit([3.0, 3.0, 3.0]) = [0.0, 0.0, 0.0]\n    Explanation: All numbers are the same, so they all transform to 0.\n\n    rescale_to_unit([5.0]) = [0.0]\n    Explanation: With only one number, it is both the minimum and maximum, so it transforms to 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not numbers:\n            return []\n        min_val = min(numbers)\n        max_val = max(numbers)\n        if min_val == max_val:\n            return [0.0] * len(numbers)\n        (other code)\n", "requirement analysis:\nThe function should efficiently rescale a list of numbers to a 0-1 range, handling edge cases like empty lists or lists with identical values. It should be easy to use and integrate into larger data processing pipelines.\nrequirement pool:\n- Implement the rescale_to_unit function to transform data accurately.\n- Ensure the function handles edge cases gracefully.\n- Optimize performance for large datasets.\n- Provide comprehensive documentation and examples.\n- Include unit tests to verify functionality.\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will handle edge cases such as empty lists and lists with identical values by returning an appropriate result. For lists with identical values, the function will return a list of zeros since the range is zero, making normalization to a 0-1 scale not meaningful.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that adjusts the values in a list so that they fit within a specified range, in this case, between 0 and 1.\n\n# [phrase showing quantity relationship]\n    'minimum number becomes 0': This means the smallest number in the list will be transformed to 0.\n    'maximum becomes 1': This means the largest number in the list will be transformed to 1.\n    Implementation: Use the formula `(x - min) / (max - min)` for each number `x` in the list.\n\n# [degree adverb] \n    'maximum': Refers to the largest value in the list.\n    'minimum': Refers to the smallest value in the list.\n    Implementation: Use Python's `max()` and `min()` functions to find these values.\n\n# [code logic]\n    1. Check if the list is empty; if so, return an empty list.\n    2. Find the minimum and maximum values in the list.\n    3. If all values are identical (min == max), return a list of zeros.\n    4. Apply the linear transformation formula `(x - min) / (max - min)` to each element in the list.\n    5. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([]) = []\n    Explanation: The list is empty, so there are no numbers to transform.\n    \n    rescale_to_unit([3.0, 3.0, 3.0]) = [0.0, 0.0, 0.0]\n    Explanation: All numbers are identical, so the range is zero, making normalization not meaningful; hence, return zeros.\n\n    rescale_to_unit([5.0]) = [0.0]\n    Explanation: With only one number, it is both the minimum and maximum, resulting in a zero after transformation.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if not numbers:\n            return []\n        min_val = min(numbers)\n        max_val = max(numbers)\n        if min_val == max_val:\n            return [0.0] * len(numbers)\n        return [(x - min_val) / (max_val - min_val) for x in numbers]\n", "requirement analysis:\nThe function should efficiently transform a list of numbers such that the minimum value becomes 0 and the maximum becomes 1, ensuring that all intermediate values are proportionally scaled. It should handle lists with varying sizes and edge cases like lists with identical elements.\nrequirement pool:\n- Implement the rescale_to_unit function to transform data accurately.\n- Optimize the function for performance with large datasets.\n- Ensure the function handles edge cases gracefully.\n- Provide comprehensive documentation for users.\n- Include unit tests to verify functionality.\nWe will implement the rescale_to_unit function using Python's built-in capabilities to ensure simplicity and efficiency. The function will handle edge cases such as lists with identical elements by returning a list of zeros, as scaling is not possible when all elements are the same. We will use NumPy for efficient computation, especially for large datasets, as it provides optimized operations for numerical data.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'linear transform'\n    Explanation: This refers to a mathematical operation that scales and shifts the numbers in the list so that the minimum value becomes 0 and the maximum value becomes 1.\n\n# [phrase showing quantity relationship]\n    'at least two elements': This indicates that the input list must contain a minimum of two numbers for the transformation to be meaningful.\n\n# [degree adverb] \n    'minimum': This refers to the smallest number in the list, which will be transformed to 0.\n    'maximum': This refers to the largest number in the list, which will be transformed to 1.\n\n# [code logic]\n1. Check if the list has at least two elements.\n2. Find the minimum and maximum values in the list.\n3. If all elements are identical, return a list of zeros.\n4. Apply the linear transformation formula: (x - min) / (max - min) for each element x in the list.\n5. Return the transformed list.\n\n# [edge case] \n    rescale_to_unit([1.0, 1.0]) = [0.0, 0.0]\n    Explanation: All elements are identical, so scaling is not possible, resulting in a list of zeros.\n    \n    rescale_to_unit([0.0, 5.0]) = [0.0, 1.0]\n    Explanation: The minimum value is 0 and the maximum is 5, so they are transformed to 0 and 1 respectively.\n    \n    rescale_to_unit([2.0, 2.0, 2.0]) = [0.0, 0.0, 0.0]\n    Explanation: All elements are identical, so scaling is not possible, resulting in a list of zeros.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where all elements are identical.\n    \n```python\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / (max_val - min_val) for x in numbers]\n```\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [130, 130, 130, 130, 130, 130, 130, 130, 130, 130], "completion": "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Transform a list of numbers such that the minimum becomes 0 and the maximum becomes 1.\n    If all elements are identical, return a list of zeros.\n\n    Args:\n        numbers: List of float numbers to be rescaled.\n\n    Returns:\n        List of rescaled float numbers.\n\n    Raises:\n        ValueError: If the list contains fewer than two elements.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    # Using NumPy for efficient computation\n    numbers_array = np.array(numbers)\n    rescaled_array = (numbers_array - min_val) / (max_val - min_val)\n    \n    return rescaled_array.tolist()\n", "passed": true, "pass": true, "pass_num": 10, "round": 770, "mutate_method": "rephrase_one", "parent_index": 19}
