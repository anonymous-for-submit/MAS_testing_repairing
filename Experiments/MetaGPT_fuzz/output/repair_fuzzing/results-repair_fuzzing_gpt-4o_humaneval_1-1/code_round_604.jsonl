{"task_id": "HumanEval/81", "prompt": "def numerical_letter_grade(grades):\t\n'''It's the final week of the term and the instructor needs to assign grades to the students. The teacher has been making her own algorithm for grading. The only problem is, she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\nExample:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    '''", "entry_point": "numerical_letter_grade", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "test": ["def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.367]) == ['A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.709]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.501]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.042, 3, 5.935, 5, 5.423]) == ['A', 'B', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.511]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6, 4.502, 2.77, 6.757, 4.66]) == ['A', 'A', 'B', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.309, 3, 3.031, 4, 3.721]) == ['A', 'B', 'B+', 'A+', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 1.067, 5.544, 2.104, 6.994]) == ['D', 'D+', 'A', 'C+', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 3.93, 1.74, 2.791, 2.576]) == ['B', 'A', 'C', 'B', 'B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.799]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.104]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6, 2.642, 5.179, 5.542, 7.925]) == ['A', 'B-', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([7.75, 2, 6.21, 4, 7.481]) == ['A', 'C', 'A', 'A+', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 1.608, 4.584, 1.801, 5.528]) == ['B', 'C-', 'A', 'C', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.259]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4, 2.626, 2.824, 7.424, 5.83]) == ['A+', 'B-', 'B', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.84, 4, 4.974, 6, 5.319]) == ['A', 'A+', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.033]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.516]) == ['B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([9.54, 5, 6.671, 1, 5.784]) == ['A', 'A', 'A', 'D', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 5.293, 4.749, 7.907, 5.656]) == ['D', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.463, 2, 3.954, 5, 7.145]) == ['A', 'C', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.826]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 3.758, 2.783, 2.733, 7.605]) == ['B', 'A', 'B', 'B', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.597]) == ['B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4, 1.435, 5.824, 1.539, 7.492]) == ['A+', 'C-', 'A', 'C-', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.423]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.143]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.891]) == ['C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.065, 4, 5.911, 2, 4.43]) == ['A', 'A+', 'A', 'C', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.477, 7, 6.699, 6, 7.022]) == ['A', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5, 2.658, 2.151, 6.268, 5.527]) == ['A', 'B-', 'C+', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 4.558, 2.072, 3.712, 5.809]) == ['B', 'A', 'C+', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3, 4.425, 6.207, 4.631, 3.821]) == ['B', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.878]) == ['C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.81]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.976, 4, 1.433, 7, 3.077]) == ['A', 'A+', 'C-', 'A', 'B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.226]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.364]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.946]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4, 3.251, 2.546, 1.98, 3.082]) == ['A+', 'B+', 'B-', 'C', 'B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.189]) == ['B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.618]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.835]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.356]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.612]) == ['A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.601]) == ['B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.978]) == ['C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5, 3.231, 4.961, 5.91, 4.348]) == ['A', 'B+', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([0.5]) == ['D-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.412]) == ['B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.699]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([9.553, 3, 1.754, 7, 7.712]) == ['A', 'B', 'C', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.909, 4, 3.917, 4, 2.236]) == ['A', 'A+', 'A', 'A+', 'C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5, 4.675, 6.301, 3.928, 5.804]) == ['A', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.845]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.091]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.822]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 1.556, 6.189, 3.588, 1.625]) == ['D', 'C-', 'A', 'A-', 'C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.134, 3, 6.155, 3, 2.084]) == ['A', 'B', 'A', 'B', 'C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5, 3.839, 3.698, 4.34, 1.955]) == ['A', 'A', 'A-', 'A', 'C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.813]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.266, 7, 4.913, 2, 1.115]) == ['D+', 'A', 'A', 'C', 'D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.381]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.985]) == ['B']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.314]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([9.317, 8, 3.7, 6, 2.483]) == ['A', 'A', 'A-', 'A', 'B-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.169]) == ['C+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.925]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.275]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.076]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.906]) == ['C']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6, 5.144, 4.622, 7.362, 8.196]) == ['A', 'A', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.778]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.012]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([0.0]) == ['E']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.873, 3, 2.438, 6, 5.365]) == ['A', 'B', 'B-', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.169]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.454]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1, 1.181, 4.176, 7.002, 5.356]) == ['D', 'D+', 'A', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.412]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.054]) == ['B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.401]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.559]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([2.454, 8, 1.163, 2, 3.831]) == ['B-', 'A', 'D+', 'C', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.288]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.516]) == ['A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.111]) == ['B+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([3.411]) == ['A-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.415]) == ['C-']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.682]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.152, 7, 2.102, 5, 8.879]) == ['A', 'A', 'C+', 'A', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6, 2.172, 3.849, 1.272, 6.298]) == ['A', 'C+', 'A', 'D+', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.697]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.86]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.2]) == ['D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([6.363]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.886]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([4.202]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([8.911, 1, 5.562, 6, 1.001]) == ['A', 'D', 'A', 'A', 'D+']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([5.442]) == ['A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.32, 8, 4.236, 1, 5.296]) == ['C-', 'A', 'A', 'D', 'A']", "def check(numerical_letter_grade):\n\tassert numerical_letter_grade([1.058, 4, 5.349, 2, 4.304]) == ['D+', 'A+', 'A', 'C', 'A']"], "test_case_list": ["assert numerical_letter_grade([3.367]) == ['A-']", "assert numerical_letter_grade([3.709]) == ['A']", "assert numerical_letter_grade([1.501]) == ['C-']", "assert numerical_letter_grade([6.042, 3, 5.935, 5, 5.423]) == ['A', 'B', 'A', 'A', 'A']", "assert numerical_letter_grade([1.511]) == ['C-']", "assert numerical_letter_grade([6, 4.502, 2.77, 6.757, 4.66]) == ['A', 'A', 'B', 'A', 'A']", "assert numerical_letter_grade([5.309, 3, 3.031, 4, 3.721]) == ['A', 'B', 'B+', 'A+', 'A']", "assert numerical_letter_grade([1, 1.067, 5.544, 2.104, 6.994]) == ['D', 'D+', 'A', 'C+', 'A']", "assert numerical_letter_grade([3, 3.93, 1.74, 2.791, 2.576]) == ['B', 'A', 'C', 'B', 'B-']", "assert numerical_letter_grade([4.799]) == ['A']", "assert numerical_letter_grade([4.104]) == ['A']", "assert numerical_letter_grade([6, 2.642, 5.179, 5.542, 7.925]) == ['A', 'B-', 'A', 'A', 'A']", "assert numerical_letter_grade([7.75, 2, 6.21, 4, 7.481]) == ['A', 'C', 'A', 'A+', 'A']", "assert numerical_letter_grade([3, 1.608, 4.584, 1.801, 5.528]) == ['B', 'C-', 'A', 'C', 'A']", "assert numerical_letter_grade([2.259]) == ['C+']", "assert numerical_letter_grade([4, 2.626, 2.824, 7.424, 5.83]) == ['A+', 'B-', 'B', 'A', 'A']", "assert numerical_letter_grade([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.", "assert numerical_letter_grade([4.84, 4, 4.974, 6, 5.319]) == ['A', 'A+', 'A', 'A', 'A']", "assert numerical_letter_grade([2.033]) == ['C+']", "assert numerical_letter_grade([2.516]) == ['B-']", "assert numerical_letter_grade([9.54, 5, 6.671, 1, 5.784]) == ['A', 'A', 'A', 'D', 'A']", "assert numerical_letter_grade([1, 5.293, 4.749, 7.907, 5.656]) == ['D', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([6.463, 2, 3.954, 5, 7.145]) == ['A', 'C', 'A', 'A', 'A']", "assert numerical_letter_grade([3.826]) == ['A']", "assert numerical_letter_grade([3, 3.758, 2.783, 2.733, 7.605]) == ['B', 'A', 'B', 'B', 'A']", "assert numerical_letter_grade([2.597]) == ['B-']", "assert numerical_letter_grade([4, 1.435, 5.824, 1.539, 7.492]) == ['A+', 'C-', 'A', 'C-', 'A']", "assert numerical_letter_grade([6.423]) == ['A']", "assert numerical_letter_grade([1.143]) == ['D+']", "assert numerical_letter_grade([1.891]) == ['C']", "assert numerical_letter_grade([5.065, 4, 5.911, 2, 4.43]) == ['A', 'A+', 'A', 'C', 'A']", "assert numerical_letter_grade([4.477, 7, 6.699, 6, 7.022]) == ['A', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([5, 2.658, 2.151, 6.268, 5.527]) == ['A', 'B-', 'C+', 'A', 'A']", "assert numerical_letter_grade([3, 4.558, 2.072, 3.712, 5.809]) == ['B', 'A', 'C+', 'A', 'A']", "assert numerical_letter_grade([3, 4.425, 6.207, 4.631, 3.821]) == ['B', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([1.878]) == ['C']", "assert numerical_letter_grade([3.81]) == ['A']", "assert numerical_letter_grade([5.976, 4, 1.433, 7, 3.077]) == ['A', 'A+', 'C-', 'A', 'B+']", "assert numerical_letter_grade([2.226]) == ['C+']", "assert numerical_letter_grade([5.364]) == ['A']", "assert numerical_letter_grade([4.946]) == ['A']", "assert numerical_letter_grade([4, 3.251, 2.546, 1.98, 3.082]) == ['A+', 'B+', 'B-', 'C', 'B+']", "assert numerical_letter_grade([3.189]) == ['B+']", "assert numerical_letter_grade([6.618]) == ['A']", "assert numerical_letter_grade([4.835]) == ['A']", "assert numerical_letter_grade([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']", "assert numerical_letter_grade([5.356]) == ['A']", "assert numerical_letter_grade([3.612]) == ['A-']", "assert numerical_letter_grade([2.601]) == ['B-']", "assert numerical_letter_grade([1.978]) == ['C']", "assert numerical_letter_grade([5, 3.231, 4.961, 5.91, 4.348]) == ['A', 'B+', 'A', 'A', 'A']", "assert numerical_letter_grade([0.5]) == ['D-']", "assert numerical_letter_grade([2.412]) == ['B-']", "assert numerical_letter_grade([1.699]) == ['C-']", "assert numerical_letter_grade([9.553, 3, 1.754, 7, 7.712]) == ['A', 'B', 'C', 'A', 'A']", "assert numerical_letter_grade([5.909, 4, 3.917, 4, 2.236]) == ['A', 'A+', 'A', 'A+', 'C+']", "assert numerical_letter_grade([5, 4.675, 6.301, 3.928, 5.804]) == ['A', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([4.845]) == ['A']", "assert numerical_letter_grade([2.091]) == ['C+']", "assert numerical_letter_grade([4.822]) == ['A']", "assert numerical_letter_grade([1, 1.556, 6.189, 3.588, 1.625]) == ['D', 'C-', 'A', 'A-', 'C-']", "assert numerical_letter_grade([6.134, 3, 6.155, 3, 2.084]) == ['A', 'B', 'A', 'B', 'C+']", "assert numerical_letter_grade([5, 3.839, 3.698, 4.34, 1.955]) == ['A', 'A', 'A-', 'A', 'C']", "assert numerical_letter_grade([4.813]) == ['A']", "assert numerical_letter_grade([1.266, 7, 4.913, 2, 1.115]) == ['D+', 'A', 'A', 'C', 'D+']", "assert numerical_letter_grade([4.381]) == ['A']", "assert numerical_letter_grade([2.985]) == ['B']", "assert numerical_letter_grade([4.314]) == ['A']", "assert numerical_letter_grade([9.317, 8, 3.7, 6, 2.483]) == ['A', 'A', 'A-', 'A', 'B-']", "assert numerical_letter_grade([2.169]) == ['C+']", "assert numerical_letter_grade([3.925]) == ['A']", "assert numerical_letter_grade([1.275]) == ['D+']", "assert numerical_letter_grade([1.076]) == ['D+']", "assert numerical_letter_grade([1.906]) == ['C']", "assert numerical_letter_grade([6, 5.144, 4.622, 7.362, 8.196]) == ['A', 'A', 'A', 'A', 'A']", "assert numerical_letter_grade([5.778]) == ['A']", "assert numerical_letter_grade([5.012]) == ['A']", "assert numerical_letter_grade([0.0]) == ['E']", "assert numerical_letter_grade([4.873, 3, 2.438, 6, 5.365]) == ['A', 'B', 'B-', 'A', 'A']", "assert numerical_letter_grade([1.169]) == ['D+']", "assert numerical_letter_grade([4.454]) == ['A']", "assert numerical_letter_grade([1, 1.181, 4.176, 7.002, 5.356]) == ['D', 'D+', 'A', 'A', 'A']", "assert numerical_letter_grade([1.412]) == ['C-']", "assert numerical_letter_grade([3.054]) == ['B+']", "assert numerical_letter_grade([5.401]) == ['A']", "assert numerical_letter_grade([5.559]) == ['A']", "assert numerical_letter_grade([2.454, 8, 1.163, 2, 3.831]) == ['B-', 'A', 'D+', 'C', 'A']", "assert numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']", "assert numerical_letter_grade([5.288]) == ['A']", "assert numerical_letter_grade([3.516]) == ['A-']", "assert numerical_letter_grade([3.111]) == ['B+']", "assert numerical_letter_grade([3.411]) == ['A-']", "assert numerical_letter_grade([1.415]) == ['C-']", "assert numerical_letter_grade([4.682]) == ['A']", "assert numerical_letter_grade([4.152, 7, 2.102, 5, 8.879]) == ['A', 'A', 'C+', 'A', 'A']", "assert numerical_letter_grade([6, 2.172, 3.849, 1.272, 6.298]) == ['A', 'C+', 'A', 'D+', 'A']", "assert numerical_letter_grade([4.697]) == ['A']", "assert numerical_letter_grade([4.86]) == ['A']", "assert numerical_letter_grade([1.2]) == ['D+']", "assert numerical_letter_grade([6.363]) == ['A']", "assert numerical_letter_grade([5.886]) == ['A']", "assert numerical_letter_grade([4.202]) == ['A']", "assert numerical_letter_grade([8.911, 1, 5.562, 6, 1.001]) == ['A', 'D', 'A', 'A', 'D+']", "assert numerical_letter_grade([5.442]) == ['A']", "assert numerical_letter_grade([1.32, 8, 4.236, 1, 5.296]) == ['C-', 'A', 'A', 'D', 'A']", "assert numerical_letter_grade([1.058, 4, 5.349, 2, 4.304]) == ['D+', 'A+', 'A', 'C', 'A']"], "nl": "It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    ", "func": "def numerical_letter_grade(grades):", "examples": "Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    ", "repair_prompt": ["def numerical_letter_grade(grades):\t\n'''It's the final week of the term and the instructor needs to assign grades to the students. The teacher has been making her own algorithm for grading. The only problem is, she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\nExample:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    '''", "```python\ndef numerical_letter_grade(grades):\t\n    '''It's the final week of the term and the instructor needs to assign grades to the students. This is a critical task for the instructor as she wants to ensure each student receives accurate feedback. The teacher has been making her own algorithm for grading. The only problem is, she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\n    Example:\n        grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    '''\n```", "```python\ndef numerical_letter_grade(grades):\t\n'''It's the final week of the term and the instructor needs to assign grades to the students, but she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\nExample:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    '''\n```"], "completions": ["from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to their corresponding letter grades.\n\n    Args:\n        grades: List of GPA values (float).\n\n    Returns:\n        List of letter grades (str) corresponding to the GPAs.\n    \"\"\"\n    # Dictionary mapping GPA thresholds to letter grades\n    gpa_to_letter = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'D-',\n    }\n\n    # List to store the resulting letter grades\n    letter_grades = []\n\n    # Iterate over each GPA in the input list\n    for gpa in grades:\n        # Check against each threshold in descending order\n        for threshold, letter in sorted(gpa_to_letter.items(), reverse=True):\n            if gpa >= threshold:\n                letter_grades.append(letter)\n                break\n\n    return letter_grades\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to their corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the input GPAs.\n    \"\"\"\n    # Define the mapping of GPA ranges to letter grades\n    gpa_to_letter_grade = {\n        (4.0,): 'A+',\n        (3.7, 4.0): 'A',\n        (3.3, 3.7): 'A-',\n        (3.0, 3.3): 'B+',\n        (2.7, 3.0): 'B',\n        (2.3, 2.7): 'B-',\n        (2.0, 2.3): 'C+',\n        (1.7, 2.0): 'C',\n        (1.3, 1.7): 'C-',\n        (1.0, 1.3): 'D+',\n        (0.7, 1.0): 'D',\n        (0.0, 0.7): 'E'\n    }\n\n    # Initialize the list to store letter grades\n    letter_grades = []\n\n    # Iterate over each GPA in the list\n    for gpa in grades:\n        # Determine the corresponding letter grade using the mapping\n        for gpa_range, letter_grade in gpa_to_letter_grade.items():\n            if len(gpa_range) == 1 and gpa == gpa_range[0]:\n                letter_grades.append(letter_grade)\n                break\n            elif len(gpa_range) == 2 and gpa_range[0] <= gpa < gpa_range[1]:\n                letter_grades.append(letter_grade)\n                break\n\n    return letter_grades\n\n# Example usage:\n# print(numerical_letter_grade([4.0, 0.0]))  # Output: ['A+', 'E']\n# print(numerical_letter_grade([3.7, 3.3, 2.3]))  # Output: ['A', 'A-', 'B-']\n# print(numerical_letter_grade([1.0, 0.7, 2.0]))  # Output: ['D+', 'D', 'C+']\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA scores.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the GPAs.\n    \"\"\"\n    result = []\n    for gpa in grades:\n        if gpa >= 4.0:\n            result.append('A+')\n        elif gpa > 3.7:\n            result.append('A')\n        elif gpa > 3.3:\n            result.append('A-')\n        elif gpa > 3.0:\n            result.append('B+')\n        elif gpa > 2.7:\n            result.append('B')\n        elif gpa > 2.3:\n            result.append('B-')\n        elif gpa > 2.0:\n            result.append('C+')\n        elif gpa > 1.7:\n            result.append('C')\n        elif gpa > 1.3:\n            result.append('C-')\n        elif gpa > 1.0:\n            result.append('D+')\n        elif gpa > 0.7:\n            result.append('D')\n        elif gpa > 0.0:\n            result.append('D-')\n        else:\n            result.append('E')  # Handle invalid or negative GPAs\n    return result\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to letter grades based on a predefined scale.\n\n    Args:\n        grades: A list of GPA values (float).\n\n    Returns:\n        A list of corresponding letter grades (str).\n    \"\"\"\n    # Define the mapping of GPA thresholds to letter grades\n    gpa_to_letter = [\n        (4.0, 'A+'),\n        (3.7, 'A'),\n        (3.3, 'A-'),\n        (3.0, 'B+'),\n        (2.7, 'B'),\n        (2.3, 'B-'),\n        (2.0, 'C+'),\n        (1.7, 'C'),\n        (1.3, 'C-'),\n        (1.0, 'D+'),\n        (0.7, 'D'),\n        (0.0, 'E')\n    ]\n\n    # Initialize the result list\n    letter_grades = []\n\n    # Iterate through each GPA in the input list\n    for gpa in grades:\n        # Determine the corresponding letter grade\n        for threshold, letter in gpa_to_letter:\n            if gpa >= threshold:\n                letter_grades.append(letter)\n                break\n\n    return letter_grades\n\n# Example usage:\n# print(numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.3, 0.0]))\n# Output: ['A+', 'A', 'A-', 'B+', 'B-', 'E']\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"Convert a list of GPAs to their corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the input GPAs.\n    \"\"\"\n    gpa_to_letter = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'E'\n    }\n    \n    letter_grades = []\n    for gpa in grades:\n        for threshold, letter in sorted(gpa_to_letter.items(), reverse=True):\n            if gpa >= threshold:\n                letter_grades.append(letter)\n                break\n    return letter_grades\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to their corresponding letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA values.\n\n    Returns:\n    list of str: A list of letter grades corresponding to the input GPAs.\n    \"\"\"\n    # Define the mapping of GPA ranges to letter grades\n    gpa_to_letter = [\n        (4.0, 'A+'),\n        (3.7, 'A'),\n        (3.3, 'A-'),\n        (3.0, 'B+'),\n        (2.7, 'B'),\n        (2.3, 'B-'),\n        (2.0, 'C+'),\n        (1.7, 'C'),\n        (1.3, 'C-'),\n        (1.0, 'D+'),\n        (0.7, 'D-'),\n        (0.0, 'E')\n    ]\n\n    # Initialize the list to store the letter grades\n    letter_grades = []\n\n    # Iterate over each GPA in the input list\n    for gpa in grades:\n        # Determine the letter grade for the current GPA\n        for threshold, letter in gpa_to_letter:\n            if gpa >= threshold:\n                letter_grades.append(letter)\n                break\n\n    return letter_grades\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    \"\"\"\n    Convert a list of GPAs to letter grades based on a predefined scale.\n\n    Args:\n        grades: List of GPAs (float values).\n\n    Returns:\n        List of corresponding letter grades (str values).\n    \"\"\"\n    # Mapping of GPA thresholds to letter grades\n    grade_mapping = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'E'\n    }\n    \n    # Result list to store the letter grades\n    result = []\n    \n    # Iterate through each GPA in the input list\n    for gpa in grades:\n        # Determine the corresponding letter grade using the mapping\n        for key in sorted(grade_mapping.keys(), reverse=True):\n            if gpa >= key:\n                result.append(grade_mapping[key])\n                break\n    \n    # Return the list of letter grades\n    return result\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    \"\"\"Convert a list of GPAs to letter grades based on a predefined scale.\n\n    Args:\n        grades (List[float]): A list of GPA values.\n\n    Returns:\n        List[str]: A list of corresponding letter grades or 'Invalid GPA' for invalid inputs.\n    \"\"\"\n    # Define the GPA to letter grade mapping\n    grade_scale = {\n        (4.0, float('inf')): 'A+',\n        (3.7, 4.0): 'A',\n        (3.3, 3.7): 'A-',\n        (3.0, 3.3): 'B+',\n        (2.7, 3.0): 'B',\n        (2.3, 2.7): 'B-',\n        (2.0, 2.3): 'C+',\n        (1.7, 2.0): 'C',\n        (1.3, 1.7): 'C-',\n        (1.0, 1.3): 'D+',\n        (0.7, 1.0): 'D',\n        (0.0, 0.7): 'D-',\n        (-float('inf'), 0.0): 'E'\n    }\n\n    result = []\n    for gpa in grades:\n        if gpa < 0 or gpa > 4.0:\n            result.append('Invalid GPA')\n        else:\n            for range, grade in grade_scale.items():\n                if range[0] <= gpa < range[1]:\n                    result.append(grade)\n                    break\n    return result\n", "from typing import List\n## main.py\n\ndef numerical_letter_grade(grades: list[float]) -> list[str]:\n    \"\"\"\n    Convert a list of GPAs to a list of letter grades.\n\n    Parameters:\n    grades (list of float): A list of GPA scores.\n\n    Returns:\n    list of str: A list of corresponding letter grades.\n    \"\"\"\n    # Define the mapping of GPA ranges to letter grades\n    grade_mapping = [\n        (4.0, 'A+'),\n        (3.7, 'A'),\n        (3.3, 'A-'),\n        (3.0, 'B+'),\n        (2.7, 'B'),\n        (2.3, 'B-'),\n        (2.0, 'C+'),\n        (1.7, 'C'),\n        (1.3, 'C-'),\n        (1.0, 'D+'),\n        (0.7, 'D'),\n        (0.0, 'E')\n    ]\n\n    # Initialize the result list\n    result = []\n\n    # Iterate through the list of GPAs\n    for gpa in grades:\n        # Determine the corresponding letter grade using conditional checks\n        for boundary, letter_grade in grade_mapping:\n            if gpa >= boundary:\n                result.append(letter_grade)\n                break\n\n    # Return the result list\n    return result\n\n# Example usage:\n# print(numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.7]))  # Output: ['A+', 'A', 'A-', 'B+', 'B']\n# print(numerical_letter_grade([0.0, 0.7, 1.0, 1.3, 1.7]))  # Output: ['E', 'D', 'D+', 'C-', 'C']\n# print(numerical_letter_grade([2.3, 2.0, 1.7, 1.3, 1.0]))  # Output: ['B-', 'C+', 'C', 'C-', 'D+']\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    '''\n    Convert a list of GPAs to letter grades.\n    \n    Parameters:\n    grades (List[float]): A list of GPA values.\n    \n    Returns:\n    List[str]: A list of corresponding letter grades.\n    '''\n    \n    # Define the mapping of GPA thresholds to letter grades\n    gpa_to_letter_grade = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'E'\n    }\n    \n    # Initialize the result list\n    letter_grades = []\n    \n    # Iterate over each GPA in the input list\n    for gpa in grades:\n        # Determine the corresponding letter grade using conditional statements\n        if gpa >= 4.0:\n            letter_grades.append('A+')\n        elif gpa >= 3.7:\n            letter_grades.append('A')\n        elif gpa >= 3.3:\n            letter_grades.append('A-')\n        elif gpa >= 3.0:\n            letter_grades.append('B+')\n        elif gpa >= 2.7:\n            letter_grades.append('B')\n        elif gpa >= 2.3:\n            letter_grades.append('B-')\n        elif gpa >= 2.0:\n            letter_grades.append('C+')\n        elif gpa >= 1.7:\n            letter_grades.append('C')\n        elif gpa >= 1.3:\n            letter_grades.append('C-')\n        elif gpa >= 1.0:\n            letter_grades.append('D+')\n        elif gpa >= 0.7:\n            letter_grades.append('D')\n        else:\n            letter_grades.append('E')\n    \n    # Return the list of letter grades\n    return letter_grades\n"], "plans": ["requirement analysis:\nThe requirement is to develop a function that converts a list of GPAs into corresponding letter grades based on a predefined scale. The function should handle various GPA inputs and return accurate letter grades efficiently.\nrequirement pool:\n- Implement the GPA to letter grade conversion function\n- Design a simple and intuitive user interface for input\n- Ensure the function handles edge cases and invalid inputs\n- Provide documentation and examples for users\n- Optimize the function for performance\nWe will implement a simple Python function that maps GPA values to letter grades using a predefined scale. The function will iterate over the list of GPAs and convert each GPA to its corresponding letter grade. We will use a dictionary to store the GPA thresholds and their corresponding letter grades for efficient lookup. The function will assume all inputs are valid GPAs as per the requirement analysis.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a standard way of measuring academic achievement in the U.S. It ranges from 0.0 to 4.0.\n    'Letter grade': A representation of a student's performance, typically ranging from A+ to E, based on their GPA.\n\n# [phrase showing quantity relationship]\n    '>': This indicates a threshold that the GPA must exceed to qualify for a particular letter grade. For example, a GPA greater than 3.7 qualifies for an 'A'.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Create a dictionary mapping GPA thresholds to letter grades.\n    2. Iterate over the list of GPAs.\n    3. For each GPA, determine the corresponding letter grade by checking against the thresholds in descending order.\n    4. Append the determined letter grade to a result list.\n    5. Return the result list.\n\n# [edge case] \n    numerical_letter_grade([4.0]) = ['A+']\n    Explanation: A GPA of 4.0 directly maps to an 'A+'.\n    \n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: A GPA of 0.0 maps to an 'E' as per the grading scale.\n    \n    numerical_letter_grade([3.7, 3.3, 2.7, 2.3, 1.7, 1.3, 0.7]) = ['A', 'A-', 'B', 'B-', 'C', 'C-', 'D']\n    Explanation: Each GPA maps to its corresponding letter grade based on the given thresholds.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the GPA thresholds in descending order and mapping them to letter grades will naturally handle all edge cases.\n", "requirement analysis:\nThe function should accurately convert GPAs to letter grades based on the provided scale. It should handle edge cases such as exact GPA values and large lists efficiently.\nrequirement pool:\n- Implement accurate GPA to letter grade conversion\n- Develop a user-friendly interface for grade input\n- Optimize performance for processing large datasets\n- Include error handling for invalid GPA values\n- Provide documentation for the grading scale\nWe will implement a simple function to convert GPAs to letter grades using a predefined mapping. The function will iterate over the list of GPAs and use conditional statements to determine the corresponding letter grade. This approach ensures accuracy and efficiency, especially for large datasets. We will use Python's built-in capabilities without any additional libraries, as the task is straightforward and does not require complex data processing.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA'\n    Explanation: GPA stands for Grade Point Average, a standard way of measuring academic achievement in the U.S. It is typically on a scale from 0.0 to 4.0.\n\n    'Letter grade'\n    Explanation: Letter grades are a way of representing academic performance, typically ranging from A+ to E, with A+ being the highest and E being the lowest.\n\n# [phrase showing quantity relationship]\n    '>': This symbol indicates a greater than relationship between GPAs and their corresponding letter grades. For example, a GPA greater than 3.7 corresponds to an 'A' grade.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    - Iterate over each GPA in the list.\n    - Use conditional statements to check the range in which the GPA falls.\n    - Assign the corresponding letter grade based on the predefined mapping.\n    - Return the list of letter grades.\n\n# [edge case] \n    numerical_letter_grade([4.0, 0.0]) = ['A+', 'E']\n    Explanation: The GPA 4.0 corresponds to the highest grade 'A+', and 0.0 corresponds to the lowest grade 'E'.\n\n    numerical_letter_grade([3.7, 3.3, 2.3]) = ['A', 'A-', 'B-']\n    Explanation: Each GPA falls into its respective range for letter grades: 3.7 is 'A', 3.3 is 'A-', and 2.3 is 'B-'.\n\n    numerical_letter_grade([1.0, 0.7, 2.0]) = ['D+', 'D', 'C+']\n    Explanation: The GPA 1.0 corresponds to 'D+', 0.7 corresponds to 'D', and 2.0 corresponds to 'C+'.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using conditional statements will correctly map each GPA to its corresponding letter grade without additional handling.\n", "requirement analysis:\nThe requirement is to develop a function that converts a list of GPAs into corresponding letter grades based on a predefined scale. The function should handle various GPA inputs and return accurate letter grades efficiently.\nrequirement pool:\n- Develop the main function to convert GPA to letter grades.\n- Create a user-friendly interface for inputting GPAs.\n- Ensure the function can handle large lists of GPAs efficiently.\n- Provide clear documentation and examples for users.\n- Implement error handling for invalid GPA inputs.\nWe will implement a simple Python function to convert a list of GPAs into corresponding letter grades based on a predefined scale. The function will use a series of conditional statements to map each GPA to its respective letter grade. We will ensure the function is efficient to handle large lists by using a straightforward approach without unnecessary complexity. We will also include basic error handling to manage any non-numeric inputs, assuming that all inputs should be valid GPAs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA'\n    Explanation: GPA stands for Grade Point Average, a standard way of measuring academic achievement in the U.S. It is typically on a scale from 0.0 to 4.0.\n\n    'Letter grade'\n    Explanation: Letter grades are a way of representing academic performance, typically ranging from A+ to E, with A+ being the highest and E being the lowest.\n\n# [phrase showing quantity relationship]\n    '>': This symbol indicates a greater than relationship between GPAs and their corresponding letter grades. For example, a GPA greater than 3.7 corresponds to an 'A' grade.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Define a function that takes a list of GPAs as input.\n    2. Create a mapping of GPA ranges to letter grades using conditional statements.\n    3. Iterate through the list of GPAs.\n    4. For each GPA, determine the corresponding letter grade using the predefined scale.\n    5. Append the letter grade to a result list.\n    6. Return the result list.\n\n# [edge case] \n    numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.7]) = ['A+', 'A', 'A-', 'B+', 'B']\n    Explanation: Each GPA falls exactly on the boundary of its respective letter grade.\n\n    numerical_letter_grade([0.0, 0.7, 1.3, 2.0, 2.3]) = ['E', 'D', 'C-', 'C+', 'B-']\n    Explanation: Each GPA falls exactly on the boundary of its respective letter grade.\n\n    numerical_letter_grade([4.1, -1, 2.5]) = ['A+', 'E', 'C+']\n    Explanation: GPA of 4.1 is treated as A+, -1 is treated as E (assuming invalid input defaults to E), and 2.5 falls between C+ and B-.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        def numerical_letter_grade(grades):\n            result = []\n            for gpa in grades:\n                if gpa >= 4.0:\n                    result.append('A+')\n                elif gpa > 3.7:\n                    result.append('A')\n                elif gpa > 3.3:\n                    result.append('A-')\n                elif gpa > 3.0:\n                    result.append('B+')\n                elif gpa > 2.7:\n                    result.append('B')\n                elif gpa > 2.3:\n                    result.append('B-')\n                elif gpa > 2.0:\n                    result.append('C+')\n                elif gpa > 1.7:\n                    result.append('C')\n                elif gpa > 1.3:\n                    result.append('C-')\n                elif gpa > 1.0:\n                    result.append('D+')\n                elif gpa > 0.7:\n                    result.append('D')\n                elif gpa > 0.0:\n                    result.append('D-')\n                else:\n                    result.append('E') # Handle invalid or negative GPAs\n            return result\n", "requirement analysis:\nThe function needs to accurately convert GPAs to letter grades based on a predefined scale. It should handle edge cases and provide consistent results. The interface should be intuitive for instructors to use, and the system should be optimized for performance, especially with large datasets.\nrequirement pool:\n- Accurate GPA to letter grade conversion\n- User-friendly interface for input\n- Performance optimization for large datasets\n- Handle edge cases in grading\n- Provide feedback on conversion process\nWe will implement a simple function to convert GPAs to letter grades using a predefined scale. The function will handle edge cases by using conditional statements to ensure accurate conversion. We will use Python's built-in capabilities to optimize performance for large datasets, ensuring the function is efficient and reliable.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates a threshold that the GPA must exceed to qualify for a particular letter grade.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Define a mapping of GPA thresholds to letter grades.\n    2. Iterate through the list of GPAs.\n    3. For each GPA, determine the corresponding letter grade by comparing it against the thresholds.\n    4. Append the letter grade to the result list.\n    5. Return the list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.0]) = ['A+']\n    Explanation: The GPA 4.0 corresponds directly to the letter grade A+.\n    \n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: The GPA 0.0 corresponds directly to the letter grade E.\n    \n    numerical_letter_grade([3.7, 3.3, 3.0]) = ['A', 'A-', 'B+']\n    Explanation: Each GPA falls within its respective range for letter grades A, A-, and B+.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of mapping GPA thresholds to letter grades inherently handles these cases.\n", "requirement analysis:\nThe function must accurately map GPA values to their corresponding letter grades based on the provided scale. It should handle a list of GPAs and return a list of letter grades. The function should be efficient and handle edge cases, such as GPAs exactly on the boundary between two grades.\nrequirement pool:\n- Implement the main grading function to convert GPA to letter grades.\n- Design a simple user interface for inputting GPAs and displaying results.\n- Ensure the function handles edge cases and boundary values correctly.\n- Optimize the function for performance with large lists of GPAs.\n- Provide documentation and examples for using the function.\nWe will implement a simple Python function that maps GPA values to their corresponding letter grades using a predefined scale. The function will handle edge cases by checking GPA values that are exactly on the boundary between two grades. We will use a dictionary to store the GPA to letter grade mappings for efficient lookup. The function will be designed to handle a list of GPAs and return a list of letter grades. We will ensure the function is optimized for performance and reliability, especially when dealing with large lists of GPAs.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates that a GPA must be greater than a certain value to qualify for a specific letter grade.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Create a dictionary mapping GPA ranges to letter grades.\n    2. Iterate through the list of GPAs.\n    3. For each GPA, determine the corresponding letter grade using the dictionary.\n    4. Handle edge cases where GPA is exactly on the boundary between two grades.\n    5. Return the list of letter grades.\n\n# [edge case] \n    numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.7]) = ['A+', 'A', 'A-', 'B+', 'B']\n    Explanation: Each GPA is exactly on the boundary of its respective grade.\n    \n    numerical_letter_grade([0.0, 0.7, 1.0, 1.3, 1.7]) = ['E', 'D-', 'D+', 'C-', 'C']\n    Explanation: Each GPA is exactly on the boundary of its respective grade.\n    \n    numerical_letter_grade([2.0, 2.3, 2.7, 3.0, 3.3]) = ['C+', 'B-', 'B', 'B+', 'A-']\n    Explanation: Each GPA is exactly on the boundary of its respective grade.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic inherently handles GPAs on boundaries by using a dictionary for mapping.\n", "requirement analysis:\nThe requirement is to develop a function that accurately converts a list of GPAs into corresponding letter grades based on a predefined scale. The function should handle various GPA inputs and return a list of letter grades. The focus is on accuracy and ease of use.\nrequirement pool:\n- Develop the main function to convert GPA to letter grades.\n- Design a simple and intuitive user interface for inputting GPAs.\n- Ensure the function handles edge cases and invalid inputs gracefully.\n- Provide detailed documentation and examples for users.\n- Implement additional grading scales for flexibility.\nWe will implement a simple Python function to convert GPAs to letter grades based on the provided scale. The function will iterate over the list of GPAs and map each GPA to its corresponding letter grade using conditional statements. We will ensure the function is robust by handling edge cases such as invalid inputs. The focus will be on accuracy and simplicity, without the need for additional grading scales at this stage.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA'\n    Explanation: GPA stands for Grade Point Average, a standard way of measuring academic achievement in the U.S. It is typically on a scale from 0.0 to 4.0.\n\n    'Letter grade'\n    Explanation: Letter grades are a way of representing academic performance using letters (A, B, C, D, E) with possible modifiers (+, -) to indicate finer distinctions.\n\n# [phrase showing quantity relationship]\n    '>': This symbol indicates a greater than relationship between GPAs and their corresponding letter grades. For example, a GPA greater than 3.7 corresponds to an 'A' grade.\n\n# [degree adverb]\n    'critical': Indicates the importance of the task for the instructor, but does not directly affect the code logic.\n\n# [code logic]\n    - Iterate over the list of GPAs.\n    - Use conditional statements to map each GPA to its corresponding letter grade based on the provided scale.\n    - Return a list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.7]) = ['A+', 'A', 'A-', 'B+', 'B']\n    Explanation: Each GPA is mapped directly to its corresponding letter grade according to the scale.\n\n    numerical_letter_grade([0.0, 0.7, 1.0, 1.3, 1.7]) = ['E', 'D-', 'D+', 'C-', 'C']\n    Explanation: Each GPA is mapped directly to its corresponding letter grade according to the scale.\n\n    numerical_letter_grade([2.3, 2.0, 3.5, 3.8, 4.0]) = ['B-', 'C+', 'A-', 'A', 'A+']\n    Explanation: Each GPA is mapped directly to its corresponding letter grade according to the scale.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using conditional statements will correctly map each GPA to its corresponding letter grade based on the provided scale.\n", "requirement analysis:\nThe function should accurately convert GPAs to letter grades based on the provided scale. It should handle input efficiently and be easy to use for instructors. The system should be optimized for performance, especially when processing large lists of GPAs.\nrequirement pool:\n- Accurate GPA to letter grade conversion\n- Efficient processing of large datasets\n- User-friendly interface for grade input\n- Clear documentation for users\n- Support for multiple grading scales\nWe will implement a simple function to convert GPAs to letter grades using a predefined mapping. The function will be optimized for performance by using efficient data structures and will handle large datasets effectively. We will use Python's built-in capabilities without any external libraries, as the task is straightforward and does not require complex operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates a threshold for each letter grade. For example, a GPA greater than 3.7 corresponds to an 'A'.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Create a mapping of GPA thresholds to letter grades.\n    2. Iterate through the list of GPAs.\n    3. For each GPA, determine the corresponding letter grade using the mapping.\n    4. Return the list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.0, 0.0]) = ['A+', 'E']\n    Explanation: 4.0 corresponds to 'A+' and 0.0 corresponds to 'E'.\n    \n    numerical_letter_grade([3.7, 3.3, 3.0]) = ['A', 'A-', 'B+']\n    Explanation: Each GPA falls within its respective range for letter grades.\n\n    numerical_letter_grade([2.3, 1.0, 0.7]) = ['B-', 'D+', 'D']\n    Explanation: Each GPA falls within its respective range for letter grades.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of mapping GPA thresholds to letter grades will handle all cases correctly.\n", "requirement analysis:\nThe requirement is to convert numerical GPAs into letter grades based on a predefined scale. The function should handle various GPA inputs and return corresponding letter grades efficiently.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design a user-friendly interface for grade input\n- Optimize the function for handling large datasets\n- Include error handling for invalid GPA inputs\n- Provide documentation for the grading scale\nWe will implement a simple function to convert GPAs to letter grades using a predefined scale. The function will handle edge cases such as negative GPAs or GPAs above 4.0 by returning an error message for invalid inputs. We will use Python's built-in capabilities to ensure efficient processing of large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA'\n    Explanation: GPA stands for Grade Point Average, a standard way of measuring academic achievement in the U.S. It ranges from 0.0 to 4.0.\n\n    'letter grade'\n    Explanation: Letter grades are a way of representing academic performance, typically ranging from A+ to E, with A+ being the highest and E being a failing grade.\n\n# [phrase showing quantity relationship]\n    '>': This symbol indicates a greater than relationship between GPAs and their corresponding letter grades. For example, a GPA greater than 3.7 corresponds to an 'A'.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    - Define a function `numerical_letter_grade` that takes a list of GPAs as input.\n    - Create a dictionary mapping GPA ranges to letter grades.\n    - Iterate through the list of GPAs.\n    - For each GPA, determine the corresponding letter grade using the dictionary.\n    - Handle edge cases such as negative GPAs or GPAs above 4.0 by returning an error message for invalid inputs.\n    - Return the list of letter grades.\n\n# [edge case]\n    numerical_letter_grade([4.1]) = ['Invalid GPA']\n    Explanation: A GPA above 4.0 is not valid according to the grading scale provided, so the function should return an error message.\n\n    numerical_letter_grade([-0.5]) = ['Invalid GPA']\n    Explanation: A negative GPA is not valid, so the function should return an error message.\n\n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: A GPA of 0.0 corresponds to the letter grade 'E' according to the grading scale.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        def numerical_letter_grade(grades):\n            grade_scale = {\n                (4.0, float('inf')): 'A+',\n                (3.7, 4.0): 'A',\n                (3.3, 3.7): 'A-',\n                (3.0, 3.3): 'B+',\n                (2.7, 3.0): 'B',\n                (2.3, 2.7): 'B-',\n                (2.0, 2.3): 'C+',\n                (1.7, 2.0): 'C',\n                (1.3, 1.7): 'C-',\n                (1.0, 1.3): 'D+',\n                (0.7, 1.0): 'D',\n                (0.0, 0.7): 'D-',\n                (-float('inf'), 0.0): 'E'\n            }\n            result = []\n            for gpa in grades:\n                if gpa < 0 or gpa > 4.0:\n                    result.append('Invalid GPA')\n                else:\n                    for range, grade in grade_scale.items():\n                        if range[0] <= gpa < range[1]:\n                            result.append(grade)\n                            break\n            return result\n", "requirement analysis:\nThe function should take a list of GPAs and return a corresponding list of letter grades based on predefined GPA ranges. It should handle edge cases and provide accurate conversions.\nrequirement pool:\n- Implement the main conversion logic from GPA to letter grade.\n- Handle edge cases where GPA is exactly on the boundary.\n- Provide clear documentation and examples for users.\n- Optimize the function for performance with large lists.\n- Include unit tests to ensure accuracy and reliability.\nWe will implement a simple function that maps GPA values to letter grades using a series of conditional checks. The function will handle edge cases by using inclusive boundaries for each grade range. We will provide clear documentation and examples to ensure ease of use. The function will be optimized for performance by using a straightforward approach without unnecessary complexity.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates that the GPA must be greater than the specified value to qualify for a particular letter grade.\n\n# [degree adverb]\n    No degree adverb\n\n# [code logic]\n    1. Create a mapping of GPA ranges to letter grades.\n    2. Iterate through the list of GPAs.\n    3. For each GPA, determine the corresponding letter grade using conditional checks.\n    4. Append the letter grade to the result list.\n    5. Return the result list.\n\n# [edge case]\n    numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.7]) = ['A+', 'A', 'A-', 'B+', 'B']\n    Explanation: Each GPA falls exactly on the boundary of a grade range.\n    \n    numerical_letter_grade([0.0, 0.7, 1.0, 1.3, 1.7]) = ['E', 'D', 'D+', 'C-', 'C']\n    Explanation: Each GPA falls exactly on the boundary of a grade range.\n    \n    numerical_letter_grade([2.3, 2.0, 1.7, 1.3, 1.0]) = ['B-', 'C+', 'C', 'C-', 'D+']\n    Explanation: Each GPA falls exactly on the boundary of a grade range.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the original logic using conditional checks will correctly map each GPA to its corresponding letter grade based on inclusive boundaries.\n", "requirement analysis:\nThe function should accurately convert GPAs to letter grades based on the provided scale. It should handle input efficiently and provide results in a user-friendly manner.\nrequirement pool:\n- Implement GPA to letter grade conversion logic\n- Design a user-friendly interface for input\n- Optimize performance for large datasets\n- Include error handling for invalid inputs\n- Provide documentation for usage\nWe will implement a simple function to convert GPAs to letter grades using a predefined mapping. The function will iterate over the list of GPAs and use conditional statements to determine the corresponding letter grade. We will use Python's built-in capabilities to handle the conversion efficiently, ensuring the function can process large datasets quickly.\nPlease read and understand the following inteperation before coding\n## Answer 3:\n\n# [core concept]\n    'GPA': Grade Point Average, a numerical representation of a student's academic performance.\n    'Letter grade': A symbolic representation of a student's performance, typically ranging from A+ to E.\n\n# [phrase showing quantity relationship]\n    '>': Indicates a threshold that the GPA must exceed to qualify for a particular letter grade.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Create a mapping of GPA thresholds to letter grades.\n    2. Iterate over the list of GPAs.\n    3. For each GPA, determine the corresponding letter grade using conditional statements.\n    4. Append the letter grade to the result list.\n    5. Return the list of letter grades.\n\n# [edge case] \n    numerical_letter_grade([0.0]) = ['E']\n    Explanation: A GPA of 0.0 corresponds to the letter grade 'E'.\n    \n    numerical_letter_grade([4.0, 3.7, 3.3, 3.0, 2.7]) = ['A+', 'A', 'A-', 'B+', 'B']\n    Explanation: Each GPA corresponds to its respective letter grade based on the predefined mapping.\n    \n    numerical_letter_grade([2.3, 1.7, 1.3, 1.0, 0.7]) = ['B-', 'C', 'C-', 'D+', 'D']\n    Explanation: Each GPA corresponds to its respective letter grade based on the predefined mapping.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic using conditional statements will correctly map each GPA to its corresponding letter grade based on the predefined thresholds.\n"], "scores": [0.3491, 0.3491, 0.3962, 0.3491, 0.3491, 0.3585, 0.3491, 0.3491, 0.3491, 0.3491], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [37, 37, 42, 37, 37, 38, 37, 37, 37, 37], "completion": "from typing import List\n## main.py\n\nfrom typing import List\n\ndef numerical_letter_grade(grades: List[float]) -> List[str]:\n    '''\n    Convert a list of GPAs to letter grades.\n    \n    Parameters:\n    grades (List[float]): A list of GPA values.\n    \n    Returns:\n    List[str]: A list of corresponding letter grades.\n    '''\n    \n    # Define the mapping of GPA thresholds to letter grades\n    gpa_to_letter_grade = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'E'\n    }\n    \n    # Initialize the result list\n    letter_grades = []\n    \n    # Iterate over each GPA in the input list\n    for gpa in grades:\n        # Determine the corresponding letter grade using conditional statements\n        if gpa >= 4.0:\n            letter_grades.append('A+')\n        elif gpa >= 3.7:\n            letter_grades.append('A')\n        elif gpa >= 3.3:\n            letter_grades.append('A-')\n        elif gpa >= 3.0:\n            letter_grades.append('B+')\n        elif gpa >= 2.7:\n            letter_grades.append('B')\n        elif gpa >= 2.3:\n            letter_grades.append('B-')\n        elif gpa >= 2.0:\n            letter_grades.append('C+')\n        elif gpa >= 1.7:\n            letter_grades.append('C')\n        elif gpa >= 1.3:\n            letter_grades.append('C-')\n        elif gpa >= 1.0:\n            letter_grades.append('D+')\n        elif gpa >= 0.7:\n            letter_grades.append('D')\n        else:\n            letter_grades.append('E')\n    \n    # Return the list of letter grades\n    return letter_grades\n", "passed": false, "pass": false, "pass_num": 0, "round": 604, "mutate_method": "rephrase_one", "parent_index": 157}
