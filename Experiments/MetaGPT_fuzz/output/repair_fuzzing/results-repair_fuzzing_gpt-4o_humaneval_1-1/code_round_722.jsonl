{"task_id": "HumanEval/58", "prompt": "def common(l1: list, l2: list):\t\n'''Find the unique elements that appear in both lists, and ensure they are returned in a sorted order.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''", "entry_point": "common", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "test": ["def check(common):\n\tassert common([6, 5, 7, 10], [8, 4]) == []", "def check(common):\n\tassert common([6, 3, 2, 37, 657, 2, 6], [5, 9, 1, 6, 4, 654, 125]) == [6]", "def check(common):\n\tassert common([1, 6, 5, 9], [1, 6, 1]) == [1, 6]", "def check(common):\n\tassert common([8, 7, 6, 13], [7, 2]) == [7]", "def check(common):\n\tassert common([1, 1, 3, 11], [5, 3, 2]) == [3]", "def check(common):\n\tassert common([7, 8, 6, 11], [4, 5, 9]) == []", "def check(common):\n\tassert common([1, 6, 5, 34, 651, 3, 3], [7, 8, 1, 7, 9, 653, 121]) == [1]", "def check(common):\n\tassert common([6, 6, 4, 12], [3, 1]) == []", "def check(common):\n\tassert common([6, 1, 5, 36, 648, 1, 6], [3, 4, 2, 1, 12, 654, 123]) == [1]", "def check(common):\n\tassert common([6, 3, 7, 6], [3, 5, 7]) == [3, 7]", "def check(common):\n\tassert common([4, 8, 2, 9], [3, 1]) == []", "def check(common):\n\tassert common([3, 5, 5, 8], [7, 6]) == []", "def check(common):\n\tassert common([1, 8, 3, 4], [8, 7, 6]) == [8]", "def check(common):\n\tassert common([5, 2, 6, 30, 650, 7, 3], [7, 10, 2, 4, 4, 651, 126]) == [2, 7]", "def check(common):\n\tassert common([4, 6, 6, 7], [8, 6, 9]) == [6]", "def check(common):\n\tassert common([3, 7, 6, 3], [2, 4, 5]) == []", "def check(common):\n\tassert common([7, 4, 3, 10], [3, 1]) == [3]", "def check(common):\n\tassert common([3, 3, 1, 4], [4, 6, 4]) == [4]", "def check(common):\n\tassert common([4, 5, 2, 5], [1, 7, 5]) == [5]", "def check(common):\n\tassert common([5, 3, 4, 35, 652, 1, 1], [9, 6, 2, 8, 6, 653, 122]) == []", "def check(common):\n\tassert common([3, 1, 6, 11], [6, 6]) == [6]", "def check(common):\n\tassert common([7, 4, 7, 13], [8, 4]) == [4]", "def check(common):\n\tassert common([4, 4, 4, 34, 652, 5, 10], [8, 2, 1, 4, 5, 652, 117]) == [4, 5, 652]", "def check(common):\n\tassert common([2, 8, 3, 29, 650, 1, 7], [3, 6, 2, 3, 7, 652, 116]) == [2, 3, 7]", "def check(common):\n\tassert common([5, 8, 7, 3], [6, 4]) == []", "def check(common):\n\tassert common([2, 2, 1, 29, 650, 4, 2], [3, 10, 6, 2, 11, 651, 119]) == [2]", "def check(common):\n\tassert common([3, 3, 2, 30, 656, 3, 4], [6, 11, 2, 4, 4, 652, 123]) == [2, 4]", "def check(common):\n\tassert common([6, 1, 4, 33, 651, 4, 3], [4, 10, 1, 10, 12, 657, 126]) == [1, 4]", "def check(common):\n\tassert common([6, 6, 4, 5], [3, 3, 8]) == []", "def check(common):\n\tassert common([5, 5, 4, 34, 648, 5, 5], [3, 7, 6, 2, 10, 648, 116]) == [648]", "def check(common):\n\tassert common([2, 1, 7, 9], [6, 3]) == []", "def check(common):\n\tassert common([4, 1, 4, 12], [5, 1, 7]) == [1]", "def check(common):\n\tassert common([7, 6, 3, 9], [6, 5]) == [6]", "def check(common):\n\tassert common([2, 3, 3, 9], [5, 2]) == [2]", "def check(common):\n\tassert common([1, 4, 1, 32, 657, 7, 6], [4, 10, 2, 2, 4, 650, 124]) == [4]", "def check(common):\n\tassert common([8, 3, 4, 10], [8, 7]) == [8]", "def check(common):\n\tassert common([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]", "def check(common):\n\tassert common([5, 2, 2, 30, 654, 5, 1], [3, 3, 2, 10, 6, 657, 126]) == [2]", "def check(common):\n\tassert common([2, 7, 4, 3], [8, 7, 5]) == [7]", "def check(common):\n\tassert common([4, 5, 7, 12], [7, 1]) == [7]", "def check(common):\n\tassert common([9, 3, 7, 4], [4, 2, 4]) == [4]", "def check(common):\n\tassert common([3, 1, 3, 10], [3, 3, 9]) == [3]", "def check(common):\n\tassert common([4, 4, 1, 37, 654, 7, 5], [3, 11, 2, 6, 9, 656, 120]) == []", "def check(common):\n\tassert common([2, 6, 2, 8], [5, 2]) == [2]", "def check(common):\n\tassert common([2, 4, 3, 12], [4, 5, 6]) == [4]", "def check(common):\n\tassert common([4, 4, 7, 8], [4, 4, 9]) == [4]", "def check(common):\n\tassert common([1, 6, 6, 12], [6, 2, 9]) == [6]", "def check(common):\n\tassert common([2, 7, 1, 4], [1, 2, 1]) == [1, 2]", "def check(common):\n\tassert common([2, 5, 6, 32, 649, 3, 9], [8, 6, 1, 4, 4, 658, 117]) == [6]", "def check(common):\n\tassert common([2, 1, 5, 37, 657, 7, 1], [4, 9, 3, 1, 12, 649, 122]) == [1]", "def check(common):\n\tassert common([5, 5, 7, 7], [5, 2]) == [5]", "def check(common):\n\tassert common([5, 3, 2, 8], [3, 2]) == [2, 3]", "def check(common):\n\tassert common([5, 4, 5, 32, 655, 6, 2], [2, 10, 4, 2, 14, 656, 117]) == [2, 4]", "def check(common):\n\tassert common([3, 4, 4, 8], [3, 3, 9]) == [3]", "def check(common):\n\tassert common([5, 2, 1, 3], [8, 3]) == [3]", "def check(common):\n\tassert common([3, 8, 3, 35, 651, 4, 2], [1, 12, 6, 10, 4, 654, 119]) == [4]", "def check(common):\n\tassert common([5, 6, 4, 8], [3, 7, 2]) == []", "def check(common):\n\tassert common([7, 7, 5, 11], [3, 4]) == []", "def check(common):\n\tassert common([4, 3, 2, 8], []) == []", "def check(common):\n\tassert common([7, 7, 7, 3], [2, 4]) == []", "def check(common):\n\tassert common([2, 9, 3, 36, 649, 6, 7], [10, 12, 4, 4, 14, 656, 116]) == []", "def check(common):\n\tassert common([3, 8, 6, 6], [4, 3, 3]) == [3]", "def check(common):\n\tassert common([1, 8, 7, 3], [2, 6]) == []", "def check(common):\n\tassert common([1, 4, 5, 11], [1, 6, 1]) == [1]", "def check(common):\n\tassert common([6, 2, 3, 8], [7, 6, 8]) == [6, 8]", "def check(common):\n\tassert common([1, 7, 4, 30, 653, 1, 1], [6, 9, 2, 2, 13, 650, 120]) == []", "def check(common):\n\tassert common([6, 8, 4, 32, 657, 7, 6], [4, 10, 1, 5, 14, 652, 120]) == [4]", "def check(common):\n\tassert common([2, 7, 7, 32, 650, 5, 6], [7, 2, 4, 3, 13, 654, 117]) == [2, 7]", "def check(common):\n\tassert common([1, 4, 7, 30, 658, 3, 10], [6, 7, 3, 10, 10, 658, 117]) == [3, 7, 10, 658]", "def check(common):\n\tassert common([8, 4, 1, 9], [6, 3]) == []", "def check(common):\n\tassert common([2, 1, 4, 37, 657, 3, 7], [8, 5, 5, 10, 7, 654, 121]) == [7]", "def check(common):\n\tassert common([9, 7, 7, 7], [5, 2]) == []", "def check(common):\n\tassert common([4, 6, 3, 31, 648, 7, 10], [1, 10, 4, 7, 7, 653, 117]) == [4, 7, 10]", "def check(common):\n\tassert common([6, 5, 2, 3], [3, 3, 3]) == [3]", "def check(common):\n\tassert common([4, 4, 1, 8], [1, 5, 7]) == [1]", "def check(common):\n\tassert common([8, 4, 6, 5], [1, 1]) == []", "def check(common):\n\tassert common([4, 5, 3, 10], [7, 5]) == [5]", "def check(common):\n\tassert common([7, 1, 7, 13], [3, 1]) == [1]", "def check(common):\n\tassert common([1, 5, 5, 29, 655, 4, 1], [5, 3, 2, 1, 5, 648, 118]) == [1, 5]", "def check(common):\n\tassert common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]", "def check(common):\n\tassert common([7, 7, 1, 4], [5, 6]) == []", "def check(common):\n\tassert common([5, 4, 2, 36, 648, 7, 10], [6, 8, 1, 5, 11, 649, 126]) == [5]", "def check(common):\n\tassert common([8, 1, 1, 3], [5, 6]) == []", "def check(common):\n\tassert common([6, 3, 6, 3], [8, 5, 8]) == []", "def check(common):\n\tassert common([6, 8, 7, 32, 654, 7, 3], [7, 7, 2, 5, 10, 654, 123]) == [7, 654]", "def check(common):\n\tassert common([2, 2, 6, 11], [5, 6, 1]) == [6]", "def check(common):\n\tassert common([1, 4, 6, 39, 653, 4, 3], [6, 12, 2, 3, 14, 654, 116]) == [3, 6]", "def check(common):\n\tassert common([1, 3, 4, 9], [7, 3]) == [3]", "def check(common):\n\tassert common([9, 6, 6, 7], [7, 7, 1]) == [7]", "def check(common):\n\tassert common([5, 6, 2, 34, 654, 3, 7], [7, 9, 1, 7, 8, 650, 122]) == [7]", "def check(common):\n\tassert common([8, 2, 7, 4], [7, 7, 1]) == [7]", "def check(common):\n\tassert common([3, 2, 1, 37, 654, 7, 6], [2, 3, 2, 6, 4, 649, 123]) == [2, 3, 6]", "def check(common):\n\tassert common([9, 2, 7, 4], [5, 4, 1]) == [4]", "def check(common):\n\tassert common([8, 1, 4, 10], [4, 2]) == [4]", "def check(common):\n\tassert common([2, 8, 5, 10], [8, 4]) == [8]", "def check(common):\n\tassert common([8, 4, 4, 6], [3, 6]) == [6]", "def check(common):\n\tassert common([3, 6, 6, 7], [7, 4, 2]) == [7]", "def check(common):\n\tassert common([3, 4, 3, 11], [4, 1, 7]) == [4]", "def check(common):\n\tassert common([3, 1, 4, 5], [1, 1]) == [1]", "def check(common):\n\tassert common([3, 2, 5, 37, 652, 2, 3], [5, 4, 6, 7, 9, 651, 120]) == [5]"], "test_case_list": ["assert common([6, 5, 7, 10], [8, 4]) == []", "assert common([6, 3, 2, 37, 657, 2, 6], [5, 9, 1, 6, 4, 654, 125]) == [6]", "assert common([1, 6, 5, 9], [1, 6, 1]) == [1, 6]", "assert common([8, 7, 6, 13], [7, 2]) == [7]", "assert common([1, 1, 3, 11], [5, 3, 2]) == [3]", "assert common([7, 8, 6, 11], [4, 5, 9]) == []", "assert common([1, 6, 5, 34, 651, 3, 3], [7, 8, 1, 7, 9, 653, 121]) == [1]", "assert common([6, 6, 4, 12], [3, 1]) == []", "assert common([6, 1, 5, 36, 648, 1, 6], [3, 4, 2, 1, 12, 654, 123]) == [1]", "assert common([6, 3, 7, 6], [3, 5, 7]) == [3, 7]", "assert common([4, 8, 2, 9], [3, 1]) == []", "assert common([3, 5, 5, 8], [7, 6]) == []", "assert common([1, 8, 3, 4], [8, 7, 6]) == [8]", "assert common([5, 2, 6, 30, 650, 7, 3], [7, 10, 2, 4, 4, 651, 126]) == [2, 7]", "assert common([4, 6, 6, 7], [8, 6, 9]) == [6]", "assert common([3, 7, 6, 3], [2, 4, 5]) == []", "assert common([7, 4, 3, 10], [3, 1]) == [3]", "assert common([3, 3, 1, 4], [4, 6, 4]) == [4]", "assert common([4, 5, 2, 5], [1, 7, 5]) == [5]", "assert common([5, 3, 4, 35, 652, 1, 1], [9, 6, 2, 8, 6, 653, 122]) == []", "assert common([3, 1, 6, 11], [6, 6]) == [6]", "assert common([7, 4, 7, 13], [8, 4]) == [4]", "assert common([4, 4, 4, 34, 652, 5, 10], [8, 2, 1, 4, 5, 652, 117]) == [4, 5, 652]", "assert common([2, 8, 3, 29, 650, 1, 7], [3, 6, 2, 3, 7, 652, 116]) == [2, 3, 7]", "assert common([5, 8, 7, 3], [6, 4]) == []", "assert common([2, 2, 1, 29, 650, 4, 2], [3, 10, 6, 2, 11, 651, 119]) == [2]", "assert common([3, 3, 2, 30, 656, 3, 4], [6, 11, 2, 4, 4, 652, 123]) == [2, 4]", "assert common([6, 1, 4, 33, 651, 4, 3], [4, 10, 1, 10, 12, 657, 126]) == [1, 4]", "assert common([6, 6, 4, 5], [3, 3, 8]) == []", "assert common([5, 5, 4, 34, 648, 5, 5], [3, 7, 6, 2, 10, 648, 116]) == [648]", "assert common([2, 1, 7, 9], [6, 3]) == []", "assert common([4, 1, 4, 12], [5, 1, 7]) == [1]", "assert common([7, 6, 3, 9], [6, 5]) == [6]", "assert common([2, 3, 3, 9], [5, 2]) == [2]", "assert common([1, 4, 1, 32, 657, 7, 6], [4, 10, 2, 2, 4, 650, 124]) == [4]", "assert common([8, 3, 4, 10], [8, 7]) == [8]", "assert common([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]", "assert common([5, 2, 2, 30, 654, 5, 1], [3, 3, 2, 10, 6, 657, 126]) == [2]", "assert common([2, 7, 4, 3], [8, 7, 5]) == [7]", "assert common([4, 5, 7, 12], [7, 1]) == [7]", "assert common([9, 3, 7, 4], [4, 2, 4]) == [4]", "assert common([3, 1, 3, 10], [3, 3, 9]) == [3]", "assert common([4, 4, 1, 37, 654, 7, 5], [3, 11, 2, 6, 9, 656, 120]) == []", "assert common([2, 6, 2, 8], [5, 2]) == [2]", "assert common([2, 4, 3, 12], [4, 5, 6]) == [4]", "assert common([4, 4, 7, 8], [4, 4, 9]) == [4]", "assert common([1, 6, 6, 12], [6, 2, 9]) == [6]", "assert common([2, 7, 1, 4], [1, 2, 1]) == [1, 2]", "assert common([2, 5, 6, 32, 649, 3, 9], [8, 6, 1, 4, 4, 658, 117]) == [6]", "assert common([2, 1, 5, 37, 657, 7, 1], [4, 9, 3, 1, 12, 649, 122]) == [1]", "assert common([5, 5, 7, 7], [5, 2]) == [5]", "assert common([5, 3, 2, 8], [3, 2]) == [2, 3]", "assert common([5, 4, 5, 32, 655, 6, 2], [2, 10, 4, 2, 14, 656, 117]) == [2, 4]", "assert common([3, 4, 4, 8], [3, 3, 9]) == [3]", "assert common([5, 2, 1, 3], [8, 3]) == [3]", "assert common([3, 8, 3, 35, 651, 4, 2], [1, 12, 6, 10, 4, 654, 119]) == [4]", "assert common([5, 6, 4, 8], [3, 7, 2]) == []", "assert common([7, 7, 5, 11], [3, 4]) == []", "assert common([4, 3, 2, 8], []) == []", "assert common([7, 7, 7, 3], [2, 4]) == []", "assert common([2, 9, 3, 36, 649, 6, 7], [10, 12, 4, 4, 14, 656, 116]) == []", "assert common([3, 8, 6, 6], [4, 3, 3]) == [3]", "assert common([1, 8, 7, 3], [2, 6]) == []", "assert common([1, 4, 5, 11], [1, 6, 1]) == [1]", "assert common([6, 2, 3, 8], [7, 6, 8]) == [6, 8]", "assert common([1, 7, 4, 30, 653, 1, 1], [6, 9, 2, 2, 13, 650, 120]) == []", "assert common([6, 8, 4, 32, 657, 7, 6], [4, 10, 1, 5, 14, 652, 120]) == [4]", "assert common([2, 7, 7, 32, 650, 5, 6], [7, 2, 4, 3, 13, 654, 117]) == [2, 7]", "assert common([1, 4, 7, 30, 658, 3, 10], [6, 7, 3, 10, 10, 658, 117]) == [3, 7, 10, 658]", "assert common([8, 4, 1, 9], [6, 3]) == []", "assert common([2, 1, 4, 37, 657, 3, 7], [8, 5, 5, 10, 7, 654, 121]) == [7]", "assert common([9, 7, 7, 7], [5, 2]) == []", "assert common([4, 6, 3, 31, 648, 7, 10], [1, 10, 4, 7, 7, 653, 117]) == [4, 7, 10]", "assert common([6, 5, 2, 3], [3, 3, 3]) == [3]", "assert common([4, 4, 1, 8], [1, 5, 7]) == [1]", "assert common([8, 4, 6, 5], [1, 1]) == []", "assert common([4, 5, 3, 10], [7, 5]) == [5]", "assert common([7, 1, 7, 13], [3, 1]) == [1]", "assert common([1, 5, 5, 29, 655, 4, 1], [5, 3, 2, 1, 5, 648, 118]) == [1, 5]", "assert common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]", "assert common([7, 7, 1, 4], [5, 6]) == []", "assert common([5, 4, 2, 36, 648, 7, 10], [6, 8, 1, 5, 11, 649, 126]) == [5]", "assert common([8, 1, 1, 3], [5, 6]) == []", "assert common([6, 3, 6, 3], [8, 5, 8]) == []", "assert common([6, 8, 7, 32, 654, 7, 3], [7, 7, 2, 5, 10, 654, 123]) == [7, 654]", "assert common([2, 2, 6, 11], [5, 6, 1]) == [6]", "assert common([1, 4, 6, 39, 653, 4, 3], [6, 12, 2, 3, 14, 654, 116]) == [3, 6]", "assert common([1, 3, 4, 9], [7, 3]) == [3]", "assert common([9, 6, 6, 7], [7, 7, 1]) == [7]", "assert common([5, 6, 2, 34, 654, 3, 7], [7, 9, 1, 7, 8, 650, 122]) == [7]", "assert common([8, 2, 7, 4], [7, 7, 1]) == [7]", "assert common([3, 2, 1, 37, 654, 7, 6], [2, 3, 2, 6, 4, 649, 123]) == [2, 3, 6]", "assert common([9, 2, 7, 4], [5, 4, 1]) == [4]", "assert common([8, 1, 4, 10], [4, 2]) == [4]", "assert common([2, 8, 5, 10], [8, 4]) == [8]", "assert common([8, 4, 4, 6], [3, 6]) == [6]", "assert common([3, 6, 6, 7], [7, 4, 2]) == [7]", "assert common([3, 4, 3, 11], [4, 1, 7]) == [4]", "assert common([3, 1, 4, 5], [1, 1]) == [1]", "assert common([3, 2, 5, 37, 652, 2, 3], [5, 4, 6, 7, 9, 651, 120]) == [5]"], "nl": "Return sorted unique common elements for two lists.\n    ", "func": "def common(l1: list, l2: list):", "examples": ">>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    ", "repair_prompt": ["def common(l1: list, l2: list):\t\n'''Find the unique elements that appear in both lists, and ensure they are returned in a sorted order.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''", "def common(l1: list, l2: list):\t\n'''Find the unique elements that appear in both lists. Make sure that they are returned in a sorted order.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''", "def common(l1: list, l2: list):\t\n'''Find the unique elements that appear in both lists and ensure they are returned in a sorted order.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists, and ensure they are returned in a sorted order.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n\n    Returns:\n        list: Sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_list = sorted(intersection)\n    \n    # Return the sorted list of unique common elements\n    return sorted_list\n\n# Example usage:\n# common([1, 2, 3, 4], [3, 4, 5, 6]) should return [3, 4]\n# common([], [1, 2, 3]) should return []\n# common([1, 2, 3], []) should return []\n# common([], []) should return []\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists, and ensure they are returned in a sorted order.\n\n    Parameters:\n    l1 (list): The first list of elements.\n    l2 (list): The second list of elements.\n\n    Returns:\n    list: A sorted list of unique elements that appear in both l1 and l2.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get the common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the resulting set of common elements back to a list\n    common_list = list(common_elements)\n    \n    # Sort the list of common elements\n    common_list.sort()\n    \n    # Return the sorted list\n    return common_list\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists, and ensure they are returned in a sorted order.\n\n    Args:\n        l1 (list): First list of integers.\n        l2 (list): Second list of integers.\n\n    Returns:\n        list: A sorted list of unique common elements.\n\n    Raises:\n        ValueError: If any of the inputs is not a list or contains non-integer elements.\n    \"\"\"\n    # Validate inputs\n    if not isinstance(l1, list) or not isinstance(l2, list):\n        raise ValueError(\"Both inputs must be lists.\")\n    \n    if not all(isinstance(x, int) for x in l1) or not all(isinstance(x, int) for x in l2):\n        raise ValueError(\"All elements in the lists must be integers.\")\n\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find intersection of both sets\n    common_elements = set1.intersection(set2)\n\n    # Convert the set to a sorted list\n    result = sorted(common_elements)\n\n    return result\n\n# Example usage:\n# print(common([1, 1, 2, 2], [2, 2, 3, 3]))  # Output: [2]\n# print(common([], []))  # Output: []\n# print(common([1, 2, 3], []))  # Output: []\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists and return them in sorted order.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n\n    Returns:\n        list: A sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_list = sorted(intersection)\n    \n    # Return the sorted list of unique common elements\n    return sorted_list\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists and return them in sorted order.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n\n    Returns:\n        list: Sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get elements that appear in both lists\n    intersection = set1.intersection(set2)\n    \n    # Convert the resulting set back to a list\n    result_list = list(intersection)\n    \n    # Sort the list to ensure the elements are in ascending order\n    result_list.sort()\n    \n    # Return the sorted list\n    return result_list\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists and return them in sorted order.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n\n    Returns:\n        list: A sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the intersection of the two sets to get the common elements\n    common_elements = set1.intersection(set2)\n\n    # Convert the resulting set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n\n    # Return the sorted list of common elements\n    return sorted_common_elements\n\n# Example usage:\n# result = common([1, 2, 3, 4], [3, 4, 5, 6])\n# print(result)  # Output: [3, 4]\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists and ensure they are returned in a sorted order.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n\n    Returns:\n        list: A sorted list of unique elements common to both lists.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get the common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the resulting set back to a list\n    common_list = list(common_elements)\n    \n    # Sort the list of common elements\n    sorted_common_list = sorted(common_list)\n    \n    # Return the sorted list\n    return sorted_common_list\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    '''\n    Find the unique elements that appear in both lists and ensure they are returned in a sorted order.\n    \n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n    \n    Returns:\n        list: A sorted list of unique elements common to both lists.\n    '''\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list\n    result_list = list(intersection)\n    \n    # Sort the list to ensure the elements are in ascending order\n    result_list.sort()\n    \n    # Return the sorted list\n    return result_list\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists and ensure they are returned in a sorted order.\n    \n    Args:\n        l1: First list of elements.\n        l2: Second list of elements.\n    \n    Returns:\n        A sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to identify elements present in both sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the resulting set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list\n    return sorted_common_elements\n\n# Example usage:\n# print(common([1, 1, 2, 2], [2, 2, 3, 3]))  # Output: [2]\n# print(common([], []))  # Output: []\n# print(common([1, 2, 3], []))  # Output: []\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists, and ensure they are returned in a sorted order.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n\n    Returns:\n        list: A sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find elements that appear in both sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the resulting set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list\n    return sorted_common_elements\n\n# Example usage:\n# result = common([1, 1, 2, 2], [2, 2, 3, 3])\n# print(result)  # Output: [2]\n"], "plans": ["requirement analysis:\nThe function should efficiently find unique common elements between two lists and return them sorted. It should handle edge cases like empty lists and be easy to use in various Python environments.\nrequirement pool:\n- The function must return sorted unique common elements.\n- The function should handle empty lists gracefully.\n- The function should be efficient for large lists.\n- The function should have clear documentation.\n- The function should be compatible with Python 3.x.\nWe will use Python's built-in set operations to efficiently find the intersection of two lists, ensuring the result is unique and sorted. This approach is both efficient and compatible with different Python versions. We will handle edge cases like empty lists by returning an empty list when no common elements are found.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: The requirement specifies that the elements returned should not have duplicates, meaning each element should appear only once in the result.\n\n    'sorted order'\n    Explanation: The elements in the result should be arranged in ascending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and find the intersection.\n    2. Convert the intersection set back to a list.\n    3. Sort the list to ensure the elements are in ascending order.\n    4. Return the sorted list.\n\n# [edge case] \n    common([], [1, 2, 3]) = []\n    Explanation: The first list is empty, so there are no common elements, resulting in an empty list.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements, resulting in an empty list.\n    \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements, resulting in an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic of using set intersection and sorting inherently handles these cases by returning an empty list when no common elements are found.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the result is unique and sorted. It should handle edge cases such as empty lists and large datasets. The implementation should be compatible with Python 3.x and be well-documented.\nrequirement pool:\n- Implement the main function to find common elements\n- Ensure the result is sorted and unique\n- Handle edge cases like empty lists\n- Optimize for large lists\n- Provide comprehensive documentation and examples\nWe will use Python's built-in set operations to efficiently find common elements between two lists. This approach ensures that the result is unique and sorted by converting the result to a list and using the sorted function. This method is efficient for handling large lists and edge cases like empty lists. The function will be compatible with Python 3.x and will include comprehensive documentation in the form of docstrings.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: This means that each element in the result should appear only once, even if it appears multiple times in the input lists.\n\n    'sorted order'\n    Explanation: The resulting list of common elements should be arranged in ascending numerical order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both input lists to sets to remove duplicates and allow for efficient intersection operations.\n    2. Find the intersection of the two sets to get the common elements.\n    3. Convert the resulting set of common elements back to a list.\n    4. Sort the list of common elements.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n\n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list.\n\n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: The number 1 is the only element in both lists, and it should appear only once in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the result is unique and sorted. It should handle edge cases such as empty lists and invalid inputs gracefully.\nrequirement pool:\n- Implement the main function to find common elements.\n- Ensure the output is sorted and contains unique elements.\n- Optimize the function for performance with large datasets.\n- Create a user-friendly interface for inputting lists.\n- Handle invalid inputs with appropriate error messages.\nWe will implement a function using Python's built-in set operations to efficiently find common elements between two lists. The function will ensure the result is unique and sorted. We will use exception handling to manage invalid inputs and provide clear error messages. The function will be optimized for performance, especially with large datasets, by leveraging set intersection and sorting.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: The requirement specifies that the elements returned should not have duplicates, meaning each element should appear only once in the result.\n\n    'sorted order'\n    Explanation: The elements in the result should be arranged in ascending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and find common elements using set intersection.\n    2. Convert the resulting set back to a list.\n    3. Sort the list to ensure the elements are in ascending order.\n    4. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements, resulting in an empty list.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list, resulting in an empty list.\n    \n    common([1, 1, 2, 2], [2, 2, 3, 3]) = [2]\n    Explanation: The number 2 is the only element that appears in both lists, and it should be returned as a unique element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists and return them in sorted order. It should handle edge cases such as empty lists and duplicates within the lists.\nrequirement pool:\n- Implement the main function to find common elements.\n- Ensure the output is sorted.\n- Optimize for performance with large lists.\n- Handle edge cases like empty lists.\n- Provide comprehensive documentation and examples.\nWe will use Python's built-in set operations to efficiently find the intersection of two lists, which inherently handles duplicates by only considering unique elements. The result will be converted to a sorted list before returning. This approach is efficient for large datasets and leverages Python's optimized set operations.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: The requirement specifies that the elements returned should be unique, meaning no duplicates should be present in the final result.\n\n    'sorted order'\n    Explanation: The requirement specifies that the elements should be returned in ascending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and find the intersection.\n    2. Convert the intersection set back to a list.\n    3. Sort the list in ascending order.\n    4. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements to return.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list.\n    \n    common([1, 1, 2, 2], [2, 2, 3, 3]) = [2]\n    Explanation: The number 2 is the only element that appears in both lists, and duplicates are removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find unique common elements between two lists and return them in sorted order. It should handle edge cases such as empty lists and duplicates gracefully.\nrequirement pool:\n- Implement the main function to find common elements\n- Optimize the function for large datasets\n- Ensure the function handles edge cases\n- Provide comprehensive documentation\n- Test compatibility with different Python versions\nWe will use Python's built-in set operations to efficiently find unique common elements between two lists. This approach is fast and intuitive, making it ideal for handling large datasets and edge cases such as empty lists and duplicates. The function will sort the result before returning it.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: This means that each element should appear only once in the result, even if it appears multiple times in the input lists.\n\n    'appear in both lists'\n    Explanation: This means that the element must be present in both input lists to be included in the result.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow for efficient intersection operations.\n    2. Find the intersection of the two sets to get elements that appear in both lists.\n    3. Convert the resulting set back to a list.\n    4. Sort the list to ensure the elements are in ascending order.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], [1, 2, 3]) = []\n    Explanation: The first list is empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements.\n    \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations and sorting inherently handles these cases by returning an empty set or list when there are no common elements.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists and return them in sorted order. It should handle edge cases such as empty lists and duplicate elements. Performance optimization is crucial for handling large datasets.\nrequirement pool:\n- Implement the main function to find common elements.\n- Ensure the output is sorted.\n- Optimize performance for large lists.\n- Handle edge cases like empty lists.\n- Provide comprehensive documentation.\nWe will implement a function using Python's built-in set operations to efficiently find common elements between two lists. The function will ensure the output is sorted and handle edge cases such as empty lists and duplicate elements. Performance optimization will be achieved by leveraging set intersection, which is generally faster for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: This means that each element should appear only once in the result, even if it appears multiple times in the input lists.\n\n    'sorted order'\n    Explanation: The resulting list of common elements should be arranged in ascending numerical order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow for efficient intersection operations.\n    2. Find the intersection of the two sets to get the common elements.\n    3. Convert the resulting set back to a list.\n    4. Sort the list to ensure the elements are in ascending order.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], [1, 2, 3]) = []\n    Explanation: The first list is empty, so there are no common elements.\n\n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements.\n\n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles empty lists and duplicates, and sorting an empty list will still result in an empty list.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the result is unique and sorted. It should handle edge cases such as empty lists and large datasets without performance degradation.\nrequirement pool:\n- Implement the main function to find common elements.\n- Ensure the result is sorted and contains unique elements.\n- Optimize for performance with large lists.\n- Provide comprehensive documentation and examples.\n- Handle edge cases like empty lists gracefully.\nWe will use Python's built-in set operations to efficiently find common elements between two lists. This approach is fast and ensures that the result is unique. We will then sort the result using Python's sorted function. This method is optimal for performance with large datasets and handles edge cases like empty lists gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: This means that each element in the result should appear only once, even if it appears multiple times in the input lists.\n\n    'sorted order'\n    Explanation: The resulting list of common elements should be arranged in ascending numerical order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow for efficient intersection operations.\n    2. Find the intersection of the two sets to get the common elements.\n    3. Convert the resulting set back to a list.\n    4. Sort the list of common elements.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list.\n    \n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: The number 1 is the only element in both lists, and it should appear only once in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the result is unique and sorted. It should handle edge cases such as empty lists and large inputs gracefully.\nrequirement pool:\n- Implement the main function to find common elements.\n- Ensure the function returns results in sorted order.\n- Handle edge cases like empty lists.\n- Optimize for performance with large lists.\n- Provide comprehensive documentation and examples.\nWe will use Python's built-in set operations to efficiently find common elements between two lists. This approach is fast and handles large lists well. After finding the intersection, we will convert the result to a sorted list to meet the requirement of returning results in sorted order. This method is optimal for performance and usability, as indicated in the competitive quadrant chart.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: The requirement specifies that the elements returned should be unique, meaning no duplicates should be present in the result.\n\n    'sorted order'\n    Explanation: The elements that appear in both lists should be returned in ascending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow for efficient intersection operations.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the intersection set back to a list.\n    4. Sort the list to ensure the elements are in ascending order.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements, resulting in an empty list.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list, resulting in an empty list.\n    \n    common([1, 1, 2, 2], [2, 2, 3, 3]) = [2]\n    Explanation: The number 2 is the only element that appears in both lists, and duplicates are removed, resulting in a list with a single element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find unique common elements between two lists and return them sorted. It should handle various data types and list sizes, ensuring performance and reliability.\nrequirement pool:\n- Implement the main function to find common elements.\n- Optimize the function for large datasets.\n- Ensure the function handles edge cases, such as empty lists.\n- Provide comprehensive documentation and examples.\n- Include unit tests to verify functionality.\nWe will use Python's built-in set operations to efficiently find the unique common elements between two lists. This approach is both efficient and easy to understand, making it suitable for handling large datasets. The function will also sort the result to meet the requirement of returning elements in a predictable order. We will ensure the function handles edge cases, such as empty lists, gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: The requirement specifies that only distinct elements that appear in both lists should be considered.\n\n    'sorted order'\n    Explanation: The result should be returned in ascending order, ensuring predictability and consistency.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and find common elements.\n    2. Use set intersection to identify elements present in both sets.\n    3. Convert the resulting set back to a list.\n    4. Sort the list to ensure elements are in ascending order.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there can be no common elements.\n    \n    common([1, 1, 2, 2], [2, 2, 3, 3]) = [2]\n    Explanation: The number 2 is the only unique element that appears in both lists.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the output is unique and sorted. It should handle edge cases such as empty lists and large datasets without compromising performance.\nrequirement pool:\n- Implement the main function to find common elements\n- Ensure the output is sorted and contains unique elements\n- Optimize the function for large datasets\n- Handle edge cases like empty lists\n- Provide clear documentation and examples\nWe will implement a function that utilizes Python's set data structure to efficiently find common elements between two lists. The set data structure is chosen for its average O(1) time complexity for membership checks, which will help in optimizing performance for large datasets. The function will ensure that the output is unique and sorted by converting the result to a list and using Python's built-in sorted function.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'unique elements'\n    Explanation: The requirement specifies that the elements appearing in both lists should be unique, meaning duplicates should be removed from the result.\n\n    'sorted order'\n    Explanation: The result should be returned in ascending order, ensuring that the elements are sorted.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and find common elements.\n    2. Use set intersection to find elements that appear in both sets.\n    3. Convert the resulting set back to a list.\n    4. Sort the list using Python's built-in sorted function.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements, resulting in an empty list.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list, resulting in an empty list.\n    \n    common([1, 1, 2, 2], [2, 2, 3, 3]) = [2]\n    Explanation: The number 2 is the only element that appears in both lists, and duplicates are removed, resulting in a list with a single element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "completion": "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Find the unique elements that appear in both lists, and ensure they are returned in a sorted order.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n\n    Returns:\n        list: A sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find elements that appear in both sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the resulting set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list\n    return sorted_common_elements\n\n# Example usage:\n# result = common([1, 1, 2, 2], [2, 2, 3, 3])\n# print(result)  # Output: [2]\n", "passed": true, "pass": true, "pass_num": 10, "round": 722, "mutate_method": "rephrase_one", "parent_index": 385}
