{"task_id": "HumanEval/58", "prompt": "def common(l1: list, l2: list):\t\n'''Return sorted unique common elements for two lists. Ensure that the solution efficiently handles large inputs by optimizing both time and space complexity.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''", "entry_point": "common", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "test": ["def check(common):\n\tassert common([6, 5, 7, 10], [8, 4]) == []", "def check(common):\n\tassert common([6, 3, 2, 37, 657, 2, 6], [5, 9, 1, 6, 4, 654, 125]) == [6]", "def check(common):\n\tassert common([1, 6, 5, 9], [1, 6, 1]) == [1, 6]", "def check(common):\n\tassert common([8, 7, 6, 13], [7, 2]) == [7]", "def check(common):\n\tassert common([1, 1, 3, 11], [5, 3, 2]) == [3]", "def check(common):\n\tassert common([7, 8, 6, 11], [4, 5, 9]) == []", "def check(common):\n\tassert common([1, 6, 5, 34, 651, 3, 3], [7, 8, 1, 7, 9, 653, 121]) == [1]", "def check(common):\n\tassert common([6, 6, 4, 12], [3, 1]) == []", "def check(common):\n\tassert common([6, 1, 5, 36, 648, 1, 6], [3, 4, 2, 1, 12, 654, 123]) == [1]", "def check(common):\n\tassert common([6, 3, 7, 6], [3, 5, 7]) == [3, 7]", "def check(common):\n\tassert common([4, 8, 2, 9], [3, 1]) == []", "def check(common):\n\tassert common([3, 5, 5, 8], [7, 6]) == []", "def check(common):\n\tassert common([1, 8, 3, 4], [8, 7, 6]) == [8]", "def check(common):\n\tassert common([5, 2, 6, 30, 650, 7, 3], [7, 10, 2, 4, 4, 651, 126]) == [2, 7]", "def check(common):\n\tassert common([4, 6, 6, 7], [8, 6, 9]) == [6]", "def check(common):\n\tassert common([3, 7, 6, 3], [2, 4, 5]) == []", "def check(common):\n\tassert common([7, 4, 3, 10], [3, 1]) == [3]", "def check(common):\n\tassert common([3, 3, 1, 4], [4, 6, 4]) == [4]", "def check(common):\n\tassert common([4, 5, 2, 5], [1, 7, 5]) == [5]", "def check(common):\n\tassert common([5, 3, 4, 35, 652, 1, 1], [9, 6, 2, 8, 6, 653, 122]) == []", "def check(common):\n\tassert common([3, 1, 6, 11], [6, 6]) == [6]", "def check(common):\n\tassert common([7, 4, 7, 13], [8, 4]) == [4]", "def check(common):\n\tassert common([4, 4, 4, 34, 652, 5, 10], [8, 2, 1, 4, 5, 652, 117]) == [4, 5, 652]", "def check(common):\n\tassert common([2, 8, 3, 29, 650, 1, 7], [3, 6, 2, 3, 7, 652, 116]) == [2, 3, 7]", "def check(common):\n\tassert common([5, 8, 7, 3], [6, 4]) == []", "def check(common):\n\tassert common([2, 2, 1, 29, 650, 4, 2], [3, 10, 6, 2, 11, 651, 119]) == [2]", "def check(common):\n\tassert common([3, 3, 2, 30, 656, 3, 4], [6, 11, 2, 4, 4, 652, 123]) == [2, 4]", "def check(common):\n\tassert common([6, 1, 4, 33, 651, 4, 3], [4, 10, 1, 10, 12, 657, 126]) == [1, 4]", "def check(common):\n\tassert common([6, 6, 4, 5], [3, 3, 8]) == []", "def check(common):\n\tassert common([5, 5, 4, 34, 648, 5, 5], [3, 7, 6, 2, 10, 648, 116]) == [648]", "def check(common):\n\tassert common([2, 1, 7, 9], [6, 3]) == []", "def check(common):\n\tassert common([4, 1, 4, 12], [5, 1, 7]) == [1]", "def check(common):\n\tassert common([7, 6, 3, 9], [6, 5]) == [6]", "def check(common):\n\tassert common([2, 3, 3, 9], [5, 2]) == [2]", "def check(common):\n\tassert common([1, 4, 1, 32, 657, 7, 6], [4, 10, 2, 2, 4, 650, 124]) == [4]", "def check(common):\n\tassert common([8, 3, 4, 10], [8, 7]) == [8]", "def check(common):\n\tassert common([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]", "def check(common):\n\tassert common([5, 2, 2, 30, 654, 5, 1], [3, 3, 2, 10, 6, 657, 126]) == [2]", "def check(common):\n\tassert common([2, 7, 4, 3], [8, 7, 5]) == [7]", "def check(common):\n\tassert common([4, 5, 7, 12], [7, 1]) == [7]", "def check(common):\n\tassert common([9, 3, 7, 4], [4, 2, 4]) == [4]", "def check(common):\n\tassert common([3, 1, 3, 10], [3, 3, 9]) == [3]", "def check(common):\n\tassert common([4, 4, 1, 37, 654, 7, 5], [3, 11, 2, 6, 9, 656, 120]) == []", "def check(common):\n\tassert common([2, 6, 2, 8], [5, 2]) == [2]", "def check(common):\n\tassert common([2, 4, 3, 12], [4, 5, 6]) == [4]", "def check(common):\n\tassert common([4, 4, 7, 8], [4, 4, 9]) == [4]", "def check(common):\n\tassert common([1, 6, 6, 12], [6, 2, 9]) == [6]", "def check(common):\n\tassert common([2, 7, 1, 4], [1, 2, 1]) == [1, 2]", "def check(common):\n\tassert common([2, 5, 6, 32, 649, 3, 9], [8, 6, 1, 4, 4, 658, 117]) == [6]", "def check(common):\n\tassert common([2, 1, 5, 37, 657, 7, 1], [4, 9, 3, 1, 12, 649, 122]) == [1]", "def check(common):\n\tassert common([5, 5, 7, 7], [5, 2]) == [5]", "def check(common):\n\tassert common([5, 3, 2, 8], [3, 2]) == [2, 3]", "def check(common):\n\tassert common([5, 4, 5, 32, 655, 6, 2], [2, 10, 4, 2, 14, 656, 117]) == [2, 4]", "def check(common):\n\tassert common([3, 4, 4, 8], [3, 3, 9]) == [3]", "def check(common):\n\tassert common([5, 2, 1, 3], [8, 3]) == [3]", "def check(common):\n\tassert common([3, 8, 3, 35, 651, 4, 2], [1, 12, 6, 10, 4, 654, 119]) == [4]", "def check(common):\n\tassert common([5, 6, 4, 8], [3, 7, 2]) == []", "def check(common):\n\tassert common([7, 7, 5, 11], [3, 4]) == []", "def check(common):\n\tassert common([4, 3, 2, 8], []) == []", "def check(common):\n\tassert common([7, 7, 7, 3], [2, 4]) == []", "def check(common):\n\tassert common([2, 9, 3, 36, 649, 6, 7], [10, 12, 4, 4, 14, 656, 116]) == []", "def check(common):\n\tassert common([3, 8, 6, 6], [4, 3, 3]) == [3]", "def check(common):\n\tassert common([1, 8, 7, 3], [2, 6]) == []", "def check(common):\n\tassert common([1, 4, 5, 11], [1, 6, 1]) == [1]", "def check(common):\n\tassert common([6, 2, 3, 8], [7, 6, 8]) == [6, 8]", "def check(common):\n\tassert common([1, 7, 4, 30, 653, 1, 1], [6, 9, 2, 2, 13, 650, 120]) == []", "def check(common):\n\tassert common([6, 8, 4, 32, 657, 7, 6], [4, 10, 1, 5, 14, 652, 120]) == [4]", "def check(common):\n\tassert common([2, 7, 7, 32, 650, 5, 6], [7, 2, 4, 3, 13, 654, 117]) == [2, 7]", "def check(common):\n\tassert common([1, 4, 7, 30, 658, 3, 10], [6, 7, 3, 10, 10, 658, 117]) == [3, 7, 10, 658]", "def check(common):\n\tassert common([8, 4, 1, 9], [6, 3]) == []", "def check(common):\n\tassert common([2, 1, 4, 37, 657, 3, 7], [8, 5, 5, 10, 7, 654, 121]) == [7]", "def check(common):\n\tassert common([9, 7, 7, 7], [5, 2]) == []", "def check(common):\n\tassert common([4, 6, 3, 31, 648, 7, 10], [1, 10, 4, 7, 7, 653, 117]) == [4, 7, 10]", "def check(common):\n\tassert common([6, 5, 2, 3], [3, 3, 3]) == [3]", "def check(common):\n\tassert common([4, 4, 1, 8], [1, 5, 7]) == [1]", "def check(common):\n\tassert common([8, 4, 6, 5], [1, 1]) == []", "def check(common):\n\tassert common([4, 5, 3, 10], [7, 5]) == [5]", "def check(common):\n\tassert common([7, 1, 7, 13], [3, 1]) == [1]", "def check(common):\n\tassert common([1, 5, 5, 29, 655, 4, 1], [5, 3, 2, 1, 5, 648, 118]) == [1, 5]", "def check(common):\n\tassert common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]", "def check(common):\n\tassert common([7, 7, 1, 4], [5, 6]) == []", "def check(common):\n\tassert common([5, 4, 2, 36, 648, 7, 10], [6, 8, 1, 5, 11, 649, 126]) == [5]", "def check(common):\n\tassert common([8, 1, 1, 3], [5, 6]) == []", "def check(common):\n\tassert common([6, 3, 6, 3], [8, 5, 8]) == []", "def check(common):\n\tassert common([6, 8, 7, 32, 654, 7, 3], [7, 7, 2, 5, 10, 654, 123]) == [7, 654]", "def check(common):\n\tassert common([2, 2, 6, 11], [5, 6, 1]) == [6]", "def check(common):\n\tassert common([1, 4, 6, 39, 653, 4, 3], [6, 12, 2, 3, 14, 654, 116]) == [3, 6]", "def check(common):\n\tassert common([1, 3, 4, 9], [7, 3]) == [3]", "def check(common):\n\tassert common([9, 6, 6, 7], [7, 7, 1]) == [7]", "def check(common):\n\tassert common([5, 6, 2, 34, 654, 3, 7], [7, 9, 1, 7, 8, 650, 122]) == [7]", "def check(common):\n\tassert common([8, 2, 7, 4], [7, 7, 1]) == [7]", "def check(common):\n\tassert common([3, 2, 1, 37, 654, 7, 6], [2, 3, 2, 6, 4, 649, 123]) == [2, 3, 6]", "def check(common):\n\tassert common([9, 2, 7, 4], [5, 4, 1]) == [4]", "def check(common):\n\tassert common([8, 1, 4, 10], [4, 2]) == [4]", "def check(common):\n\tassert common([2, 8, 5, 10], [8, 4]) == [8]", "def check(common):\n\tassert common([8, 4, 4, 6], [3, 6]) == [6]", "def check(common):\n\tassert common([3, 6, 6, 7], [7, 4, 2]) == [7]", "def check(common):\n\tassert common([3, 4, 3, 11], [4, 1, 7]) == [4]", "def check(common):\n\tassert common([3, 1, 4, 5], [1, 1]) == [1]", "def check(common):\n\tassert common([3, 2, 5, 37, 652, 2, 3], [5, 4, 6, 7, 9, 651, 120]) == [5]"], "test_case_list": ["assert common([6, 5, 7, 10], [8, 4]) == []", "assert common([6, 3, 2, 37, 657, 2, 6], [5, 9, 1, 6, 4, 654, 125]) == [6]", "assert common([1, 6, 5, 9], [1, 6, 1]) == [1, 6]", "assert common([8, 7, 6, 13], [7, 2]) == [7]", "assert common([1, 1, 3, 11], [5, 3, 2]) == [3]", "assert common([7, 8, 6, 11], [4, 5, 9]) == []", "assert common([1, 6, 5, 34, 651, 3, 3], [7, 8, 1, 7, 9, 653, 121]) == [1]", "assert common([6, 6, 4, 12], [3, 1]) == []", "assert common([6, 1, 5, 36, 648, 1, 6], [3, 4, 2, 1, 12, 654, 123]) == [1]", "assert common([6, 3, 7, 6], [3, 5, 7]) == [3, 7]", "assert common([4, 8, 2, 9], [3, 1]) == []", "assert common([3, 5, 5, 8], [7, 6]) == []", "assert common([1, 8, 3, 4], [8, 7, 6]) == [8]", "assert common([5, 2, 6, 30, 650, 7, 3], [7, 10, 2, 4, 4, 651, 126]) == [2, 7]", "assert common([4, 6, 6, 7], [8, 6, 9]) == [6]", "assert common([3, 7, 6, 3], [2, 4, 5]) == []", "assert common([7, 4, 3, 10], [3, 1]) == [3]", "assert common([3, 3, 1, 4], [4, 6, 4]) == [4]", "assert common([4, 5, 2, 5], [1, 7, 5]) == [5]", "assert common([5, 3, 4, 35, 652, 1, 1], [9, 6, 2, 8, 6, 653, 122]) == []", "assert common([3, 1, 6, 11], [6, 6]) == [6]", "assert common([7, 4, 7, 13], [8, 4]) == [4]", "assert common([4, 4, 4, 34, 652, 5, 10], [8, 2, 1, 4, 5, 652, 117]) == [4, 5, 652]", "assert common([2, 8, 3, 29, 650, 1, 7], [3, 6, 2, 3, 7, 652, 116]) == [2, 3, 7]", "assert common([5, 8, 7, 3], [6, 4]) == []", "assert common([2, 2, 1, 29, 650, 4, 2], [3, 10, 6, 2, 11, 651, 119]) == [2]", "assert common([3, 3, 2, 30, 656, 3, 4], [6, 11, 2, 4, 4, 652, 123]) == [2, 4]", "assert common([6, 1, 4, 33, 651, 4, 3], [4, 10, 1, 10, 12, 657, 126]) == [1, 4]", "assert common([6, 6, 4, 5], [3, 3, 8]) == []", "assert common([5, 5, 4, 34, 648, 5, 5], [3, 7, 6, 2, 10, 648, 116]) == [648]", "assert common([2, 1, 7, 9], [6, 3]) == []", "assert common([4, 1, 4, 12], [5, 1, 7]) == [1]", "assert common([7, 6, 3, 9], [6, 5]) == [6]", "assert common([2, 3, 3, 9], [5, 2]) == [2]", "assert common([1, 4, 1, 32, 657, 7, 6], [4, 10, 2, 2, 4, 650, 124]) == [4]", "assert common([8, 3, 4, 10], [8, 7]) == [8]", "assert common([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]", "assert common([5, 2, 2, 30, 654, 5, 1], [3, 3, 2, 10, 6, 657, 126]) == [2]", "assert common([2, 7, 4, 3], [8, 7, 5]) == [7]", "assert common([4, 5, 7, 12], [7, 1]) == [7]", "assert common([9, 3, 7, 4], [4, 2, 4]) == [4]", "assert common([3, 1, 3, 10], [3, 3, 9]) == [3]", "assert common([4, 4, 1, 37, 654, 7, 5], [3, 11, 2, 6, 9, 656, 120]) == []", "assert common([2, 6, 2, 8], [5, 2]) == [2]", "assert common([2, 4, 3, 12], [4, 5, 6]) == [4]", "assert common([4, 4, 7, 8], [4, 4, 9]) == [4]", "assert common([1, 6, 6, 12], [6, 2, 9]) == [6]", "assert common([2, 7, 1, 4], [1, 2, 1]) == [1, 2]", "assert common([2, 5, 6, 32, 649, 3, 9], [8, 6, 1, 4, 4, 658, 117]) == [6]", "assert common([2, 1, 5, 37, 657, 7, 1], [4, 9, 3, 1, 12, 649, 122]) == [1]", "assert common([5, 5, 7, 7], [5, 2]) == [5]", "assert common([5, 3, 2, 8], [3, 2]) == [2, 3]", "assert common([5, 4, 5, 32, 655, 6, 2], [2, 10, 4, 2, 14, 656, 117]) == [2, 4]", "assert common([3, 4, 4, 8], [3, 3, 9]) == [3]", "assert common([5, 2, 1, 3], [8, 3]) == [3]", "assert common([3, 8, 3, 35, 651, 4, 2], [1, 12, 6, 10, 4, 654, 119]) == [4]", "assert common([5, 6, 4, 8], [3, 7, 2]) == []", "assert common([7, 7, 5, 11], [3, 4]) == []", "assert common([4, 3, 2, 8], []) == []", "assert common([7, 7, 7, 3], [2, 4]) == []", "assert common([2, 9, 3, 36, 649, 6, 7], [10, 12, 4, 4, 14, 656, 116]) == []", "assert common([3, 8, 6, 6], [4, 3, 3]) == [3]", "assert common([1, 8, 7, 3], [2, 6]) == []", "assert common([1, 4, 5, 11], [1, 6, 1]) == [1]", "assert common([6, 2, 3, 8], [7, 6, 8]) == [6, 8]", "assert common([1, 7, 4, 30, 653, 1, 1], [6, 9, 2, 2, 13, 650, 120]) == []", "assert common([6, 8, 4, 32, 657, 7, 6], [4, 10, 1, 5, 14, 652, 120]) == [4]", "assert common([2, 7, 7, 32, 650, 5, 6], [7, 2, 4, 3, 13, 654, 117]) == [2, 7]", "assert common([1, 4, 7, 30, 658, 3, 10], [6, 7, 3, 10, 10, 658, 117]) == [3, 7, 10, 658]", "assert common([8, 4, 1, 9], [6, 3]) == []", "assert common([2, 1, 4, 37, 657, 3, 7], [8, 5, 5, 10, 7, 654, 121]) == [7]", "assert common([9, 7, 7, 7], [5, 2]) == []", "assert common([4, 6, 3, 31, 648, 7, 10], [1, 10, 4, 7, 7, 653, 117]) == [4, 7, 10]", "assert common([6, 5, 2, 3], [3, 3, 3]) == [3]", "assert common([4, 4, 1, 8], [1, 5, 7]) == [1]", "assert common([8, 4, 6, 5], [1, 1]) == []", "assert common([4, 5, 3, 10], [7, 5]) == [5]", "assert common([7, 1, 7, 13], [3, 1]) == [1]", "assert common([1, 5, 5, 29, 655, 4, 1], [5, 3, 2, 1, 5, 648, 118]) == [1, 5]", "assert common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]", "assert common([7, 7, 1, 4], [5, 6]) == []", "assert common([5, 4, 2, 36, 648, 7, 10], [6, 8, 1, 5, 11, 649, 126]) == [5]", "assert common([8, 1, 1, 3], [5, 6]) == []", "assert common([6, 3, 6, 3], [8, 5, 8]) == []", "assert common([6, 8, 7, 32, 654, 7, 3], [7, 7, 2, 5, 10, 654, 123]) == [7, 654]", "assert common([2, 2, 6, 11], [5, 6, 1]) == [6]", "assert common([1, 4, 6, 39, 653, 4, 3], [6, 12, 2, 3, 14, 654, 116]) == [3, 6]", "assert common([1, 3, 4, 9], [7, 3]) == [3]", "assert common([9, 6, 6, 7], [7, 7, 1]) == [7]", "assert common([5, 6, 2, 34, 654, 3, 7], [7, 9, 1, 7, 8, 650, 122]) == [7]", "assert common([8, 2, 7, 4], [7, 7, 1]) == [7]", "assert common([3, 2, 1, 37, 654, 7, 6], [2, 3, 2, 6, 4, 649, 123]) == [2, 3, 6]", "assert common([9, 2, 7, 4], [5, 4, 1]) == [4]", "assert common([8, 1, 4, 10], [4, 2]) == [4]", "assert common([2, 8, 5, 10], [8, 4]) == [8]", "assert common([8, 4, 4, 6], [3, 6]) == [6]", "assert common([3, 6, 6, 7], [7, 4, 2]) == [7]", "assert common([3, 4, 3, 11], [4, 1, 7]) == [4]", "assert common([3, 1, 4, 5], [1, 1]) == [1]", "assert common([3, 2, 5, 37, 652, 2, 3], [5, 4, 6, 7, 9, 651, 120]) == [5]"], "nl": "Return sorted unique common elements for two lists.\n    ", "func": "def common(l1: list, l2: list):", "examples": ">>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    ", "repair_prompt": ["def common(l1: list, l2: list):\t\n'''Return sorted unique common elements for two lists. Ensure that the solution efficiently handles large inputs by optimizing both time and space complexity.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''", "def common(l1: list, l2: list):\t\n'''Return sorted unique common elements for two lists. Make sure to remove any duplicates and only include each element once. Ensure that the solution efficiently handles large inputs by optimizing both time and space complexity.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''", "def common(l1: list, l2: list):\t\n'''Return sorted unique common elements for two lists while ensuring that the solution efficiently handles large inputs by optimizing both time and space complexity.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n\n    Returns:\n    list: Sorted list of unique common elements.\n\n    Example:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list\n    common_elements = list(intersection)\n    \n    # Sort the list of common elements\n    common_elements.sort()\n    \n    # Return the sorted list\n    return common_elements\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    Args:\n        l1: First list of elements.\n        l2: Second list of elements.\n    \n    Returns:\n        Sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and allow efficient membership checking\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_common_elements = sorted(intersection)\n    \n    # Return the sorted list of unique common elements\n    return sorted_common_elements\n\n# Example usage:\n# print(common([1, 2, 3, 4], [3, 4, 5, 6]))  # Output: [3, 4]\n# print(common([1, 1, 1], [1, 1]))          # Output: [1]\n# print(common([], []))                     # Output: []\n# print(common([1, 2, 3], []))              # Output: []\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Finds the sorted list of unique elements that are common to both input lists.\n\n    Args:\n        l1: List of elements (can be of any hashable type).\n        l2: List of elements (can be of any hashable type).\n\n    Returns:\n        A sorted list of unique elements that are common to both l1 and l2.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient membership checking\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the resulting set of common elements back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list of unique common elements\n    return sorted_common_elements\n\n# Example usage:\n# print(common([1, 2, 3, 4], [3, 4, 5, 6]))  # Output: [3, 4]\n# print(common([1, 1, 1], [1, 1]))          # Output: [1]\n# print(common([], []))                     # Output: []\n# print(common([1, 2, 3], []))              # Output: []\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Finds the sorted list of unique integers that are common to both input lists.\n\n    Args:\n        l1 (list): The first list of integers.\n        l2 (list): The second list of integers.\n\n    Returns:\n        list: A sorted list of unique integers that are common to both l1 and l2.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient membership checks\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list\n    return sorted_common_elements\n\n# Example usage:\n# print(common([1, 2, 3, 4], [3, 4, 5, 6]))  # Output: [3, 4]\n# print(common([1, 1, 1], [1, 1]))          # Output: [1]\n# print(common([], []))                     # Output: []\n# print(common([1, 2, 3], []))              # Output: []\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Finds the sorted list of unique integers that are common to both input lists.\n\n    Args:\n        l1 (list): The first list of integers.\n        l2 (list): The second list of integers.\n\n    Returns:\n        list: A sorted list of unique integers that are common to both input lists.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list of common elements\n    return sorted_common_elements\n\n# Example usage:\n# print(common([1, 1, 2, 2], [2, 2, 3, 3]))  # Output: [2]\n# print(common([], []))  # Output: []\n# print(common([1, 2, 3], []))  # Output: []\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Finds the sorted list of unique integers that are common to both input lists.\n\n    Args:\n        l1 (list): The first list of integers.\n        l2 (list): The second list of integers.\n\n    Returns:\n        list: A sorted list of unique integers that are common to both l1 and l2.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the resulting set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list\n    return sorted_common_elements\n\n# Example usage:\n# result = common([1, 2, 3, 4], [3, 4, 5, 6])\n# print(result)  # Output: [3, 4]\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"Finds and returns a sorted list of unique integers that are common to both input lists.\n\n    Args:\n        l1 (list): The first list of integers.\n        l2 (list): The second list of integers.\n\n    Returns:\n        list: A sorted list of unique integers that are common to both l1 and l2.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow efficient membership checking\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list of unique common elements\n    return sorted_common_elements\n\n# Example usage:\n# result = common([1, 2, 3, 4], [3, 4, 5, 6])\n# print(result)  # Output: [3, 4]\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"Finds and returns a sorted list of unique integers that are common to both input lists.\n\n    Args:\n        l1 (list): The first list of integers.\n        l2 (list): The second list of integers.\n\n    Returns:\n        list: A sorted list of unique integers that are common to both l1 and l2.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the resulting set of common elements back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list of common elements\n    return sorted_common_elements\n\n# Example usage:\n# print(common([1, 2, 3, 4], [3, 4, 5, 6]))  # Output: [3, 4]\n# print(common([1, 1, 1], [1, 1]))          # Output: [1]\n# print(common([], []))                     # Output: []\n# print(common([1, 2, 3], []))              # Output: []\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"Finds common elements between two lists, returns them sorted and unique.\n\n    Args:\n        l1 (list): The first list of integers.\n        l2 (list): The second list of integers.\n\n    Returns:\n        list: A sorted list of unique integers that are common to both l1 and l2.\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and allow efficient membership checking\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list of unique common elements\n    return sorted_common_elements\n\n# Example usage:\n# result = common([1, 2, 3, 4], [3, 4, 5, 6])\n# print(result)  # Output: [3, 4]\n", "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1: First list of elements.\n        l2: Second list of elements.\n\n    Returns:\n        A sorted list of unique common elements between l1 and l2.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow efficient intersection operation\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list of common elements\n    return sorted_common_elements\n"], "plans": ["requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the result is sorted and unique. It should handle large inputs by optimizing both time and space complexity.\nrequirement pool:\n- Efficiently find common elements between two lists\n- Ensure the result is sorted and unique\n- Optimize for large input sizes\n- Minimize memory usage\n- Provide clear documentation and examples\nWe will use Python's built-in set operations to efficiently find common elements between two lists. Sets provide fast membership testing and intersection operations, which are ideal for this task. After finding the intersection, we will convert the result to a sorted list to meet the requirement of sorted unique common elements. This approach is both time and space efficient, especially for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, ensure they are unique, and return them in sorted order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow efficient intersection operations.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the intersection set back to a list.\n    4. Sort the list of common elements.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements.\n    \n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: The element '1' is common in both lists, but should only appear once in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring that the solution is both time and space efficient. The output should be sorted and contain unique elements only. The implementation should be straightforward to facilitate future maintenance and enhancements.\nrequirement pool:\n- Efficiently handle large inputs\n- Return sorted unique common elements\n- Optimize both time and space complexity\n- Ensure code readability\n- Provide comprehensive test cases\nWe will use Python's built-in set data structure to efficiently find common elements between two lists. Sets provide average time complexity of O(1) for membership checks and are ideal for handling large datasets. The solution will convert both lists to sets, find their intersection, and then return the sorted list of unique elements. This approach optimizes both time and space complexity while ensuring code readability and maintainability.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, ensure they are unique, and return them in sorted order.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for time and space complexity, particularly for large datasets.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to eliminate duplicates and allow efficient membership checking.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the intersection set back to a list and sort it.\n    4. Return the sorted list of unique common elements.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements.\n    \n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: Both lists contain only the number 1, which is common and should be returned as a unique element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of sets inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the output is sorted and unique. It must handle large inputs with optimized time and space complexity.\nrequirement pool:\n- Efficiently find common elements between two lists\n- Ensure output is sorted and unique\n- Optimize for large input datasets\n- Provide a simple and intuitive interface\n- Include error handling for invalid inputs\nWe will use Python's built-in set data structure to efficiently find common elements between two lists. Sets provide average time complexity of O(1) for membership checks, which makes them suitable for handling large datasets. The solution will convert both lists to sets, find their intersection, and then return the sorted list of unique common elements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, remove duplicates, and return them in sorted order.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for both time and space complexity, meaning it should work well even with large datasets.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both input lists to sets to remove duplicates and allow for efficient membership checking.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the resulting set of common elements back to a list.\n    4. Sort the list of common elements.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n\n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements.\n\n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: The number 1 is the only common element, and duplicates are removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of sets inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the results are unique and sorted. It must handle large inputs by optimizing both time and space complexity, which suggests using data structures like sets for quick lookups and avoiding unnecessary memory usage.\nrequirement pool:\n- Implement the main function to find common elements.\n- Ensure the results are unique and sorted.\n- Optimize the function for large input lists.\n- Minimize space complexity.\n- Provide comprehensive test cases.\nWe will use Python's built-in set data structure to efficiently find common elements between two lists. Sets provide O(1) average time complexity for membership checks, making them ideal for handling large inputs. After finding the intersection, we will convert the result to a sorted list to ensure the output is both unique and ordered.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, remove duplicates, and return them in a sorted order.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for both time and space complexity, meaning it should work well even with large lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow for efficient membership checks.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the intersection set back to a list.\n    4. Sort the list to ensure the elements are in ascending order.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list.\n    \n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: The number 1 is common in both lists, but duplicates should be removed, resulting in a single 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of sets inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the results are unique and sorted. It must handle large inputs with optimal time and space complexity.\nrequirement pool:\n- Implement the main function to find common elements\n- Ensure the results are unique and sorted\n- Optimize for large input sizes\n- Minimize time complexity\n- Minimize space complexity\nWe will use Python's built-in set operations to efficiently find common elements between two lists. Sets inherently handle uniqueness and provide fast intersection operations, which are optimal for large input sizes. After finding the intersection, we will convert the result to a sorted list to meet the requirement of sorted output.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, ensure they are unique (no duplicates), and return them in sorted order.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for time and space complexity, meaning it should work well even if the input lists are very large.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow for efficient intersection operations.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the intersection set back to a list.\n    4. Sort the list of common elements.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there can be no common elements with the first list.\n    \n    common([1, 1, 2, 2], [2, 2, 3, 3]) = [2]\n    Explanation: The only common element between the two lists is 2, and it should be returned as a unique element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the results are unique and sorted. It must handle large inputs by optimizing time and space complexity.\nrequirement pool:\n- Efficiently find common elements between two lists\n- Ensure results are unique and sorted\n- Optimize for large datasets\n- Provide a user-friendly interface\n- Ensure accurate and reliable results\nWe will use Python's built-in set data structure to efficiently find common elements between two lists. Sets inherently handle duplicates and allow for fast intersection operations, which will optimize both time and space complexity for large datasets. The sorted function will be used to ensure the results are returned in a sorted order.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, remove any duplicates, and return them in a sorted order.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for both time and space complexity, meaning it should work well even with large datasets.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'efficiently': The solution should be optimized to handle large inputs without excessive time or space usage.\n\n# [code logic]\n1. Convert both lists to sets to remove duplicates and allow for efficient intersection operations.\n2. Find the intersection of the two sets to get common elements.\n3. Convert the resulting set back to a list.\n4. Sort the list of common elements.\n5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list.\n    \n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: Both lists contain only the number 1, which is the only common element. Duplicates are removed.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of sets inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the results are sorted and unique. It must handle large inputs with optimized time and space complexity.\nrequirement pool:\n- Implement efficient algorithm for finding common elements\n- Ensure results are sorted and unique\n- Optimize for large input handling\n- Provide clear documentation and examples\n- Design a user-friendly interface\nWe will use Python's built-in set data structure to efficiently find common elements between two lists. Sets provide average time complexity of O(1) for membership checks, making them ideal for handling large datasets. We will convert both lists to sets, find their intersection, and then return the sorted list of unique common elements.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, remove duplicates, and return them in sorted order.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for time and space complexity, especially when dealing with large datasets.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow efficient membership checking.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the intersection set back to a list and sort it.\n    4. Return the sorted list of unique common elements.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements.\n    \n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: Both lists contain only the number 1, which is the common element. The result should be unique and sorted.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of sets inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the results are unique and sorted. It must handle large inputs by optimizing time and space complexity.\nrequirement pool:\n- Efficiently find common elements between two lists\n- Ensure results are unique and sorted\n- Optimize for large input sizes\n- Minimize time complexity\n- Minimize space complexity\nWe will use Python's built-in set operations to efficiently find common elements between two lists. Sets provide a fast way to perform intersection operations, which will help optimize both time and space complexity. The results will be converted to a sorted list to ensure they are unique and ordered.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, ensure they are unique, and return them in a sorted order.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for both time and space complexity, meaning it should work well even with large lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow for efficient intersection operations.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the resulting set of common elements back to a list.\n    4. Sort the list of common elements.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n\n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements.\n\n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: Both lists contain only the number 1, which is the only common element. The result is a unique list with one element.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set operations inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the results are sorted and unique. It must handle large inputs with optimized time and space complexity.\nrequirement pool:\n- Implement efficient algorithm for finding common elements\n- Ensure results are sorted and unique\n- Optimize for large datasets\n- Provide clear documentation and examples\n- Design a user-friendly interface\nWe will use Python's built-in set data structure to efficiently find common elements between two lists. Sets provide average time complexity of O(1) for membership checks, making them ideal for this task. We will convert both lists to sets, find their intersection, and then convert the result back to a sorted list to ensure the elements are unique and sorted. This approach optimizes both time and space complexity, especially for large datasets.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'common elements'\n    Explanation: The requirement is to find elements that appear in both lists.\n\n    'sorted unique'\n    Explanation: The result should be sorted in ascending order and contain no duplicate elements.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for time and space complexity, particularly for large datasets.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to eliminate duplicates and allow efficient membership checking.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the intersection set back to a list.\n    4. Sort the list to ensure the elements are in ascending order.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements.\n\n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements.\n\n    common([1, 1, 1], [1, 1]) = [1]\n    Explanation: Both lists contain only the number 1, which is common and should appear once in the result.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of sets inherently handles duplicates and empty lists efficiently.\n", "requirement analysis:\nThe function should efficiently find common elements between two lists, ensuring the results are unique and sorted. It must handle large inputs without compromising performance.\nrequirement pool:\n- Optimize for large input handling\n- Ensure efficient time and space complexity\n- Provide accurate and sorted results\n- Handle edge cases like empty lists\n- Include comprehensive test cases\nWe will use Python's built-in set data structure to efficiently find common elements between two lists. Sets are ideal for this task because they automatically handle uniqueness and provide efficient operations for intersection. After finding the intersection, we will convert the result back to a sorted list to meet the requirement of sorted output.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    'sorted unique common elements'\n    Explanation: The requirement is to find elements that appear in both lists, ensure they are unique, and return them in sorted order.\n\n    'efficiently handles large inputs'\n    Explanation: The solution should be optimized for both time and space complexity, meaning it should perform well even with large lists.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    1. Convert both lists to sets to remove duplicates and allow efficient intersection operation.\n    2. Find the intersection of the two sets to get common elements.\n    3. Convert the intersection set back to a list.\n    4. Sort the list of common elements.\n    5. Return the sorted list.\n\n# [edge case] \n    common([], []) = []\n    Explanation: Both lists are empty, so there are no common elements, resulting in an empty list.\n    \n    common([1, 2, 3], []) = []\n    Explanation: The second list is empty, so there are no common elements with the first list, resulting in an empty list.\n    \n    common([1, 2, 3], [4, 5, 6]) = []\n    Explanation: There are no overlapping elements between the two lists, so the result is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The use of set intersection naturally handles these scenarios by returning an empty set when there are no common elements.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "completion": "from typing import List\n## main.py\n\ndef common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n        l1: First list of elements.\n        l2: Second list of elements.\n\n    Returns:\n        A sorted list of unique common elements between l1 and l2.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow efficient intersection operation\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    sorted_common_elements = sorted(common_elements)\n    \n    # Return the sorted list of common elements\n    return sorted_common_elements\n", "passed": true, "pass": true, "pass_num": 10, "round": 866, "mutate_method": "add_1_sentence_at_end", "parent_index": 385}
