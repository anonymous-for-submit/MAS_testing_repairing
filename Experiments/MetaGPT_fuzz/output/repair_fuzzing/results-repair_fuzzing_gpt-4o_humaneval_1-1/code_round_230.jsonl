{"task_id": "HumanEval/87", "prompt": "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. Ensure to handle cases where x is not found in the list, returning an empty list in such scenarios.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": ["def check(get_row):\n\tassert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "def check(get_row):\n\tassert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "def check(get_row):\n\tassert get_row([], 5) == []", "def check(get_row):\n\tassert get_row([[2]], 5) == []", "def check(get_row):\n\tassert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "def check(get_row):\n\tassert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "def check(get_row):\n\tassert get_row([[2]], 3) == []", "def check(get_row):\n\tassert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "def check(get_row):\n\tassert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "def check(get_row):\n\tassert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "def check(get_row):\n\tassert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "def check(get_row):\n\tassert get_row([], 6) == []", "def check(get_row):\n\tassert get_row([], 1) == []", "def check(get_row):\n\tassert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "def check(get_row):\n\tassert get_row([[2]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "def check(get_row):\n\tassert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "def check(get_row):\n\tassert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "def check(get_row):\n\tassert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "def check(get_row):\n\tassert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "def check(get_row):\n\tassert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "def check(get_row):\n\tassert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "def check(get_row):\n\tassert get_row([[5]], 6) == []", "def check(get_row):\n\tassert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "def check(get_row):\n\tassert get_row([[4]], 4) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[4]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 3) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "def check(get_row):\n\tassert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "def check(get_row):\n\tassert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "def check(get_row):\n\tassert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "def check(get_row):\n\tassert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "def check(get_row):\n\tassert get_row([], 2) == []", "def check(get_row):\n\tassert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "def check(get_row):\n\tassert get_row([[1]], 3) == []", "def check(get_row):\n\tassert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "def check(get_row):\n\tassert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "def check(get_row):\n\tassert get_row([[2]], 7) == []", "def check(get_row):\n\tassert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "def check(get_row):\n\tassert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "def check(get_row):\n\tassert get_row([[1]], 2) == []", "def check(get_row):\n\tassert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "def check(get_row):\n\tassert get_row([], 4) == []", "def check(get_row):\n\tassert get_row([[1]], 6) == []", "def check(get_row):\n\tassert get_row([[6]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "def check(get_row):\n\tassert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "def check(get_row):\n\tassert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "def check(get_row):\n\tassert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "def check(get_row):\n\tassert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "def check(get_row):\n\tassert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "def check(get_row):\n\tassert get_row([[5]], 7) == []", "def check(get_row):\n\tassert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "def check(get_row):\n\tassert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "def check(get_row):\n\tassert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "def check(get_row):\n\tassert get_row([], 3) == []", "def check(get_row):\n\tassert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "def check(get_row):\n\tassert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "def check(get_row):\n\tassert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "def check(get_row):\n\tassert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "def check(get_row):\n\tassert get_row([[1]], 4) == []", "def check(get_row):\n\tassert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "def check(get_row):\n\tassert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "def check(get_row):\n\tassert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "def check(get_row):\n\tassert get_row([[6]], 5) == []", "def check(get_row):\n\tassert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "def check(get_row):\n\tassert get_row([[6]], 3) == []", "def check(get_row):\n\tassert get_row([[3]], 6) == []", "def check(get_row):\n\tassert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "def check(get_row):\n\tassert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "test_case_list": ["assert get_row([[2, 5, 3, 1, 6, 8], [6, 3, 5, 3, 8, 8], [2, 1, 3, 4, 3, 11], [1, 5, 4, 8, 10, 10], [1, 1, 6, 3, 10, 8], [6, 1, 5, 4, 7, 5]], 3) == [(0, 2), (1, 3), (1, 1), (2, 4), (2, 2), (4, 3)]", "assert get_row([[1, 2, 4, 8, 6, 8], [3, 4, 5, 1, 3, 9], [3, 4, 7, 8, 10, 4], [6, 3, 5, 1, 8, 2], [5, 5, 5, 3, 10, 10], [3, 6, 1, 7, 5, 3], [1, 2, 8, 4, 1, 5]], 2) == [(0, 1), (3, 5), (6, 1)]", "assert get_row([[6, 7, 4, 8, 7, 3], [5, 5, 6, 9, 5, 9], [1, 1, 8, 5, 6, 3]], 4) == [(0, 2)]", "assert get_row([[6, 5, 8, 8, 3, 6], [1, 3, 2, 4, 5, 8], [4, 2, 2, 2, 5, 1]], 4) == [(1, 3), (2, 0)]", "assert get_row([[5, 4, 3, 2, 5, 3], [4, 7, 4, 1, 1, 10], [3, 7, 3, 5, 6, 6]], 5) == [(0, 4), (0, 0), (2, 3)]", "assert get_row([[3, 5, 3, 7, 8, 8], [6, 3, 3, 7, 4, 4], [5, 4, 7, 3, 10, 1], [6, 3, 5, 7, 10, 8], [1, 3, 5, 6, 8, 9], [5, 2, 6, 7, 2, 4], [5, 7, 5, 9, 7, 2]], 5) == [(0, 1), (2, 0), (3, 2), (4, 2), (5, 0), (6, 2), (6, 0)]", "assert get_row([[3, 6, 5, 9, 7, 4], [4, 1, 5, 8, 6, 7], [1, 6, 4, 8, 6, 3], [3, 1, 5, 8, 3, 8], [2, 6, 1, 1, 1, 2], [2, 2, 1, 1, 3, 5], [6, 4, 1, 1, 9, 1]], 4) == [(0, 5), (1, 0), (2, 2), (6, 1)]", "assert get_row([], 5) == []", "assert get_row([[2]], 5) == []", "assert get_row([[1, 1, 5, 1, 10, 10], [4, 7, 8, 6, 4, 9], [4, 5, 3, 5, 9, 3], [3, 2, 6, 5, 9, 8], [5, 4, 3, 5, 10, 3], [4, 1, 7, 5, 3, 8], [4, 1, 3, 1, 8, 3]], 2) == [(3, 1)]", "assert get_row([[5, 7, 4, 8, 5, 10], [2, 6, 4, 5, 1, 10], [5, 1, 8, 5, 9, 5]], 5) == [(0, 4), (0, 0), (1, 3), (2, 5), (2, 3), (2, 0)]", "assert get_row([[2]], 3) == []", "assert get_row([[5, 7, 2, 6, 3, 2], [5, 7, 8, 4, 10, 6], [1, 4, 4, 8, 3, 1], [6, 3, 6, 3, 9, 11], [5, 1, 5, 4, 4, 11], [6, 4, 2, 2, 2, 7]], 2) == [(0, 5), (0, 2), (5, 4), (5, 3), (5, 2)]", "assert get_row([[4, 4, 4, 5, 2, 2], [4, 3, 1, 1, 4, 4], [3, 7, 7, 5, 4, 4]], 4) == [(0, 2), (0, 1), (0, 0), (1, 5), (1, 4), (1, 0), (2, 5), (2, 4)]", "assert get_row([[5, 1, 3, 8, 10, 5], [4, 7, 1, 8, 9, 4], [6, 2, 6, 4, 4, 1], [6, 2, 4, 5, 2, 7], [1, 5, 4, 4, 1, 10], [2, 2, 4, 1, 1, 4], [3, 4, 2, 6, 10, 1]], 5) == [(0, 5), (0, 0), (3, 3), (4, 1)]", "assert get_row([[5, 1, 6, 5, 8, 5], [4, 2, 2, 4, 9, 8], [6, 3, 7, 7, 4, 8], [1, 5, 8, 4, 10, 7], [3, 3, 6, 1, 6, 10], [2, 3, 3, 9, 9, 6]], 1) == [(0, 1), (3, 0), (4, 3)]", "assert get_row([[3, 7, 5, 5, 5, 3], [2, 1, 5, 1, 1, 4], [5, 2, 6, 7, 7, 1]], 6) == [(2, 2)]", "assert get_row([[2, 7, 1, 5, 3, 4], [6, 3, 3, 9, 8, 7], [1, 6, 2, 7, 7, 7], [3, 5, 6, 9, 1, 6], [6, 3, 7, 5, 5, 3], [2, 7, 3, 9, 5, 6], [6, 7, 3, 1, 1, 3]], 2) == [(0, 0), (2, 2), (5, 0)]", "assert get_row([[6, 5, 1, 9, 4, 3], [6, 4, 6, 8, 10, 5], [5, 1, 6, 4, 6, 10], [2, 7, 5, 3, 9, 10], [4, 1, 7, 3, 6, 4], [3, 1, 3, 1, 5, 1]], 4) == [(0, 4), (1, 1), (2, 3), (4, 5), (4, 0)]", "assert get_row([[5, 2, 6, 1, 10, 3], [5, 1, 3, 3, 3, 4], [1, 3, 4, 6, 1, 2], [4, 2, 3, 4, 8, 10], [5, 4, 7, 5, 10, 1], [5, 4, 1, 2, 1, 6], [1, 7, 4, 9, 6, 6]], 5) == [(0, 0), (1, 0), (4, 3), (4, 0), (5, 0)]", "assert get_row([[6, 5, 3, 2, 5, 9], [4, 3, 6, 6, 5, 1], [5, 3, 2, 7, 6, 2]], 4) == [(1, 0)]", "assert get_row([], 6) == []", "assert get_row([], 1) == []", "assert get_row([[2, 6, 5, 5, 5, 7], [5, 4, 6, 3, 2, 7], [3, 4, 4, 7, 2, 10], [1, 3, 7, 9, 6, 3], [5, 4, 6, 4, 1, 7], [2, 6, 8, 3, 2, 2]], 6) == [(0, 1), (1, 2), (3, 4), (4, 2), (5, 1)]", "assert get_row([[2]], 4) == []", "assert get_row([[1, 6, 7, 2, 4, 8], [5, 1, 4, 8, 4, 2], [4, 1, 8, 6, 9, 3], [2, 1, 5, 8, 5, 11], [3, 4, 6, 5, 4, 8], [2, 7, 4, 3, 4, 7], [6, 1, 8, 6, 10, 3]], 6) == [(0, 1), (2, 3), (4, 2), (6, 3), (6, 0)]", "assert get_row([[3, 5, 2, 6, 9, 5], [5, 3, 7, 7, 6, 8], [6, 3, 3, 2, 5, 6]], 1) == []", "assert get_row([[2, 1, 2, 2, 7, 6], [2, 5, 4, 9, 9, 6], [3, 1, 7, 6, 5, 10], [3, 4, 4, 2, 5, 4], [5, 4, 8, 1, 3, 10], [5, 5, 4, 6, 2, 6], [2, 5, 5, 3, 7, 1]], 1) == [(0, 1), (2, 1), (4, 3), (6, 5)]", "assert get_row([[1, 5, 2, 1, 8, 10], [2, 7, 3, 8, 1, 3], [2, 3, 5, 2, 9, 6]], 4) == []", "assert get_row([[1, 2, 2, 9, 5, 6], [2, 2, 6, 6, 2, 7], [2, 4, 1, 4, 9, 4], [3, 5, 2, 6, 5, 5], [5, 5, 4, 2, 4, 3], [1, 2, 4, 3, 5, 10], [3, 1, 4, 3, 5, 2]], 5) == [(0, 4), (3, 5), (3, 4), (3, 1), (4, 1), (4, 0), (5, 4), (6, 4)]", "assert get_row([[6, 5, 4, 6, 2, 3], [3, 3, 1, 7, 6, 1], [2, 3, 8, 3, 1, 3], [2, 3, 6, 9, 3, 8], [5, 3, 3, 1, 3, 9], [4, 5, 7, 1, 7, 10]], 4) == [(0, 2), (5, 0)]", "assert get_row([[5, 1, 8, 8, 10, 6], [6, 3, 6, 8, 7, 4], [2, 6, 3, 1, 5, 4], [2, 2, 3, 5, 10, 7], [1, 4, 8, 5, 4, 3], [5, 4, 3, 8, 2, 5]], 2) == [(2, 0), (3, 1), (3, 0), (5, 4)]", "assert get_row([[5]], 6) == []", "assert get_row([[2, 4, 7, 4, 2, 9], [2, 7, 5, 7, 10, 4], [4, 7, 6, 3, 5, 9], [4, 5, 7, 5, 2, 2], [6, 7, 7, 2, 2, 5], [5, 5, 4, 5, 5, 10]], 1) == []", "assert get_row([[4]], 4) == [(0, 0)]", "assert get_row([[4]], 3) == []", "assert get_row([[3]], 3) == [(0, 0)]", "assert get_row([[1, 2, 2, 3, 1, 3], [2, 7, 5, 6, 5, 3], [1, 7, 8, 4, 3, 4]], 5) == [(1, 4), (1, 2)]", "assert get_row([[3, 7, 1, 5, 5, 2], [4, 5, 1, 1, 4, 6], [3, 1, 5, 1, 7, 8], [5, 3, 6, 6, 10, 1], [3, 4, 4, 1, 2, 6], [2, 4, 3, 9, 6, 1], [1, 1, 2, 2, 7, 5]], 6) == [(1, 5), (3, 3), (3, 2), (4, 5), (5, 4)]", "assert get_row([[4, 7, 1, 8, 1, 1], [5, 3, 8, 9, 10, 6], [4, 6, 6, 1, 1, 1], [1, 4, 6, 3, 3, 11], [1, 3, 1, 3, 1, 10], [5, 7, 4, 9, 8, 3]], 7) == [(0, 1), (5, 1)]", "assert get_row([[6, 5, 2, 3, 2, 4], [3, 1, 8, 6, 8, 10], [4, 6, 5, 3, 8, 3], [6, 3, 1, 6, 1, 7], [4, 7, 6, 1, 4, 2], [2, 4, 2, 1, 1, 3]], 1) == [(1, 1), (3, 4), (3, 2), (4, 3), (5, 4), (5, 3)]", "assert get_row([[5, 6, 3, 8, 9, 11], [6, 3, 7, 7, 10, 2], [3, 4, 6, 3, 1, 5], [1, 7, 6, 1, 6, 3], [6, 4, 1, 2, 7, 4], [4, 5, 7, 7, 4, 2]], 1) == [(2, 4), (3, 3), (3, 0), (4, 2)]", "assert get_row([[6, 6, 1, 4, 5, 11], [2, 2, 1, 5, 7, 4], [4, 5, 3, 5, 10, 1], [6, 5, 2, 5, 1, 10], [5, 7, 6, 8, 2, 2], [4, 5, 7, 3, 2, 5]], 6) == [(0, 1), (0, 0), (3, 0), (4, 2)]", "assert get_row([[4, 4, 1, 8, 10, 5], [1, 2, 5, 7, 8, 10], [4, 1, 8, 6, 2, 2], [6, 2, 3, 6, 8, 4], [6, 1, 2, 3, 1, 11], [1, 1, 5, 1, 6, 9], [3, 1, 6, 6, 5, 3]], 2) == [(1, 1), (2, 5), (2, 4), (3, 1), (4, 2)]", "assert get_row([], 2) == []", "assert get_row([[4, 2, 7, 4, 10, 5], [5, 4, 8, 6, 6, 10], [6, 5, 3, 7, 4, 1]], 5) == [(0, 5), (1, 0), (2, 1)]", "assert get_row([[1]], 3) == []", "assert get_row([[4, 7, 5, 6, 6, 8], [2, 1, 7, 1, 8, 2], [1, 6, 6, 6, 10, 8], [6, 6, 3, 1, 1, 5], [3, 6, 6, 7, 2, 4], [6, 5, 4, 6, 10, 11]], 1) == [(1, 3), (1, 1), (2, 0), (3, 4), (3, 3)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]", "assert get_row([[5, 2, 7, 1, 5, 7], [3, 1, 1, 3, 6, 2], [2, 5, 4, 4, 7, 6], [2, 7, 1, 5, 6, 10], [4, 4, 7, 6, 9, 3], [1, 2, 6, 9, 3, 2], [2, 2, 5, 5, 6, 5]], 2) == [(0, 1), (1, 5), (2, 0), (3, 0), (5, 5), (5, 1), (6, 1), (6, 0)]", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]", "assert get_row([[4, 7, 4, 2, 8, 2], [3, 6, 4, 9, 4, 2], [5, 7, 4, 5, 1, 2]], 1) == [(2, 4)]", "assert get_row([[2, 4, 5, 8, 8, 9], [3, 1, 4, 8, 9, 10], [5, 3, 7, 6, 3, 7], [3, 7, 6, 3, 3, 10], [1, 5, 8, 6, 3, 2], [4, 2, 7, 6, 1, 11], [3, 2, 5, 1, 5, 6]], 2) == [(0, 0), (4, 5), (5, 1), (6, 1)]", "assert get_row([[2]], 7) == []", "assert get_row([[6, 5, 8, 1, 7, 11], [1, 1, 8, 9, 1, 1], [6, 7, 1, 7, 3, 3]], 2) == []", "assert get_row([[5, 7, 8, 4, 3, 7], [3, 6, 6, 1, 10, 6], [5, 6, 2, 8, 5, 2], [4, 1, 6, 7, 4, 8], [3, 3, 7, 1, 3, 6], [5, 3, 2, 8, 5, 8], [2, 4, 8, 5, 5, 6]], 6) == [(1, 5), (1, 2), (1, 1), (2, 1), (3, 2), (4, 5), (6, 5)]", "assert get_row([[6, 5, 5, 9, 7, 9], [6, 5, 2, 1, 8, 4], [6, 2, 2, 1, 5, 1], [2, 1, 3, 1, 10, 5], [3, 3, 1, 4, 6, 4], [6, 6, 7, 2, 5, 10], [6, 4, 4, 2, 9, 5]], 3) == [(3, 2), (4, 1), (4, 0)]", "assert get_row([[1]], 2) == []", "assert get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "assert get_row([], 4) == []", "assert get_row([[1]], 6) == []", "assert get_row([[6]], 4) == []", "assert get_row([[5, 4, 6, 1, 1, 2], [5, 1, 1, 3, 10, 2], [5, 4, 6, 3, 4, 8], [2, 4, 3, 8, 4, 1], [6, 3, 8, 5, 6, 7], [6, 5, 6, 5, 2, 8], [2, 7, 1, 9, 9, 5]], 2) == [(0, 5), (1, 5), (3, 0), (5, 4), (6, 0)]", "assert get_row([[5, 2, 2, 3, 2, 6], [4, 4, 1, 9, 1, 10], [1, 3, 8, 1, 10, 3], [1, 3, 1, 8, 5, 9], [4, 1, 1, 8, 5, 2], [3, 6, 2, 6, 5, 9]], 6) == [(0, 5), (5, 3), (5, 1)]", "assert get_row([[6, 3, 6, 5, 5, 1], [1, 6, 5, 3, 4, 2], [4, 6, 4, 8, 2, 7], [5, 4, 3, 6, 1, 2], [2, 2, 7, 4, 1, 11], [4, 5, 6, 2, 2, 1], [2, 7, 3, 5, 10, 6]], 5) == [(0, 4), (0, 3), (1, 2), (3, 0), (5, 1), (6, 3)]", "assert get_row([[6, 2, 7, 6, 8, 3], [2, 2, 5, 9, 6, 11], [2, 2, 1, 9, 1, 4]], 2) == [(0, 1), (1, 1), (1, 0), (2, 1), (2, 0)]", "assert get_row([[6, 5, 8, 6, 5, 1], [5, 4, 3, 2, 2, 11], [6, 1, 1, 8, 1, 9], [6, 6, 1, 4, 7, 8], [6, 4, 3, 7, 7, 2], [1, 1, 6, 8, 4, 7]], 4) == [(1, 1), (3, 3), (4, 1), (5, 4)]", "assert get_row([[6, 4, 6, 5, 10, 10], [3, 7, 7, 8, 10, 9], [1, 2, 4, 9, 9, 8], [1, 6, 1, 6, 3, 11], [1, 4, 5, 8, 6, 5], [5, 4, 7, 4, 9, 2]], 1) == [(2, 0), (3, 2), (3, 0), (4, 0)]", "assert get_row([[5]], 7) == []", "assert get_row([[4, 1, 8, 8, 5, 3], [1, 6, 2, 3, 7, 2], [4, 5, 2, 7, 6, 1], [5, 3, 2, 2, 3, 6], [2, 7, 3, 8, 2, 4], [6, 4, 7, 8, 4, 7]], 5) == [(0, 4), (2, 1), (3, 0)]", "assert get_row([[2, 7, 4, 2, 6, 11], [2, 2, 1, 2, 8, 1], [3, 4, 5, 8, 7, 9], [5, 2, 2, 2, 8, 8], [3, 4, 8, 1, 7, 2], [3, 7, 7, 8, 8, 9]], 4) == [(0, 2), (2, 1), (4, 1)]", "assert get_row([[1, 3, 2, 5, 2, 6], [5, 4, 5, 8, 1, 5], [6, 3, 3, 4, 4, 5]], 1) == [(0, 0), (1, 4)]", "assert get_row([], 3) == []", "assert get_row([[5, 6, 5, 9, 3, 10], [3, 6, 4, 1, 4, 8], [2, 1, 3, 5, 10, 2]], 5) == [(0, 2), (0, 0), (2, 3)]", "assert get_row([[3, 7, 3, 4, 10, 6], [5, 7, 1, 1, 7, 10], [4, 1, 5, 2, 2, 6], [5, 1, 5, 7, 6, 5], [4, 4, 7, 3, 5, 5], [6, 5, 5, 7, 4, 5]], 7) == [(0, 1), (1, 4), (1, 1), (3, 3), (4, 2), (5, 3)]", "assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.", "assert get_row([[2, 5, 4, 9, 9, 1], [3, 2, 1, 6, 2, 9], [2, 6, 6, 3, 3, 2]], 1) == [(0, 5), (1, 2)]", "assert get_row([[1]], 4) == []", "assert get_row([[5, 6, 7, 1, 4, 1], [5, 2, 8, 9, 1, 7], [6, 4, 5, 8, 1, 8], [5, 2, 4, 3, 5, 4], [4, 1, 6, 2, 3, 8], [2, 7, 2, 9, 7, 6]], 7) == [(0, 2), (1, 5), (5, 4), (5, 1)]", "assert get_row([[3, 7, 7, 5, 3, 11], [3, 1, 2, 6, 5, 2], [6, 6, 1, 2, 6, 7], [3, 6, 4, 4, 5, 9], [3, 4, 2, 2, 1, 10], [5, 2, 7, 2, 1, 6], [3, 3, 8, 1, 2, 4]], 4) == [(3, 3), (3, 2), (4, 1), (6, 5)]", "assert get_row([[6, 7, 4, 3, 10, 4], [3, 2, 3, 1, 4, 2], [3, 4, 3, 1, 5, 4]], 6) == [(0, 0)]", "assert get_row([[6]], 5) == []", "assert get_row([[5, 3, 3, 1, 1, 3], [6, 6, 2, 4, 6, 9], [5, 3, 8, 2, 5, 3]], 3) == [(0, 5), (0, 2), (0, 1), (2, 5), (2, 1)]", "assert get_row([[6]], 3) == []", "assert get_row([[3]], 6) == []", "assert get_row([[3, 7, 6, 5, 5, 10], [1, 1, 7, 2, 2, 10], [3, 2, 2, 6, 4, 1]], 4) == [(2, 4)]", "assert get_row([[6, 6, 5, 9, 2, 3], [2, 6, 5, 5, 2, 5], [5, 6, 7, 6, 8, 7], [6, 7, 6, 8, 10, 6], [4, 7, 3, 4, 10, 3], [3, 2, 8, 6, 4, 2], [1, 1, 5, 7, 7, 2]], 5) == [(0, 2), (1, 5), (1, 3), (1, 2), (2, 0), (6, 2)]"], "nl": "\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    ", "func": "def get_row(lst, x):", "examples": "Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    ", "repair_prompt": ["def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. Ensure to handle cases where x is not found in the list, returning an empty list in such scenarios.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''", "```python\ndef get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix. However, unlike matrices, each row may contain a different number of columns. Given lst, and integer x, you must find integers that match x in the list. You need to return a list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. Ensure to handle cases where x is not found in the list, returning an empty list in such scenarios.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''\n```", "def get_row(lst, x):\t\n'''You are given a 2 dimensional data, as a nested lists, which is similar to matrix, and unlike matrices, each row may contain a different number of columns. Given lst, and integer x, find integers x in the list, returning list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns), starting with 0. Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order. Ensure to handle cases where x is not found in the list, returning an empty list in such scenarios.\nExamples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds all occurrences of an integer in a nested list and returns their coordinates.\n\n    Args:\n        lst: A list of lists where each sublist contains integers.\n        x: An integer to find within the nested list.\n\n    Returns:\n        A list of tuples, each representing the (row, column) coordinates of occurrences of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row and column of the nested list\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            # If the integer x is found, append its coordinates (row, column) to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order\n    # Within each row, sort the coordinates by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n\n# Example usage:\n# print(get_row([[1, 2], [], [3, 1]], 1))  # Output: [(0, 0), (2, 1)]\n# print(get_row([[3], [3, 3], [3, 3, 3]], 3))  # Output: [(0, 0), (1, 1), (1, 0), (2, 2), (2, 1), (2, 0)]\n# print(get_row([], 1))  # Output: []\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Given a 2D list 'lst' and an integer 'x', return a list of tuples representing the coordinates (row, column) of 'x' in 'lst'.\n    The coordinates are sorted by rows in ascending order and by columns in descending order within each row.\n    If 'x' is not found, return an empty list.\n\n    Args:\n        lst: A 2D list of integers.\n        x: An integer to find within the 2D list.\n\n    Returns:\n        A list of tuples, where each tuple contains the row and column indices of 'x' in the 2D list.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the 2D list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates by row index in ascending order\n    # For coordinates with the same row index, sort by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate and return the coordinates of integer x in a nested list structure.\n\n    Args:\n    lst: A list of lists where each sublist contains integers.\n    x: The integer to find within the nested list.\n\n    Returns:\n    A list of tuples, each representing the (row, column) coordinates of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row in the 2D list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"Finds all occurrences of the integer x in a nested list and returns their coordinates.\n\n    Args:\n        lst: A nested list of integers representing a 2D matrix.\n        x: An integer to find within the matrix.\n\n    Returns:\n        A list of tuples, each containing the row and column indices of occurrences of x.\n        The list is sorted by row indices in ascending order and column indices in descending order.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_index, element in enumerate(row):\n            # Check if the element matches x\n            if element == x:\n                # Append the coordinates (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the coordinates first by row index in ascending order, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n\n# Example usage:\n# print(get_row([[1, 2], [], [3, 1]], 1))  # Output: [(0, 0), (2, 1)]\n# print(get_row([[1], [1, 2], [3]], 4))    # Output: []\n# print(get_row([], 1))                    # Output: []\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Finds the coordinates of a specified integer within a 2D list.\n\n    Args:\n        lst: A list of lists containing integers, representing a 2D data structure.\n        x: An integer to find within the nested list.\n\n    Returns:\n        A list of tuples, where each tuple contains the row and column indices of occurrences of x,\n        sorted by rows in ascending order and columns in descending order.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row in the 2D list using its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row using its index\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append its coordinate\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Searches for occurrences of the integer x in a nested list and returns\n    their coordinates sorted by row in ascending order and column in descending order.\n\n    Parameters:\n    lst: A nested list of integers where each sublist represents a row.\n    x: An integer to search for within the nested list.\n\n    Returns:\n    A list of tuples where each tuple contains the row and column indices of occurrences of x,\n    sorted by row in ascending order and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row of the nested list using an index to track the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through each element using an index to track the column number\n        for col_index, element in enumerate(row):\n            # If an element matches x, append its coordinate (row_index, column_index) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row index in ascending order\n    # and then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds the positions of integer x in a nested list and returns them as a list of coordinates.\n\n    Parameters:\n    lst: A nested list of integers where each sublist represents a row.\n    x: An integer to find within the nested list.\n\n    Returns:\n    A list of tuples, where each tuple contains the row and column indices of occurrences of x,\n    sorted by row in ascending order and by column in descending order.\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row with its index\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row with its index\n        for col_index, element in enumerate(row):\n            # Check if the element matches the integer x\n            if element == x:\n                # Append the coordinate (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row in ascending order and column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"Locate and return coordinates of integer x within a nested list structure.\n\n    Args:\n        lst (List[List[int]]): A 2D list where each sublist represents a row.\n        x (int): The integer to locate within the list.\n\n    Returns:\n        List[Tuple[int, int]]: A list of tuples representing the coordinates of x,\n        sorted by row in ascending order and column in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the nested list using an index to keep track of the row number\n    for row_index, row in enumerate(lst):\n        # Iterate through each element in the row using an index to keep track of the column number\n        for col_index, element in enumerate(row):\n            # If the element matches the integer x, append the coordinate (row, column) to the list\n            if element == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Locate the integer x in a nested list and return a list of tuples representing the coordinates.\n\n    Parameters:\n    lst (list[list[int]]): A nested list where each sublist represents a row.\n    x (int): The integer to locate within the nested list.\n\n    Returns:\n    list[tuple[int, int]]: A list of tuples with each tuple containing the row and column index of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row and column in the nested list\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            # If the integer x is found, append its coordinates (row, column) to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds the coordinates of the integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists where each sublist represents a row of integers.\n        x: An integer to find within the nested list.\n\n    Returns:\n        A list of tuples, where each tuple contains the row and column indices\n        of occurrences of x, sorted by rows in ascending order and columns in\n        descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row and column\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            # Check if the current element equals x\n            if value == x:\n                # Append the coordinates (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row ascending, column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n"], "plans": ["requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring the output is sorted by row and column as specified. It must handle cases where the integer is not present, returning an empty list, and should be robust against varying row lengths.\nrequirement pool:\n- Implement the main function to locate integer positions.\n- Ensure sorting of output by row and column.\n- Handle empty list scenarios gracefully.\n- Optimize for performance with large datasets.\n- Provide clear documentation and examples.\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the specified integer. For each occurrence, we will record the coordinates as a tuple. The function will then sort these tuples first by row in ascending order and then by column in descending order. We will use Python's built-in list and tuple data structures for simplicity and efficiency, as they are well-suited for this task. The function will handle empty lists by returning an empty list immediately.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, where each row can have a different number of columns. This is represented using nested lists in Python.\n\n    'coordinate'\n    Explanation: A coordinate in this context refers to a tuple (row, column) indicating the position of an integer within the 2D structure.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting from smallest to largest\n    'descending order': means sorting from largest to smallest\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate through each row and column of the nested list.\n    3. If the integer x is found, append its coordinates (row, column) to the list.\n    4. Sort the list of coordinates first by row in ascending order.\n    5. Within each row, sort the coordinates by column in descending order.\n    6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no coordinates to return.\n\n    get_row([[1, 2], [], [3, 1]], 1) = [(0, 0), (2, 1)]\n    Explanation: The integer 1 is found at (0, 0) and (2, 1). The coordinates are sorted by row in ascending order.\n\n    get_row([[3], [3, 3], [3, 3, 3]], 3) = [(0, 0), (1, 1), (1, 0), (2, 2), (2, 1), (2, 0)]\n    Explanation: The integer 3 is found in multiple positions. The coordinates are sorted by row in ascending order and by column in descending order within each row.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and sorting requirements effectively.\n", "requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a nested list structure. It must handle varying row lengths and ensure the output is sorted as specified. Edge cases, such as empty lists or the absence of the integer, should be managed gracefully.\nrequirement pool:\n- Implement the main function to find coordinates of integer x.\n- Ensure the function handles empty lists and missing integers.\n- Optimize sorting of coordinates for performance.\n- Include comprehensive test cases for edge scenarios.\n- Document the function with clear usage examples.\nWe will implement a function using native Python features such as list comprehensions and nested loops to efficiently find and sort the coordinates of a specified integer within a nested list structure. This approach is chosen for its simplicity and flexibility in handling varying row lengths. We will ensure the function handles edge cases like empty lists and missing integers gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': Sort rows in increasing order based on their index.\n    'descending order': Sort columns in decreasing order within each row.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the 2D list using its index.\n3. For each row, iterate over each element using its index.\n4. If the element matches the integer x, append its coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row index in ascending order.\n6. For coordinates with the same row index, sort by column index in descending order.\n7. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any of the rows, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for matches will naturally handle these cases by returning an empty list when no matches are found.\n", "requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a nested list structure, ensuring results are sorted by row and column as specified. It must handle cases where the integer is not present by returning an empty list.\nrequirement pool:\n- Implement the main function to find coordinates of integer x.\n- Ensure the function handles empty lists gracefully.\n- Sort the results by row in ascending order and by column in descending order.\n- Optimize for performance with large datasets.\n- Include comprehensive test cases for edge scenarios.\nWe will implement a function using native Python features such as list comprehensions and nested loops to efficiently find and sort the coordinates of a specified integer within a nested list structure. This approach is chosen for its simplicity and flexibility, ensuring the function handles empty datasets gracefully and sorts results as required.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D data, with the format (row, column).\n    'sort coordinates': The requirement to order the found coordinates first by row in ascending order, then by column in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending': Means increasing order, from smallest to largest.\n    'descending': Means decreasing order, from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the 2D list using its index.\n3. For each row, iterate over each element using its index.\n4. If the element matches the integer x, append the coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to find, resulting in an empty list.\n    \n    get_row([[1], [2], [3]], 4) = []\n    Explanation: The integer 4 is not present in any of the rows, so the result is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for matches will naturally handle these cases by returning an empty list when no matches are found.\n", "requirement analysis:\nThe function should efficiently locate all instances of a given integer within a nested list structure, returning their coordinates sorted by specified criteria. It must handle varying row lengths and empty datasets without errors.\nrequirement pool:\n- Implement the main function to find and return coordinates of the integer.\n- Ensure the function handles empty lists gracefully.\n- Sort the results by rows in ascending order and columns in descending order.\n- Optimize for performance with large datasets.\n- Include comprehensive test cases for edge scenarios.\nWe will implement a function using native Python list operations and comprehensions to efficiently locate all instances of a given integer within a nested list structure. The function will handle varying row lengths and empty datasets gracefully. Sorting will be done using Python's built-in sorting capabilities to ensure the results are sorted by rows in ascending order and columns in descending order.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D data structure, which is represented as nested lists in Python. Each sublist represents a row, similar to a matrix, but the number of columns can vary between rows.\n\n    'coordinate'\n    Explanation: The requirement asks for the positions of elements matching a given integer x, represented as tuples of (row, column) indices.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb]\n    'ascending order', 'descending order'\n    Explanation: The requirement specifies sorting the coordinates first by rows in ascending order (smallest to largest) and then by columns in descending order (largest to smallest).\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the nested list using its index.\n3. For each row, iterate over each element using its index.\n4. If an element matches x, append its coordinates (row index, column index) to the list.\n5. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to match x. The expected output is an empty list.\n\n    get_row([[1, 2], [], [3, 1]], 1) = [(0, 0), (2, 1)]\n    Explanation: The number 1 appears at (0, 0) and (2, 1). The empty row does not affect the result.\n\n    get_row([[1], [1, 2], [3]], 4) = []\n    Explanation: The number 4 does not appear in any row, so the expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and cases where x is not found by returning an empty list.\n", "requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a nested list structure. It must handle varying row lengths and ensure the output is sorted by the specified criteria. Edge cases, such as empty lists or absence of the integer, should be managed gracefully.\nrequirement pool:\n- Implement the main function to find and return coordinates of the integer.\n- Ensure the function handles empty lists without errors.\n- Sort the output by rows in ascending order and columns in descending order.\n- Optimize the function for performance with large datasets.\n- Include comprehensive test cases to validate functionality.\nWe will use native Python list comprehensions and sorting functions to efficiently locate and return the coordinates of the specified integer within a nested list structure. This approach is chosen for its simplicity and performance, given the requirement to handle varying row lengths and sort the output by specific criteria.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': Refers to a list of lists, where each sublist represents a row in a matrix-like structure.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'descending': Indicates that the columns within each row should be sorted from highest to lowest.\n    'ascending': Indicates that the rows should be sorted from lowest to highest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the 2D list using its index.\n3. For each row, iterate over each element using its index.\n4. If an element matches the integer x, append its coordinate (row index, column index) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to match with x. The expected output is an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to match with x. The expected output is an empty list.\n    \n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any of the rows. The expected output is an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for matches will naturally handle these cases by returning an empty list when no matches are found.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring the output is sorted by rows in ascending order and columns in descending order. It must handle cases where the integer is not present, returning an empty list, and accommodate varying row lengths.\nrequirement pool:\n- Implement efficient search algorithm for nested lists\n- Ensure output is sorted correctly\n- Handle edge cases where integer is not found\n- Support varying row lengths in lists\n- Optimize for performance\nWe will implement a function that iterates through each row of the nested list, checking for the presence of the integer x. For each occurrence, we will store the coordinates in a list of tuples. The function will then sort this list first by row index in ascending order and then by column index in descending order. We will use Python's built-in sorting capabilities to achieve this efficiently. The function will handle edge cases such as empty lists or rows gracefully.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data'\n    Explanation: This refers to a list of lists, where each inner list represents a row, similar to a matrix but with potentially varying numbers of columns.\n\n    'coordinate'\n    Explanation: A tuple representing the position of an element in the 2D data, with the format (row_index, column_index).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order'\n    Explanation: Sorting the row indices from smallest to largest.\n\n    'descending order'\n    Explanation: Sorting the column indices from largest to smallest within each row.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row of the nested list using an index to track the row number.\n3. For each row, iterate through each element using an index to track the column number.\n4. If an element matches x, append its coordinate (row_index, column_index) to the list.\n5. Sort the list of coordinates first by row index in ascending order and then by column index in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to match with x, resulting in an empty list.\n\n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to match with x, resulting in an empty list.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any of the rows, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through each element and checking for matches naturally handles these scenarios.\n", "requirement analysis:\nThe function should efficiently locate and return the positions of a specified integer within a nested list structure, ensuring results are sorted by row and column as specified. It must handle cases where the integer is not present by returning an empty list.\nrequirement pool:\n- Efficiently find and return positions of integer x in nested lists.\n- Sort results by row in ascending order and by column in descending order.\n- Handle empty lists and missing integers gracefully.\n- Ensure the function is easy to understand and use.\n- Optimize for performance with large datasets.\nWe will implement a function using native Python list operations and comprehensions to efficiently find and return the positions of integer x in nested lists. The function will handle edge cases such as empty lists and missing integers gracefully. Sorting will be done using Python's built-in sorting capabilities to ensure the results are sorted by row in ascending order and by column in descending order.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': This refers to a list of lists, where each sublist represents a row, similar to a matrix.\n    'coordinate': A tuple representing the position of an element in the 2D list, with the format (row, column).\n    'sort coordinates': The requirement specifies sorting the coordinates by rows in ascending order and columns in descending order.\n\n# [phrase showing quantity relationship]\n    No explicit phrase showing quantity relationship.\n\n# [degree adverb]\n    No explicit degree adverb.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate over each row in the 2D list using an index to track the row number.\n3. For each row, iterate over each element using an index to track the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order and then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no elements to search for, resulting in an empty list.\n    \n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no elements to search for, resulting in an empty list.\n    \n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not present in any of the rows, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for matches will naturally handle these cases by returning an empty list when no matches are found.\n", "requirement analysis:\nThe function should efficiently locate and return coordinates of a specified integer within a nested list structure, ensuring results are sorted by row and column as specified. It must handle cases where the integer is not present, returning an empty list without errors.\nrequirement pool:\n- Implement efficient search and retrieval of integer coordinates.\n- Ensure sorting by row in ascending order and column in descending order.\n- Handle empty list scenarios gracefully.\n- Optimize performance for large datasets.\n- Provide clear error messages for invalid inputs.\nWe will implement a function using Python's built-in list operations to efficiently search for the integer within the nested list structure. The function will handle sorting using Python's sorted function, which is optimized for performance. We will ensure the function handles empty lists gracefully and returns an empty list when the integer is not found. Type checking will be included to ensure the input is valid.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data': refers to a nested list structure, similar to a matrix, where each sublist represents a row.\n    'coordinate': refers to the position of an element in the nested list, represented as a tuple (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting from smallest to largest.\n    'descending order': means sorting from largest to smallest.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Iterate through each row in the nested list using an index to keep track of the row number.\n3. For each row, iterate through each element using an index to keep track of the column number.\n4. If the element matches the integer x, append the coordinate (row, column) to the list.\n5. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n6. Return the sorted list of coordinates.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no elements to search for, resulting in an empty list.\n    \n    get_row([[1, 2], [], [3, 4]], 5) = []\n    Explanation: The integer 5 is not found in any row, so the function returns an empty list.\n    \n    get_row([[1], [1, 2], [3]], 1) = [(0, 0), (1, 0)]\n    Explanation: The integer 1 is found at (0, 0) and (1, 0). The coordinates are sorted by row in ascending order.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic handles empty lists and cases where x is not found by returning an empty list.\n", "requirement analysis:\nThe function should efficiently locate and return the coordinates of a specified integer within a nested list structure. It must handle varying row lengths and sort the results by row and column as specified. Edge cases, such as empty lists or absence of the integer, should be managed gracefully.\nrequirement pool:\n- Implement the main function to locate integer coordinates.\n- Ensure sorting of results by row and column.\n- Handle empty list scenarios without errors.\n- Optimize for performance with large datasets.\n- Provide detailed documentation and examples.\nWe will implement a function that iterates over each row and column of the nested list to find the specified integer. We will store the coordinates in a list of tuples, sort them by row in ascending order, and by column in descending order. The function will handle empty lists and cases where the integer is not found by returning an empty list. Python's built-in list and tuple data structures will be used for simplicity and efficiency.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D structure similar to a matrix, where each row can have a different number of columns. This is represented using nested lists in Python.\n\n    'coordinate'\n    Explanation: The requirement asks for the position of the integer x in terms of its row and column index, starting from 0.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    'ascending order': means sorting the rows from smallest to largest index.\n    'descending order': means sorting the columns within each row from largest to smallest index.\n\n# [code logic]\n    1. Initialize an empty list to store the coordinates.\n    2. Iterate over each row and column in the nested list.\n    3. If the integer x is found, append its coordinates (row, column) to the list.\n    4. Sort the list of coordinates first by row in ascending order, then by column in descending order.\n    5. Return the sorted list of coordinates.\n    6. Handle cases where x is not found by returning an empty list.\n\n# [edge case] \n    get_row([], 1) = []\n    Explanation: The list is empty, so there are no coordinates to return.\n\n    get_row([[], [1], [1, 2, 3]], 3) = [(2, 2)]\n    Explanation: The integer 3 is found at row index 2 and column index 2.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer 7 is not found in the list, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic already handles cases where x is not found by returning an empty list.\n", "requirement analysis:\nThe function should efficiently locate all instances of a given integer within a nested list structure, returning their coordinates sorted by specified criteria. It must handle varying row lengths and empty datasets without errors.\nrequirement pool:\n- Efficiently find and return coordinates of integer x in the dataset.\n- Sort results by rows in ascending order and columns in descending order.\n- Handle empty datasets gracefully, returning an empty list.\n- Ensure compatibility with non-uniform row lengths.\n- Optimize for large datasets if possible.\nWe will use a simple nested loop approach to iterate through the nested list structure to find the integer x. This approach is straightforward and allows us to handle non-uniform row lengths and empty datasets efficiently. We will use Python's built-in sorting capabilities to sort the results as specified. This method is chosen for its simplicity and adequacy for the given problem size, without the need for more complex libraries like NumPy or Pandas.\nPlease read and understand the following inteperation before coding\n# [core concept]\n    '2 dimensional data', 'nested lists', 'matrix'\n    Explanation: The requirement involves working with a 2D data structure, specifically nested lists, which resemble matrices but can have rows of varying lengths.\n\n    'coordinate'\n    Explanation: The requirement asks for the positions of integer x in the form of coordinates (row, column).\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb]\n    'ascending order', 'descending order'\n    Explanation: The requirement specifies sorting the coordinates by rows in ascending order and by columns in descending order.\n\n# [code logic]\n1. Initialize an empty list to store the coordinates.\n2. Use a nested loop to iterate through each row and column of the nested list.\n3. If the integer x is found, append its coordinates (row index, column index) to the list.\n4. Sort the list of coordinates first by row index in ascending order, then by column index in descending order.\n5. Return the sorted list of coordinates.\n\n# [edge case]\n    get_row([], 1) = []\n    Explanation: The input list is empty, so there are no coordinates to return.\n\n    get_row([[], [], []], 1) = []\n    Explanation: All rows are empty, so there are no occurrences of x.\n\n    get_row([[1, 2], [3, 4], [5, 6]], 7) = []\n    Explanation: The integer x is not present in any row, so the function returns an empty list.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic of iterating through the list and checking for occurrences of x naturally handles these scenarios.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [87, 87, 87, 87, 87, 87, 87, 87, 87, 87], "completion": "from typing import List\n## main.py\n\ndef get_row(lst: list[list[int]], x: int) -> list[tuple[int, int]]:\n    \"\"\"\n    Finds the coordinates of the integer x in a nested list structure.\n\n    Args:\n        lst: A list of lists where each sublist represents a row of integers.\n        x: An integer to find within the nested list.\n\n    Returns:\n        A list of tuples, where each tuple contains the row and column indices\n        of occurrences of x, sorted by rows in ascending order and columns in\n        descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate over each row and column\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            # Check if the current element equals x\n            if value == x:\n                # Append the coordinates (row_index, col_index) to the list\n                coordinates.append((row_index, col_index))\n\n    # Sort the list of coordinates by row ascending, column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    # Return the sorted list of coordinates\n    return coordinates\n", "passed": true, "pass": true, "pass_num": 10, "round": 230, "mutate_method": "add_1_sentence_at_end", "parent_index": 75}
