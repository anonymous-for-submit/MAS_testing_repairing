{"name": "1607_C. Minimum Extraction", "description": "Yelisey has an array a of n integers.\n\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \n\n  1. First, Yelisei finds the minimal number m in the array. If there are several identical minima, Yelisey can choose any of them. \n  2. Then the selected minimal element is removed from the array. After that, m is subtracted from each remaining element. \n\n\n\nThus, after each operation, the length of the array is reduced by 1.\n\nFor example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\n\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\n\nHelp him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "tags": ["brute force", "sortings"], "difficulty": 9, "id": 1607, "sample_io": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}], "test_list": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 0 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 19 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n12\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 6\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n7\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 1\n5\n3 2 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 12\n2\n2 4\n5\n3 3 -5 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n8\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -6 -1 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n5\n3\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -1 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-3\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 12\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n10\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 0 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n11\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-1 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n0 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n4\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -1 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-2 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["15\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n1\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n7\n2\n0 -1\n3\n-2 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["7\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -7 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n5\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 1\n5\n0 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n1\n2\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 1 0\n4\n2 10 1 7\n2\n2 6\n5\n3 4 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n1\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-3\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n4 3\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n3\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n1\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 15 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 8\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 16 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n8\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 2\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n8\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 4 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -4\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n4\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 0\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 -1 1\n2\n-1 1\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n0 18 1 9\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n9\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 0\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n1\n0\n"]}, {"input": "8\n1\n19\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["19\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-2 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n3 12 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-3\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-3\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 1 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 1\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n1\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n0 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n4 10 1 7\n2\n-1 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n5\n4\n2\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 14\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n0 4\n5\n0 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n0 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n6\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 8\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n4 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n1 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n5\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 -1\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["8\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 11 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n9\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n6 10 2 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-4\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-4\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -12 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n8\n2\n-2\n"]}, {"input": "8\n1\n1\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["1\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 6\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 12\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 0 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 0\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n1\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 0\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n1\n-2\n"]}], "task_id": "codecontest/100", "prompt": "Yelisey possesses an array, denoted as 'a,' comprising n integers. If the array\u2019s length is strictly more than one, Yelisey can perform an operation named minimum extraction: Initially, Yelisei identifies the smallest number m in the array; if there are multiple identical minimum values, Yelisey can opt for any one of them, subsequently, the chosen smallest element is eliminated from the array, and then m is deducted from every other remaining element. Thus, following each operation, the array's length diminishes by one. For instance, given a = [1, 6, -4, -2, -4], the minimum element in this array is a_3 = -4, signifying that post-operation, the array will become a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0]. Since Yelisey has a preference for large numbers, he desires the numbers in array 'a' to be as large as feasible, aiming to maximize the lowest number in array 'a' (that is, he wants the minimum to be as large as it can be). In pursuit of this goal, Yelisey can carry out the minimum extraction operation on the array any number of times he wishes (possibly none at all). Bear in mind that the operation cannot be conducted on an array with length equal to one. Assist him in determining what maximum value the array's minimal element can achieve after performing several (possibly zero) minimum extraction operations. Consider edge cases and efficiency in your solution. Ensure your approach accounts for varying initial conditions and constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "repair_prompt": ["Yelisey possesses an array, denoted as 'a,' comprising n integers. If the array\u2019s length is strictly more than one, Yelisey can perform an operation named minimum extraction: Initially, Yelisei identifies the smallest number m in the array; if there are multiple identical minimum values, Yelisey can opt for any one of them, subsequently, the chosen smallest element is eliminated from the array, and then m is deducted from every other remaining element. Thus, following each operation, the array's length diminishes by one. For instance, given a = [1, 6, -4, -2, -4], the minimum element in this array is a_3 = -4, signifying that post-operation, the array will become a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0]. Since Yelisey has a preference for large numbers, he desires the numbers in array 'a' to be as large as feasible, aiming to maximize the lowest number in array 'a' (that is, he wants the minimum to be as large as it can be). In pursuit of this goal, Yelisey can carry out the minimum extraction operation on the array any number of times he wishes (possibly none at all). Bear in mind that the operation cannot be conducted on an array with length equal to one. Assist him in determining what maximum value the array's minimal element can achieve after performing several (possibly zero) minimum extraction operations. Consider edge cases and efficiency in your solution. Ensure your approach accounts for varying initial conditions and constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case after performing\n    the minimum extraction operation any number of times.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the operation cannot be performed.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to easily calculate differences between consecutive elements.\n        case.sort()\n        \n        # Initialize the maximum possible minimum value as the first element.\n        max_min_value = case[0]\n        \n        # Calculate the maximum difference between consecutive elements.\n        for i in range(1, len(case)):\n            difference = case[i] - case[i - 1]\n            max_min_value = max(max_min_value, difference)\n        \n        results.append(max_min_value)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case after performing minimum extraction operations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum possible minimum values for each test case.\n    \"\"\"\n    results = []\n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, no operation can be performed, return the single element.\n            results.append(case[0])\n        else:\n            # Sort the array to simulate the minimum extraction operation.\n            case.sort()\n            # Initialize the maximum possible minimum value.\n            max_min_value = case[0]\n            # Calculate the difference between consecutive elements to simulate the operation.\n            for i in range(1, len(case)):\n                max_min_value = max(max_min_value, case[i] - case[i - 1])\n            results.append(max_min_value)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Process test cases and output results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Determine the maximum possible minimum value of the array after performing\n    the minimum extraction operation.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum possible minimum values for each test case.\n    \"\"\"\n    results = []\n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, no operation can be performed.\n            results.append(case[0])\n        else:\n            # Sort the array to simulate the extraction process.\n            case.sort()\n            # Calculate the maximum possible minimum value.\n            max_minimum = case[0]\n            for i in range(1, len(case)):\n                max_minimum = max(max_minimum, case[i] - case[i - 1])\n            results.append(max_minimum)\n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport heapq\nfrom typing import List, Tuple\n\ndef maximum_possible_minimum(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value of the array after performing\n    the minimum extraction operation any number of times.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing\n            an integer n and a list of integers a.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible\n            minimum value of the array.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        if n == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(a[0])\n            continue\n\n        # Convert the list into a min-heap\n        heapq.heapify(a)\n\n        # Initialize the maximum possible minimum\n        max_possible_min = float('-inf')\n        current_min = 0\n\n        while len(a) > 1:\n            # Extract the minimum element\n            min_element = heapq.heappop(a)\n            # Calculate the current minimum possible value\n            current_min = min_element - current_min\n            # Update the maximum possible minimum\n            max_possible_min = max(max_possible_min, current_min)\n\n        # The last element in the heap is the final minimum\n        max_possible_min = max(max_possible_min, a[0] - current_min)\n\n        results.append(max_possible_min)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    t = int(data[0])\n    index = 1\n    test_cases = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n\n    # Call the function and print results\n    results = maximum_possible_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Compute the maximum possible minimum value for each test case after performing minimum extraction operations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum possible minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        # Sort the array to facilitate the minimum extraction operation\n        case.sort()\n        \n        # Initialize the maximum possible minimum value\n        max_possible_min = case[0]\n        \n        # Iterate through the sorted array and compute the maximum possible minimum\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements\n            difference = case[i] - case[i - 1]\n            # Update the maximum possible minimum value\n            max_possible_min = max(max_possible_min, difference)\n        \n        # Append the result for the current test case\n        results.append(max_possible_min)\n    \n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(f\"Maximum possible minimum value: {result}\")\n\n# Program entry point\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value of the array after performing\n    several minimum extraction operations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum possible minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, return the single element as the result\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate minimum extraction\n        case.sort()\n        \n        # Initialize the maximum possible minimum value\n        max_minimum = case[0]\n        \n        # Perform the minimum extraction operation\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements\n            difference = case[i] - case[i - 1]\n            # Update the maximum possible minimum value\n            max_minimum = max(max_minimum, difference)\n        \n        results.append(max_minimum)\n    \n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    \n    # Initialize an empty list to store test cases\n    test_cases = []\n    \n    for _ in range(t):\n        # Read the length of the array\n        n = int(input())\n        # Read the array elements\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and store the result\n    results = maximize_minimum(t, test_cases)\n    \n    # Output each result for the test cases\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value of the array after performing\n    the minimum extraction operation any number of times.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the minimum extraction operation.\n        case.sort()\n        \n        # Initialize the maximum possible minimum value.\n        max_minimum = case[0]\n        \n        # Iterate through the sorted array to simulate the minimum extraction operation.\n        for i in range(1, len(case)):\n            # Calculate the difference between the current element and the previous one.\n            difference = case[i] - case[i - 1]\n            # Update the maximum possible minimum value.\n            max_minimum = max(max_minimum, difference)\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n    \n    # Call the function and print the results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximum_possible_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum possible minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, return the single element as the result\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the minimum extraction operation\n        case.sort()\n        \n        # Initialize the maximum possible minimum value\n        max_possible_min = case[0]\n        \n        # Perform the minimum extraction operation iteratively\n        for i in range(1, len(case)):\n            # Calculate the difference between the current element and the previous minimum\n            diff = case[i] - case[i - 1]\n            # Update the maximum possible minimum value\n            max_possible_min = max(max_possible_min, diff)\n        \n        results.append(max_possible_min)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print the results\n    results = maximum_possible_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\n# Entry point for the script\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case after performing\n    the minimum extraction operation.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        # Sort the array to facilitate the minimum extraction operation\n        case.sort()\n        \n        # Initialize the maximum possible minimum value\n        max_min_value = case[0]\n        \n        # Iterate through the sorted array to calculate the maximum possible minimum\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements\n            diff = case[i] - case[i - 1]\n            # Update the maximum possible minimum value\n            max_min_value = max(max_min_value, diff)\n        \n        # Append the result for the current test case\n        results.append(max_min_value)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximum_possible_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value of the array after performing\n    the minimum extraction operation any number of times.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the operation cannot be applied\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the greedy approach\n        case.sort()\n        \n        # Initialize the maximum possible minimum value\n        max_possible_min = case[0]\n        \n        # Iterate through the sorted array to calculate the maximum possible minimum\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements\n            diff = case[i] - case[i - 1]\n            # Update the maximum possible minimum\n            max_possible_min = max(max_possible_min, diff)\n        \n        results.append(max_possible_min)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Process and output results\n    results = maximum_possible_minimum(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires an efficient algorithm to maximize the minimum element of an array after performing a series of operations. The solution must handle up to 10,000 test cases with a total of up to 200,000 elements across all test cases. The algorithm should be optimized for both time and space complexity, considering the constraints on input size and value range.\nrequirement pool:\n- Develop an efficient algorithm to maximize the minimum element\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Provide clear documentation and explanation of the solution\n- Implement additional test cases for validation\nWe will use a greedy approach to solve the problem efficiently. The key observation is that the maximum possible minimum value after performing the operations is the maximum difference between consecutive sorted elements of the array. This is because each operation reduces the array size and increases the minimum value by the difference between the smallest and the next smallest element. We will sort the array and compute the differences between consecutive elements to find the maximum possible minimum value.\n", "requirement analysis:\nThe task requires implementing an algorithm that efficiently performs the minimum extraction operation on an array to maximize the minimum element. The solution must handle multiple test cases, large input sizes, and edge cases while ensuring optimal performance.\nrequirement pool:\n- Implement the minimum extraction operation efficiently\n- Ensure the solution handles large datasets within constraints\n- Optimize the algorithm for performance and scalability\n- Provide clear and concise output format\n- Consider edge cases in the solution\nWe will implement a function that processes each test case independently. For each array, we will sort the array and then simulate the minimum extraction operation by iteratively calculating the difference between consecutive elements. This approach ensures that we efficiently determine the maximum possible minimum value after all operations. We will use Python's built-in sorting capabilities to handle large datasets efficiently.\n", "requirement analysis:\nThe requirements focus on maximizing the minimum element in an array through a series of operations. The solution must efficiently handle multiple test cases and large arrays, ensuring accuracy and performance. Edge cases must be considered, and the solution should be scalable and easy to implement.\nrequirement pool:\n- Efficiently process multiple test cases\n- Handle large arrays with optimal performance\n- Ensure accuracy in edge cases\n- Provide clear and understandable implementation\n- Optimize for scalability\nWe will use a sorting-based approach to efficiently determine the maximum possible minimum value of the array after performing the minimum extraction operation. By sorting the array, we can simulate the extraction process and calculate the differences between consecutive elements to find the maximum possible minimum value. This approach ensures that we handle large datasets efficiently and accurately.\n", "requirement analysis:\nThe requirements focus on efficiently determining the maximum possible minimum value of an array after performing a series of operations. The solution must handle large input sizes and edge cases, including arrays with negative numbers and arrays of length one where no operations can be performed.\nrequirement pool:\n- Implement efficient algorithm for minimum extraction\n- Ensure solution handles negative numbers correctly\n- Optimize for large datasets\n- Provide clear output format\n- Handle edge cases gracefully\nWe will implement a function that iteratively performs the minimum extraction operation on the array until it cannot be performed anymore. The function will use a priority queue (min-heap) to efficiently find and remove the minimum element, and then update the remaining elements. This approach ensures efficient computation even for large datasets. We will use the 'heapq' library from Python's standard library to manage the priority queue.\n", "requirement analysis:\nThe requirement involves performing a series of operations on an array to maximize the minimum element. The solution must efficiently handle up to 10,000 test cases with arrays of varying lengths and values, ensuring optimal performance and accuracy.\nrequirement pool:\n- Implement the minimum extraction operation efficiently.\n- Ensure the solution handles edge cases, such as arrays of length one.\n- Optimize the algorithm for large datasets to minimize execution time.\n- Provide clear documentation and examples for understanding the solution.\n- Consider user experience in terms of input/output format and clarity.\nWe will implement a function that processes each test case independently. The key idea is to sort the array and then compute the maximum possible minimum by iterating through the sorted array and calculating the difference between consecutive elements. This approach ensures that we efficiently determine the maximum possible minimum value after performing the minimum extraction operations. Sorting the array allows us to handle the operations in a straightforward manner, and the complexity of sorting (O(n log n)) is suitable given the constraints.\n", "requirement analysis:\nThe requirements focus on maximizing the minimum element in an array through a series of operations. The solution must efficiently handle multiple test cases and large arrays, ensuring accuracy and performance. Edge cases, such as arrays with only one element, must be considered.\nrequirement pool:\n- Efficiently process multiple test cases\n- Handle large arrays with optimal performance\n- Ensure accuracy in edge cases\n- Provide clear input/output instructions\n- Optimize for scalability\nWe will implement a function that processes multiple test cases efficiently by iterating through each test case, extracting the minimum element, and adjusting the array accordingly. We will use Python's built-in list operations to handle the array manipulations. The approach will ensure that the solution is scalable and handles large datasets effectively.\n", "requirement analysis:\nThe requirements focus on maximizing the minimum element in an array through a series of operations. The solution must efficiently handle multiple test cases and large arrays, ensuring the output is accurate and follows the specified format. Edge cases, such as arrays of length one, must be considered, and the solution should be optimized for performance and memory usage.\nrequirement pool:\n- Implement the minimum extraction operation efficiently\n- Ensure the solution handles edge cases correctly\n- Optimize the algorithm for large datasets\n- Provide clear and concise output\n- Maintain consistent output format\nWe will implement a function that iteratively performs the minimum extraction operation on the array. The function will use efficient data structures to handle large datasets and ensure the solution is optimized for performance and memory usage. We will use the built-in Python list and sorting capabilities to efficiently find and remove the minimum element, and update the remaining elements accordingly.\n", "requirement analysis:\nThe requirements focus on efficiently determining the maximum possible minimum value in an array after performing a series of minimum extraction operations. The solution must handle multiple test cases, large arrays, and edge cases effectively. The output format must be clear and adhere to the specified format.\nrequirement pool:\n- Implement the minimum extraction operation efficiently\n- Ensure the solution handles large datasets within constraints\n- Optimize the algorithm for edge cases\n- Provide clear and concise output format\n- Test the solution against a variety of test cases\nWe will implement a function that efficiently performs the minimum extraction operation on the array. The approach involves sorting the array and iteratively calculating the maximum possible minimum value by subtracting the smallest element from the rest. This ensures that the solution handles large datasets within constraints and optimizes for edge cases.\n", "requirement analysis:\nThe requirements focus on optimizing the minimum extraction operation to maximize the smallest element in the array after several operations. The solution must efficiently handle multiple test cases and large arrays, ensuring accuracy and performance. Edge cases, such as arrays with only one element or arrays with identical elements, must be considered.\nrequirement pool:\n- Efficiently process multiple test cases\n- Handle large arrays with optimal performance\n- Ensure accuracy in edge cases\n- Provide clear and understandable output\n- Optimize for scalability\nWe will implement a function that processes multiple test cases efficiently by iterating through each test case, sorting the array, and calculating the maximum possible minimum value after performing the minimum extraction operation. We will use Python's built-in sorting capabilities to ensure optimal performance.\n", "requirement analysis:\nThe problem requires a solution that efficiently computes the maximum possible minimum value of an array after performing a series of minimum extraction operations. The solution must handle multiple test cases and large arrays, ensuring that the operations are performed optimally to achieve the desired result. Edge cases, such as arrays with only one element, must be considered to prevent unnecessary operations.\nrequirement pool:\n- Implement the minimum extraction operation efficiently\n- Handle multiple test cases in a single execution\n- Optimize for large arrays and high constraints\n- Ensure robustness against edge cases\n- Provide clear and concise output format\nWe will use a greedy approach to solve the problem efficiently. The idea is to sort the array and then perform the minimum extraction operation iteratively, keeping track of the cumulative effect of the operations. This allows us to determine the maximum possible minimum value after all operations. Sorting the array initially helps in efficiently finding the minimum element and applying the operation in a straightforward manner.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 686, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 397}
