{"name": "1586_B. Omkar and Heavenly Tree", "description": "Lord Omkar would like to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1 \u2264 m < n) restrictions to ensure that the tree will be as heavenly as possible. \n\nA tree with n nodes is an connected undirected graph with n nodes and n-1 edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\n\nHere is an example of a tree: \n\n<image>\n\nA restriction consists of 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n). It signifies that node b cannot lie on the simple path between node a and node c. \n\nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "tags": ["brute force", "constructive algorithms", "trees"], "difficulty": 8, "id": 1586, "sample_io": [{"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}], "test_list": [{"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n10 3\n2 2 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 4\n8 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 12\n6 5 4\n6 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n8 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n7 3\n1 2 -1\n3 3 4\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n"]}, {"input": "2\n12 4\n1 2 3\n3 1 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n6 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 1\n7 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 3 7\n5 5 4\n4 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n"]}, {"input": "2\n7 4\n1 1 3\n3 2 5\n6 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 0\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n8 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 7 4\n13 0\n1 1 -1\n2 3 4\n3 7 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n"]}, {"input": "2\n21 4\n1 2 3\n4 4 2\n5 7 10\n4 5 4\n6 0\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 1 4\n3 6 0\n5 5 7\n5 5 4\n8 3\n2 2 -1\n6 2 4\n3 4 10\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n7 4\n0 1 2\n10 2 5\n6 6 7\n6 5 4\n5 3\n1 1 0\n0 3 4\n3 3 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 2\n6 2 10\n7 2 20\n6 3 4\n9 0\n0 1 1\n4 3 4\n2 4 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n"]}, {"input": "2\n11 4\n-1 4 1\n3 7 5\n5 2 22\n2 5 1\n10 1\n2 2 1\n5 1 3\n4 2 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n26 4\n1 3 3\n4 4 5\n5 6 17\n4 9 4\n6 0\n1 3 0\n2 1 4\n7 0 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 25\n1 26\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n11 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n23 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 0\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n13 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n1 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n24 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 3\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n2 1\n2 3\n2 4\n"]}, {"input": "2\n21 4\n1 2 3\n4 1 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 13\n3 14\n3 15\n3 16\n3 17\n3 18\n3 19\n3 20\n3 21\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n4 3\n1 2 1\n2 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n"]}, {"input": "2\n9 4\n2 2 6\n3 4 10\n-1 6 7\n6 5 4\n8 3\n1 4 0\n1 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n"]}, {"input": "2\n7 4\n0 2 1\n3 1 5\n5 6 12\n3 5 4\n6 3\n2 1 0\n4 1 3\n4 2 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n9 4\n1 4 3\n3 4 17\n5 6 12\n8 5 8\n9 3\n1 1 0\n3 3 4\n3 5 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n"]}, {"input": "2\n9 4\n1 4 3\n3 1 17\n5 6 12\n8 5 15\n5 3\n1 1 0\n3 3 7\n3 5 7\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 1 1\n3 7 5\n5 6 12\n3 5 4\n6 3\n2 1 0\n4 1 3\n4 2 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n27 4\n1 3 3\n4 2 2\n5 7 10\n4 9 4\n6 0\n1 2 -1\n2 6 4\n4 1 8\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 25\n1 26\n1 27\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n-1 4 1\n3 7 5\n5 2 22\n2 1 4\n10 1\n2 2 0\n4 1 3\n4 2 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n-1 4 1\n3 7 5\n5 1 22\n2 5 1\n10 1\n2 2 0\n4 1 3\n4 2 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n9 4\n-1 4 1\n0 7 9\n5 2 22\n2 5 1\n10 1\n4 2 1\n5 1 3\n4 1 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n26 4\n1 3 3\n4 4 7\n5 1 17\n4 9 4\n6 0\n1 3 0\n2 1 4\n7 -1 12\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n2 13\n2 14\n2 15\n2 16\n2 17\n2 18\n2 19\n2 20\n2 21\n2 22\n2 23\n2 24\n2 25\n2 26\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n11 4\n0 4 2\n1 10 9\n5 2 22\n2 5 1\n19 1\n4 2 1\n5 1 3\n4 1 9\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n"]}, {"input": "2\n24 4\n1 4 3\n1 4 7\n5 6 17\n1 13 4\n6 0\n1 3 0\n2 1 4\n7 -1 21\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n1 15\n1 16\n1 17\n1 18\n1 19\n1 20\n1 21\n1 22\n1 23\n1 24\n1 2\n1 3\n1 4\n1 5\n1 6\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n7 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n4 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n4 1 3\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n5 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 3 4\n3 4 3\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 12\n5 6 7\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 6\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n5 4 10\n5 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n2 2 3\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 7\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n4 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 -1\n3 3 4\n0 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n6 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n6 4 10\n5 6 12\n6 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 2\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 10\n5 6 7\n6 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n6 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 8\n5 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n5 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n5 3\n2 2 0\n4 4 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 12\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n4 6 7\n5 5 4\n5 3\n2 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 4 0\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 7\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 7\n8 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 5\n4 6 3\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n12 5 4\n5 3\n1 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 6 3\n3 4 2\n5 6 7\n6 4 4\n5 3\n1 2 3\n2 3 4\n6 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n5 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 1\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n6 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n9 6 10\n6 5 4\n5 3\n1 2 -1\n3 3 4\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n5 6 7\n5 4 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 3 3\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n4 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n4 4 5\n5 6 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 5\n5 5 4\n5 3\n2 2 0\n4 4 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 7\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 6 7\n5 5 4\n10 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 11\n4 6 7\n5 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n4 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 6\n3 2 5\n5 6 1\n6 5 4\n5 3\n1 2 0\n3 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n5 6 7\n6 5 4\n5 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 10\n10 6 7\n6 5 1\n8 3\n1 1 -1\n2 3 2\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n"]}, {"input": "2\n14 4\n1 2 3\n3 4 10\n8 3 7\n6 5 4\n5 3\n1 1 -1\n2 3 1\n3 4 12\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 13\n1 14\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n2 2 3\n5 4 10\n5 6 7\n4 5 4\n10 1\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n0 2 3\n3 4 10\n5 6 7\n5 4 4\n5 3\n1 2 0\n6 2 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 2\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n2 3 4\n5 4 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 12\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n12 4\n1 2 3\n4 4 5\n5 7 10\n4 5 4\n5 3\n1 2 -1\n3 3 4\n3 1 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n4 1\n4 2\n4 3\n4 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n4 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 0\n4 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 4 10\n5 3 7\n5 5 4\n10 3\n2 4 0\n5 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 10\n7 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n5 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 1 3\n3 4 5\n6 6 7\n6 5 4\n5 3\n1 2 3\n0 3 4\n3 3 5\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n0 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 3 3\n4 4 6\n5 6 7\n6 4 4\n5 3\n1 2 5\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n5 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n8 4\n2 2 3\n4 4 10\n5 6 7\n6 5 4\n5 3\n1 1 -1\n2 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 2 3\n6 3 10\n5 6 5\n8 5 4\n10 3\n1 1 -1\n1 3 4\n3 4 6\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 1\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 1\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 0\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 4\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n1 2 3\n3 4 10\n5 6 7\n6 5 4\n4 3\n1 1 -1\n2 3 3\n5 4 14\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n1 12\n2 1\n2 3\n2 4\n"]}, {"input": "2\n12 4\n1 2 3\n3 1 8\n5 6 10\n6 5 1\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 5 7\n5 5 4\n5 3\n1 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n3 2 10\n7 6 20\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n6 5 4\n5 3\n0 1 0\n5 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 0\n4 1 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 10\n5 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n10 5 4\n5 3\n4 2 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n1 2 3\n3 4 5\n5 6 7\n5 5 4\n5 3\n0 4 1\n2 3 4\n4 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n2 2 6\n3 4 10\n0 6 7\n6 5 4\n4 3\n1 2 0\n2 2 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n"]}, {"input": "2\n9 4\n1 2 3\n5 4 10\n5 6 12\n6 5 8\n5 3\n1 1 0\n2 3 4\n3 5 7\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n1 4 3\n3 4 9\n4 6 3\n6 4 4\n5 3\n1 2 1\n2 1 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 1\n3 4 10\n12 6 12\n12 5 4\n5 3\n0 1 -1\n2 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n10 4\n1 3 3\n3 4 10\n5 6 7\n5 5 4\n5 3\n1 2 0\n2 3 0\n3 5 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n12 4\n2 3 4\n5 1 10\n5 6 7\n6 5 4\n10 0\n1 1 -1\n2 3 4\n3 7 6\n", "output": ["2 1\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 12\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n"]}, {"input": "2\n12 4\n1 2 6\n3 1 8\n5 6 10\n6 5 1\n5 3\n1 2 -1\n3 5 4\n3 1 5\n", "output": ["3 1\n3 2\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n3 11\n3 12\n3 1\n3 2\n3 4\n3 5\n"]}, {"input": "2\n7 4\n1 2 2\n3 6 10\n5 5 7\n5 5 4\n5 3\n2 2 0\n6 2 4\n3 4 10\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}, {"input": "2\n7 4\n0 2 2\n6 2 10\n7 6 20\n6 3 4\n5 3\n0 1 0\n4 3 4\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n7 6 12\n12 5 4\n5 3\n0 1 0\n5 3 6\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n"]}, {"input": "2\n7 4\n0 2 3\n3 2 10\n0 6 11\n6 5 4\n6 3\n1 1 1\n4 1 5\n3 4 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 1\n2 3\n2 4\n2 5\n2 6\n"]}, {"input": "2\n7 4\n0 2 1\n3 2 18\n5 6 12\n12 5 4\n6 3\n1 1 0\n4 1 3\n3 2 5\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n3 1\n3 2\n3 4\n3 5\n3 6\n"]}, {"input": "2\n7 4\n1 2 2\n3 2 11\n4 6 7\n10 5 4\n5 3\n4 3 0\n10 2 4\n3 4 4\n", "output": ["1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 2\n1 3\n1 4\n1 5\n"]}], "task_id": "codecontest/37", "prompt": "Lord Omkar wants to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has requested his disciples to construct the tree, introducing m (1 \u2264 m < n) restrictions to ensure the tree will be as divine as possible. A tree with n nodes is a connected undirected graph with n nodes and n-1 edges; for any pair of nodes, there is exactly one simple path connecting them, where a simple path is a route between two nodes that does not visit any node more than once. Here is an example of a tree: <image> A restriction comprises 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n), implying that node b cannot lie on the simple path linking node a and node c. Can you assist Lord Omkar and become his most faithful disciple? You will need to identify heavenly trees for multiple sets of restrictions. It can be demonstrated that a heavenly tree will always exist for any set of restrictions under the stated constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "repair_prompt": ["Lord Omkar wants to have a tree with n nodes (3 \u2264 n \u2264 10^5) and has requested his disciples to construct the tree, introducing m (1 \u2264 m < n) restrictions to ensure the tree will be as divine as possible. A tree with n nodes is a connected undirected graph with n nodes and n-1 edges; for any pair of nodes, there is exactly one simple path connecting them, where a simple path is a route between two nodes that does not visit any node more than once. Here is an example of a tree: <image> A restriction comprises 3 pairwise distinct integers, a, b, and c (1 \u2264 a,b,c \u2264 n), implying that node b cannot lie on the simple path linking node a and node c. Can you assist Lord Omkar and become his most faithful disciple? You will need to identify heavenly trees for multiple sets of restrictions. It can be demonstrated that a heavenly tree will always exist for any set of restrictions under the stated constraints.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n"], "completions": ["from typing import List\n## main.py\n\nimport typing\nimport networkx as nx\n\ndef construct_tree(t: int, test_cases: typing.List[typing.Tuple[int, int, typing.List[typing.Tuple[int, int, int]]]]) -> typing.List[typing.List[typing.Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: The number of nodes in the tree.\n            - m: The number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Create a graph with n nodes\n        G = nx.Graph()\n        G.add_nodes_from(range(1, n + 1))\n\n        # To satisfy the restrictions, we can choose a root and connect all other nodes to it\n        # This ensures that no node b lies on the path between any two other nodes a and c\n        root = 1  # Arbitrarily choose node 1 as the root\n        edges = []\n\n        for node in range(2, n + 1):\n            edges.append((root, node))\n            G.add_edge(root, node)\n\n        # Check if the constructed tree satisfies all restrictions\n        for a, b, c in restrictions:\n            # Ensure node b is not on the path between a and c\n            path = nx.shortest_path(G, source=a, target=c)\n            if b in path:\n                raise ValueError(\"Constructed tree does not satisfy the restrictions\")\n\n        results.append(edges)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        restrictions = [tuple(map(int, input().strip().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n\n    # Call the function and get the result\n    result = construct_tree(t, test_cases)\n\n    # Output interface\n    for edges in result:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"\n    Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): A list of test cases, each containing:\n            - n (int): Number of nodes in the tree.\n            - m (int): Number of restrictions.\n            - restrictions (List[Tuple[int, int, int]]): List of restrictions, each as a tuple (a, b, c).\n\n    Returns:\n        List[List[Tuple[int, int]]]: A list of edges for each test case, where each edge is represented as a tuple (u, v).\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # To construct the tree, we need to find a node that is not involved in any restrictions as node b.\n        # This node can be used as the root of the tree.\n        involved_as_b = set(b for _, b, _ in restrictions)\n        \n        # Find a node that is not involved as b\n        root = next(node for node in range(1, n + 1) if node not in involved_as_b)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = [(root, node) for node in range(1, n + 1) if node != root]\n        \n        results.append(edges)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n\n    # Output interface\n    results = construct_tree(t, test_cases)\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case based on the given restrictions.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): List of test cases, each containing:\n            - n (int): Number of nodes in the tree.\n            - m (int): Number of restrictions.\n            - restrictions (List[Tuple[int, int, int]]): List of restrictions, each containing three integers a, b, c.\n\n    Returns:\n        List[List[Tuple[int, int]]]: List of edges for each test case, representing the constructed tree.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Initialize a list to store the edges of the tree\n        edges = []\n\n        # To satisfy the restrictions, we can choose a node that is not 'b' in any restriction as the root\n        # We will use a set to track nodes that cannot be the root\n        restricted_nodes = set(b for _, b, _ in restrictions)\n\n        # Find a node that is not restricted to be the root\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n\n        # Connect the root to all other nodes to form a tree\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n\n        results.append(edges)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n    test_cases.append((n, m, restrictions))\n\n# Output interface\nresults = construct_tree(t, test_cases)\nfor result in results:\n    for edge in result:\n        print(edge[0], edge[1])\n", "from typing import List\n## main.py\n\nimport typing\nimport networkx as nx\n\ndef construct_tree(t: int, test_cases: typing.List[typing.Tuple[int, int, typing.List[typing.Tuple[int, int, int]]]]) -> typing.List[typing.List[typing.Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: The number of nodes in the tree.\n            - m: The number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree for a test case.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Initialize a graph with n nodes\n        G = nx.Graph()\n        G.add_nodes_from(range(1, n + 1))\n\n        # Choose a central node that will be connected to all other nodes\n        # Ensure the central node is not part of any restriction\n        restricted_nodes = set()\n        for a, b, c in restrictions:\n            restricted_nodes.update([a, b, c])\n\n        # Find a node that is not restricted\n        central_node = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n\n        # Connect the central node to all other nodes\n        for node in range(1, n + 1):\n            if node != central_node:\n                G.add_edge(central_node, node)\n\n        # Collect the edges of the graph\n        edges = list(G.edges())\n        results.append(edges)\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n\n    # Call the function and get the result\n    result = construct_tree(t, test_cases)\n\n    # Output the edges for each test case\n    for edges in result:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case based on the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c).\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # To satisfy the restrictions, we can choose a node that is not b in any (a, b, c) as the root.\n        # We can use a set to track all nodes that appear as b in any restriction.\n        b_nodes = set(b for _, b, _ in restrictions)\n\n        # Find a node that is not in b_nodes to use as the root.\n        root = next(node for node in range(1, n + 1) if node not in b_nodes)\n\n        # Construct the tree by connecting all other nodes to the root.\n        edges = [(root, node) for node in range(1, n + 1) if node != root]\n        results.append(edges)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        restrictions = [tuple(map(int, input().strip().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n\n    # Output interface\n    results = construct_tree(t, test_cases)\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_heavenly_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c).\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root.\n        # We will use a greedy approach to select a root node and connect it to all other nodes.\n        \n        # Find a node that is not 'b' in any restriction\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = [(root, node) for node in range(1, n + 1) if node != root]\n        results.append(edges)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n\n    results = construct_heavenly_tree(t, test_cases)\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case while satisfying the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c) representing a restriction.\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # To satisfy the restrictions, we can choose a root node that is not restricted\n        # and connect all other nodes to it. This ensures no restricted node lies on any path.\n        \n        # We will use a boolean array to mark restricted nodes\n        restricted = [False] * (n + 1)\n        \n        # Mark all nodes that are restricted\n        for a, b, c in restrictions:\n            restricted[b] = True\n        \n        # Find a node that is not restricted to use as the root\n        root = next(i for i in range(1, n + 1) if not restricted[i])\n        \n        # Create the tree by connecting all other nodes to the root\n        edges = []\n        for i in range(1, n + 1):\n            if i != root:\n                edges.append((root, i))\n        \n        results.append(edges)\n    \n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        \n        test_cases.append((n, m, restrictions))\n    \n    # Call the function\n    result = construct_tree(t, test_cases)\n    \n    # Output interface\n    for edges in result:\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"\n    Constructs a tree for each test case that satisfies the given restrictions.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): A list of test cases, each containing:\n            - n (int): Number of nodes in the tree.\n            - m (int): Number of restrictions.\n            - restrictions (List[Tuple[int, int, int]]): List of restrictions, each as a tuple (a, b, c).\n\n    Returns:\n        List[List[Tuple[int, int]]]: A list of edges for each test case, where each edge is represented as a tuple (u, v).\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # To satisfy the restrictions, we can choose a node that is not restricted as a middle node\n        # and connect it to all other nodes. This ensures no restricted node lies on the path between any two nodes.\n        \n        # We will use a set to track all nodes that are restricted as middle nodes\n        restricted_middle_nodes = set()\n\n        for a, b, c in restrictions:\n            restricted_middle_nodes.add(b)\n\n        # Find a node that is not in restricted_middle_nodes to use as the root\n        root = next(node for node in range(1, n + 1) if node not in restricted_middle_nodes)\n\n        # Construct the tree by connecting the root to all other nodes\n        edges = [(root, node) for node in range(1, n + 1) if node != root]\n        results.append(edges)\n\n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        restrictions = []\n        for _ in range(m):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            restrictions.append((a, b, c))\n            index += 3\n        test_cases.append((n, m, restrictions))\n    \n    # Call the function\n    results = construct_tree(t, test_cases)\n    \n    # Output interface\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_heavenly_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs heavenly trees for multiple test cases based on given restrictions.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): List of test cases, each containing:\n            - n (int): Number of nodes in the tree.\n            - m (int): Number of restrictions.\n            - restrictions (List[Tuple[int, int, int]]): List of restrictions, each containing three distinct integers a, b, c.\n\n    Returns:\n        List[List[Tuple[int, int]]]: List of edges for each test case, representing the constructed tree.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root.\n        # This ensures that no restriction is violated.\n        # We will use a greedy approach to select a root node and connect it to all other nodes.\n        \n        # Find a node that is not 'b' in any restriction\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n        \n        # Construct the tree by connecting the root to all other nodes\n        edges = [(root, node) for node in range(1, n + 1) if node != root]\n        \n        results.append(edges)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n    \n    results = construct_heavenly_tree(t, test_cases)\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef construct_tree(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"Constructs a tree for each test case based on the given restrictions.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of nodes in the tree.\n            - m: Number of restrictions.\n            - restrictions: A list of tuples, each containing three integers (a, b, c).\n\n    Returns:\n        A list of lists, where each inner list contains tuples representing the edges of the tree.\n    \"\"\"\n    results = []\n\n    for n, m, restrictions in test_cases:\n        # Initialize the adjacency list for the tree\n        edges = []\n\n        # To satisfy the restrictions, we can choose a node that is not involved in any restriction as the root\n        # Find a node that is not 'b' in any restriction\n        restricted_nodes = set(b for _, b, _ in restrictions)\n        root = next(node for node in range(1, n + 1) if node not in restricted_nodes)\n\n        # Connect all other nodes to the root\n        for node in range(1, n + 1):\n            if node != root:\n                edges.append((root, node))\n\n        results.append(edges)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        restrictions = [tuple(map(int, input().split())) for _ in range(m)]\n        test_cases.append((n, m, restrictions))\n\n    # Output interface\n    results = construct_tree(t, test_cases)\n    for result in results:\n        for edge in result:\n            print(edge[0], edge[1])\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe main requirement is to construct a tree that satisfies all given restrictions for multiple test cases. The solution must be efficient to handle the upper limits of input size and ensure the output format is correct for each test case.\nrequirement pool:\n- Construct a tree that satisfies all restrictions for each test case.\n- Ensure the solution is efficient for large input sizes.\n- Provide a clear and correct output format.\n- Optimize the algorithm for performance.\n- Include error handling for invalid inputs.\nWe will use NetworkX, a comprehensive graph library, to construct the tree efficiently. NetworkX provides tools for handling large graphs and can be used to ensure the tree structure meets all given restrictions. The approach involves iterating through each test case, constructing a tree, and checking restrictions using graph traversal methods.\n", "requirement analysis:\nThe requirements focus on constructing a tree with n nodes while adhering to m restrictions. The tree must be a connected undirected graph with n-1 edges, ensuring a simple path between any two nodes. The restrictions specify that certain nodes cannot lie on the path between two other nodes. The solution must handle multiple test cases efficiently, with the sum of n across all test cases not exceeding 10^5. The output must be formatted correctly, providing n-1 edges for each test case.\nrequirement pool:\n- Efficiently construct a tree with n nodes and n-1 edges\n- Ensure the tree meets all m restrictions for each test case\n- Handle multiple test cases with the sum of n not exceeding 10^5\n- Provide correct output format for n-1 edges per test case\n- Optimize the algorithm for large values of n\nWe will use a greedy approach to construct the tree. The key idea is to select a root node and connect it to all other nodes, ensuring that the restrictions are satisfied. By choosing a node that is not involved in any restrictions as the root, we can easily construct the tree. This approach is efficient and works within the constraints provided.\n", "requirement analysis:\nThe problem requires constructing a tree that satisfies specific path restrictions. The solution must efficiently handle large input sizes and ensure that the output format is correct. The algorithm should be designed to guarantee that all restrictions are met while maintaining the properties of a tree.\nrequirement pool:\n- Develop an efficient algorithm to construct the tree.\n- Ensure the algorithm meets all given restrictions.\n- Optimize the solution for large input sizes.\n- Provide clear documentation and code comments.\n- Implement additional test cases for validation.\nWe will use a greedy approach to construct the tree. The key idea is to select a root node and connect it to all other nodes, ensuring that the restrictions are satisfied. This approach leverages the fact that a tree with n nodes has exactly n-1 edges and is always connected. We will use a simple adjacency list to represent the tree and ensure that no restricted node lies on the path between any two other nodes by carefully choosing the root node.\n", "requirement analysis:\nThe problem requires constructing a tree that satisfies given restrictions for multiple test cases. The solution must efficiently handle large inputs and ensure that the constructed tree meets all restrictions. The output format is crucial and must be adhered to strictly.\nrequirement pool:\n- Efficiently construct a tree that satisfies all restrictions.\n- Ensure the solution can handle the maximum input size within time limits.\n- Maintain a clear and understandable code structure.\n- Provide detailed comments and documentation for the code.\n- Consider edge cases and validate input data.\nWe will use a greedy approach to construct the tree while ensuring that all restrictions are satisfied. The key idea is to start with a star-like structure where one node is connected to all others, and then adjust the connections to satisfy the restrictions. We will use the NetworkX library for efficient graph operations.\n", "requirement analysis:\nThe problem requires constructing a tree that satisfies given restrictions for multiple test cases. The solution must efficiently handle large inputs and ensure that the output format is strictly followed. The constraints guarantee that a valid tree always exists, which simplifies the problem to finding a valid construction method.\nrequirement pool:\n- Efficiently construct a tree that satisfies all restrictions.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and concise output formatting.\n- Maintain code readability and simplicity.\n- Include comments and documentation for better understanding.\nWe will use a simple approach to construct the tree by selecting a root node and connecting all other nodes to it. This ensures that no node lies on the path between any two other nodes, thus satisfying all restrictions. This approach is efficient and works within the constraints provided.\n", "requirement analysis:\nThe problem requires constructing a tree that satisfies given restrictions for multiple test cases. The solution must efficiently handle up to 10^5 nodes and restrictions, ensuring that the tree remains connected and adheres to the constraints. The output format is crucial for correctness.\nrequirement pool:\n- Efficiently construct a tree that satisfies all restrictions.\n- Ensure the solution handles the maximum input size within time limits.\n- Provide clear and understandable code for future maintenance.\n- Optimize the solution for both time and space complexity.\n- Include comments and documentation for better code readability.\nWe will use a greedy approach to construct the tree. The key idea is to select a root node and connect it to all other nodes, ensuring that the restrictions are satisfied. This approach leverages the fact that a tree with n nodes has n-1 edges and is inherently connected. We will use a simple adjacency list to represent the tree and ensure that the restrictions are met by carefully choosing the root node and connecting it to other nodes.\n", "requirement analysis:\nThe problem requires constructing a tree that satisfies a set of restrictions for multiple test cases. Each restriction specifies that a particular node cannot be on the path between two other nodes. The solution must efficiently handle up to 10^5 nodes and restrictions, ensuring that the tree remains connected and adheres to all constraints.\nrequirement pool:\n- Efficiently construct a tree for each test case that satisfies all restrictions.\n- Ensure the solution can handle the maximum input size within time limits.\n- Provide clear and understandable code for future maintenance.\n- Optimize the solution for both time and space complexity.\n- Include comments and documentation for better code readability.\nWe will use a greedy approach to construct the tree by ensuring that each restriction is satisfied. We will utilize a disjoint set (union-find) data structure to efficiently manage the connectivity of nodes and ensure that no restricted node lies on the path between specified nodes. This approach is efficient and scalable for large inputs, leveraging the union-find data structure to maintain and query connected components quickly.\n", "requirement analysis:\nThe main requirement is to construct a tree that satisfies all given restrictions for multiple test cases. The solution must be efficient to handle the upper limits of input size, ensuring that the sum of n across all test cases does not exceed 10^5. The output must be formatted correctly to pass all test cases.\nrequirement pool:\n- Develop an efficient algorithm to construct the tree with given restrictions\n- Ensure the solution handles the maximum input size effectively\n- Provide a clear and concise output format\n- Optimize the algorithm for speed and memory usage\n- Include comprehensive test cases to validate the solution\nWe will use a greedy approach to construct the tree. The key idea is to select a root node and connect it to all other nodes, ensuring that the restrictions are satisfied. This approach leverages the fact that a tree with n nodes has n-1 edges and is inherently connected. We will use a simple adjacency list to represent the tree and ensure that no restricted node lies on the path between any two other nodes by carefully selecting the root node.\n", "requirement analysis:\nThe problem requires constructing a tree that satisfies given restrictions for multiple test cases. The solution must efficiently handle up to 10^5 nodes and restrictions, ensuring that the tree remains connected and adheres to the constraints. The output must be formatted correctly for each test case, providing n-1 edges that form a valid tree.\nrequirement pool:\n- Efficiently construct a tree that satisfies all given restrictions.\n- Ensure the solution can handle the maximum input size within time limits.\n- Provide clear and concise output for each test case.\n- Maintain code readability and simplicity.\n- Include comments and documentation for better understanding.\nWe will use a greedy approach to construct the tree. The key idea is to select a root node and connect it to all other nodes, ensuring that the restrictions are satisfied. This approach leverages the fact that a tree with n nodes has n-1 edges and is inherently connected. We will use a simple adjacency list to represent the tree and ensure that the restrictions are respected by carefully choosing the root node and the connections.\n", "requirement analysis:\nThe task is to construct a tree with n nodes and n-1 edges while satisfying m restrictions. Each restriction specifies that a particular node cannot be on the path between two other nodes. The solution must handle multiple test cases efficiently, given the constraints on n and m.\nrequirement pool:\n- Implement the tree construction algorithm to satisfy the restrictions.\n- Ensure the solution is efficient for large values of n and m.\n- Optimize the input/output handling for multiple test cases.\n- Validate the tree structure to ensure it meets all restrictions.\n- Provide clear documentation and comments in the code.\nWe will implement a function to construct a tree with n nodes and n-1 edges while satisfying m restrictions. The approach involves selecting a root node and connecting all other nodes to it, ensuring that the restrictions are respected. This is possible because a tree with n nodes and n-1 edges is always connected and acyclic, and the problem guarantees that a solution exists for any set of restrictions. We will use a simple adjacency list to represent the tree and ensure that the restrictions are met by carefully choosing the root and connecting nodes.\n"], "scores": [], "pass_results": [true, true, true, true, true, false, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 506, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nThe first line of each test case contains two integers, n and m (3 \u2264 n \u2264 10^5, 1 \u2264 m < n), representing the size of the tree and the number of restrictions.\n\nThe i-th of the next m lines contains three integers a_i, b_i, c_i (1 \u2264 a_i, b_i, c_i \u2264 n, a, b, c are distinct), signifying that node b_i cannot lie on the simple path between nodes a_i and c_i. \n\nIt is guaranteed that the sum of n across all test cases will not exceed 10^5.\n\nOutput\n\nFor each test case, output n-1 lines representing the n-1 edges in the tree. On each line, output two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\n\nExample\n\nInput\n\n\n2\n7 4\n1 2 3\n3 4 5\n5 6 7\n6 5 4\n5 3\n1 2 3\n2 3 4\n3 4 5\n\n\nOutput\n\n\n1 2\n1 3\n3 5\n3 4\n2 7\n7 6\n5 1\n1 3\n3 2\n2 4\n\nNote\n\nThe output of the first sample case corresponds to the following tree: \n\n<image> For the first restriction, the simple path between 1 and 3 is 1, 3, which doesn't contain 2. The simple path between 3 and 5 is 3, 5, which doesn't contain 4. The simple path between 5 and 7 is 5, 3, 1, 2, 7, which doesn't contain 6. The simple path between 6 and 4 is 6, 7, 2, 1, 3, 4, which doesn't contain 5. Thus, this tree meets all of the restrictions.\n\nThe output of the second sample case corresponds to the following tree: \n", "mutate_method": "condense_two2one", "parent_index": 91}
