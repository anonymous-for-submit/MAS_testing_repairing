{"name": "1579_F. Array Stabilization (AND version)", "description": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "tags": ["brute force", "graphs", "math", "number theory", "shortest paths"], "difficulty": 12, "id": 1579, "sample_io": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}], "test_list": [{"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n2\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 4\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["-1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n2\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n1\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n4\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 0 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n0\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n2\n3\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n0\n", "output": ["-1\n1\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["-1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 0 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 5\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n-1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["0\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n-1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n0 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n0\n2\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 1\n5 3\n1 0 0 0 0\n4 4\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n1\n-1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 1\n5 4\n1 1 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n1\n3\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 5\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n-1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n1\n", "output": ["1\n0\n2\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["1\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 0 0\n5 1\n1 1 0 0 0\n4 1\n0 1 1 1\n1 1\n0\n", "output": ["0\n0\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n3\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 1 0 1\n1 1\n1\n", "output": ["-1\n1\n1\n3\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 1\n1 0 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["0\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 0\n5 2\n1 0 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n0\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 1 0\n4 1\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n3\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 4\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 1\n1 1 0 0 0\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n1 1 0\n5 4\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n2\n2\n2\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n1 1 0 0\n1 1\n0\n", "output": ["0\n1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 1 1\n1 1\n1\n", "output": ["1\n1\n2\n3\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["-1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 0 0\n4 1\n1 1 0 0\n1 1\n0\n", "output": ["0\n-1\n2\n2\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n1\n1\n-1\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 1\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 0 0\n5 1\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 1\n1 1 0 0 1\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["1\n0\n3\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 3\n0 1 0\n5 4\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["-1\n-1\n3\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 5\n0 0 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n0\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n-1\n-1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n1 1 1\n5 4\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 1\n1 0 1 0 0\n4 2\n0 1 0 1\n1 1\n1\n", "output": ["0\n1\n1\n-1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 1\n5 3\n0 0 1 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["0\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 3\n0 0 0\n5 3\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 1 1 0\n1 1\n0\n", "output": ["0\n2\n2\n2\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n1 1 0\n5 4\n1 1 1 1 1\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n2\n-1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n1 1 0\n5 2\n1 0 0 1 1\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["0\n2\n2\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 0 0 1\n1 1\n1\n", "output": ["-1\n1\n3\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n4\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n1 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n3\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 0 0\n5 3\n1 1 1 0 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n0\n2\n1\n-1\n"]}, {"input": "5\n2 2\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["-1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 4\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 2\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 1\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 1 0\n4 4\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n-1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["-1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 1 1 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 3\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 1 1 1 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["0\n-1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 2\n0 1 0\n5 2\n1 1 1 1 0\n4 2\n0 0 0 1\n1 1\n0\n", "output": ["0\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 0\n1 1\n0\n", "output": ["1\n-1\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["0\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 1 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n2\n2\n-1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n0 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 2\n0 0\n3 2\n0 0 1\n5 2\n1 1 0 0 1\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["0\n1\n2\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n3\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 0 0\n4 2\n0 1 1 1\n1 1\n0\n", "output": ["1\n1\n1\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 3\n1 1 1 0\n1 1\n0\n", "output": ["1\n2\n1\n3\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 0 0 0\n1 1\n0\n", "output": ["1\n1\n1\n0\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n-1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 3\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 1 0\n5 2\n1 1 1 1 0\n4 2\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n4\n-1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n0\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 1\n5 2\n1 1 0 0 0\n4 1\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 1 0\n5 2\n1 1 1 0 1\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 0 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n1\n1\n0\n"]}, {"input": "5\n2 2\n0 0\n3 3\n0 1 0\n5 1\n1 0 1 1 0\n4 1\n0 1 0 1\n1 1\n1\n", "output": ["0\n-1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 1 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n1\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 0 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n2\n1\n1\n0\n"]}, {"input": "5\n2 1\n1 0\n3 2\n0 0 0\n5 2\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n0\n", "output": ["1\n0\n4\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 3\n0 1 0\n5 3\n1 1 1 1 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n-1\n4\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 3\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n2\n-1\n"]}, {"input": "5\n2 1\n0 1\n3 2\n1 0 0\n5 2\n1 1 0 0 1\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 2\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n0 0 1\n5 2\n1 1 1 0 0\n4 3\n0 1 0 0\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 0\n3 1\n0 1 0\n5 2\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 1\n1 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 0\n1 1\n0\n", "output": ["1\n2\n3\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 3\n1 1 1 0 0\n4 3\n0 1 0 1\n1 1\n1\n", "output": ["1\n1\n2\n1\n-1\n"]}, {"input": "5\n2 1\n1 1\n3 1\n0 1 0\n5 4\n1 0 0 0 0\n4 2\n1 1 0 0\n1 1\n1\n", "output": ["-1\n1\n1\n1\n-1\n"]}, {"input": "5\n2 1\n0 0\n3 1\n0 1 0\n5 3\n1 1 0 0 0\n4 3\n1 0 0 0\n1 1\n0\n", "output": ["0\n1\n1\n1\n0\n"]}, {"input": "5\n2 1\n0 1\n3 2\n0 1 0\n5 1\n1 1 0 0 0\n4 3\n0 1 0 1\n1 1\n0\n", "output": ["1\n1\n2\n1\n0\n"]}], "task_id": "codecontest/18", "prompt": "You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Consider edge cases or specific conditions that might influence the result and ensure your code handles them efficiently.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "repair_prompt": ["You are given an array a[0 \u2026 n - 1] = [a_0, a_1, \u2026, a_{n - 1}] of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.\n\nIn one step, the array a is replaced by another array of length n according to the following rules: \n\n  1. First, a new array a^{\u2192 d} is defined as a cyclic shift of the array a to the right by d cells. The elements of this array can be defined as a^{\u2192 d}_i = a_{(i + n - d) mod n}, where (i + n - d) mod n is the remainder of integer division of i + n - d by n. \n\nIt means that the whole array a^{\u2192 d} can be represented as a sequence $$$a^{\u2192 d} = [a_{n - d}, a_{n - d + 1}, \u2026, a_{n - 1}, a_0, a_1, \u2026, a_{n - d - 1}]$$$\n\n  2. Then each element of the array a_i is replaced by a_i  \\&  a^{\u2192 d}_i, where \\& is a logical \"AND\" operator. \n\n\n\nFor example, if a = [0, 0, 1, 1] and d = 1, then a^{\u2192 d} = [1, 0, 0, 1] and the value of a after the first step will be [0  \\&  1, 0  \\&  0, 1  \\&  0, 1  \\&  1], that is [0, 0, 0, 1].\n\nThe process ends when the array stops changing. For a given array a, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes. Consider edge cases or specific conditions that might influence the result and ensure your code handles them efficiently.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Processes each test case to determine the number of steps required for the array to become all zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing:\n            - n: The size of the array.\n            - d: The cyclic shift offset.\n            - a: The array of zeroes and ones.\n\n    Returns:\n        A list of integers where each integer represents the number of steps required for the corresponding test case\n        to make the array all zeros. If the array never becomes all zeros, return -1 for that test case.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        steps = 0\n        seen_states = set()\n        \n        while True:\n            # Create the cyclic shifted array\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform the logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array is all zeros\n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            \n            # Check for cycles\n            state_tuple = tuple(new_a)\n            if state_tuple in seen_states:\n                results.append(-1)\n                break\n            \n            # Update the array and steps\n            a = new_a\n            steps += 1\n            seen_states.add(state_tuple)\n    \n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    # Process test cases\n    results = process_test_cases(test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef number_of_steps_to_all_zeros(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the number of steps required for each test case to make the array all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Size of the array.\n            - d (int): Cyclic shift offset.\n            - a (List[int]): The array of zeroes and ones.\n\n    Returns:\n        List[int]: List of results for each test case, where each result is the number of steps\n                   to make the array all zeros, or -1 if it never becomes all zeros.\n    \"\"\"\n    results = []\n\n    for n, d, a in test_cases:\n        seen_states = set()\n        steps = 0\n\n        while True:\n            # Check if the array is already all zeros\n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n\n            # Convert the array to a tuple to store in the set\n            state = tuple(a)\n            if state in seen_states:\n                # If the state is repeated, it means we are in a cycle\n                results.append(-1)\n                break\n\n            # Add the current state to the set\n            seen_states.add(state)\n\n            # Perform the cyclic shift and logical AND operation\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            a = [a[i] & a_shifted[i] for i in range(n)]\n\n            steps += 1\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n\n    # Call the function and print results\n    results = number_of_steps_to_all_zeros(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Processes each test case to determine the number of steps required for the array to become all zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing:\n            - n: The size of the array.\n            - d: The cyclic shift offset.\n            - a: The array of zeroes and ones.\n\n    Returns:\n        A list of integers where each integer represents the number of steps required for the corresponding test case\n        to make the array all zeros, or -1 if the array does not become all zeros.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            # Perform cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array has become all zeros\n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            \n            # Check if the array stops changing\n            if new_a == a:\n                results.append(-1)\n                break\n            \n            # Update the array and increment step count\n            a = new_a\n            steps += 1\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    results = process_test_cases(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_array(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Processes each test case by performing cyclic shifts and logical AND operations\n    until the array becomes all zeros or it is determined that it will never become all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing\n            the size of the array, the cyclic shift offset, and the array itself.\n\n    Returns:\n        List[int]: A list of integers representing the number of steps for each test case\n        or -1 if the array never becomes all zeros.\n    \"\"\"\n    results = []\n\n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            # Perform the cyclic shift\n            a_shifted = a[-d:] + a[:-d]\n            \n            # Perform the logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array is all zeros\n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            \n            # If the array doesn't change, it will never become all zeros\n            if new_a == a:\n                results.append(-1)\n                break\n            \n            # Update the array and increment the step count\n            a = new_a\n            steps += 1\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    # Call the function and print the results\n    results = process_array(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_array(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Process each test case to determine the number of steps until the array becomes all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Size of the array.\n            - d (int): Cyclic shift offset.\n            - a (List[int]): Array of zeroes and ones.\n\n    Returns:\n        List[int]: Number of steps for each test case to become all zeros, or -1 if it never does.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            # Perform cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array has stabilized\n            if new_a == a:\n                if all(x == 0 for x in new_a):\n                    results.append(steps)\n                else:\n                    results.append(-1)\n                break\n            \n            # Update the array and increment step count\n            a = new_a\n            steps += 1\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    results = process_array(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Process each test case to determine the number of steps until the array consists only of zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing:\n            - n: The size of the array.\n            - d: The cyclic shift offset.\n            - a: The array of zeroes and ones.\n\n    Returns:\n        A list of integers where each integer represents the number of steps required for the corresponding\n        test case to result in an array of all zeros. If it never results in all zeros, return -1.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            # Create the cyclically shifted array\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform the logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array has stabilized\n            if new_a == a:\n                if all(x == 0 for x in a):\n                    results.append(steps)\n                else:\n                    results.append(-1)\n                break\n            \n            # Update the array and increment the step count\n            a = new_a\n            steps += 1\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    results = process_test_cases(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_array(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Process each test case to determine the number of steps required for the array to become all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Size of the array.\n            - d (int): Cyclic shift offset.\n            - a (List[int]): Array of zeroes and ones.\n\n    Returns:\n        List[int]: List of results for each test case, indicating the number of steps to reach all zeros or -1 if impossible.\n    \"\"\"\n    results = []\n\n    for n, d, a in test_cases:\n        steps = 0\n        previous_a = None\n\n        while a != previous_a:\n            previous_a = a.copy()\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            a = [a[i] & a_shifted[i] for i in range(n)]\n            steps += 1\n\n            if all(x == 0 for x in a):\n                results.append(steps)\n                break\n        else:\n            results.append(-1)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n\n    results = process_array(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_array(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Processes each test case to determine the number of steps required for the array to become all zeros.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): List of test cases, each containing:\n            - n (int): Size of the array.\n            - d (int): Cyclic shift offset.\n            - a (List[int]): Array of zeroes and ones.\n\n    Returns:\n        List[int]: Number of steps for each test case to become all zeros, or -1 if it never does.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            # Perform cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array has stabilized\n            if new_a == a:\n                if all(x == 0 for x in new_a):\n                    results.append(steps)\n                else:\n                    results.append(-1)\n                break\n            \n            # Update the array and increment step count\n            a = new_a\n            steps += 1\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    results = process_array(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Process each test case to determine the number of steps required for the array to become all zeros.\n\n    Args:\n        test_cases: A list of tuples, each containing:\n            - n: The size of the array.\n            - d: The cyclic shift offset.\n            - a: The array of zeroes and ones.\n\n    Returns:\n        A list of integers where each integer represents the number of steps required for the array to become all zeros.\n        If the array never becomes all zeros, return -1 for that test case.\n    \"\"\"\n    results = []\n\n    for n, d, a in test_cases:\n        steps = 0\n        seen_states = set()\n        \n        while True:\n            # Create the cyclic shifted array\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform the logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array is all zeros\n            if all(x == 0 for x in new_a):\n                results.append(steps)\n                break\n            \n            # Check if the array state is repeating\n            state_tuple = tuple(new_a)\n            if state_tuple in seen_states:\n                results.append(-1)\n                break\n            \n            # Update the array and increment the step count\n            a = new_a\n            seen_states.add(state_tuple)\n            steps += 1\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    results = process_test_cases(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_arrays(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Processes each test case to determine the number of steps required for the array to become all zeroes.\n\n    Args:\n        test_cases: A list of tuples, each containing:\n            - n: The size of the array.\n            - d: The cyclic shift offset.\n            - a: The array of zeroes and ones.\n\n    Returns:\n        A list of integers where each integer represents the number of steps required for the corresponding test case\n        to make the array all zeroes. If the array never becomes all zeroes, return -1 for that test case.\n    \"\"\"\n    results = []\n    \n    for n, d, a in test_cases:\n        steps = 0\n        while True:\n            # Perform cyclic shift\n            a_shifted = [a[(i + n - d) % n] for i in range(n)]\n            \n            # Perform logical AND operation\n            new_a = [a[i] & a_shifted[i] for i in range(n)]\n            \n            # Check if the array has changed\n            if new_a == a:\n                # If no change, check if all elements are zero\n                if all(x == 0 for x in a):\n                    results.append(steps)\n                else:\n                    results.append(-1)\n                break\n            \n            # Update the array and increment step count\n            a = new_a\n            steps += 1\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, d = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, d, a))\n    \n    # Output interface\n    results = process_arrays(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming an array of binary values through cyclic shifts and logical operations until a stable state is reached. The challenge lies in efficiently handling large arrays and ensuring the process terminates correctly. Edge cases, such as arrays that do not change, must be considered to avoid infinite loops.\nrequirement pool:\n- Implement the cyclic shift and logical AND operation\n- Ensure termination of the process when the array stabilizes\n- Optimize for large input sizes and performance\n- Handle edge cases where the array does not change\n- Maintain consistent output format as per requirements\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations on the array until it stabilizes or becomes all zeros. We will use efficient list operations to handle large arrays and ensure the process terminates correctly. The function will also handle edge cases where the array does not change by checking for cycles in the transformation process.\n", "requirement analysis:\nThe problem requires an efficient algorithm to determine the number of steps needed for an array of binary values to become all zeros after cyclic shifts and logical AND operations. The solution must handle large input sizes and edge cases where the array may never become all zeros.\nrequirement pool:\n- Efficiently process arrays with up to 10^6 elements.\n- Accurately determine the number of steps for each test case.\n- Handle edge cases where the array does not change.\n- Optimize for minimal memory usage.\n- Provide clear and concise output format.\nWe will implement a function that simulates the process of cyclically shifting the array and performing logical AND operations until the array becomes all zeros or it is determined that it will never become all zeros. The function will efficiently handle large input sizes by using a set to track the states of the array to detect cycles, which indicates that the array will never become all zeros.\n", "requirement analysis:\nThe requirements focus on processing arrays of binary values with cyclic shifts and logical operations. The challenge lies in efficiently handling large input sizes and ensuring the process terminates correctly, either with an array of zeros or identifying non-zero elements. Edge cases, such as arrays that do not change, must be considered.\nrequirement pool:\n- Efficiently handle large input sizes up to 10^6\n- Ensure accurate results for all test cases\n- Optimize performance for high input limits\n- Handle edge cases gracefully\n- Provide clear and concise output\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations on the array until it either becomes all zeros or stops changing. We will use efficient list operations to handle large input sizes and ensure the process terminates correctly. The function will return the number of steps required or -1 if the array does not become all zeros.\n", "requirement analysis:\nThe problem requires an efficient algorithm to determine the number of steps needed for an array of binary values to become all zeros after cyclic shifts and logical AND operations. The solution must handle up to 10^6 elements across multiple test cases, ensuring performance and correctness.\nrequirement pool:\n- Implement the main algorithm to perform cyclic shifts and logical AND operations\n- Optimize the solution to handle large inputs efficiently\n- Ensure the output format is consistent with the requirements\n- Handle edge cases where the array does not change\n- Provide clear documentation and comments in the code\nWe will implement a function that performs cyclic shifts and logical AND operations on the array. The function will iterate until the array becomes all zeros or it is determined that it will never become all zeros. We will use efficient list operations to handle the cyclic shift and logical AND operations. The solution will be optimized to handle the maximum constraints efficiently.\n", "requirement analysis:\nThe requirements focus on processing arrays of binary values through cyclic shifts and logical operations until a stable state is reached. The challenge lies in efficiently handling large input sizes and ensuring the process terminates correctly.\nrequirement pool:\n- Implement cyclic shift and logical AND operation\n- Ensure termination condition is correctly identified\n- Optimize for large input sizes\n- Handle edge cases where the array does not change\n- Provide clear and concise output for each test case\nWe will implement a function that performs cyclic shifts and logical AND operations on the array until it stabilizes. The function will efficiently handle large input sizes by using modular arithmetic for cyclic shifts and will track changes to determine when the array becomes all zeros or stops changing.\n", "requirement analysis:\nThe requirements focus on processing an array of binary values through cyclic shifts and logical operations until a stable state is reached. The main challenge is to efficiently handle large arrays and multiple test cases while ensuring the output is accurate and meets the specified conditions. Edge cases, such as arrays that do not change or take a long time to stabilize, must be considered.\nrequirement pool:\n- Efficiently process arrays up to 10^6 in size\n- Correctly determine the number of steps to reach an all-zero array\n- Handle edge cases where the array does not change\n- Optimize for speed and memory usage\n- Provide clear error messages for invalid inputs\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations until the array stabilizes. The function will efficiently handle large arrays using list operations and modular arithmetic. We will use Python's built-in capabilities for list manipulation and logical operations, ensuring the solution is both efficient and easy to understand.\n", "requirement analysis:\nThe problem requires simulating a process where an array of binary values is cyclically shifted and modified using a logical AND operation until it becomes all zeros or stabilizes. The solution must efficiently handle large input sizes and multiple test cases, ensuring correctness and optimal performance.\nrequirement pool:\n- Implement the cyclic shift and AND operation efficiently.\n- Ensure the solution handles up to 10^6 elements across all test cases.\n- Optimize the solution to minimize computational steps.\n- Provide clear and maintainable code.\n- Include detailed comments and documentation.\nWe will implement a function that simulates the cyclic shift and logical AND operation on the array until it becomes all zeros or stabilizes. The approach will use efficient list operations to handle large input sizes and ensure correctness across all edge cases. We will use Python's built-in list manipulation capabilities to perform the cyclic shift and logical operations efficiently.\n", "requirement analysis:\nThe requirements focus on processing arrays of binary values through cyclic shifts and logical operations until a stable state is reached. The challenge lies in efficiently handling large arrays and ensuring the process terminates correctly, especially in edge cases where the array may not change.\nrequirement pool:\n- Implement efficient cyclic shift and logical AND operations\n- Ensure termination condition is correctly identified\n- Optimize for large input sizes\n- Handle edge cases where the array does not change\n- Provide clear output format as specified\nWe will implement a function that performs cyclic shifts and logical AND operations on the array until it stabilizes. The function will efficiently handle large arrays by using modular arithmetic for cyclic shifts and will track changes to determine when the array becomes all zeros or stops changing. We will use Python's built-in list operations for simplicity and efficiency.\n", "requirement analysis:\nThe requirements focus on processing arrays of binary values with cyclic shifts and logical operations. The main challenge is ensuring the process terminates correctly and efficiently, especially for large input sizes. Edge cases, such as arrays that do not change, must be handled accurately.\nrequirement pool:\n- Implement the cyclic shift and logical AND operation efficiently\n- Ensure the process terminates correctly for all test cases\n- Optimize the code for performance and memory usage\n- Handle edge cases where the array does not change\n- Provide clear documentation and maintainability\nWe will implement a function that processes each test case by performing cyclic shifts and logical AND operations on the array. The function will continue these operations until the array becomes all zeros or it is determined that it will never become all zeros. We will use efficient list operations to handle large input sizes and ensure the process terminates correctly. The approach will involve checking for cycles in the transformation to detect if the array will never become all zeros.\n", "requirement analysis:\nThe requirements focus on processing arrays of zeroes and ones with cyclic shifts and logical operations. The main challenge is ensuring the process ends efficiently and correctly, especially for large arrays and edge cases.\nrequirement pool:\n- Implement efficient cyclic shift and logical AND operations.\n- Ensure the process terminates correctly for all test cases.\n- Optimize for large array sizes up to 10^6 elements.\n- Handle edge cases where the array does not change.\n- Provide detailed output for each test case.\nWe will implement a function that performs cyclic shifts and logical AND operations on arrays of zeroes and ones. The function will iterate until the array becomes all zeroes or no changes occur. We will use efficient list operations to handle large arrays and ensure the process terminates correctly. The approach will focus on balancing speed and accuracy, using Python's built-in capabilities for list manipulation.\n"], "scores": [], "pass_results": [true, true, false, false, false, false, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 300, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases. \n\nThe first line of each test case description contains two integers: n (1 \u2264 n \u2264 10^6) \u2014 array size and d (1 \u2264 d \u2264 n) \u2014 cyclic shift offset. The second line of the description contains n space-separated integers a_i (0 \u2264 a_i \u2264 1) \u2014 elements of the array.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer \u2014 the number of steps after which the array will contain only zeros for the first time. If there are still elements equal to 1 in the array after the end of the process, print -1.\n\nExample\n\nInput\n\n\n5\n2 1\n0 1\n3 2\n0 1 0\n5 2\n1 1 0 1 0\n4 2\n0 1 0 1\n1 1\n0\n\n\nOutput\n\n\n1\n1\n3\n-1\n0\n\nNote\n\nIn the third sample test case the array will change as follows: \n\n  1. At the beginning a = [1, 1, 0, 1, 0], and a^{\u2192 2} = [1, 0, 1, 1, 0]. Their element-by-element \"AND\" is equal to $$$[1  \\&  1, 1  \\&  0, 0  \\&  1, 1  \\&  1, 0  \\&  0] = [1, 0, 0, 1, 0]$$$ \n  2. Now a = [1, 0, 0, 1, 0], then a^{\u2192 2} = [1, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  1, 0  \\&  0, 0  \\&  1, 1  \\&  0, 0  \\&  0] = [1, 0, 0, 0, 0]$$$ \n  3. And finally, when a = [1, 0, 0, 0, 0] we get a^{\u2192 2} = [0, 0, 1, 0, 0]. Their element-by-element \"AND\" equals to $$$[1  \\&  0, 0  \\&  0, 0  \\&  1, 0  \\&  0, 0  \\&  0] = [0, 0, 0, 0, 0]$$$ \n\nThus, the answer is 3 steps.\n\nIn the fourth sample test case, the array will not change as it shifts by 2 to the right, so each element will be calculated as 0  \\&  0 or 1  \\&  1 thus not changing its value. So the answer is -1, the array will never contain only zeros.", "mutate_method": "add_1_sentence_at_end", "parent_index": 9}
