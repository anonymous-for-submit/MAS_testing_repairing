{"name": "1598_D. Training Session", "description": "Monocarp is the coach of the Berland State University programming teams. He decided to compose a problemset for a training session for his teams.\n\nMonocarp has n problems that none of his students have seen yet. The i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n). All problems are different, that is, there are no two tasks that have the same topic and difficulty at the same time.\n\nMonocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both):\n\n  * the topics of all three selected problems are different; \n  * the difficulties of all three selected problems are different. \n\n\n\nYour task is to determine the number of ways to select three problems for the problemset.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "tags": ["combinatorics", "data structures", "geometry", "implementation", "math"], "difficulty": 10, "id": 1598, "sample_io": [{"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}], "test_list": [{"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n0\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n0\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n1 2\n5 1\n", "output": ["2\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 3\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["0\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n2 2\n5 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 2\n3 3\n3 2\n4 2\n", "output": ["3\n6\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n0\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n0\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n1 1\n5 1\n", "output": ["4\n6\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n4 5\n4 2\n4 1\n", "output": ["2\n4\n"]}, {"input": "2\n4\n4 4\n1 4\n3 2\n3 3\n0\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n0\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 5\n1 1\n5 1\n", "output": ["3\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 2\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n4 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 1\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 4\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 3\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 1\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 1\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n2 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 4\n3 4\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 1\n2 1\n2 3\n5\n1 5\n4 4\n3 3\n4 3\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n2 3\n3 4\n4 3\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n1 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 3\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 4\n1 4\n4 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n1 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n4 4\n3 2\n4 3\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n2 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 5\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n1 5\n3 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 2\n", "output": ["3\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 3\n3 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n2 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 5\n3 3\n4 2\n1 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 5\n2 4\n3 1\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n1 2\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 1\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 3\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n4 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 4\n5 3\n4 2\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 1\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 1\n5\n2 5\n2 4\n2 1\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n4 1\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 3\n4 2\n4 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n3 2\n2 3\n5\n1 5\n1 3\n3 3\n4 2\n2 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n4 3\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n2 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 4\n5\n1 5\n2 4\n1 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 3\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n5 5\n2 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n2 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 3\n3 2\n4 4\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n2 5\n2 4\n3 3\n3 2\n4 2\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 3\n1 3\n5\n1 5\n2 4\n5 5\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 4\n3 5\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 1\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n2 1\n3 4\n2 3\n4 2\n5 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n3 4\n1 4\n2 2\n3 3\n5\n1 5\n2 4\n2 1\n4 2\n4 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 1\n1 3\n5\n1 5\n2 1\n1 2\n4 1\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 5\n2 3\n4 2\n5 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n4 4\n5 2\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n2 3\n5\n1 5\n3 4\n3 1\n3 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n3 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 3\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n4 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 1\n5\n2 5\n2 3\n3 3\n4 2\n2 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 1\n3 1\n2 2\n2 3\n5\n1 2\n2 4\n5 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 1\n1 2\n2 1\n5\n1 5\n2 4\n3 3\n4 1\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n3 3\n5\n2 5\n2 4\n3 2\n4 2\n3 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n3 4\n1 2\n2 2\n2 3\n5\n2 5\n2 4\n2 2\n4 2\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 1\n3 3\n1 1\n5 1\n", "output": ["3\n8\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n1 3\n5\n1 4\n2 4\n3 2\n4 2\n4 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n4 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n5 3\n2 1\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n4 3\n4 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n3 3\n5\n2 5\n2 4\n2 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 2\n2 4\n1 5\n2 2\n5 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n4 4\n3 3\n4 2\n2 3\n5\n1 5\n2 4\n4 3\n4 1\n5 1\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n2 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n1 2\n2 2\n1 4\n4 2\n5 1\n", "output": ["4\n8\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n1 3\n5\n1 5\n2 4\n3 3\n5 4\n5 2\n", "output": ["4\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 2\n4 4\n5\n1 5\n4 4\n3 3\n4 2\n4 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 4\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n1 4\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n2 2\n2 4\n3 3\n4 4\n4 1\n", "output": ["2\n8\n"]}, {"input": "2\n4\n2 4\n1 1\n2 2\n2 3\n5\n1 5\n1 4\n2 3\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n4 1\n1 3\n5\n1 5\n2 1\n3 3\n3 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 1\n3 5\n4 2\n4 1\n", "output": ["2\n7\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n2 5\n2 3\n3 3\n4 4\n1 1\n", "output": ["3\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n1 1\n1 3\n5\n1 5\n2 4\n3 4\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n5 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n4 4\n1 4\n2 2\n3 3\n5\n1 4\n2 4\n3 5\n4 2\n4 1\n", "output": ["4\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 3\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 1\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n4 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 2\n2 4\n3 3\n4 2\n4 1\n", "output": ["2\n9\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n4 4\n2 3\n4 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 3\n2 2\n2 3\n5\n1 5\n2 4\n3 3\n1 2\n5 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n1 2\n2 3\n5\n1 5\n2 3\n3 3\n4 2\n5 1\n", "output": ["3\n10\n"]}, {"input": "2\n4\n2 4\n3 4\n2 2\n2 3\n5\n1 5\n1 4\n3 3\n4 2\n2 1\n", "output": ["2\n10\n"]}, {"input": "2\n4\n4 4\n3 4\n2 2\n2 3\n5\n2 5\n2 4\n3 3\n4 2\n1 1\n", "output": ["4\n10\n"]}], "task_id": "codecontest/61", "prompt": "Monocarp, the coach of Berland State University's programming teams, chose to create a problem set for training sessions for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), meaning all problems are different with no two tasks having the same topic or difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Ensure that your solution efficiently handles cases where n is large.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "repair_prompt": ["Monocarp, the coach of Berland State University's programming teams, chose to create a problem set for training sessions for his teams. Monocarp has n problems that none of his students have seen yet, where the i-th problem has a topic a_i (an integer from 1 to n) and a difficulty b_i (an integer from 1 to n), meaning all problems are different with no two tasks having the same topic or difficulty at the same time. Monocarp decided to select exactly 3 problems from n problems for the problemset. The problems should satisfy at least one of two conditions (possibly, both): the topics of all three selected problems are different; the difficulties of all three selected problems are different. Your task is to determine the number of ways to select three problems for the problemset. Ensure that your solution efficiently handles cases where n is large.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_combinations(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid combinations of problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid combinations for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not unique\n        invalid_combinations = 0\n\n        for topic, difficulty in problems:\n            # Subtract combinations where the current topic or difficulty is repeated\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n    results = count_valid_combinations(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Subtract combinations where neither condition is met\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total minus invalid\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import Counter\nfrom math import comb\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of ways to select three problems such that either all topics or all difficulties are different.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: A list of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = Counter()\n        difficulty_count = Counter()\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Total ways to choose any 3 problems\n        total_ways = comb(n, 3)\n\n        # Subtract invalid ways where not all topics or difficulties are different\n        invalid_ways = 0\n        for topic, difficulty in problems:\n            # Calculate the number of ways to choose 2 more problems with the same topic or difficulty\n            invalid_ways += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid ways are total ways minus invalid ways\n        valid_ways = total_ways - invalid_ways\n        results.append(valid_ways)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of topic and difficulty.\n\n    Returns:\n        A list of integers where each integer represents the number of valid problem sets for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of selecting 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not unique\n        invalid_combinations = 0\n\n        for topic, count in topic_count.items():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        for difficulty, count in difficulty_count.items():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Subtract invalid combinations from total combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print the results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\ndef count_valid_problem_sets(t: int, test_cases: list) -> list:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the number of problems\n                           and a list of problems represented as tuples of topic and difficulty.\n\n    Returns:\n        list: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Dictionaries to count occurrences of each topic and difficulty\n        topic_count = {}\n        difficulty_count = {}\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            if topic not in topic_count:\n                topic_count[topic] = 0\n            if difficulty not in difficulty_count:\n                difficulty_count[difficulty] = 0\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not unique\n        invalid_combinations = 0\n\n        for topic, count in topic_count.items():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        for difficulty, count in difficulty_count.items():\n            if count >= 2:\n                invalid_combinations += count * (count - 1) // 2 * (n - count)\n\n        # Calculate valid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Interface using input() and print()\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Count the number of valid sets of three problems for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid sets of three problems for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for a_i, b_i in problems:\n            topic_count[a_i] += 1\n            difficulty_count[b_i] += 1\n\n        # Calculate total combinations of 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not all different\n        invalid_combinations = 0\n        for a_i, b_i in problems:\n            # Subtract combinations where two problems share the same topic or difficulty\n            invalid_combinations += (topic_count[a_i] - 1) * (difficulty_count[b_i] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    problems = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, problems))\n\n# Output interface\nresults = count_valid_problem_sets(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of valid problem sets for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing the number of problems\n            and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not unique\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of problems and a list of problems.\n                    Each problem is represented as a tuple of topic and difficulty.\n\n    Returns:\n        A list of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Initialize dictionaries to count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        # Count occurrences of each topic and difficulty\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not all different\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Calculate invalid combinations for the current problem\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Call the function and print results\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Calculate the number of ways to select three problems for the problem set.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: List of integers representing the number of valid problem sets for each test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate total combinations of 3 problems\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Calculate invalid combinations where topics or difficulties are not unique\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Calculate invalid combinations for this specific problem\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    # Output interface\n    results = count_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef count_valid_problem_sets(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"Counts the number of valid problem sets for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of test cases, each containing\n            the number of problems and a list of tuples representing the topic and difficulty of each problem.\n\n    Returns:\n        List[int]: A list of integers where each integer represents the number of valid problem sets\n        for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, problems in test_cases:\n        # Calculate total combinations of choosing 3 problems from n\n        total_combinations = n * (n - 1) * (n - 2) // 6\n\n        # Count occurrences of each topic and difficulty\n        topic_count = defaultdict(int)\n        difficulty_count = defaultdict(int)\n\n        for topic, difficulty in problems:\n            topic_count[topic] += 1\n            difficulty_count[difficulty] += 1\n\n        # Calculate invalid combinations\n        invalid_combinations = 0\n        for topic, difficulty in problems:\n            # Subtract combinations where all three problems have the same topic or difficulty\n            invalid_combinations += (topic_count[topic] - 1) * (difficulty_count[difficulty] - 1)\n\n        # Valid combinations are total combinations minus invalid combinations\n        valid_combinations = total_combinations - invalid_combinations\n        results.append(valid_combinations)\n\n    return results\n\n# Interface using input() and print()\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        test_cases.append((n, problems))\n\n    results = count_valid_problem_sets(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle large input sizes, as the sum of n over all test cases can be up to 200,000. The approach should focus on optimizing the selection process to ensure performance and accuracy.\nrequirement pool:\n- Efficiently handle large input sizes\n- Ensure accurate problem selection\n- Optimize for performance and speed\n- Provide clear and concise output\n- Include detailed comments and documentation\nWe will use a combinatorial approach to solve this problem efficiently. The key is to count the number of valid combinations of three problems that satisfy the given conditions. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle large input sizes, as the sum of n over all test cases can be up to 200,000. The approach should focus on optimizing the selection process to ensure both conditions are checked effectively.\nrequirement pool:\n- Efficiently handle large input sizes\n- Ensure accurate problem selection\n- Optimize for performance and speed\n- Provide clear and concise output\n- Include detailed comments and documentation\nWe will use combinatorial counting to efficiently determine the number of ways to select three problems that meet the given conditions. The approach involves calculating the total number of combinations of three problems and subtracting the invalid combinations where neither condition is met. We will utilize Python's collections library to count occurrences of topics and difficulties, which will help in determining invalid combinations.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either all topics or all difficulties are different. The solution must efficiently handle large input sizes, up to 200,000 problems in total across all test cases. The constraints ensure that no two problems have the same topic and difficulty simultaneously, simplifying the selection process.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems.\n- Ensure that selected problems have either all different topics or all different difficulties.\n- Optimize the algorithm for performance and speed.\n- Provide clear and accurate output for each test case.\n- Consider edge cases and ensure robustness.\nWe will use combinatorial counting to efficiently determine the number of ways to select three problems such that either all topics or all difficulties are different. We will utilize Python's collections library to count occurrences and combinations to calculate the number of valid selections.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle large input sizes, as the sum of n over all test cases can be up to 200,000. The approach should focus on optimizing the selection process to ensure performance and accuracy.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000.\n- Ensure accurate selection of problems meeting the criteria.\n- Optimize the algorithm for performance and speed.\n- Provide clear and reliable output for each test case.\n- Consider edge cases and ensure robustness.\nWe will use a combinatorial approach to solve this problem efficiently. The key is to count the number of ways to select three problems such that they satisfy the given conditions. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle large input sizes, as the sum of n across all test cases can be up to 200,000.\nrequirement pool:\n- Efficiently handle large input sizes\n- Ensure accurate problem selection\n- Optimize for performance and speed\n- Provide clear and correct output format\n- Include comprehensive test cases\nWe will use a combinatorial approach to solve this problem efficiently. The key is to count the number of ways to select three problems such that they satisfy the given conditions. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle large values of n, up to 200,000, and multiple test cases, up to 50,000. The constraints ensure that no two problems have the same topic and difficulty simultaneously, simplifying the selection process.\nrequirement pool:\n- Efficiently handle large input sizes and constraints.\n- Ensure the solution is optimized for performance and speed.\n- Provide accurate and reliable outputs for all test cases.\n- Implement a robust algorithm to select problems based on given conditions.\n- Maintain code readability and maintainability.\nWe will use combinatorial counting to efficiently determine the number of valid sets of three problems. The key is to count combinations where either topics or difficulties are all different, leveraging Python's collections library for efficient counting and handling large input sizes.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle large input sizes, up to 200,000 problems in total across all test cases.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000.\n- Ensure that selected problems meet the topic or difficulty criteria.\n- Optimize the solution for performance and speed.\n- Provide clear and correct output for each test case.\n- Consider edge cases where n is minimal or maximal.\nWe will use combinatorial counting to efficiently determine the number of valid problem sets. The key is to count combinations of problems that satisfy the conditions using hash maps to track occurrences of topics and difficulties. This approach will leverage Python's collections library for efficient counting and will handle large input sizes by processing each test case independently.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that either all topics or all difficulties are different. The solution must efficiently handle large input sizes, up to 200,000 problems in total across all test cases.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000.\n- Ensure that selected problems have either different topics or difficulties.\n- Optimize the solution for performance and speed.\n- Provide accurate results for all test cases.\n- Implement a user-friendly interface for input and output.\nWe will use a combinatorial approach to solve this problem efficiently. The key is to count the number of ways to select three problems such that either all topics or all difficulties are different. We will use dictionaries to count occurrences of each topic and difficulty, and then use these counts to calculate the number of valid combinations. This approach ensures that we handle large input sizes efficiently.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle large input sizes, up to 200,000 problems in total across all test cases. The constraints ensure that no two problems have the same topic and difficulty simultaneously, which simplifies the selection process.\nrequirement pool:\n- Efficiently handle large input sizes up to 200,000 problems.\n- Ensure accurate selection of problem sets meeting the given conditions.\n- Optimize the algorithm for performance and speed.\n- Provide clear and concise output for each test case.\n- Consider edge cases and ensure robustness of the solution.\nWe will use combinatorial counting to efficiently determine the number of ways to select three problems that meet the given conditions. By leveraging Python's collections library, we can count occurrences of topics and difficulties, and use these counts to calculate valid combinations. This approach ensures that we handle large input sizes efficiently.\n", "requirement analysis:\nThe requirement is to select three problems from a set of n problems such that the selected problems have either all different topics or all different difficulties. The solution must efficiently handle large input sizes, as the sum of n across all test cases can be up to 200,000. The approach should ensure that the solution is both time and space efficient, leveraging data structures that allow quick access and manipulation of problem attributes.\nrequirement pool:\n- Efficiently handle large input sizes\n- Ensure accurate problem selection\n- Optimize for performance and speed\n- Provide clear and concise output\n- Maintain code readability and maintainability\nWe will use a combination of combinatorial mathematics and hash maps to efficiently count the number of valid problem sets. The key idea is to first calculate the total number of ways to choose any three problems, which is C(n, 3) = n * (n-1) * (n-2) / 6. Then, we will subtract the invalid combinations where all three problems have the same topic or the same difficulty. We will use hash maps to count the occurrences of each topic and difficulty, allowing us to quickly compute the number of invalid combinations.\n"], "scores": [], "pass_results": [true, false, true, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 663, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 50000) \u2014 the number of testcases.\n\nThe first line of each testcase contains an integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of problems that Monocarp have.\n\nIn the i-th of the following n lines, there are two integers a_i and b_i (1 \u2264 a_i, b_i \u2264 n) \u2014 the topic and the difficulty of the i-th problem.\n\nIt is guaranteed that there are no two problems that have the same topic and difficulty at the same time.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint the number of ways to select three training problems that meet either of the requirements described in the statement.\n\nExample\n\nInput\n\n\n2\n4\n2 4\n3 4\n2 1\n1 3\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n\n\nOutput\n\n\n3\n10\n\nNote\n\nIn the first example, you can take the following sets of three problems:\n\n  * problems 1, 2, 4; \n  * problems 1, 3, 4; \n  * problems 2, 3, 4. \n\n\n\nThus, the number of ways is equal to three.", "mutate_method": "rephrase_one", "parent_index": 237}
