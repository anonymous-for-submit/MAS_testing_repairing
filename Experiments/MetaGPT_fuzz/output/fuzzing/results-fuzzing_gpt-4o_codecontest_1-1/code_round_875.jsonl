{"name": "1613_E. Crazy Robot", "description": "There is a grid, consisting of n rows and m columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "tags": ["dfs and similar", "graphs"], "difficulty": 11, "id": 1613, "sample_io": [{"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n"]}], "test_list": [{"input": "1\n3 31\n############################..#\n.............................L.\n############################..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n3 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n############################..#\n", "output": ["#++############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n#..######################\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n#..######################\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n#++######################\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "1\n3 25\n##..#####################\n.......................L.\n#..######################\n", "output": ["##..#####################\n....+++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 31\n#############################..\n...........L...................\n############################..#\n", "output": ["#############################..\n+++++++++++L++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n#++######################\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#..###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#..############################\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n#++############################\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n############################..#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n######################..#\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n######################..#\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n#..######$####\"#$########\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n3 31\n..#############################\n.L.............................\n############################..#\n", "output": ["++#############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n##########\"######\"##########./#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n############################..#\n", "output": ["#############################..\n+++++++++++++++++++L++++++++...\n############################..#\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#.##.##########################\n", "output": ["#++############################\n+L++...........................\n#+##.##########################\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"#################..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"########..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.......................L.\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n.......................L+\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n################.############.#\n", "output": ["#++############################\n+L++++++++++++++...............\n################.############.#\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n..#..\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n..#..\n.....\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#..############################\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 25\n##.#####.################\n.L.......................\n#..######$####\"#$########\n", "output": ["##.#####.################\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#.##.##########################\n", "output": ["#..############################\n.....++++++++++++++++++++++++L+\n#.##.##########################\n"]}, {"input": "1\n2 25\n######################..#\n......................L..\n#..###$##################\n", "output": ["######################++#\n++++++++++++++++++++++L++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n++++L++#.\n"]}, {"input": "1\n2 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n"]}, {"input": "1\n2 25\n########.#############.##\n.L.......................\n#..###$###########$######\n", "output": ["########.#############.##\n+L++++++.................\n"]}, {"input": "1\n2 25\n###########.##########.##\n.L.......................\n####\"#################..#\n", "output": ["###########.##########.##\n+L+++++++++..............\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n################.############.#\n", "output": ["#..############################\n.................++++++++++++L+\n################.############+#\n"]}, {"input": "1\n2 25\n##########.############.#\n......................L..\n#..###$##################\n", "output": ["##########.############.#\n...........+++++++++++L..\n"]}, {"input": "1\n2 31\n#..############################\n...............L...............\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++L+++++++++++++++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\nL.##.\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#....\nL.##.\n...#.\n.....\nL\n++++L++#.\n"]}, {"input": "1\n2 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n2 25\n#..######################\n....................L....\n#..######################\n", "output": ["#..######################\n...+++++++++++++++++L++++\n"]}, {"input": "1\n2 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n"]}, {"input": "1\n2 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n######################..#\n", "output": ["##..#####################\n+L.......................\n######################..#\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n#..############################\n", "output": ["#############################..\n...++++++++++++++++L+++++++++..\n#..############################\n"]}, {"input": "1\n2 25\n######.###############.##\n.......................L.\n#..###$##################\n", "output": ["######.###############.##\n.......................L+\n"]}, {"input": "1\n3 31\n############################..#\n.............................L.\n#..############################\n", "output": ["############################++#\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 31\n#..############################\n.L.............................\n#################\"##########-.#\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"##########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$##################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$###########$######\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$###########$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"##############$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"####\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##########\"###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$####$###\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$##$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#.#############.#########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$##################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############\"######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########$##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#######\"######$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n##################$###..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##################$###..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########./#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#$########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##############\"#######..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$#####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##$##$###########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############!######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$$#..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$#####$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n####\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n$#######$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###################$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#############\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"##########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########-.#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$########$##$######\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##$#\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n##########\"######\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"\"###\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######!###############..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$##################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-##########\"#################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######$##$########$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"##$######$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#########$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"###\"###$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#########\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n######\"######\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#####\"###\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$#####..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$######\"####$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#######\"#########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.#############.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########%##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#..##########\"######\"##########\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$$\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n##############\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#/.###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###################$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#./######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####$########\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n###$####$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########-.#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$##\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"..##$#########\"####\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"############\"####..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##%#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"##\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######\"#######\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$#####$##\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#$#######$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###\"\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"####$######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#########\"####$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$##\"..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$#$..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..$\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n.#################$####.#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n########$#\"####$######..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n\"###\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$######$###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"######\"##########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-######\"#####################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"###\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"#############$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#######$#########\"###\"\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########!##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.############$.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######$##%########$###..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$#$###..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$\"#\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$###$########\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"#$#\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n$..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$###\"\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}], "task_id": "codecontest/117", "prompt": "There exists a grid, made up of n rows and m columns. Each cell in the grid is either unoccupied or blocked, and one of the unoccupied cells contains a laboratory. All the cells outside the grid's limits are blocked. That means they cannot be accessed by any movement from within the grid.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", where each command means moving to a neighbouring cell in the corresponding direction. \n\nHowever, because the robot is crazy, it will do anything except obey the command. Upon being given a command, it will select a direction that is not the one specified in the command and where the cell in that direction is not blocked, then proceed to a neighbouring cell in that direction if it exists; otherwise, it will remain stationary.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "repair_prompt": ["There exists a grid, made up of n rows and m columns. Each cell in the grid is either unoccupied or blocked, and one of the unoccupied cells contains a laboratory. All the cells outside the grid's limits are blocked. That means they cannot be accessed by any movement from within the grid.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", where each command means moving to a neighbouring cell in the corresponding direction. \n\nHowever, because the robot is crazy, it will do anything except obey the command. Upon being given a command, it will select a direction that is not the one specified in the command and where the cell in that direction is not blocked, then proceed to a neighbouring cell in that direction if it exists; otherwise, it will remain stationary.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can be forced to reach the lab in each test case grid.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - grid (List[str]): The grid itself, with '.' for free cells, '#' for blocked cells, and 'L' for the lab.\n\n    Returns:\n        List[List[str]]: A list of grids with free cells that can reach the lab marked with '+'.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a mutable list of lists\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to mark reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_directions = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_directions += 1\n                        if free_directions <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n                    elif grid[nx][ny] == 'L':\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        result_grid = [''.join(row) for row in grid]\n        results.append(result_grid)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function\nresults = find_reachable_cells(t, test_cases)\n\n# Output interface\nfor result in results:\n    for line in result:\n        print(line)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Find free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Perform BFS to find reachable cells from the lab.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[str]): Grid data.\n\n        Returns:\n            List[str]: Modified grid with reachable cells marked.\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        visited = set()\n        queue = deque()\n        lab_position = None\n\n        # Find the lab position and initialize the queue\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    queue.append(lab_position)\n                    visited.add(lab_position)\n                    break\n            if lab_position:\n                break\n\n        # Perform BFS from the lab\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.':\n                    # Check if the cell can be forced to reach the lab\n                    free_neighbors = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_neighbors += 1\n                    if free_neighbors <= 1:\n                        grid[nx] = grid[nx][:ny] + '+' + grid[nx][ny+1:]\n                        queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        return grid\n\n    result = []\n    for n, m, grid in test_cases:\n        modified_grid = bfs(n, m, grid)\n        result.append(modified_grid)\n\n    return result\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - grid: A list of strings representing the grid.\n\n    Returns:\n        A list of grids with free cells replaced by '+' if the robot can be forced to reach the lab.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a mutable list of lists\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to find all reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        result_grid = [''.join(row) for row in grid]\n        results.append(result_grid)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds all free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - grid: A list of strings representing the grid.\n\n    Returns:\n        A list of grids with reachable free cells marked with '+'.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a mutable list of lists\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to mark reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_directions = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_directions += 1\n                        if free_directions <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n                    elif grid[nx][ny] == 'L':\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    results = find_reachable_cells(t, test_cases)\n    for result in results:\n        for row in result:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        # Convert grid to a mutable list of lists\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Directions for moving in the grid: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # BFS queue\n        queue = deque([lab_position])\n        \n        # Visited set to keep track of cells that can reach the lab\n        visited = set()\n        visited.add(lab_position)\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            # Check all four possible directions\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                # Check if the new position is within bounds and is a free cell\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.':\n                    # Count the number of free adjacent cells\n                    free_adjacent_count = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_adjacent_count += 1\n                    \n                    # If there is only one free adjacent cell, mark it as reachable\n                    if free_adjacent_count <= 1:\n                        grid[nx][ny] = '+'\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        return [''.join(row) for row in grid]\n\n    results = []\n    for n, m, grid in test_cases:\n        result_grid = bfs(n, m, grid)\n        results.append(result_grid)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n    \n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determines which free cells can guide the robot to the lab in each test case grid.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - grid: A list of strings representing the grid.\n\n    Returns:\n        A list of grids with free cells marked as '+' if the robot can be forced to reach the lab from them.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # BFS to find reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell is surrounded by at most one free cell\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n    \n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can lead the robot to the lab using BFS.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Perform BFS to find all reachable cells from the lab.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[str]): The grid representation.\n\n        Returns:\n            List[str]: The modified grid with reachable cells marked.\n        \"\"\"\n        # Directions for moving in the grid: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # Find the lab position\n        lab_pos = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_pos = (i, j)\n                    break\n            if lab_pos:\n                break\n        \n        # Initialize the queue for BFS and the visited set\n        queue = deque([lab_pos])\n        visited = set([lab_pos])\n        \n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            # Check all four possible directions\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                # Check if the new position is within bounds and not visited\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Count the number of free adjacent cells\n                        free_adjacent = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_adjacent += 1\n                        \n                        # If there is only one free adjacent cell, mark it as reachable\n                        if free_adjacent <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    \n                    # Mark the cell as visited\n                    visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        return [''.join(row) for row in grid]\n\n    # Process each test case\n    results = []\n    for n, m, grid in test_cases:\n        modified_grid = bfs(n, m, grid)\n        results.append(modified_grid)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of grids for each test case.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n        grid = [list(row) for row in grid]\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # BFS to find all reachable cells from the lab\n        if lab_position:\n            queue = deque([lab_position])\n            visited = set([lab_position])\n\n            while queue:\n                x, y = queue.popleft()\n\n                # Check all four possible directions\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n\n                    if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                        if grid[nx][ny] == '.':\n                            # Check if the cell can be forced to move to the lab\n                            free_directions = 0\n                            for ddx, ddy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                                nnx, nny = nx + ddx, ny + ddy\n                                if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                    free_directions += 1\n\n                            if free_directions <= 1:\n                                grid[nx][ny] = '+'\n                                queue.append((nx, ny))\n                                visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print the result\n    results = find_reachable_cells(t, test_cases)\n    for result in results:\n        for line in result:\n            print(line)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the number of rows, number of columns, and the grid itself.\n\n    Returns:\n        A list of grids with free cells replaced by '+' if the robot can be forced to reach the lab from there.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for moving in the grid: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to find all reachable cells from the lab\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_directions = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_directions += 1\n                        if free_directions <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n                    elif grid[nx][ny] == 'L':\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Find free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of test cases, each containing a grid of cells.\n\n    Returns:\n        A list of grids with free cells marked as '+' if the robot can be forced to reach the lab.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        # Perform BFS to find reachable cells\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Count free neighbors\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n\n                        # If the cell has at most one free neighbor, it can be forced to reach the lab\n                        if free_neighbors <= 1:\n                            grid[nx] = grid[nx][:ny] + '+' + grid[nx][ny+1:]\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n\n        results.append(grid)\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n    test_cases = []\n\n    # Read each test case\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output results\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Optimize the algorithm for performance with large grids.\n- Ensure the solution handles edge cases correctly.\n- Develop a testing suite for multiple test cases.\n- Provide clear documentation and examples.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab to determine which free cells can be forced to reach the lab. The BFS will propagate through all free cells, marking those that can reach the lab. This approach ensures that we efficiently handle large grids by only exploring necessary paths.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring correct output format.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles the maximum input constraints.\n- Optimize the algorithm for computational efficiency.\n- Provide clear and concise output for each test case.\n- Test the solution against edge cases and large inputs.\nWe will use a Breadth-First Search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring we find all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the output will be formatted according to the requirements.\n", "requirement analysis:\nThe requirements focus on determining which free cells can guide the robot to the lab. The solution must efficiently handle large grids and multiple test cases, ensuring accurate output for each scenario.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Optimize for large grid sizes to ensure performance.\n- Ensure the solution handles edge cases correctly.\n- Provide clear output formatting for each test case.\n- Document the solution for ease of understanding and maintenance.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can guide the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring we find all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will start from the lab and explore all free cells, marking those that can reach the lab.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab cell, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed. The challenge lies in simulating the robot's movement and ensuring all possible paths to the lab are considered.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells for the robot.\n- Ensure the solution handles the maximum constraints of grid size and test cases.\n- Optimize the algorithm to reduce time complexity.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will use a Breadth-first Search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring that we can identify all reachable cells. The algorithm will start from the lab cell and mark all reachable free cells with a '+'.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Optimize the solution for large grid sizes.\n- Ensure the output format is correct and consistent.\n- Test the solution against edge cases and large inputs.\n- Document the code for maintainability and clarity.\nWe will use a breadth-first search (BFS) approach starting from the lab to determine which free cells can be forced to reach the lab. This approach is efficient for grid-based problems and will help us explore all possible paths the robot can take. We will mark cells that can reach the lab with a '+'. The BFS will ensure that we only explore valid paths and handle large grids efficiently.\n", "requirement analysis:\nThe requirements focus on determining which free cells can guide the robot to the lab. The solution must efficiently handle large grids and provide clear output for each test case.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Optimize for large grid sizes\n- Ensure clear output format\n- Handle edge cases and blocked cells\n- Test with multiple scenarios\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can guide the robot to the lab. The BFS will start from the lab and explore all reachable free cells, marking them as reachable. This approach ensures that we efficiently handle large grids by only exploring necessary paths. We will use a queue to manage the BFS and a set to track visited cells. The algorithm will be optimized to handle the constraints of large grid sizes by ensuring each cell is processed only once.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed. The challenge lies in navigating the grid while considering the robot's unpredictable movement.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles the maximum input size within constraints.\n- Optimize the algorithm to reduce computational complexity.\n- Provide clear documentation and comments in the code.\n- Include edge case testing to ensure robustness.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The algorithm will start from the lab and explore all free cells, marking those that can reach the lab.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Validate the output format against requirements\n- Document the solution for maintainability\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. The BFS will start from the lab and explore all reachable free cells, marking them as reachable. This approach ensures that we efficiently handle large grids by only exploring necessary paths. The BFS will be implemented using a queue to manage the exploration of cells, and we will use a set to track visited cells to avoid redundant processing.\n", "requirement analysis:\nThe main requirement is to determine which free cells can guide the robot to the lab. The solution must efficiently handle large grids and multiple test cases, ensuring performance and clarity in output.\nrequirement pool:\n- Implement efficient pathfinding algorithm for large grids\n- Ensure output format is clear and matches requirements\n- Optimize for performance with large number of test cases\n- Provide detailed analysis of reachable cells\n- Enhance user interface for better understanding\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can guide the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the output will be formatted according to the requirements.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is correct for each scenario.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs.\n- Optimize the algorithm to reduce computational complexity.\n- Provide clear documentation and comments in the code.\n- Implement additional test cases for thorough testing.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab cell to determine which free cells can be forced to reach the lab. This approach is efficient for grid-based problems and will ensure that we can handle large inputs within the constraints. The BFS will explore all possible paths from the lab, marking cells that can reach the lab. We will use a queue to manage the exploration of cells and a set to track visited cells.\n"], "scores": [], "pass_results": [true, false, true, true, true, false, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 875, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "mutate_method": "expand_one2two", "parent_index": 208}
