{"name": "1607_E. Robot on the Board 1", "description": "The robot is located on a checkered rectangular board of size n \u00d7 m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns \u2014 from 1 to m from left to right.\n\nThe robot is able to move from the current cell to one of the four cells adjacent by side.\n\nThe sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and triggers the movement to left, right, down or up, respectively.\n\nThe robot can start its movement in any cell. The robot executes the commands starting from the first one, strictly in the order in which they are listed in s. If the robot moves beyond the edge of the board, it falls and breaks. A command that causes the robot to break is not considered successfully executed.\n\nThe robot's task is to execute as many commands as possible without falling off the board. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge. If the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column).\n\n<image> The robot starts from cell (2, 1) (second row, first column). It moves right, right, down, left, up, and up. In this case it ends in the cell (1, 2) (first row, second column).\n\nDetermine the cell from which the robot should start its movement in order to execute as many commands as possible.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "tags": ["implementation"], "difficulty": 11, "id": 1607, "sample_io": [{"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}], "test_list": [{"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n1 1\n3 4\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n2 1\n4 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRUDLLLDU\n", "output": ["1 2\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n2 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n2 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 1\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUUURDDLLLUR\n", "output": ["1 1\n1 1\n1 1\n4 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nLRDRUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 2\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n17 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 1\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 1\n3 1\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUURRDLLLDU\n", "output": ["1 1\n1 2\n2 1\n4 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 4\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nUULRRD\n6 1\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 1\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n3 4\nDUULRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n2 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 2\nUULRRD\n6 2\nUULULDRRDULL\n", "output": ["1 1\n1 2\n3 2\n4 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n13 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n9 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n22 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n8 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n1 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n4 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRDRLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n4 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n6 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n4 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n10 3\nRRDLUU\n6 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n3 2\nLUUDRLDLRLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 4\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 4\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nRRDLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n8 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUT\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n5 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n3 3\nRRDUUL\n4 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n6 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n3 3\nUULDRR\n11 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n7 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n3 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nDRRLUU\n6 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n12 3\nRRDLUU\n8 2\nUULLLDDRRUUL\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n2 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n5 2\nL\n3 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n10 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nRRDLUU\n4 3\nLUULRRDLDLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n2 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nRRDUUL\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n6 3\nRRDLUU\n9 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n2 3\nRRDUUL\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n6 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n4 3\nRRDLUU\n9 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n3 3\nRDRLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nUULDRR\n4 2\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n6 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 3\nRRDLUU\n4 4\nLUUDRRLLLDUU\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n6 3\nRRDLUU\n4 3\nUULLLDURDURL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 1\nL\n1 3\nRRDLUU\n8 3\nLUURRDDLLLUU\n", "output": ["1 2\n1 1\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n2 2\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n12 2\nL\n5 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 2\nL\n3 2\nL\n3 3\nRRDLUU\n8 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n2 3\nDRRLUU\n6 3\nLUUDRRDLLLVU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n4 3\nRRDLUU\n5 3\nLUURRDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nDRRLUU\n6 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n12 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nUULDRR\n3 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n11 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRDLUU\n5 3\nUUULLDRRDULL\n", "output": ["1 1\n1 2\n2 1\n4 3\n"]}, {"input": "4\n1 1\nL\n10 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 2\nUULDRR\n10 3\nLUULRRDDLLUU\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n4 3\nRRULDU\n23 3\nLLUDRRDLLUUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n1 3\nRRDLUU\n3 3\nUULLLDRRDTUL\n", "output": ["1 1\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n13 2\nL\n2 3\nRRDLUU\n8 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n2 2\nL\n7 2\nL\n3 3\nUULDRR\n6 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n7 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n6 2\nL\n3 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n9 3\nRRDLUU\n4 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n15 3\nLUURRDDLLLUU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n3 3\nRRDLUU\n8 3\nLRUURDDLLLVU\n", "output": ["1 1\n1 1\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n6 3\nRRDLUU\n4 4\nLUURRDDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDLUU\n3 3\nLUUDRUDLLLUR\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n4 3\nRRDLUU\n6 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nUULDRR\n5 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n2 2\nL\n3 3\nRRDLUU\n5 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n3 3\nRRDUUL\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n2 1\n3 2\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n5 3\nRRDLUU\n4 4\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n11 2\nL\n2 3\nRRDLUU\n5 3\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n1 1\n3 2\n"]}, {"input": "4\n1 1\nL\n1 1\nL\n1 3\nRRDKUU\n8 3\nLUURRDDLLLUV\n", "output": ["1 1\n1 1\n1 1\n3 2\n"]}, {"input": "4\n1 2\nL\n7 2\nL\n2 2\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n1 1\n3 3\n"]}, {"input": "4\n1 1\nL\n2 2\nL\n3 3\nUULDRR\n10 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n3 2\n3 3\n"]}, {"input": "4\n1 1\nL\n3 2\nL\n5 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 2\nL\n4 2\nL\n4 3\nUULDRR\n4 3\nLUUDRRDLLLUU\n", "output": ["1 2\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n3 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}, {"input": "4\n1 1\nL\n7 2\nL\n3 3\nRRDLUU\n12 1\nUULLLDRRDUUL\n", "output": ["1 1\n1 2\n2 1\n3 1\n"]}, {"input": "4\n1 1\nL\n4 2\nL\n3 3\nUULRDR\n6 2\nLUUDRRDLLLUU\n", "output": ["1 1\n1 2\n3 2\n3 2\n"]}, {"input": "4\n1 2\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nUULLLDRRDUUL\n", "output": ["1 2\n1 2\n2 1\n3 3\n"]}], "task_id": "codecontest/102", "prompt": "The robot is situated on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns), and the rows are numbered from 1 to n from top to bottom, while the columns \u2014 from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side and these movements can be made in any direction which connects directly to the sides of the current position. The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and initiates the movement to left, right, down or up, respectively. The robot can start its movement in any cell and executes the commands starting from the first one, strictly in the order in which they are listed in s, but if the robot moves beyond the edge of the board, it falls and breaks; a command that causes the robot to break is not considered successfully executed. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge, and if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column). <image> The robot starts from cell (2, 1) (second row, first column), moves right, right, down, left, up, and up, and in this case it ends in the cell (1, 2) (first row, second column). Ascertain the cell from which the robot should begin its movement so as to execute as many commands as feasible. Ensure to take into account edge scenarios where the instructions could propel the robot out of bounds shortly in its path.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "repair_prompt": ["The robot is situated on a checkered rectangular board with dimensions n \u00d7 m (n rows, m columns), and the rows are numbered from 1 to n from top to bottom, while the columns \u2014 from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side and these movements can be made in any direction which connects directly to the sides of the current position. The sequence of commands s executed by the robot is given. Each command is denoted by one of the symbols 'L', 'R', 'D' or 'U', and initiates the movement to left, right, down or up, respectively. The robot can start its movement in any cell and executes the commands starting from the first one, strictly in the order in which they are listed in s, but if the robot moves beyond the edge of the board, it falls and breaks; a command that causes the robot to break is not considered successfully executed. For example, on board 3 \u00d7 3, if the robot starts a sequence of actions s=\"RRDLUU\" (\"right\", \"right\", \"down\", \"left\", \"up\", \"up\") from the central cell, the robot will perform one command, then the next command will force him to cross the edge, and if the robot starts moving from the cell (2, 1) (second row, first column) then all commands will be executed successfully and the robot will stop at the cell (1, 2) (first row, second column). <image> The robot starts from cell (2, 1) (second row, first column), moves right, right, down, left, up, and up, and in this case it ends in the cell (1, 2) (first row, second column). Ascertain the cell from which the robot should begin its movement so as to execute as many commands as feasible. Ensure to take into account edge scenarios where the instructions could propel the robot out of bounds shortly in its path.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    for n, m, s in test_cases:\n        # Initialize variables to track the best starting position\n        max_commands_executed = 0\n        best_start_row = 1\n        best_start_col = 1\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                # Simulate the robot's movement from the current starting position\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot is still within bounds\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_start_row = start_row\n                    best_start_col = start_col\n        \n        # Append the best starting position for the current test case\n        results.append((best_start_row, best_start_col))\n    \n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m = map(int, data[index].split())\n        s = data[index + 1].strip()\n        test_cases.append((n, m, s))\n        index += 2\n    \n    # Call the function and print results\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Finds the optimal starting position for the robot on a board to execute the maximum number of commands.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the dimensions of the board (n, m) and the command sequence (s).\n\n    Returns:\n        A list of tuples, each containing the optimal starting row and column for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, s in test_cases:\n        max_commands = 0\n        best_start = (1, 1)\n\n        # Iterate over each possible starting position\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n\n                # Simulate the command sequence\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n\n                    # Check if the robot is still on the board\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n\n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands:\n                    max_commands = commands_executed\n                    best_start = (start_row, start_col)\n\n        results.append(best_start)\n\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n\n    # Output interface\n    results = find_optimal_starting_position(t, test_cases)\n    for result in results:\n        print(result[0], result[1])\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Find the optimal starting position for the robot to execute the maximum number of commands.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, str]]): List of test cases, each containing the dimensions of the board\n            and the sequence of commands.\n\n    Returns:\n        List[Tuple[int, int]]: List of starting positions (row, column) for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, s in test_cases:\n        max_commands_executed = 0\n        best_start_position = (1, 1)\n\n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n\n                # Simulate the command sequence\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n\n                    # Check if the robot is out of bounds\n                    if current_row < 1 or current_row > n or current_col < 1 or current_col > m:\n                        break\n\n                    commands_executed += 1\n\n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_start_position = (start_row, start_col)\n\n        results.append(best_start_position)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n\n    # Output interface\n    results = find_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    for n, m, s in test_cases:\n        max_commands_executed = 0\n        best_start_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the command sequence\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_start_position = (start_row, start_col)\n        \n        results.append(best_start_position)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output interface\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Finds the optimal starting position for the robot to execute the maximum number of commands.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the dimensions of the board (n, m) and the command sequence (s).\n\n    Returns:\n        A list of tuples, each containing the optimal starting position (row, column) for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, s in test_cases:\n        max_commands_executed = 0\n        optimal_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the command sequence\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot is still within bounds\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the optimal position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    optimal_position = (start_row, start_col)\n        \n        results.append(optimal_position)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    # Define movement deltas for each command\n    move_deltas = {\n        'L': (0, -1),\n        'R': (0, 1),\n        'U': (-1, 0),\n        'D': (1, 0)\n    }\n    \n    for n, m, s in test_cases:\n        max_commands_executed = 0\n        best_starting_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the command sequence\n                for command in s:\n                    delta_row, delta_col = move_deltas[command]\n                    new_row = current_row + delta_row\n                    new_col = current_col + delta_col\n                    \n                    # Check if the new position is within bounds\n                    if 1 <= new_row <= n and 1 <= new_col <= m:\n                        current_row, current_col = new_row, new_col\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_starting_position = (start_row, start_col)\n        \n        results.append(best_starting_position)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output results\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    results = []\n    \n    for n, m, s in test_cases:\n        # Initialize variables to track the best starting position\n        max_commands_executed = 0\n        best_start_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                # Simulate the robot's movement from the current starting position\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot is still within bounds\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_start_position = (start_row, start_col)\n        \n        results.append(best_start_position)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output interface\n    results = find_optimal_starting_position(t, test_cases)\n    for result in results:\n        print(result[0], result[1])\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Finds the optimal starting position for the robot to execute the maximum number of commands.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, str]]): List of test cases, each containing the board dimensions and command sequence.\n\n    Returns:\n        List[Tuple[int, int]]: List of optimal starting positions for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, s in test_cases:\n        # Initialize variables to track the best starting position\n        max_commands_executed = 0\n        best_start_position = (1, 1)\n        \n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n                \n                # Simulate the command sequence\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n                    \n                    # Check if the robot is still on the board\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n                \n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_start_position = (start_row, start_col)\n        \n        results.append(best_start_position)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Call the function and print the results\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Finds the optimal starting position for the robot to execute the maximum number of commands.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, str]]): List of test cases, each containing the dimensions of the board and the command sequence.\n\n    Returns:\n        List[Tuple[int, int]]: List of starting positions (row, column) for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, s in test_cases:\n        # Initialize variables to track the boundaries of the robot's movement\n        min_row, max_row, min_col, max_col = 0, 0, 0, 0\n        current_row, current_col = 0, 0\n        \n        # Simulate the command sequence to determine the movement boundaries\n        for command in s:\n            if command == 'L':\n                current_col -= 1\n            elif command == 'R':\n                current_col += 1\n            elif command == 'U':\n                current_row -= 1\n            elif command == 'D':\n                current_row += 1\n            \n            # Update the boundaries based on the current position\n            min_row = min(min_row, current_row)\n            max_row = max(max_row, current_row)\n            min_col = min(min_col, current_col)\n            max_col = max(max_col, current_col)\n        \n        # Calculate the optimal starting position\n        start_row = max(1, 1 - min_row)\n        start_col = max(1, 1 - min_col)\n        \n        # Ensure the starting position is within the board dimensions\n        if start_row + max_row <= n and start_col + max_col <= m:\n            results.append((start_row, start_col))\n        else:\n            # If the calculated position is out of bounds, adjust to fit within the board\n            results.append((n - max_row, m - max_col))\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n    \n    # Output interface\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_optimal_starting_position(t: int, test_cases: List[Tuple[int, int, str]]) -> List[Tuple[int, int]]:\n    \"\"\"Finds the optimal starting position for the robot on a board for each test case.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing the dimensions of the board (n, m) and the command sequence (s).\n\n    Returns:\n        A list of tuples, each containing the optimal starting row and column for the robot.\n    \"\"\"\n    results = []\n\n    for n, m, s in test_cases:\n        # Initialize variables to track the best starting position\n        max_commands_executed = 0\n        best_start_row = 1\n        best_start_col = 1\n\n        # Iterate over all possible starting positions\n        for start_row in range(1, n + 1):\n            for start_col in range(1, m + 1):\n                current_row, current_col = start_row, start_col\n                commands_executed = 0\n\n                # Simulate the robot's movement\n                for command in s:\n                    if command == 'L':\n                        current_col -= 1\n                    elif command == 'R':\n                        current_col += 1\n                    elif command == 'U':\n                        current_row -= 1\n                    elif command == 'D':\n                        current_row += 1\n\n                    # Check if the robot is still on the board\n                    if 1 <= current_row <= n and 1 <= current_col <= m:\n                        commands_executed += 1\n                    else:\n                        break\n\n                # Update the best starting position if more commands are executed\n                if commands_executed > max_commands_executed:\n                    max_commands_executed = commands_executed\n                    best_start_row = start_row\n                    best_start_col = start_col\n\n        results.append((best_start_row, best_start_col))\n\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        s = input().strip()\n        test_cases.append((n, m, s))\n\n    # Output interface\n    results = find_optimal_starting_position(t, test_cases)\n    for r, c in results:\n        print(r, c)\n"], "plans": ["requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without breaking. The solution must efficiently handle large board sizes and command sequences, ensuring accurate output for each test case.\nrequirement pool:\n- Develop an algorithm to find the optimal starting position for the robot.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm for performance.\n- Consider edge cases where the robot might break early.\nWe will implement a function to determine the optimal starting position for the robot on a checkered board. The function will simulate the robot's movements from each possible starting position and track the number of commands executed before the robot breaks. We will use a greedy approach to find the starting position that allows the maximum number of commands to be executed. Given the constraints, we will optimize the solution to handle large board sizes and command sequences efficiently.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for a robot on a board to execute a sequence of commands without falling off. The solution must handle large inputs efficiently and provide accurate results for each test case.\nrequirement pool:\n- Develop an algorithm to find the optimal starting position for the robot\n- Ensure the solution handles large board sizes and command sequences efficiently\n- Implement edge case handling where the robot might fall off the board\n- Provide clear output format for each test case\n- Optimize the solution for speed and accuracy\nWe will implement a function to determine the optimal starting position for the robot on a board to execute the maximum number of commands without falling off. The approach involves simulating the robot's movement from each possible starting position and tracking the number of successful commands executed. We will use a greedy algorithm to efficiently handle large board sizes and command sequences. The function will iterate over each cell on the board, simulate the command sequence, and keep track of the maximum number of commands executed without falling off. We will use Python's built-in data structures for efficient computation.\n", "requirement analysis:\nThe solution must efficiently determine the optimal starting position for the robot to execute the maximum number of commands without breaking. It should handle large board sizes and multiple test cases, ensuring clarity and accuracy in output.\nrequirement pool:\n- Efficiently compute the starting position for maximum command execution.\n- Handle large board sizes up to 10^6 x 10^6.\n- Provide clear and accurate output for each test case.\n- Ensure the solution is scalable for multiple test cases.\n- Optimize for edge cases where commands may lead to breaking.\nWe will use a simulation approach to determine the optimal starting position for the robot. The key challenge is efficiently handling large board sizes and ensuring the robot does not move out of bounds. We will iterate over possible starting positions and simulate the command sequence, keeping track of the maximum number of commands executed successfully. The use of numpy for efficient array manipulation can be considered, but given the constraints, a simple loop-based approach should suffice.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without breaking. The solution must efficiently handle large board sizes and command sequences, ensuring accurate and clear output for each test case.\nrequirement pool:\n- Determine the optimal starting position for maximum command execution.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear and accurate output for each test case.\n- Optimize the algorithm for performance on large board sizes.\n- Consider edge cases where commands may lead to breaking early.\nWe will use a simulation approach to determine the optimal starting position for the robot. The algorithm will iterate over all possible starting positions on the board and simulate the execution of the command sequence from each position. We will track the number of successfully executed commands for each starting position and select the position with the maximum number of commands executed. To handle large inputs efficiently, we will use a greedy approach to stop the simulation early if the robot breaks, and we will use efficient data structures to store the board and command sequence.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without falling off the board. The solution must handle large board sizes and command sequences efficiently, ensuring that the output is accurate and follows the specified format.\nrequirement pool:\n- Develop an algorithm to find the optimal starting position for the robot\n- Ensure the solution handles large board sizes and command sequences efficiently\n- Provide clear output for each test case\n- Test the solution against edge cases\n- Optimize the algorithm for performance\nWe will implement a function that simulates the robot's movement on the board and determines the optimal starting position to execute the maximum number of commands without falling off the board. The approach will involve iterating over possible starting positions and simulating the command sequence to check how many commands can be executed successfully. We will use efficient data structures to handle large board sizes and command sequences, ensuring the solution is optimized for performance.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without falling off the board. The solution must efficiently handle large board sizes and command sequences, ensuring performance and usability.\nrequirement pool:\n- Determine optimal starting position for maximum command execution\n- Handle large input sizes efficiently\n- Ensure the robot does not fall off the board\n- Provide clear output format for test cases\n- Optimize algorithm for performance\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions on the board and simulate the execution of the command sequence from each position. It will track the number of commands successfully executed before the robot falls off the board. The starting position that allows the maximum number of commands to be executed will be selected. Given the constraints, we will ensure the solution is efficient by avoiding unnecessary computations and using simple arithmetic operations to track the robot's position.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for a robot on a checkered board to execute a sequence of commands without breaking. The solution must handle large board sizes and command sequences efficiently, ensuring accurate output for each test case.\nrequirement pool:\n- Develop an algorithm to find the optimal starting position for the robot\n- Ensure the solution handles large input sizes efficiently\n- Provide clear output format for each test case\n- Test the algorithm against edge cases\n- Optimize the code for performance\nWe will implement a function that simulates the robot's movement on the board and determines the optimal starting position to execute the maximum number of commands without breaking. The approach involves iterating over possible starting positions and simulating the command sequence to check how many commands can be executed successfully. We will use efficient data structures to handle large board sizes and command sequences, ensuring the solution is optimized for performance.\n", "requirement analysis:\nThe main requirement is to determine the optimal starting position for the robot on a given board to execute the maximum number of commands without breaking. The solution must efficiently handle large board sizes and command sequences, ensuring accurate results for each test case.\nrequirement pool:\n- Determine the optimal starting position for maximum command execution.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear output format for each test case.\n- Consider edge cases where the robot might break early.\n- Optimize the algorithm for speed and accuracy.\nWe will implement a function that simulates the robot's movement on the board. The function will iterate over all possible starting positions on the board and simulate the execution of the command sequence from each position. It will track the number of commands successfully executed before the robot falls off the board. The starting position that allows the maximum number of commands to be executed will be selected. Given the constraints, the solution will be optimized to handle large board sizes and command sequences efficiently.\n", "requirement analysis:\nThe requirements focus on determining the optimal starting position for the robot to execute the maximum number of commands without breaking. The solution must handle large board sizes and command sequences efficiently, ensuring clear output for each test case.\nrequirement pool:\n- Determine the optimal starting position for the robot.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear output format for each test case.\n- Optimize the algorithm for performance.\n- Consider edge cases where the robot might break early.\nWe will implement a function that simulates the robot's movement on the board and determines the optimal starting position to execute the maximum number of commands without breaking. The approach will involve iterating over possible starting positions and simulating the command sequence to check how many commands can be executed successfully. We will use efficient algorithms to handle large board sizes and command sequences, ensuring the solution is optimized for performance.\n", "requirement analysis:\nThe solution must efficiently determine the optimal starting position for the robot on a board of size n \u00d7 m, given a sequence of commands. It should handle edge cases where commands may lead the robot out of bounds and ensure maximum command execution without breaking. The algorithm should be optimized for large inputs, considering constraints on board size and command sequence length.\nrequirement pool:\n- Develop an algorithm to find the optimal starting position for maximum command execution.\n- Ensure the solution handles large board sizes and command sequences efficiently.\n- Implement edge case handling for commands leading out of bounds.\n- Provide accurate output for each test case.\n- Optimize the solution for speed and reliability.\nWe will implement a function to determine the optimal starting position for the robot on a board of size n \u00d7 m, given a sequence of commands. The function will simulate the robot's movements from each possible starting position and track the number of successfully executed commands. The optimal starting position will be the one that allows the maximum number of commands to be executed without the robot falling off the board. We will use efficient iteration and boundary checks to handle large board sizes and command sequences. The solution will be optimized for speed and reliability, ensuring it handles edge cases where commands may lead the robot out of bounds.\n"], "scores": [], "pass_results": [true, false, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 628, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains two integers n and m (1 \u2264 n, m \u2264 10^6) \u2014 the height and width of the field that the robot is located on. The second line of the description is a string s consisting solely of characters 'L', 'R', 'D' and 'U' \u2014 the sequence of commands the robot executes. The string has a length from 1 to 10^6 commands.\n\nIt is guaranteed that the total length of s over all test cases does not exceed 10^6.\n\nOutput\n\nPrint t lines, each of which contains the answer to the corresponding test case. The answer to the test case are two integers r (1 \u2264 r \u2264 n) and c (1 \u2264 c \u2264 m), separated by a space \u2014 the coordinates of the cell (row number and column number) from which the robot should start moving to perform as many commands as possible.\n\nIf there are several such cells, you may output any of them.\n\nExample\n\nInput\n\n\n4\n1 1\nL\n1 2\nL\n3 3\nRRDLUU\n4 3\nLUURRDDLLLUU\n\n\nOutput\n\n\n1 1\n1 2\n2 1\n3 2", "mutate_method": "condense_two2one", "parent_index": 306}
