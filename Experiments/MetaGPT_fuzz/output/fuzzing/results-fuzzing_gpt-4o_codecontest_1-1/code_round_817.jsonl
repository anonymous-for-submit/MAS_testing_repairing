{"name": "1607_C. Minimum Extraction", "description": "Yelisey has an array a of n integers.\n\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \n\n  1. First, Yelisei finds the minimal number m in the array. If there are several identical minima, Yelisey can choose any of them. \n  2. Then the selected minimal element is removed from the array. After that, m is subtracted from each remaining element. \n\n\n\nThus, after each operation, the length of the array is reduced by 1.\n\nFor example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\n\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\n\nHelp him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "tags": ["brute force", "sortings"], "difficulty": 9, "id": 1607, "sample_io": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}], "test_list": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 0 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 19 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n12\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 6\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n7\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 1\n5\n3 2 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 12\n2\n2 4\n5\n3 3 -5 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n8\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -6 -1 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n5\n3\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -1 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-3\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 12\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n10\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 0 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n11\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-1 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n0 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n4\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -1 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-2 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["15\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n1\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n7\n2\n0 -1\n3\n-2 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["7\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -7 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n5\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 1\n5\n0 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n1\n2\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 1 0\n4\n2 10 1 7\n2\n2 6\n5\n3 4 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n1\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-3\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n4 3\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n3\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n1\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 15 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 8\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 16 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n8\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 2\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n8\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 4 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -4\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n4\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 0\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 -1 1\n2\n-1 1\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n0 18 1 9\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n9\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 0\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n1\n0\n"]}, {"input": "8\n1\n19\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["19\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-2 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n3 12 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-3\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-3\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 1 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 1\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n1\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n0 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n4 10 1 7\n2\n-1 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n5\n4\n2\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 14\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n0 4\n5\n0 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n0 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n6\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 8\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n4 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n1 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n5\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 -1\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["8\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 11 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n9\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n6 10 2 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-4\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-4\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -12 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n8\n2\n-2\n"]}, {"input": "8\n1\n1\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["1\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 6\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 12\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 0 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 0\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n1\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 0\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n1\n-2\n"]}], "task_id": "codecontest/100", "prompt": "Yelisey has an array a of n integers. If a has length strictly greater than 1, then Yelisey can apply an operation called minimum extraction to it: First, Yelisei finds the minimal number m in the array and, if there are several identical minima, Yelisey can choose any of them; then the selected minimal element is removed from the array, and afterwards, m is subtracted from each remaining element. Thus, after each operation, the length of the array is reduced by 1. For example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0]. Since Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible. Formally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1. Help him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array. Consider edge cases such as arrays with positive, negative or repeated numbers to ensure your solution is comprehensive.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "repair_prompt": ["Yelisey has an array a of n integers. If a has length strictly greater than 1, then Yelisey can apply an operation called minimum extraction to it: First, Yelisei finds the minimal number m in the array and, if there are several identical minima, Yelisey can choose any of them; then the selected minimal element is removed from the array, and afterwards, m is subtracted from each remaining element. Thus, after each operation, the length of the array is reduced by 1. For example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0]. Since Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible. Formally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1. Help him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array. Consider edge cases such as arrays with positive, negative or repeated numbers to ensure your solution is comprehensive.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n        else:\n            # Sort the array to facilitate the greedy approach.\n            case.sort()\n            # Initialize the maximum possible minimum as the first element.\n            max_min = case[0]\n            # Iterate through the sorted array to find the maximum possible minimum.\n            for i in range(1, len(case)):\n                # Calculate the difference between consecutive elements.\n                diff = case[i] - case[i - 1]\n                # Update the maximum possible minimum.\n                max_min = max(max_min, diff)\n            results.append(max_min)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimum values for each test case.\n    \"\"\"\n    results = []\n    for array in test_cases:\n        if len(array) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(array[0])\n        else:\n            # Sort the array to apply the greedy approach.\n            array.sort()\n            # Initialize the maximum possible minimum value.\n            max_min_value = array[0]\n            # Iterate through the sorted array to find the maximum possible minimum value.\n            for i in range(1, len(array)):\n                # Calculate the difference between consecutive elements.\n                difference = array[i] - array[i - 1]\n                # Update the maximum possible minimum value.\n                max_min_value = max(max_min_value, difference)\n            results.append(max_min_value)\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        array = list(map(int, input().strip().split()))\n        test_cases.append(array)\n\n    # Call the function and print the results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximal_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimum values for each test case.\n    \"\"\"\n    results = []\n    for array in test_cases:\n        if len(array) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(array[0])\n        else:\n            # Sort the array to simulate the minimum extraction operation.\n            array.sort()\n            # Calculate the maximal possible minimum value.\n            max_min = array[0]\n            for i in range(1, len(array)):\n                max_min = max(max_min, array[i] - array[i - 1])\n            results.append(max_min)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append(array)\n\n    results = maximal_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximal_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results, each representing the maximal possible minimum value for the corresponding test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array has only one element, the answer is the element itself\n            results.append(case[0])\n            continue\n        \n        # Sort the array\n        case.sort()\n        \n        # Calculate the maximum difference between consecutive elements\n        max_diff = float('-inf')\n        for i in range(1, len(case)):\n            diff = case[i] - case[i - 1]\n            if diff > max_diff:\n                max_diff = diff\n        \n        # The maximal possible minimum is the maximum difference found\n        results.append(max_diff)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append(a)\n    \n    results = maximal_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maximal_possible_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Compute the maximal possible minimum for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimums for each test case.\n    \"\"\"\n    results = []\n    for array in test_cases:\n        if len(array) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(array[0])\n        else:\n            # Sort the array to simulate the minimum extraction operation.\n            array.sort()\n            # Initialize the maximal possible minimum.\n            max_min = array[0]\n            # Iterate through the sorted array to compute the maximal possible minimum.\n            for i in range(1, len(array)):\n                # Calculate the difference between the current element and the previous one.\n                diff = array[i] - array[i - 1]\n                # Update the maximal possible minimum.\n                max_min = max(max_min, diff)\n            results.append(max_min)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append(array)\n\n    # Process the test cases and get results\n    results = maximal_possible_minimum(t, test_cases)\n\n    # Output interface\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array has only one element, the minimum is the element itself.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the greedy approach.\n        case.sort()\n        \n        # Initialize the maximum possible minimum as the first element.\n        max_possible_min = case[0]\n        \n        # Iterate through the sorted array to find the maximum possible minimum.\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements.\n            diff = case[i] - case[i - 1]\n            # Update the maximum possible minimum.\n            max_possible_min = max(max_possible_min, diff)\n        \n        results.append(max_possible_min)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Process and output results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum for each test case after applying\n    the minimum extraction operation.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimums for each test case.\n    \"\"\"\n    results = []\n    \n    for array in test_cases:\n        if len(array) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(array[0])\n            continue\n        \n        # Sort the array to efficiently perform minimum extraction operations.\n        array.sort()\n        \n        # Initialize the maximum possible minimum.\n        max_possible_min = array[0]\n        \n        # Perform the minimum extraction operation iteratively.\n        for i in range(1, len(array)):\n            # Calculate the difference between the current element and the previous minimum.\n            difference = array[i] - array[i - 1]\n            # Update the maximum possible minimum.\n            max_possible_min = max(max_possible_min, difference)\n        \n        results.append(max_possible_min)\n    \n    return results\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of an integer n followed by n integers\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append(array)\n\n# Call the function and print the results\nresults = maximize_minimum(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximal_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimum values for each test case.\n    \"\"\"\n    results = []\n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n        else:\n            # Sort the array to easily compute differences between consecutive elements.\n            case.sort()\n            # Calculate the differences between consecutive elements.\n            max_minimum = case[0]  # Initialize with the first element\n            for i in range(1, len(case)):\n                max_minimum = max(max_minimum, case[i] - case[i - 1])\n            results.append(max_minimum)\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    results = maximal_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximal_possible_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximal possible minimum for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimums for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        # Sort the array to facilitate the minimum extraction process\n        case.sort()\n        \n        # Initialize the maximum possible minimum\n        max_possible_min = case[0]\n        \n        # Iterate through the sorted array to calculate the maximum possible minimum\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements\n            diff = case[i] - case[i - 1]\n            # Update the maximum possible minimum\n            max_possible_min = max(max_possible_min, diff)\n        \n        # Append the result for the current test case\n        results.append(max_possible_min)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input().strip())\n    test_cases = []\n    \n    # Read each test case\n    for _ in range(t):\n        n = int(input().strip())\n        array = list(map(int, input().strip().split()))\n        test_cases.append(array)\n    \n    # Get results for each test case\n    results = maximal_possible_minimum(t, test_cases)\n    \n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculates the maximal possible minimum value for each test case after applying minimum extraction operations.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximal possible minimum values for each test case.\n    \"\"\"\n    results = []\n    for array in test_cases:\n        if len(array) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(array[0])\n        else:\n            # Sort the array to simulate the minimum extraction operation.\n            array.sort()\n            # Calculate the maximal possible minimum by finding the maximum difference between consecutive elements.\n            max_minimum = array[0]\n            for i in range(1, len(array)):\n                max_minimum = max(max_minimum, array[i] - array[i - 1])\n            results.append(max_minimum)\n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        array = list(map(int, input().strip().split()))\n        test_cases.append(array)\n\n    # Call the function and print the results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on maximizing the minimum value in an array after applying a series of operations. The solution must efficiently handle large arrays and correctly process arrays with negative and repeated numbers. The output must be clear and adhere to the specified format.\nrequirement pool:\n- Efficiently handle large arrays up to 2 \u22c5 10^5 elements\n- Correctly process arrays with negative numbers\n- Ensure the solution is correct for arrays with repeated numbers\n- Provide clear output for each test case\n- Optimize for performance and correctness\nWe will use a greedy approach to solve the problem efficiently. The idea is to sort the array and then calculate the maximum possible minimum by iteratively subtracting the smallest element from the rest of the array. This approach ensures that we handle large arrays efficiently and correctly process arrays with negative and repeated numbers.\n", "requirement analysis:\nThe requirements focus on maximizing the minimum value in an array after applying a series of operations. The solution must efficiently handle large inputs and consider edge cases such as arrays with negative numbers or repeated values. The output format must be clear and adhere to the specified format.\nrequirement pool:\n- Efficiently handle large arrays and multiple test cases\n- Correctly compute the maximal possible minimum for each test case\n- Consider edge cases with negative and repeated numbers\n- Ensure the solution is fast and responsive\n- Provide clear output format as specified\nWe will use a greedy approach to solve the problem efficiently. The idea is to sort the array and then perform the minimum extraction operation iteratively, keeping track of the maximum possible minimum value. This approach ensures that we handle large inputs efficiently and consider edge cases with negative and repeated numbers.\n", "requirement analysis:\nThe requirement is to find the maximal possible minimum value in an array after applying a series of minimum extraction operations. The solution must efficiently handle multiple test cases and large arrays, considering edge cases such as arrays with negative, positive, and repeated numbers.\nrequirement pool:\n- Efficiently process large arrays up to the maximum input size\n- Correctly handle arrays with negative numbers\n- Provide accurate maximal minimum value for each test case\n- Consider edge cases with repeated numbers\n- Ensure solution clarity and correctness\nWe will implement a function that processes each test case independently. For each array, we will simulate the minimum extraction operation by sorting the array and calculating the differences between consecutive elements. This approach ensures that we efficiently find the maximal possible minimum value after all possible operations. We will use Python's built-in sorting capabilities to handle large arrays efficiently.\n", "requirement analysis:\nThe requirements focus on maximizing the minimum value in an array after applying a series of operations. The solution must efficiently handle multiple test cases and large arrays, considering edge cases such as negative numbers and repeated values. The output must be accurate and follow the specified format.\nrequirement pool:\n- Efficiently handle large input sizes\n- Accurately compute the maximal minimum value\n- Consider edge cases such as negative and repeated numbers\n- Ensure output format is correct\n- Optimize for performance\nWe will implement a function that processes each test case independently. For each test case, we will sort the array and then calculate the differences between consecutive elements. The maximum of these differences will be the answer for that test case. This approach efficiently handles large input sizes and considers edge cases such as negative and repeated numbers.\n", "requirement analysis:\nThe requirement is to find the maximal possible minimum of an array after applying a series of operations. The operation involves removing the minimum element and subtracting it from the remaining elements. The solution must efficiently handle multiple test cases and large arrays, considering edge cases such as arrays with negative numbers and repeated elements.\nrequirement pool:\n- Efficiently process large arrays\n- Correctly handle negative numbers\n- Provide clear output format\n- Consider edge cases\n- Optimize for speed\nWe will use a greedy approach to solve the problem efficiently. The idea is to sort the array and then simulate the minimum extraction operation by iterating through the sorted array. This allows us to efficiently compute the maximal possible minimum by subtracting the smallest element from the rest of the array elements. We will use Python's built-in sorting function which is optimized for large inputs.\n", "requirement analysis:\nThe requirements focus on maximizing the minimum value in an array after applying a series of operations. The solution must efficiently handle large inputs and edge cases, including arrays with negative, positive, and repeated numbers. The output format must be strictly followed to ensure compatibility with test cases.\nrequirement pool:\n- Efficiently process large arrays up to 2 \u22c5 10^5 elements.\n- Correctly handle arrays with negative numbers.\n- Ensure output format matches the required specification.\n- Handle arrays with repeated numbers accurately.\n- Provide robust solution against edge cases.\nWe will use a greedy approach to solve the problem efficiently. The idea is to sort the array and then calculate the maximum possible minimum by iteratively subtracting the smallest element from the rest of the array. This approach ensures that we maximize the minimum value after each operation. We will use Python's built-in sorting function for efficiency and simplicity.\n", "requirement analysis:\nThe requirement is to find the maximal possible minimum of an array after applying a series of minimum extraction operations. The solution must efficiently handle multiple test cases and large arrays, considering edge cases such as arrays with negative numbers and repeated elements.\nrequirement pool:\n- Efficiently process large arrays\n- Handle negative numbers correctly\n- Provide clear output format\n- Consider edge cases\n- Optimize for repeated elements\nWe will implement a function that processes each test case independently. For each test case, we will sort the array and then calculate the maximum possible minimum by iteratively applying the minimum extraction operation. The approach leverages sorting to efficiently determine the sequence of minimum extractions, ensuring the solution handles large arrays and negative numbers correctly.\n", "requirement analysis:\nThe requirement is to find the maximal possible minimum value in an array after applying a series of minimum extraction operations. The solution must efficiently handle multiple test cases and large arrays, considering edge cases such as arrays with negative numbers and repeated values.\nrequirement pool:\n- Efficiently process large arrays\n- Handle negative numbers correctly\n- Provide accurate results for each test case\n- Consider edge cases in the solution\n- Optimize for performance\nWe will implement a function that processes each test case independently. For each test case, we will sort the array and then calculate the differences between consecutive elements. The maximum of these differences will be the answer for that test case. This approach ensures that we efficiently find the maximal possible minimum value after applying the minimum extraction operation multiple times. Sorting the array will allow us to easily compute the differences, and the solution will handle both positive and negative numbers correctly.\n", "requirement analysis:\nThe requirement is to find the maximal possible minimum of an array after applying a series of minimum extraction operations. The solution must efficiently handle large inputs and consider edge cases such as arrays with negative numbers, repeated numbers, and arrays of length 1.\nrequirement pool:\n- Efficiently handle large inputs up to 2 \u22c5 10^5 elements\n- Correctly compute the maximal possible minimum for each test case\n- Consider edge cases such as negative numbers and repeated numbers\n- Ensure solution is fast for maximum number of test cases\n- Provide clear and understandable implementation\nWe will implement a function that processes each test case independently. For each test case, we will sort the array and then calculate the maximal possible minimum by iteratively applying the minimum extraction operation. The approach leverages sorting to efficiently determine the sequence of minimum extractions, ensuring the solution is both accurate and efficient. We will use Python's built-in sorting capabilities to handle large inputs efficiently.\n", "requirement analysis:\nThe requirements focus on maximizing the minimum element of an array after applying a series of operations. The solution must efficiently handle multiple test cases and large arrays, considering edge cases such as arrays with negative numbers and repeated elements.\nrequirement pool:\n- Efficiently process up to 10,000 test cases.\n- Correctly identify and extract the minimum element from arrays.\n- Handle arrays with negative and repeated numbers.\n- Ensure the solution is scalable for large inputs.\n- Provide clear documentation and output format.\nWe will implement a function that processes each test case independently. For each array, we will simulate the minimum extraction operation by sorting the array and calculating the differences between consecutive elements. This approach efficiently finds the maximal possible minimum after the operations. We will use Python's built-in sorting capabilities to handle large arrays efficiently.\n"], "scores": [], "pass_results": [true, true, true, false, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 817, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "mutate_method": "add_1_sentence_at_end", "parent_index": 112}
