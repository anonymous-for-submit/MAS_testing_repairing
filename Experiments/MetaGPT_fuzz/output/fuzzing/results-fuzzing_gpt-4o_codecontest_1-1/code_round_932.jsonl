{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM found a rectangle A with dimensions n by m. There are n rows and m columns comprised of blocks. Each block in the rectangle is either an obsidian block or it is empty. CQXYM can convert an obsidian block to an empty block or convert an empty block to an obsidian block in a single operation.\n\nA rectangle M with dimensions a by b is considered a portal if and only if it fulfills the following requirements:\n\n  * a is at least 5 and b is at least 4.\n  * For all values where 1 < x < a, blocks M_{x,1} and M_{x,b} must be obsidian blocks.\n  * For all values where 1 < x < b, blocks M_{1,x} and M_{a,x} must be obsidian blocks.\n  * For all values where 1 < x < a and 1 < y < b, block M_{x,y} must be an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations required for him to transform at least one sub-rectangle into a portal. Provide a solution that is efficient in relation to time complexity.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM found a rectangle A with dimensions n by m. There are n rows and m columns comprised of blocks. Each block in the rectangle is either an obsidian block or it is empty. CQXYM can convert an obsidian block to an empty block or convert an empty block to an obsidian block in a single operation.\n\nA rectangle M with dimensions a by b is considered a portal if and only if it fulfills the following requirements:\n\n  * a is at least 5 and b is at least 4.\n  * For all values where 1 < x < a, blocks M_{x,1} and M_{x,b} must be obsidian blocks.\n  * For all values where 1 < x < b, blocks M_{1,x} and M_{a,x} must be obsidian blocks.\n  * For all values where 1 < x < a and 1 < y < b, block M_{x,y} must be an empty block.\n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type.\n\nNote that there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations required for him to transform at least one sub-rectangle into a portal. Provide a solution that is efficient in relation to time complexity.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid representing the blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Check the borders and inner blocks according to portal requirements\n    for i in range(start_row, end_row + 1):\n        for j in range(start_col, end_col + 1):\n            if (i == start_row or i == end_row) and (j > start_col and j < end_col):\n                # Top and bottom borders (except corners)\n                if grid[i][j] != '1':\n                    operations += 1\n            elif (j == start_col or j == end_col) and (i > start_row and i < end_row):\n                # Left and right borders (except corners)\n                if grid[i][j] != '1':\n                    operations += 1\n            elif (i > start_row and i < end_row) and (j > start_col and j < end_col):\n                # Inner blocks\n                if grid[i][j] != '0':\n                    operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test cases, each containing dimensions n, m and the grid.\n\n    Returns:\n        list: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_rect, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to transform.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n\n    # Check the inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations required to transform sub-rectangles into portals.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m and the grid\n    :return: List of minimum operations for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([[int(char) for char in row] for row in grid])\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of operations needed to transform the sub-rectangle into a portal\n                        operations = calculate_operations(matrix, i, j, a, b)\n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(matrix: np.ndarray, i: int, j: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param matrix: The grid as a numpy array\n    :param i: Top-left row index of the sub-rectangle\n    :param j: Top-left column index of the sub-rectangle\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n    \n    # Check the borders and inner blocks of the sub-rectangle\n    for x in range(a):\n        for y in range(b):\n            if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                # Border conditions\n                if (x > 0 and x < a - 1 and (y == 0 or y == b - 1)) or (y > 0 and y < b - 1 and (x == 0 or x == a - 1)):\n                    # Should be obsidian\n                    if matrix[i + x, j + y] == 0:\n                        operations += 1\n            else:\n                # Inner blocks should be empty\n                if matrix[i + x, j + y] == 1:\n                    operations += 1\n    \n    return operations\n\n# Interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: Minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for a in range(i + 4, n):\n                    for b in range(j + 3, m):\n                        # Calculate operations needed to convert current sub-rectangle to a portal\n                        operations = calculate_operations(grid_array, i, j, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, i: int, j: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        i (int): Top-left row index of the sub-rectangle.\n        j (int): Top-left column index of the sub-rectangle.\n        a (int): Bottom-right row index of the sub-rectangle.\n        b (int): Bottom-right column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions for the portal\n    for x in range(i + 1, a):\n        if grid[x, j] != 1:\n            operations += 1\n        if grid[x, b] != 1:\n            operations += 1\n\n    for y in range(j + 1, b):\n        if grid[i, y] != 1:\n            operations += 1\n        if grid[a, y] != 1:\n            operations += 1\n\n    # Check the inner conditions for the portal\n    for x in range(i + 1, a):\n        for y in range(j + 1, b):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print the results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for a in range(i + 4, n):\n                    for b in range(j + 3, m):\n                        # Calculate operations needed to transform the sub-rectangle into a portal\n                        operations = calculate_operations(grid, i, j, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], i: int, j: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of '0's and '1's.\n        i (int): Top-left row index of the sub-rectangle.\n        j (int): Top-left column index of the sub-rectangle.\n        a (int): Bottom-right row index of the sub-rectangle.\n        b (int): Bottom-right column index of the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions\n    for x in range(i + 1, a):\n        if grid[x][j] != '1':\n            operations += 1\n        if grid[x][b] != '1':\n            operations += 1\n\n    for y in range(j + 1, b):\n        if grid[i][y] != '1':\n            operations += 1\n        if grid[a][y] != '1':\n            operations += 1\n\n    # Check the inner conditions\n    for x in range(i + 1, a):\n        for y in range(j + 1, b):\n            if grid[x][y] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform at least one sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        List[int]: List of minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed for current sub-rectangle\n                        operations = calculate_operations(grid, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid representing the blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        end_row (int): Ending row of the sub-rectangle.\n        end_col (int): Ending column of the sub-rectangle.\n\n    Returns:\n        int: Number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Check border conditions\n    for i in range(start_row + 1, end_row):\n        if grid[i][start_col] != '1':\n            operations += 1\n        if grid[i][end_col] != '1':\n            operations += 1\n\n    for j in range(start_col + 1, end_col):\n        if grid[start_row][j] != '1':\n            operations += 1\n        if grid[end_row][j] != '1':\n            operations += 1\n\n    # Check internal empty block conditions\n    for i in range(start_row + 1, end_row):\n        for j in range(start_col + 1, end_col):\n            if grid[i][j] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: List of minimum operations for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([[int(char) for char in row] for row in grid])\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Check sub-rectangle of size 5x4\n                sub_matrix = matrix[i:i+5, j:j+4]\n                operations = calculate_operations(sub_matrix)\n                min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(sub_matrix: np.ndarray) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-matrix into a portal.\n\n    Args:\n        sub_matrix (np.ndarray): The sub-matrix to be transformed.\n\n    Returns:\n        int: The number of operations required.\n    \"\"\"\n    a, b = sub_matrix.shape\n    operations = 0\n    \n    # Check the conditions for a portal\n    for x in range(1, a - 1):\n        if sub_matrix[x, 0] != 1:\n            operations += 1\n        if sub_matrix[x, b - 1] != 1:\n            operations += 1\n    \n    for y in range(1, b - 1):\n        if sub_matrix[0, y] != 1:\n            operations += 1\n        if sub_matrix[a - 1, y] != 1:\n            operations += 1\n    \n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_matrix[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the grid as a list of strings\n    :return: List of integers, each representing the minimum operations for a test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    :param grid: Numpy array representing the grid\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations required\n    \"\"\"\n    operations = 0\n    \n    # Check and transform the borders\n    for x in range(start_row + 1, end_row):\n        if grid[x, start_col] != 1:\n            operations += 1\n        if grid[x, end_col] != 1:\n            operations += 1\n    \n    for y in range(start_col + 1, end_col):\n        if grid[start_row, y] != 1:\n            operations += 1\n        if grid[end_row, y] != 1:\n            operations += 1\n    \n    # Check and transform the inner blocks\n    for x in range(start_row + 1, end_row):\n        for y in range(start_col + 1, end_col):\n            if grid[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations required to transform sub-rectangles into portals.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = matrix[i:i+a, j:j+b]\n                        \n                        # Calculate operations needed to transform sub-rectangle into a portal\n                        operations = calculate_operations_to_portal(sub_rect, a, b)\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations required to transform a sub-rectangle into a portal.\n\n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of operations required\n    \"\"\"\n    operations = 0\n    \n    # Check and transform the borders\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n    \n    # Check and transform the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nnum_cases = int(input())\ntest_cases = []\nfor _ in range(num_cases):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(num_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: A list of minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([[int(char) for char in row] for row in grid])\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for a in range(i + 4, n):\n                    for b in range(j + 3, m):\n                        # Calculate the cost to transform the sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, i, j, a, b)\n                        # Update the minimum operations if a lower cost is found\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, i: int, j: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        i (int): Top-left row index of the sub-rectangle.\n        j (int): Top-left column index of the sub-rectangle.\n        a (int): Bottom-right row index of the sub-rectangle.\n        b (int): Bottom-right column index of the sub-rectangle.\n\n    Returns:\n        int: The number of operations required.\n    \"\"\"\n    operations = 0\n\n    # Check the border conditions for the portal\n    for x in range(i + 1, a):\n        if grid[x, j] != 1:\n            operations += 1\n        if grid[x, b] != 1:\n            operations += 1\n\n    for y in range(j + 1, b):\n        if grid[i, y] != 1:\n            operations += 1\n        if grid[a, y] != 1:\n            operations += 1\n\n    # Check the inner conditions for the portal\n    for x in range(i + 1, a):\n        for y in range(j + 1, b):\n            if grid[x, y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific conditions. The solution must efficiently calculate the minimum number of operations needed, considering the constraints on dimensions and block types. The problem is computationally intensive due to the potential size of the input, requiring an optimized approach.\nrequirement pool:\n- Implement efficient algorithm to transform rectangle into portal\n- Ensure solution handles maximum input sizes within constraints\n- Optimize for minimum operations\n- Provide clear and concise output\n- Consider edge cases and validate input\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of operations. The function will use a dynamic programming approach to efficiently calculate the number of operations required for each sub-rectangle, leveraging the constraints provided. This approach ensures that the solution is both efficient and scalable for large inputs.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern with minimal operations. The constraints ensure that the solution must be efficient, especially given the maximum possible grid size. The solution should iterate over possible sub-rectangles and calculate the cost of transformation, ensuring that it adheres to the portal requirements.\nrequirement pool:\n- Develop an algorithm to find the minimum operations for transformation\n- Ensure the solution is efficient for maximum constraints\n- Provide clear output for each test case\n- Optimize the algorithm for both small and large inputs\n- Include comments and documentation for better understanding\nWe will use a brute-force approach to iterate over all possible sub-rectangles of the given grid and calculate the number of operations required to transform each into a portal. The solution will leverage efficient iteration and calculation techniques to ensure it handles the maximum constraints effectively. We will use numpy for efficient array manipulation.\n", "requirement analysis:\nThe requirements focus on transforming sub-rectangles within a larger rectangle into portals with specific block arrangements. The solution must efficiently calculate the minimum number of operations needed for this transformation, considering constraints on dimensions and block types.\nrequirement pool:\n- Efficient algorithm to find sub-rectangles that can be transformed into portals.\n- Minimize operations required for transformation.\n- Handle multiple test cases efficiently.\n- Ensure clarity in output format.\n- Scalability for larger inputs.\nWe will use a dynamic programming approach to efficiently find sub-rectangles that can be transformed into portals. The algorithm will iterate over possible sub-rectangles and calculate the minimum number of operations required to transform each into a portal. We will leverage numpy for efficient matrix operations.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern with minimal operations. The constraints ensure that the solution must be efficient, especially given the maximum possible grid size. The solution should iterate over possible sub-rectangles and calculate the number of operations needed to convert them into the desired portal pattern.\nrequirement pool:\n- Develop an algorithm to find the minimum operations for portal transformation.\n- Ensure the solution is efficient for maximum constraints.\n- Provide clear output for each test case.\n- Handle edge cases effectively.\n- Optimize for readability and maintainability.\nWe will use a brute-force approach to iterate over all possible sub-rectangles of the given grid and calculate the number of operations needed to convert them into the desired portal pattern. Given the constraints, this approach will be efficient enough as the maximum grid size is limited. We will use numpy for efficient array manipulation.\n", "requirement analysis:\nThe requirements focus on transforming sub-rectangles into portals with minimal operations. The constraints on dimensions and block types are crucial for determining the transformation process. The solution must efficiently handle multiple test cases and large inputs while adhering to the specified format.\nrequirement pool:\n- Efficient algorithm for portal transformation\n- Minimize operations required for transformation\n- Handle multiple test cases effectively\n- Ensure solution meets time complexity constraints\n- Provide clear output format\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations needed to convert it into a portal. We will use a dynamic programming approach to efficiently calculate the number of operations for each sub-rectangle, leveraging the constraints provided. The solution will be optimized to handle the maximum input size efficiently.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern with minimal operations. The constraints ensure that the solution must be efficient, especially given the maximum grid size of 400x400. The solution should iterate over possible sub-rectangles and calculate the number of operations needed to transform them into the desired portal pattern, ensuring optimal performance.\nrequirement pool:\n- Develop an algorithm to find the minimum operations for transformation.\n- Ensure the solution handles edge cases and maximum constraints.\n- Optimize the algorithm for performance and efficiency.\n- Provide clear and formatted output for each test case.\n- Document the solution for better understanding and maintenance.\nWe will iterate over all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of operations required to transform it into a portal. This involves checking the border conditions and the internal empty block conditions. We will use a dynamic programming approach to efficiently calculate the number of operations needed for each sub-rectangle, ensuring that the solution is optimized for performance given the constraints.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern with minimal operations. The constraints ensure that the solution must be efficient, especially for larger grids. The solution should iterate over possible sub-rectangles and calculate the cost of transformation, ensuring it adheres to the portal requirements.\nrequirement pool:\n- Develop an algorithm to find the minimum operations for transformation.\n- Ensure the solution is efficient for maximum constraints.\n- Provide clear output for each test case.\n- Optimize the algorithm for both small and large inputs.\n- Include detailed comments and documentation in the code.\nWe will use a dynamic programming approach to efficiently calculate the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the cost of transformation by checking the conditions for a portal. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern with minimal operations. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must account for all possible sub-rectangles that meet the minimum size requirements and calculate the operations needed to convert them into the desired portal pattern.\nrequirement pool:\n- Develop an algorithm to find the minimum operations for transformation\n- Ensure the solution is efficient for maximum constraints\n- Optimize the algorithm for common patterns\n- Provide detailed output for each test case\n- Implement additional test cases for edge scenarios\nWe will implement a function that iterates over all possible sub-rectangles of the given grid that meet the minimum size requirements. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will keep track of the minimum number of operations required across all sub-rectangles. Given the constraints, we will use a brute-force approach with optimizations to ensure efficiency. The use of numpy will help in efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming sub-rectangles within a larger rectangle into portals with specific block configurations. The solution must efficiently calculate the minimum number of operations needed, considering constraints on dimensions and block types.\nrequirement pool:\n- Efficient algorithm to find sub-rectangles that can be transformed into portals\n- Minimize operations required for transformation\n- Handle multiple test cases efficiently\n- Ensure scalability for large inputs\n- Provide clear and concise output\nWe will use a dynamic programming approach to efficiently find and transform sub-rectangles into portals. The algorithm will iterate over possible sub-rectangles and calculate the minimum number of operations required to transform each into a portal. We will leverage numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe problem requires transforming a sub-rectangle of a given grid into a specific pattern with minimal operations. The constraints suggest that the solution must efficiently handle grids up to 400x400 in size. The key challenge is to identify the optimal sub-rectangle and calculate the minimum operations required.\nrequirement pool:\n- Develop an algorithm to find the optimal sub-rectangle efficiently.\n- Ensure the solution can handle the maximum input size within time limits.\n- Optimize the algorithm for both small and large inputs.\n- Provide detailed comments and documentation for the algorithm.\n- Implement additional test cases to validate the solution.\nWe will use a dynamic programming approach to efficiently find the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over possible sub-rectangles and calculate the cost of transforming each into a portal, while maintaining a minimum cost. We will leverage numpy for efficient matrix operations.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 932, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 503}
