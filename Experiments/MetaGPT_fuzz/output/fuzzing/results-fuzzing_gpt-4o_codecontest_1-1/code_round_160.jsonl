{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir possesses a rectangular sheet featuring a checkered zone with dimensions n \u00d7 m. At the outset, every cell within the region is white.\n\nLet's assign labels to the cell using vertical coordinate i and horizontal coordinate j as (i, j). The cell situated at the top left will be marked (1, 1), and the cell at the bottom right will be marked (n, m).\n\nCasimir sketches ticks of various sizes on the area. A tick of size d (d > 0) centered in cell (i, j) is created in the following manner:\n\n1. Initially, the cell at the center (i, j) receives a black paint. \n2. Subsequently, exactly d cells in the top-left diagonal to the center and exactly d cells in the top-right diagonal to the center are also turned black. \n3. That is all the cells with coordinates (i - h, j \u00b1 h) for every h ranging from 0 to d are painted. Specifically, a tick contains a total of 2d + 1 black cells.\n\nA cell that's already painted will remain black if repainted. Below you can see an illustration of the 4 \u00d7 9 grid, showcasing two ticks with sizes 2 and 3.\n\n<image>\n\nYou receive a description of a checkered area sized n \u00d7 m. Casimir states that this area is a result of him drawing several ticks on it. The ticks might vary in sizes, but each tick size is at least k (meaning d \u2265 k for every tick).\n\nDetermine whether this area can genuinely be composed by sketching a few (potentially none) ticks with sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir possesses a rectangular sheet featuring a checkered zone with dimensions n \u00d7 m. At the outset, every cell within the region is white.\n\nLet's assign labels to the cell using vertical coordinate i and horizontal coordinate j as (i, j). The cell situated at the top left will be marked (1, 1), and the cell at the bottom right will be marked (n, m).\n\nCasimir sketches ticks of various sizes on the area. A tick of size d (d > 0) centered in cell (i, j) is created in the following manner:\n\n1. Initially, the cell at the center (i, j) receives a black paint. \n2. Subsequently, exactly d cells in the top-left diagonal to the center and exactly d cells in the top-right diagonal to the center are also turned black. \n3. That is all the cells with coordinates (i - h, j \u00b1 h) for every h ranging from 0 to d are painted. Specifically, a tick contains a total of 2d + 1 black cells.\n\nA cell that's already painted will remain black if repainted. Below you can see an illustration of the 4 \u00d7 9 grid, showcasing two ticks with sizes 2 and 3.\n\n<image>\n\nYou receive a description of a checkered area sized n \u00d7 m. Casimir states that this area is a result of him drawing several ticks on it. The ticks might vary in sizes, but each tick size is at least k (meaning d \u2265 k for every tick).\n\nDetermine whether this area can genuinely be composed by sketching a few (potentially none) ticks with sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given checkered area can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): The grid representation with '*' for black cells and '.' for white cells.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" if the area can be composed of ticks, \"NO\" otherwise.\n    \"\"\"\n    \n    def is_valid_tick_center(n: int, m: int, k: int, grid: List[str], i: int, j: int) -> bool:\n        \"\"\"Check if a cell can be the center of a tick of size at least k.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the ticks.\n            grid (List[str]): The grid representation.\n            i (int): Row index of the potential tick center.\n            j (int): Column index of the potential tick center.\n\n        Returns:\n            bool: True if the cell can be the center of a valid tick, False otherwise.\n        \"\"\"\n        size = 0\n        while True:\n            if i - size < 0 or j - size < 0 or j + size >= m:\n                break\n            if grid[i - size][j - size] != '*' or grid[i - size][j + size] != '*':\n                break\n            size += 1\n        return size > k\n\n    def can_form_ticks_in_grid(n: int, m: int, k: int, grid: List[str]) -> str:\n        \"\"\"Determine if the grid can be composed of ticks of at least size k.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the ticks.\n            grid (List[str]): The grid representation.\n\n        Returns:\n            str: \"YES\" if the grid can be composed of ticks, \"NO\" otherwise.\n        \"\"\"\n        # Create a copy of the grid to mark used cells\n        used = [[False] * m for _ in range(n)]\n\n        # Traverse the grid from bottom to top\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                if grid[i][j] == '*' and not used[i][j]:\n                    if is_valid_tick_center(n, m, k, grid, i, j):\n                        size = 0\n                        while True:\n                            if i - size < 0 or j - size < 0 or j + size >= m:\n                                break\n                            if grid[i - size][j - size] != '*' or grid[i - size][j + size] != '*':\n                                break\n                            used[i - size][j - size] = True\n                            used[i - size][j + size] = True\n                            size += 1\n                    else:\n                        return \"NO\"\n        return \"YES\"\n\n    results = []\n    for n, m, k, grid in test_cases:\n        result = can_form_ticks_in_grid(n, m, k, grid)\n        results.append(result)\n    \n    return results\n\n# Example usage:\n# t = int(input())\n# test_cases = []\n# for _ in range(t):\n#     n, m, k = map(int, input().split())\n#     grid = [input().strip() for _ in range(n)]\n#     test_cases.append((n, m, k, grid))\n# results = can_form_ticks(t, test_cases)\n# for result in results:\n#     print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each grid can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check for possible tick centers from bottom to top\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                        size += 1\n\n                    # If a valid tick of size at least k is found, mark the cells\n                    if size > k:\n                        for h in range(size):\n                            marked[i - h][j - h] = True\n                            marked[i - h][j + h] = True\n\n        # Verify if all '*' in the grid are covered by valid ticks\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    t = int(data[0])\n    index = 1\n    test_cases = []\n\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        grid = data[index + 1:index + 1 + n]\n        test_cases.append((n, m, k, grid))\n        index += n + 1\n\n    # Call the function and get results\n    results = can_form_ticks(t, test_cases)\n\n    # Output interface\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a grid can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing grid dimensions, minimum tick size, and grid data.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to track if a cell can be part of a tick\n        can_be_center = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick of size at least k\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if grid[i][j] == '*':\n                    # Check if there are k cells in both diagonals\n                    valid_tick = True\n                    for h in range(1, k + 1):\n                        if grid[i - h][j - h] != '*' or grid[i - h][j + h] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        can_be_center[i][j] = True\n\n        # Mark cells that can be part of a tick\n        for i in range(n):\n            for j in range(m):\n                if can_be_center[i][j]:\n                    for h in range(k + 1):\n                        grid[i - h][j - h] = '.'\n                        grid[i - h][j + h] = '.'\n\n        # Check if all '*' cells can be part of a tick\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    possible = False\n                    break\n            if not possible:\n                break\n\n        results.append('YES' if possible else 'NO')\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given grid can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the grid.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, k, grid = case\n        # Create a boolean grid to mark cells that can be part of a tick\n        can_be_tick = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    if is_valid_tick_center(i, j, n, m, k, grid):\n                        mark_tick_cells(i, j, k, can_be_tick)\n\n        # Verify if all '*' in the grid can be part of a tick\n        if all(grid[i][j] == '.' or can_be_tick[i][j] for i in range(n) for j in range(m)):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef is_valid_tick_center(i: int, j: int, n: int, m: int, k: int, grid: List[str]) -> bool:\n    \"\"\"Check if a tick of size k can be centered at (i, j).\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        k (int): Minimum size of the tick.\n        grid (List[str]): The grid representation.\n\n    Returns:\n        bool: True if a tick of size k can be centered at (i, j), False otherwise.\n    \"\"\"\n    for d in range(1, k + 1):\n        if i - d < 0 or j - d < 0 or j + d >= m:\n            return False\n        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n            return False\n    return True\n\ndef mark_tick_cells(i: int, j: int, k: int, can_be_tick: List[List[bool]]):\n    \"\"\"Mark the cells that can be part of a tick centered at (i, j).\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Size of the tick.\n        can_be_tick (List[List[bool]]): Boolean grid to mark tick cells.\n    \"\"\"\n    for d in range(k + 1):\n        can_be_tick[i - d][j - d] = True\n        can_be_tick[i - d][j + d] = True\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given grid can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the grid.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, k, grid = case\n        # Create a 2D list to track if a cell is part of a valid tick\n        valid_tick = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick of size at least k\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if can_form_tick_of_size_k(i, j, n, m, k, grid):\n                        # Mark the cells of the tick as valid\n                        mark_tick_cells(i, j, k, valid_tick)\n\n        # Verify if all '*' in the grid are part of a valid tick\n        if all(grid[i][j] == '.' or valid_tick[i][j] for i in range(n) for j in range(m)):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef can_form_tick_of_size_k(i: int, j: int, n: int, m: int, k: int, grid: List[str]) -> bool:\n    \"\"\"Check if a tick of size at least k can be formed with (i, j) as the center.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        k (int): Minimum size of the tick.\n        grid (List[str]): The grid representation.\n\n    Returns:\n        bool: True if a tick of size at least k can be formed, False otherwise.\n    \"\"\"\n    # Check if there are enough cells in both diagonals\n    for d in range(1, k + 1):\n        if i - d < 0 or j - d < 0 or j + d >= m:\n            return False\n        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n            return False\n    return True\n\ndef mark_tick_cells(i: int, j: int, k: int, valid_tick: List[List[bool]]):\n    \"\"\"Mark the cells of a tick as valid in the valid_tick grid.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Size of the tick.\n        valid_tick (List[List[bool]]): 2D list to track valid tick cells.\n    \"\"\"\n    # Mark the center\n    valid_tick[i][j] = True\n    # Mark the diagonals\n    for d in range(1, k + 1):\n        valid_tick[i - d][j - d] = True\n        valid_tick[i - d][j + d] = True\n\n# Example usage:\n# t = int(input())\n# test_cases = []\n# for _ in range(t):\n#     n, m, k = map(int, input().split())\n#     grid = [input().strip() for _ in range(n)]\n#     test_cases.append((n, m, k, grid))\n# results = can_form_ticks(t, test_cases)\n# for result in results:\n#     print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given grid can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the grid.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a copy of the grid to mark cells that can be part of a tick\n        marked_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if this cell can be the center of a tick of size at least k\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells\n                    if size >= k:\n                        for h in range(size):\n                            marked_grid[i - h][j - h] = True\n                            marked_grid[i - h][j + h] = True\n\n        # Check if all '*' in the grid are marked\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked_grid[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a grid can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing grid dimensions, minimum tick size, and grid data.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a matrix to track if a cell can be the center of a tick\n        can_be_center = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if can_form_tick(i, j, k, n, m, grid):\n                        can_be_center[i][j] = True\n\n        # Check if all '*' cells can be part of a tick\n        if all_stars_covered(n, m, grid, can_be_center):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef can_form_tick(i: int, j: int, k: int, n: int, m: int, grid: List[str]) -> bool:\n    \"\"\"Check if a tick of size k can be formed with (i, j) as the center.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Minimum size of the tick.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[str]): Grid data.\n\n    Returns:\n        bool: True if a tick can be formed, False otherwise.\n    \"\"\"\n    for d in range(1, k + 1):\n        if i - d < 0 or j - d < 0 or j + d >= m:\n            return False\n        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n            return False\n    return True\n\ndef all_stars_covered(n: int, m: int, grid: List[str], can_be_center: List[List[bool]]) -> bool:\n    \"\"\"Check if all '*' cells can be part of a tick.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[str]): Grid data.\n        can_be_center (List[List[bool]]): Matrix indicating if a cell can be the center of a tick.\n\n    Returns:\n        bool: True if all '*' cells can be covered by ticks, False otherwise.\n    \"\"\"\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                # Check if this '*' can be part of a tick\n                if not is_part_of_tick(i, j, n, m, can_be_center):\n                    return False\n    return True\n\ndef is_part_of_tick(i: int, j: int, n: int, m: int, can_be_center: List[List[bool]]) -> bool:\n    \"\"\"Check if a '*' cell can be part of a tick.\n\n    Args:\n        i (int): Row index of the cell.\n        j (int): Column index of the cell.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        can_be_center (List[List[bool]]): Matrix indicating if a cell can be the center of a tick.\n\n    Returns:\n        bool: True if the cell can be part of a tick, False otherwise.\n    \"\"\"\n    for d in range(n):\n        if i + d < n and j - d >= 0 and j + d < m:\n            if can_be_center[i + d][j]:\n                return True\n    return False\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Output interface\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given grid can be formed using ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing grid dimensions, minimum tick size, and grid data.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    def is_valid_tick_center(n: int, m: int, k: int, grid: List[str], i: int, j: int) -> bool:\n        \"\"\"Check if the cell (i, j) can be the center of a tick of size at least k.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the ticks.\n            grid (List[str]): Grid data.\n            i (int): Row index of the potential tick center.\n            j (int): Column index of the potential tick center.\n\n        Returns:\n            bool: True if the cell can be the center of a valid tick, False otherwise.\n        \"\"\"\n        for d in range(1, k + 1):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                return False\n        return True\n\n    def can_form_grid_with_ticks(n: int, m: int, k: int, grid: List[str]) -> str:\n        \"\"\"Determine if the grid can be formed using ticks of size at least k.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the ticks.\n            grid (List[str]): Grid data.\n\n        Returns:\n            str: \"YES\" if the grid can be formed with valid ticks, \"NO\" otherwise.\n        \"\"\"\n        painted = [[False] * m for _ in range(n)]\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and is_valid_tick_center(n, m, k, grid, i, j):\n                    for d in range(k + 1):\n                        painted[i - d][j - d] = True\n                        painted[i - d][j + d] = True\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not painted[i][j]:\n                    return \"NO\"\n        return \"YES\"\n\n    results = []\n    for n, m, k, grid in test_cases:\n        results.append(can_form_grid_with_ticks(n, m, k, grid))\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Call the function and print results\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given grid can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the grid.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, k, grid = case\n        # Create a 2D list to track if a cell is part of a valid tick\n        valid_tick = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a valid tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                                grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells as part of a valid tick\n                    if size > k:\n                        for h in range(size):\n                            valid_tick[i - h][j - h] = True\n                            valid_tick[i - h][j + h] = True\n\n        # Check if all '*' cells are part of a valid tick\n        is_valid = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not valid_tick[i][j]:\n                    is_valid = False\n                    break\n            if not is_valid:\n                break\n\n        results.append(\"YES\" if is_valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\ndef can_form_ticks(t: int, test_cases: list[tuple[int, int, int, list[str]]]) -> list[str]:\n    \"\"\"Determine if the given grid can be formed by drawing ticks of at least the given size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, int, list[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (list[str]): Grid representation with '*' for painted cells and '.' for unpainted cells.\n\n    Returns:\n        list[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    def mark_tick_cells(n, m, k, grid, marked, i, j):\n        \"\"\"Mark cells that are part of a valid tick of size at least k.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the ticks.\n            grid (list[str]): Grid representation.\n            marked (list[list[bool]]): Grid to mark cells part of a valid tick.\n            i (int): Row index of the center of the tick.\n            j (int): Column index of the center of the tick.\n        \"\"\"\n        size = 0\n        while True:\n            if i - size < 0 or j - size < 0 or j + size >= m:\n                break\n            if grid[i - size][j - size] != '*' or grid[i - size][j + size] != '*':\n                break\n            size += 1\n        if size >= k:\n            for h in range(size):\n                marked[i - h][j - h] = True\n                marked[i - h][j + h] = True\n\n    results = []\n    for n, m, k, grid in test_cases:\n        marked = [[False] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    mark_tick_cells(n, m, k, grid, marked, i, j)\n\n        valid = all(marked[i][j] for i in range(n) for j in range(m) if grid[i][j] == '*')\n        results.append('YES' if valid else 'NO')\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print the results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on determining if a given checkered area can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases, ensuring accurate results while optimizing performance. Edge cases must be considered, and the output should be clear and concise.\nrequirement pool:\n- Accurate tick detection algorithm\n- Efficient handling of multiple test cases\n- Optimization for performance\n- Clear and concise output format\n- Edge case handling\nWe will implement a function to determine if a given checkered area can be composed of ticks of a minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use a simple nested loop to traverse the grid and a helper function to validate potential tick centers. The solution will be optimized for performance by breaking early when a valid configuration is found or when it's impossible to form a tick.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, ensuring that all black cells can be part of valid ticks. The constraints are small enough to allow a direct simulation approach, but care must be taken to handle edge cases where ticks cannot be formed.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the output format is correct and matches the required specifications.\n- Write test cases to cover all possible edge cases.\n- Document the code to improve readability and maintainability.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. If a cell is part of a tick, it will be marked as such, and we will ensure that all '*' cells are covered by valid ticks. The solution will handle multiple test cases efficiently by processing each grid independently.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases, ensuring accurate detection of tick patterns while optimizing for performance. Edge cases, such as grids with minimal painted cells, must be considered to ensure robustness.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case handling\n- Ensure accurate output for each test case\n- Handle edge cases effectively\n- Provide detailed output explanation\nWe will implement a function to determine if a grid can be composed of ticks of a minimum size using a straightforward algorithm. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use simple loops and condition checks to ensure performance is optimized for multiple test cases. The solution will handle edge cases by verifying if each painted cell can be part of a valid tick.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each cell to see if it can be the center of a valid tick, considering the constraints of the grid size and tick size.\nrequirement pool:\n- Implement the main algorithm to check for valid tick formations.\n- Ensure the solution handles all edge cases, including minimum and maximum grid sizes.\n- Optimize the algorithm for performance with large inputs.\n- Maintain code readability and simplicity for future maintenance.\n- Provide detailed comments and documentation for the code.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid and check if it can be the center of a valid tick, considering the constraints of the grid size and tick size. We will use simple loops and condition checks to ensure efficiency and readability. The solution will handle edge cases such as overlapping ticks and minimal grid sizes.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each cell to see if it can be the center of a valid tick and ensure all '*' cells are covered by ticks of at least size k.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid and check if it can be the center of a valid tick of size at least k. We will use a simple nested loop to traverse the grid and check the conditions for forming ticks. The solution will be efficient enough to handle the maximum constraints given the small grid size limits.\n", "requirement analysis:\nThe task involves determining if a given checkered area can be formed by drawing ticks of a minimum size k. The challenge is to ensure that all black cells can be part of ticks of size at least k, and no isolated black cells exist that cannot be part of such ticks.\nrequirement pool:\n- Implement the main algorithm to check if the grid can be formed by ticks of size at least k.\n- Ensure the solution handles multiple test cases efficiently.\n- Optimize the algorithm for edge cases with maximum constraints.\n- Provide clear and concise output for each test case.\n- Consider user experience in terms of input and output format.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. If a cell is part of a tick, it will be marked as such, and the function will continue to the next cell. The solution will handle multiple test cases efficiently by processing each grid independently.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must handle multiple test cases efficiently and provide accurate results. Edge cases, such as grids with minimal painted cells, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case processing\n- Handle edge cases gracefully\n- Ensure output clarity and conciseness\n- Improve UI for better user experience\nWe will implement a function to determine if a grid can be composed of ticks of a minimum size using a straightforward algorithm. The algorithm will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use simple loops and condition checks to ensure the solution is efficient and handles multiple test cases. The Python standard library will be sufficient for this task.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be formed using ticks of a minimum size. The solution must efficiently handle multiple test cases and provide clear output for each. Edge cases, such as grids with minimal painted cells, must be considered.\nrequirement pool:\n- Implement the main algorithm to check tick formation\n- Optimize for handling up to 100 test cases efficiently\n- Ensure output format is clear and matches requirements\n- Handle edge cases where minimal cells are painted\n- Provide detailed error messages for invalid inputs\nWe will implement a function to determine if a given grid can be formed using ticks of a minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use a simple nested loop to traverse the grid and a helper function to validate potential tick centers. The solution will be optimized to handle up to 100 test cases efficiently by processing each grid independently.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, ensuring that all black cells can be part of valid ticks. The constraints are small enough to allow a direct simulation approach, but care must be taken to handle edge cases where ticks cannot be formed.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the output format is correct and matches the required specifications.\n- Write test cases to cover edge scenarios and validate the solution.\n- Document the code to improve readability and maintainability.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. If all black cells can be part of valid ticks, the function will return YES; otherwise, NO. The constraints are small enough to allow a direct simulation approach without the need for complex data structures.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, ensuring that all black cells can be part of valid ticks. The constraints are manageable, allowing for a direct simulation approach.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is robust against edge cases, such as minimal grid sizes.\n- Provide clear and consistent output formatting.\n- Maintain code readability and simplicity for future maintenance.\nWe will iterate over each test case and simulate the process of drawing ticks on the grid. For each cell marked with '*', we will check if it can be the center of a tick of size at least k. We will use a helper function to verify if a tick can be formed at a given position. If all '*' cells can be part of valid ticks, we will return 'YES', otherwise 'NO'. This approach ensures that we efficiently handle the constraints and edge cases.\n"], "scores": [], "pass_results": [false, true, true, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 160, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "rephrase_one", "parent_index": 55}
