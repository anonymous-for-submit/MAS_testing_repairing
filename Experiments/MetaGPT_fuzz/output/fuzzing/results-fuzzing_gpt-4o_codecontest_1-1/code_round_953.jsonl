{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or an empty block. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The blocks on the edges of the portal must be made of obsidian to maintain its structure.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is either an obsidian block or an empty block. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. The blocks on the edges of the portal must be made of obsidian to maintain its structure.\n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n    \n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing n, m, and the grid as a list of strings\n    :return: List of integers representing the minimum operations for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = calculate_operations(grid_array, start_row, start_col, end_row, end_col)\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n    \n    :param grid: Numpy array representing the grid\n    :param start_row: Starting row index of the sub-rectangle\n    :param start_col: Starting column index of the sub-rectangle\n    :param end_row: Ending row index of the sub-rectangle\n    :param end_col: Ending column index of the sub-rectangle\n    :return: Number of operations needed\n    \"\"\"\n    operations = 0\n    \n    # Transform edges to obsidian blocks\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            operations += 1\n        if grid[row, end_col] != 1:\n            operations += 1\n    \n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            operations += 1\n        if grid[end_row, col] != 1:\n            operations += 1\n    \n    # Transform inner blocks to empty blocks\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and matrix.\n\n    Returns:\n        list[int]: Minimum number of operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient manipulation\n        matrix_np = np.array([list(row) for row in matrix], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a \u00d7 b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_matrix = matrix_np[i:i + a, j:j + b]\n                        operations = calculate_operations(sub_matrix, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_matrix: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_matrix (np.ndarray): The sub-rectangle matrix.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the edges and inner part of the sub-rectangle\n    for x in range(a):\n        for y in range(b):\n            if (x == 0 or x == a - 1) and (1 <= y < b - 1):\n                # Top and bottom edges (except corners)\n                if sub_matrix[x, y] != 1:\n                    operations += 1\n            elif (y == 0 or y == b - 1) and (1 <= x < a - 1):\n                # Left and right edges (except corners)\n                if sub_matrix[x, y] != 1:\n                    operations += 1\n            elif 1 <= x < a - 1 and 1 <= y < b - 1:\n                # Inner part\n                if sub_matrix[x, y] != 0:\n                    operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = calculate_operations(grid, i, j, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to convert a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the edges of the portal\n    for x in range(1, a - 1):\n        if grid[start_row + x][start_col] != '1':\n            operations += 1\n        if grid[start_row + x][start_col + b - 1] != '1':\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row][start_col + y] != '1':\n            operations += 1\n        if grid[start_row + a - 1][start_col + y] != '1':\n            operations += 1\n\n    # Check the inner blocks of the portal\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x][start_col + y] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing the dimensions\n            of the matrix and the matrix itself.\n\n    Returns:\n        list[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of operations needed to make the sub-rectangle a portal\n                        operations = calculate_operations(grid, i, j, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The matrix of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the edges of the portal\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            operations += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            operations += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            operations += 1\n\n    # Check the inner part of the portal\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, and the grid.\n\n    Returns:\n        List[int]: List of minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([[int(char) for char in row] for row in grid])\n        \n        # Initialize the minimum operations to a large number\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size a x b\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[i:i+a, j:j+b]\n                        \n                        # Calculate the number of operations needed to make this sub-rectangle a portal\n                        operations = calculate_operations(sub_rect, a, b)\n                        \n                        # Update the minimum operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to transform.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the edges and the inner part of the sub-rectangle\n    for x in range(a):\n        for y in range(b):\n            if (x == 0 or x == a - 1 or y == 0 or y == b - 1):\n                # Edge conditions\n                if (x == 0 or x == a - 1) and (1 <= y < b - 1):\n                    # Top and bottom edges (except corners)\n                    if sub_rect[x, y] != 1:\n                        operations += 1\n                elif (y == 0 or y == b - 1) and (1 <= x < a - 1):\n                    # Left and right edges (except corners)\n                    if sub_rect[x, y] != 1:\n                        operations += 1\n            else:\n                # Inner part should be empty\n                if sub_rect[x, y] != 0:\n                    operations += 1\n\n    return operations\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = calculate_operations(grid, i, j, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check the edges of the portal\n    for x in range(1, a - 1):\n        if grid[start_row + x][start_col] != '1':\n            operations += 1\n        if grid[start_row + x][start_col + b - 1] != '1':\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row][start_col + y] != '1':\n            operations += 1\n        if grid[start_row + a - 1][start_col + y] != '1':\n            operations += 1\n\n    # Check the inner blocks of the portal\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x][start_col + y] != '0':\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_operations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of operations to transform a sub-rectangle into a portal.\n    \n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings.\n    \n    Returns:\n        List of integers, each representing the minimum operations for a test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        min_operations = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i+a, j:j+b]\n                        \n                        # Calculate operations needed to transform sub-rectangle into a portal\n                        operations = calculate_operations(sub_rect, a, b)\n                        \n                        # Update minimum operations\n                        min_operations = min(min_operations, operations)\n        \n        results.append(min_operations)\n    \n    return results\n\ndef calculate_operations(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of operations needed to transform a sub-rectangle into a portal.\n    \n    Args:\n        sub_rect: The sub-rectangle as a numpy array.\n        a: Number of rows in the sub-rectangle.\n        b: Number of columns in the sub-rectangle.\n    \n    Returns:\n        The number of operations needed.\n    \"\"\"\n    operations = 0\n    \n    # Check and transform the edges to obsidian blocks\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            operations += 1\n        if sub_rect[x, b - 1] != 1:\n            operations += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            operations += 1\n        if sub_rect[a - 1, y] != 1:\n            operations += 1\n    \n    # Check and transform the inner blocks to empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                operations += 1\n    \n    return operations\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        \n        # Initialize prefix sums for obsidian and empty blocks\n        prefix_obsidian = [[0] * (m + 1) for _ in range(n + 1)]\n        prefix_empty = [[0] * (m + 1) for _ in range(n + 1)]\n\n        # Fill prefix sum arrays\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                is_obsidian = 1 if grid[i - 1][j - 1] == '1' else 0\n                prefix_obsidian[i][j] = (prefix_obsidian[i - 1][j] + prefix_obsidian[i][j - 1] \n                                         - prefix_obsidian[i - 1][j - 1] + is_obsidian)\n                prefix_empty[i][j] = (prefix_empty[i - 1][j] + prefix_empty[i][j - 1] \n                                      - prefix_empty[i - 1][j - 1] + (1 - is_obsidian))\n\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(1, n - a + 2):\n                    for j in range(1, m - b + 2):\n                        # Calculate the number of operations needed for the current sub-rectangle\n                        total_obsidian = (prefix_obsidian[i + a - 1][j + b - 1] \n                                          - prefix_obsidian[i - 1][j + b - 1] \n                                          - prefix_obsidian[i + a - 1][j - 1] \n                                          + prefix_obsidian[i - 1][j - 1])\n                        total_empty = (prefix_empty[i + a - 1][j + b - 1] \n                                       - prefix_empty[i - 1][j + b - 1] \n                                       - prefix_empty[i + a - 1][j - 1] \n                                       + prefix_empty[i - 1][j - 1])\n\n                        # Calculate the number of obsidian blocks needed on the edges\n                        edge_obsidian = (2 * (a - 2) + 2 * (b - 2))\n                        # Calculate the number of empty blocks needed inside\n                        inside_empty = (a - 2) * (b - 2)\n\n                        # Calculate operations needed to transform current sub-rectangle into a portal\n                        operations = (edge_obsidian - (total_obsidian - inside_empty) \n                                      + inside_empty - (total_empty - edge_obsidian))\n\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_operations_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef find_min_operations(t: int, test_cases: list) -> list:\n    \"\"\"Find the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of test case data, each containing dimensions and the grid.\n\n    Returns:\n        list: List of minimum operations for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        operations = calculate_operations(grid_array, i, j, a, b)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\ndef calculate_operations(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of operations needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid of blocks.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of operations needed.\n    \"\"\"\n    operations = 0\n\n    # Check and count operations for the edges\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            operations += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            operations += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            operations += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            operations += 1\n\n    # Check and count operations for the inner empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                operations += 1\n\n    return operations\n\n# Input interface\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = find_min_operations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_operations_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of operations required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum operations required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Initialize prefix sums for obsidian and empty blocks\n        obsidian_prefix = [[0] * (m + 1) for _ in range(n + 1)]\n        empty_prefix = [[0] * (m + 1) for _ in range(n + 1)]\n\n        # Calculate prefix sums\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                obsidian_prefix[i][j] = obsidian_prefix[i - 1][j] + obsidian_prefix[i][j - 1] - obsidian_prefix[i - 1][j - 1] + (1 if grid[i - 1][j - 1] == '1' else 0)\n                empty_prefix[i][j] = empty_prefix[i - 1][j] + empty_prefix[i][j - 1] - empty_prefix[i - 1][j - 1] + (1 if grid[i - 1][j - 1] == '0' else 0)\n\n        min_operations = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(1, n - a + 2):\n                    for j in range(1, m - b + 2):\n                        # Calculate the number of operations needed to transform the sub-rectangle into a portal\n                        obsidian_edges = (a - 2) * 2 + (b - 2) * 2\n                        empty_inside = (a - 2) * (b - 2)\n                        \n                        obsidian_count = (\n                            obsidian_prefix[i + a - 1][j + b - 1]\n                            - obsidian_prefix[i - 1][j + b - 1]\n                            - obsidian_prefix[i + a - 1][j - 1]\n                            + obsidian_prefix[i - 1][j - 1]\n                        )\n                        \n                        empty_count = (\n                            empty_prefix[i + a - 1][j + b - 1]\n                            - empty_prefix[i - 1][j + b - 1]\n                            - empty_prefix[i + a - 1][j - 1]\n                            + empty_prefix[i - 1][j - 1]\n                        )\n                        \n                        operations = abs(obsidian_edges - obsidian_count) + abs(empty_inside - empty_count)\n                        min_operations = min(min_operations, operations)\n\n        results.append(min_operations)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_operations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to transform a given grid into a portal with minimal operations. The portal must have obsidian edges and empty inner blocks, except for corners which can be any type. The solution must efficiently handle multiple test cases and large grid sizes.\nrequirement pool:\n- Implement efficient algorithm to find and transform sub-rectangles into portals.\n- Ensure the solution handles edge cases and large inputs effectively.\n- Provide clear output format for easy understanding.\n- Optimize the code for minimal operations.\n- Enhance user interface for better interaction.\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will return the minimum number of operations required across all sub-rectangles. We will use numpy for efficient grid manipulation and calculations.\n", "requirement analysis:\nThe requirements focus on transforming a given matrix into a portal with minimal operations. The constraints on the size of the portal and the matrix dimensions are crucial for ensuring the solution is efficient and scalable. The output format must be strictly adhered to for compatibility with test cases.\nrequirement pool:\n- Implement efficient matrix transformation algorithm\n- Ensure output format matches requirements\n- Optimize for minimal operations\n- Handle edge cases effectively\n- Provide clear documentation for users\nWe will implement a function that iterates over all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m matrix. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will return the minimum number of operations required across all sub-rectangles. We will use numpy for efficient matrix manipulation.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, but the solution must efficiently handle the maximum input size. The key challenge is to ensure the algorithm can quickly identify potential portal areas and calculate the necessary transformations.\nrequirement pool:\n- Develop an algorithm to identify potential portal areas.\n- Optimize the algorithm for performance with large inputs.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed documentation for the algorithm.\n- Implement additional features for user interaction.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and checking the number of changes needed to convert them into a portal. We will use a brute-force approach with optimizations to handle the constraints efficiently. The function will calculate the number of operations for each potential portal and return the minimum value.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on the dimensions and block types are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and provide clear outputs.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations for portal creation.\n- Ensure solution handles maximum input constraints effectively.\n- Provide clear and concise output format.\n- Optimize code for performance and scalability.\n- Include edge case handling in the solution.\nWe will implement a function to determine the minimum number of operations required to transform a sub-rectangle into a portal. The approach will involve iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to satisfy the portal conditions. We will use numpy for efficient matrix manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on the size and type of blocks are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and provide clear outputs for each.\nrequirement pool:\n- Efficiently compute the minimum operations for each test case\n- Ensure the solution handles maximum constraints effectively\n- Provide clear and concise output for each test case\n- Optimize the algorithm for speed and efficiency\n- Handle edge cases and unusual input scenarios\nWe will use a brute-force approach to check all possible sub-rectangles of size a \u00d7 b within the given n \u00d7 m rectangle. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The solution will leverage numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on the size and type of blocks are crucial for determining the operations needed. Efficient handling of multiple test cases is necessary due to the potential large input size.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations.\n- Ensure the solution handles edge cases correctly.\n- Optimize the code for large input sizes.\n- Provide clear documentation for the solution.\n- Include examples for better understanding.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal conditions. We will use a brute-force approach with optimizations to handle the constraints efficiently. The function will handle multiple test cases and output the results for each.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal operations. The constraints on the size and type of blocks are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and provide clear outputs for each.\nrequirement pool:\n- Implement efficient algorithm to find minimum operations\n- Ensure solution handles maximum input constraints\n- Optimize for speed and performance\n- Provide clear and concise output format\n- Include edge case handling\nWe will implement a function that iterates over all possible sub-rectangles of size at least 5x4 within the given n x m grid. For each sub-rectangle, we will calculate the number of operations needed to transform it into a portal. The function will keep track of the minimum number of operations required across all sub-rectangles. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient due to the potential size of the input. The solution should iterate over possible sub-rectangles and calculate the operations needed to meet the portal conditions.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations for a portal.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases effectively.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution.\nWe will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of operations needed to transform each into a portal. The key challenge is efficiently checking each sub-rectangle and counting the necessary changes. We will use a prefix sum array to quickly calculate the number of obsidian and empty blocks in any sub-rectangle, which will help in determining the number of operations required.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints ensure that the solution must be efficient, especially given the maximum possible size of the input. The solution should iterate over possible sub-rectangles and calculate the required operations, ensuring that the solution is optimal and handles edge cases effectively.\nrequirement pool:\n- Implement the main algorithm to find the minimum operations.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases.\n- Provide detailed comments and documentation.\n- Implement additional test cases for validation.\nWe will implement a function to find the minimum number of operations required to transform a sub-rectangle into a portal. The approach will involve iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal conditions. We will use numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe problem requires finding the minimum number of operations to transform a sub-rectangle into a portal. The constraints are significant, with n and m up to 400, necessitating an efficient algorithm. The solution must handle multiple test cases and provide clear outputs.\nrequirement pool:\n- Develop an efficient algorithm to minimize operations for transforming a sub-rectangle into a portal.\n- Ensure the solution can handle the maximum constraints of n and m effectively.\n- Provide clear and concise output for each test case.\n- Optimize the solution for both small and large inputs.\n- Include detailed comments and documentation for the algorithm.\nWe will use a dynamic programming approach to efficiently calculate the minimum number of operations required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 and calculate the cost of transforming each into a portal. We will use a 2D prefix sum array to quickly calculate the number of obsidian and empty blocks in any sub-rectangle, which will help in determining the number of operations needed.\n"], "scores": [], "pass_results": [false, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 953, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "expand_one2two", "parent_index": 10}
