{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n \u00d7 m, consisting of n rows and m columns of blocks, where each block within this rectangle is either an obsidian block or empty, and CQXYM has the ability to transform an obsidian block into an empty block or vice versa with a single operation. A rectangle M with dimensions a \u00d7 b is defined as a portal if it meets the following criteria: a must be at least 5, and b must be at least 4, and for every 1 < x < a, the blocks located at M_{x,1} and M_{x,b} must be obsidian blocks, while for every 1 < x < b, the blocks at M_{1,x} and M_{a,x} need to be obsidian blocks, plus for all 1 < x < a, 1 < y < b, block M_{x,y} must be empty, and the blocks located at M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type. It's important to note that the arrangement must include a rows and b columns, instead of b rows and a columns, and the blocks at the corners can be of any type. CQXYM is curious about the minimum number of changes he must perform for at least one sub-rectangle to become a portal. Ensure that you carefully consider the criteria for a valid portal when developing a solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n \u00d7 m, consisting of n rows and m columns of blocks, where each block within this rectangle is either an obsidian block or empty, and CQXYM has the ability to transform an obsidian block into an empty block or vice versa with a single operation. A rectangle M with dimensions a \u00d7 b is defined as a portal if it meets the following criteria: a must be at least 5, and b must be at least 4, and for every 1 < x < a, the blocks located at M_{x,1} and M_{x,b} must be obsidian blocks, while for every 1 < x < b, the blocks at M_{1,x} and M_{a,x} need to be obsidian blocks, plus for all 1 < x < a, 1 < y < b, block M_{x,y} must be empty, and the blocks located at M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type. It's important to note that the arrangement must include a rows and b columns, instead of b rows and a columns, and the blocks at the corners can be of any type. CQXYM is curious about the minimum number of changes he must perform for at least one sub-rectangle to become a portal. Ensure that you carefully consider the criteria for a valid portal when developing a solution.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions of the rectangle and the matrix.\n\n    Returns:\n        list: Minimum number of changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_changes = float('inf')\n\n        # Convert the matrix to a numpy array for efficient operations\n        np_matrix = np.array(matrix)\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = np_matrix[i:i + a, j:j + b]\n\n                        # Calculate the number of changes needed to make this sub-rectangle a portal\n                        changes = calculate_changes_to_portal(sub_rect, a, b)\n\n                        # Update the minimum changes found\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle matrix.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions for the portal\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n\n    # Check the inner part of the portal\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().strip())) for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Call the function and print results\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required for each test case to form a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(matrix, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    :param matrix: The grid as a numpy array\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes required\n    \"\"\"\n    changes = 0\n\n    # Check the portal criteria\n    for x in range(1, a - 1):\n        if matrix[start_row + x, start_col] != 1:\n            changes += 1\n        if matrix[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if matrix[start_row, start_col + y] != 1:\n            changes += 1\n        if matrix[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Process and output results\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of changes required for at least one sub-rectangle to become a portal.\n    \n    Parameters:\n    t (int): Number of test cases.\n    test_cases (list): A list of tuples, each containing n, m, and the matrix as a list of strings.\n    \n    Returns:\n    list: A list of integers representing the minimum changes for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient operations\n        grid = np.array([[int(char) for char in row] for row in matrix])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n        \n        # Iterate over all possible top-left corners of the sub-rectangle\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible bottom-right corners of the sub-rectangle\n                for end_row in range(start_row + 4, n):\n                    for end_col in range(start_col + 3, m):\n                        # Calculate the number of changes required for this sub-rectangle\n                        changes = calculate_changes(grid, start_row, start_col, end_row, end_col)\n                        # Update the minimum changes if this is a better solution\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n    \n    Parameters:\n    grid (np.ndarray): The matrix as a numpy array.\n    start_row (int): The starting row of the sub-rectangle.\n    start_col (int): The starting column of the sub-rectangle.\n    end_row (int): The ending row of the sub-rectangle.\n    end_col (int): The ending column of the sub-rectangle.\n    \n    Returns:\n    int: The number of changes required.\n    \"\"\"\n    changes = 0\n    \n    # Check the vertical borders\n    for row in range(start_row + 1, end_row):\n        if grid[row, start_col] != 1:\n            changes += 1\n        if grid[row, end_col] != 1:\n            changes += 1\n    \n    # Check the horizontal borders\n    for col in range(start_col + 1, end_col):\n        if grid[start_row, col] != 1:\n            changes += 1\n        if grid[end_row, col] != 1:\n            changes += 1\n    \n    # Check the inner area\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row, col] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        changes = calculate_changes(grid, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the borders and inner blocks according to portal criteria\n    for x in range(a):\n        for y in range(b):\n            current_block = grid[start_row + x][start_col + y]\n            if x == 0 or x == a - 1:\n                if 1 <= y < b - 1 and current_block != '1':\n                    changes += 1\n            elif y == 0 or y == b - 1:\n                if 1 <= x < a - 1 and current_block != '1':\n                    changes += 1\n            else:\n                if current_block != '0':\n                    changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        list[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the rectangle.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions for obsidian blocks\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the inner conditions for empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and matrix.\n\n    Returns:\n        list[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix to a numpy array for efficient manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible top-left corners of the sub-rectangle\n        for i in range(n - 4):\n            for j in range(m - 3):\n                # Iterate over all possible bottom-right corners of the sub-rectangle\n                for a in range(i + 4, n):\n                    for b in range(j + 3, m):\n                        # Calculate the number of changes required for the current sub-rectangle\n                        changes = calculate_changes(grid, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, i: int, j: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The matrix as a numpy array.\n        i (int): Top-left row index of the sub-rectangle.\n        j (int): Top-left column index of the sub-rectangle.\n        a (int): Bottom-right row index of the sub-rectangle.\n        b (int): Bottom-right column index of the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the vertical borders\n    for x in range(i + 1, a):\n        if grid[x, j] != 1:\n            changes += 1\n        if grid[x, b] != 1:\n            changes += 1\n\n    # Check the horizontal borders\n    for y in range(j + 1, b):\n        if grid[i, y] != 1:\n            changes += 1\n        if grid[a, y] != 1:\n            changes += 1\n\n    # Check the inner area\n    for x in range(i + 1, a):\n        for y in range(j + 1, b):\n            if grid[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, matrix))\n\n    # Output interface\n    results = min_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to form a portal for each test case.\n\n    Parameters:\n    t (int): Number of test cases.\n    test_cases (list): A list of tuples, each containing n, m, and the grid as a list of strings.\n\n    Returns:\n    list: A list of integers representing the minimum changes for each test case.\n    \"\"\"\n    def calculate_changes(n, m, grid):\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i+a, j:j+b]\n                        changes = 0\n\n                        # Calculate changes for the portal criteria\n                        # Top and bottom rows\n                        changes += np.sum(sub_rect[0, 1:b-1] == 0)  # Top row\n                        changes += np.sum(sub_rect[a-1, 1:b-1] == 0)  # Bottom row\n\n                        # Left and right columns\n                        changes += np.sum(sub_rect[1:a-1, 0] == 0)  # Left column\n                        changes += np.sum(sub_rect[1:a-1, b-1] == 0)  # Right column\n\n                        # Inner area\n                        changes += np.sum(sub_rect[1:a-1, 1:b-1] == 1)  # Inner area should be empty\n\n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n\n        return min_changes\n\n    results = []\n    for n, m, grid in test_cases:\n        result = calculate_changes(n, m, grid)\n        results.append(result)\n\n    return results\n\n# Input interface\nnum_cases = int(input())\ntest_cases = []\nfor _ in range(num_cases):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(num_cases, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers, each representing the minimum number of changes for each test case\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i+a, j:j+b]\n                        \n                        # Calculate changes needed to transform sub-rectangle into a portal\n                        changes = calculate_changes_to_portal(sub_rect, a, b)\n                        \n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes required\n    \"\"\"\n    changes = 0\n\n    # Check the borders and inner area according to portal criteria\n    for x in range(1, a - 1):\n        # Left and right borders\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        # Top and bottom borders\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n\n    # Inner area\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of changes required to form a portal for each test case.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the rectangle.\n            - m: Number of columns in the rectangle.\n            - grid: List of strings representing the grid.\n\n    Returns:\n        A list of integers, each representing the minimum number of changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid_array, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        grid: Numpy array representing the grid.\n        start_row: Starting row index of the sub-rectangle.\n        start_col: Starting column index of the sub-rectangle.\n        a: Number of rows in the sub-rectangle.\n        b: Number of columns in the sub-rectangle.\n\n    Returns:\n        The number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions for obsidian blocks\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the inner conditions for empty blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Parameters:\n    t (int): Number of test cases.\n    test_cases (list): A list of tuples, each containing n, m, and the grid as a list of strings.\n\n    Returns:\n    list: A list of integers representing the minimum changes for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([[int(char) for char in row] for row in grid])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[i:i+a, j:j+b]\n                        \n                        # Calculate the number of changes needed to make this sub-rectangle a portal\n                        changes = calculate_changes_to_portal(sub_rect, a, b)\n                        \n                        # Update the minimum changes if this is a better solution\n                        if changes < min_changes:\n                            min_changes = changes\n        \n        # Append the result for this test case\n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a given sub-rectangle into a portal.\n\n    Parameters:\n    sub_rect (np.ndarray): The sub-rectangle to be transformed.\n    a (int): Number of rows in the sub-rectangle.\n    b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n    int: The number of changes required.\n    \"\"\"\n    changes = 0\n    \n    # Check the border conditions for the portal\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n    \n    # Check the inner area for the portal\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nnum_cases = int(input())\ntest_cases = []\nfor _ in range(num_cases):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(num_cases, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a sub-rectangle within a larger rectangle to meet specific criteria for a portal. The solution must efficiently calculate the minimum number of changes required, considering the constraints on dimensions and block types. The algorithm should handle multiple test cases and provide accurate results for each.\nrequirement pool:\n- Develop the main algorithm to identify the minimum changes required.\n- Ensure the solution handles multiple test cases efficiently.\n- Optimize the algorithm for scalability with large inputs.\n- Provide clear and concise output for each test case.\n- Implement error handling for invalid inputs.\nWe will develop an efficient algorithm to identify the minimum changes required to transform a sub-rectangle into a portal. The algorithm will iterate over all possible sub-rectangles of size at least 5x4 within the given n x m rectangle and calculate the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for ensuring valid transformations. The solution must efficiently handle multiple test cases and large inputs, adhering to the specified criteria for portal formation.\nrequirement pool:\n- Implement the transformation algorithm to convert rectangles into portals.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Provide clear output for each test case.\n- Document the transformation process for user understanding.\nWe will implement a function to determine the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and checking the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe solution must efficiently transform blocks to meet portal criteria with minimal operations. It should handle multiple test cases and large matrices within the given constraints. The output must clearly indicate the minimum number of changes required for each test case.\nrequirement pool:\n- Efficient block transformation algorithm\n- Scalable solution for large inputs\n- Clear and concise output format\n- Handle multiple test cases\n- Optimize for minimum operations\nWe will implement a function that iterates over all possible sub-rectangles of the given matrix that meet the minimum size requirements for a portal. For each sub-rectangle, we will calculate the number of changes required to transform it into a valid portal. The function will return the minimum number of changes required for at least one sub-rectangle to become a portal. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific criteria. The solution must efficiently handle multiple test cases and large dimensions, ensuring minimal operations for transformation while maintaining accuracy.\nrequirement pool:\n- Implement the transformation logic for rectangles to portals.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles edge cases accurately.\n- Provide clear documentation for the transformation process.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine the minimum number of changes required to transform a given sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal criteria. We will use a brute-force approach due to the constraints, ensuring that the solution is efficient enough given the maximum dimensions. The function will handle multiple test cases and output the results for each.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining valid portals. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement the main algorithm to transform rectangles into portals.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide clear output for each test case.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine the minimum number of changes required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 within the given rectangle and calculate the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations and slicing.\n", "requirement analysis:\nThe solution must efficiently transform blocks to meet the portal criteria while handling multiple test cases. It should be optimized for large inputs and provide clear output for each test case. The algorithm should minimize the number of changes required to form a valid portal.\nrequirement pool:\n- Develop an efficient algorithm to transform blocks into a portal.\n- Ensure the solution handles maximum constraints efficiently.\n- Provide clear output for each test case.\n- Optimize the solution for speed and scalability.\n- Include detailed explanation of output results.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given n x m matrix. For each sub-rectangle, we will calculate the number of changes required to transform it into a portal according to the given criteria. The solution will iterate over all possible positions and dimensions of sub-rectangles, ensuring that the constraints are met. We will use numpy for efficient matrix manipulation.\n", "requirement analysis:\nThe problem requires identifying sub-rectangles within a given grid that can be transformed into a portal with the minimum number of changes. The constraints on dimensions and block types must be carefully considered to ensure valid portal formation. The solution must efficiently handle multiple test cases and provide accurate results.\nrequirement pool:\n- Develop the main algorithm to identify and transform sub-rectangles into portals.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles edge cases accurately.\n- Provide clear documentation and examples for users.\n- Implement efficient input/output handling.\nWe will implement a function that iterates over all possible sub-rectangles of the given grid that meet the minimum size requirements for a portal. For each sub-rectangle, we will calculate the number of changes required to transform it into a valid portal. The function will keep track of the minimum number of changes needed across all sub-rectangles. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe solution must efficiently identify sub-rectangles within a given grid and calculate the minimum number of transformations required to convert them into portals. The constraints on dimensions and block types must be strictly adhered to, ensuring the solution is scalable and performs well with maximum input sizes.\nrequirement pool:\n- Implement the main algorithm to identify and transform sub-rectangles into portals.\n- Optimize the solution for large grid sizes to ensure quick computation.\n- Develop a user-friendly interface for input and output handling.\n- Ensure the solution adheres to all portal criteria accurately.\n- Provide detailed documentation for understanding the solution process.\nWe will implement a function that iterates over all possible sub-rectangles of the given grid that meet the minimum size requirements for a portal. For each sub-rectangle, we will calculate the number of changes required to transform it into a portal. The function will keep track of the minimum number of changes needed across all sub-rectangles. We will use efficient iteration and calculation techniques to ensure the solution is scalable for large grids. The numpy library will be used for efficient array manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining valid portals. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement the main algorithm to transform rectangles into portals.\n- Optimize the solution for large input sizes.\n- Provide clear input and output formatting instructions.\n- Ensure the solution is scalable and efficient.\n- Include detailed output explanations for user understanding.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of changes. The function will use a nested loop to explore all sub-rectangles of size at least 5x4 and calculate the number of changes required to convert each into a valid portal. The solution will be optimized to handle the constraints efficiently by leveraging numpy for fast array manipulations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle of blocks into a portal with specific criteria. The solution must efficiently handle multiple test cases and large input sizes, ensuring minimum operations are performed to achieve the desired portal configuration.\nrequirement pool:\n- Develop an algorithm to identify and transform sub-rectangles into portals.\n- Optimize the solution for minimum block transformations.\n- Ensure scalability for maximum input constraints.\n- Provide clear output for each test case.\n- Include detailed comments and documentation for the code.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of changes. The function will use a dynamic programming approach to efficiently calculate the number of changes required for each sub-rectangle. We will utilize numpy for efficient matrix operations.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 423, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "add_1_sentence_at_end", "parent_index": 127}
