{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir is eager to understand if the pattern he created can be replicated using ticks that meet the size constraints detailed above.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir is eager to understand if the pattern he created can be replicated using ticks that meet the size constraints detailed above.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_replicate_pattern(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if the given field can be obtained by drawing ticks of at least the given size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the field.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell is part of a valid tick\n        tickable = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark cells as part of a valid tick\n                        for d in range(k + 1):\n                            tickable[i - d][j - d] = True\n                            tickable[i - d][j + d] = True\n\n        # Check if all '*' in the field are part of a valid tick\n        can_replicate = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tickable[i][j]:\n                    can_replicate = False\n                    break\n            if not can_replicate:\n                break\n\n        results.append('YES' if can_replicate else 'NO')\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_replicate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_replicate_pattern(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if the pattern can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the field.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell is part of a valid tick\n        tick_map = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the field\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If a valid tick of at least size k is found, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            tick_map[i - s][j - s] = True\n                            tick_map[i - s][j + s] = True\n\n        # Check if all '*' in the field are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_map[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    field = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, field))\n\n# Output interface\nresults = can_replicate_pattern(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_replicate_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a field can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): Field representation with '*' and '.'.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell can be part of a tick\n        tick_possible = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells as part of a tick\n                    if size > k:\n                        for s in range(size):\n                            tick_possible[i - s][j - s] = True\n                            tick_possible[i - s][j + s] = True\n\n        # Check if all '*' in the field can be part of a tick\n        can_replicate = all(\n            field[i][j] == '.' or tick_possible[i][j]\n            for i in range(n)\n            for j in range(m)\n        )\n\n        results.append(\"YES\" if can_replicate else \"NO\")\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    results = can_replicate_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_replicate_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given field can be replicated using ticks of specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the field.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell can be part of a tick\n        tick_possible = [[False] * m for _ in range(n)]\n\n        # Traverse the field to check for possible ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If a tick of at least size k is possible, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            tick_possible[i - s][j - s] = True\n                            tick_possible[i - s][j + s] = True\n\n        # Check if all '*' in the field can be part of a tick\n        can_replicate = all(\n            field[i][j] == '.' or tick_possible[i][j]\n            for i in range(n) for j in range(m)\n        )\n\n        results.append(\"YES\" if can_replicate else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_replicate_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef can_replicate_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given field can be replicated using ticks of specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark positions that can be part of a tick\n        tick_possible = [[False] * m for _ in range(n)]\n\n        # Check each position in the field\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if this position can be the center of a tick of size k\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the positions\n                    if size > k:\n                        for s in range(size):\n                            tick_possible[i - s][j - s] = True\n                            tick_possible[i - s][j + s] = True\n\n        # Verify if all '*' in the field can be part of a tick\n        can_replicate = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_possible[i][j]:\n                    can_replicate = False\n                    break\n            if not can_replicate:\n                break\n\n        results.append(\"YES\" if can_replicate else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_replicate_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_replicate_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determines if the given field can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell is part of a valid tick\n        tick_map = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the field\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If a valid tick of at least size k is found, mark its cells\n                    if size > k:\n                        for s in range(size):\n                            tick_map[i - s][j - s] = True\n                            tick_map[i - s][j + s] = True\n\n        # Check if all '*' in the field are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_map[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_replicate_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef can_replicate_pattern(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determines if the given field can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a '*' can be part of a valid tick\n        valid_tick = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the field\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If a valid tick of at least size k is found, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            valid_tick[i - s][j - s] = True\n                            valid_tick[i - s][j + s] = True\n\n        # Check if all '*' can be part of a valid tick\n        can_replicate = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not valid_tick[i][j]:\n                    can_replicate = False\n                    break\n            if not can_replicate:\n                break\n\n        results.append('YES' if can_replicate else 'NO')\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output interface\n    results = can_replicate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_replicate_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given field can be replicated using ticks of at least the specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark the positions that can be part of a tick\n        can_be_tick = [[False] * m for _ in range(n)]\n\n        # Check each position in the field\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    size -= 1  # Adjust size to the last valid tick size\n\n                    if size >= k:\n                        # Mark all positions of this tick\n                        for s in range(size + 1):\n                            can_be_tick[i - s][j - s] = True\n                            can_be_tick[i - s][j + s] = True\n\n        # Verify if all '*' in the field can be part of a tick\n        is_possible = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not can_be_tick[i][j]:\n                    is_possible = False\n                    break\n            if not is_possible:\n                break\n\n        results.append(\"YES\" if is_possible else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output interface\n    results = can_replicate_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_replicate_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given field can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark cells that can be part of a tick\n        can_be_tick = [[False] * m for _ in range(n)]\n\n        # Check for possible tick centers\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                                field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            can_be_tick[i - s][j - s] = True\n                            can_be_tick[i - s][j + s] = True\n\n        # Verify if all '*' in the field can be part of a tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not can_be_tick[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output results\n    results = can_replicate_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_replicate_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given field can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark the cells that can be part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                                field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the field are part of a tick\n        can_replicate = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    can_replicate = False\n                    break\n            if not can_replicate:\n                break\n\n        results.append(\"YES\" if can_replicate else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = data[index + 1:index + 1 + n]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    results = can_replicate_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on determining if a pattern can be replicated using ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide clear outputs indicating whether the pattern can be replicated.\nrequirement pool:\n- Implement efficient pattern replication logic\n- Ensure accurate handling of test cases\n- Optimize performance for large input sizes\n- Provide clear and concise output format\n- Enhance user interface for input and output\nWe will implement a function to determine if the given field can be obtained by drawing ticks of at least the given size. The function will iterate over each cell in the field and check if it can be the center of a tick of the required size. We will use a simple loop and condition checks to verify the tick pattern. The solution will handle multiple test cases efficiently by processing each test case independently. We will use standard Python libraries for input and output handling.\n", "requirement analysis:\nThe requirements focus on determining if a pattern can be replicated using ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide clear outputs. The constraints on field size and tick size must be adhered to, ensuring accurate pattern replication.\nrequirement pool:\n- Implement pattern replication logic\n- Optimize for multiple test case processing\n- Ensure output clarity and correctness\n- Adhere to input constraints\n- Enhance user experience with intuitive interface\nWe will implement a function to determine if the pattern can be replicated using ticks of a specified minimum size. The function will iterate over each test case, analyze the field, and check if the ticks can be formed according to the constraints. We will use basic Python data structures such as lists and strings to represent the field and process the input efficiently.\n", "requirement analysis:\nThe requirements focus on determining if a field can be replicated using ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide clear output for each. Edge cases, such as fields with isolated asterisks, must be considered to ensure accurate results.\nrequirement pool:\n- Implement the main algorithm to check tick replication\n- Optimize for performance with maximum test cases\n- Ensure clear and concise output format\n- Handle edge cases effectively\n- Provide detailed error messages for invalid inputs\nWe will implement a function to determine if a field can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the field, checking if it can be the center of a tick of the required size. We will use a simple nested loop approach to check the conditions for tick formation. The solution will be optimized to handle up to 100 test cases efficiently.\n", "requirement analysis:\nThe requirements focus on determining if a given field can be replicated using ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide clear results for each. Edge cases, such as fields with isolated asterisks or insufficient tick size, must be addressed.\nrequirement pool:\n- Implement the main logic to check tick replication\n- Optimize for performance with maximum test cases\n- Ensure output clarity and correctness\n- Handle edge cases effectively\n- Provide user-friendly input and output format\nWe will implement a function to determine if a given field can be replicated using ticks of a specified minimum size. The approach involves checking each '*' in the field to see if it can be the center of a tick of at least size k. We will use nested loops to traverse the field and validate tick formation. The solution will be optimized to handle up to 100 test cases efficiently.\n", "requirement analysis:\nThe requirements focus on determining if a given field can be replicated using ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results for each. The constraints on field size and tick size must be adhered to, ensuring that the output is clear and matches the expected format.\nrequirement pool:\n- Implement the main algorithm to check tick replication\n- Ensure the solution handles up to 100 test cases efficiently\n- Optimize the algorithm for performance\n- Provide clear output format as specified\n- Enhance user experience with intuitive input handling\nWe will implement a function to determine if a given field can be replicated using ticks of a specified minimum size. The approach involves checking each '*' in the field to see if it can be the center of a tick of at least size k. We will use nested loops to traverse the field and check the conditions for tick formation. The solution will efficiently handle up to 100 test cases using standard Python data structures.\n", "requirement analysis:\nThe requirements focus on determining if a given field can be replicated using ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results for each. Edge cases, such as fields with isolated asterisks or insufficient tick size, must be addressed to ensure robustness.\nrequirement pool:\n- Implement tick pattern recognition algorithm\n- Optimize for performance across multiple test cases\n- Ensure output format consistency\n- Handle edge cases effectively\n- Provide user-friendly error messages\nWe will implement a function to check if the given field can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the field and attempt to form ticks of the required size. We will use simple loops and condition checks to ensure performance and accuracy. The solution will handle edge cases such as isolated asterisks and insufficient tick size by verifying the tick formation constraints. We will use Python's built-in data structures for efficient processing.\n", "requirement analysis:\nThe requirements focus on determining if a given field can be replicated using ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide clear outputs indicating whether the pattern can be replicated.\nrequirement pool:\n- Implement the main algorithm to check pattern replication\n- Optimize the solution for performance across multiple test cases\n- Ensure the output format is clear and concise\n- Handle edge cases and validate input constraints\n- Provide documentation for understanding the solution\nWe will implement a function to check if the given field can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the field and attempt to form ticks of the required size. If all '*' can be part of valid ticks, the function will return 'YES', otherwise 'NO'. We will use simple loops and condition checks to achieve this, ensuring the solution is efficient for multiple test cases.\n", "requirement analysis:\nThe requirements focus on determining if a given field can be replicated using ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as fields with isolated asterisks or insufficient tick size, must be considered. The output should be clear and adhere to the specified format.\nrequirement pool:\n- Implement the main algorithm to check tick replication\n- Ensure the solution handles maximum input size efficiently\n- Optimize the code for performance\n- Provide detailed error handling for edge cases\n- Enhance output readability\nWe will implement a function to determine if a given field can be replicated using ticks of a specified minimum size. The approach involves checking each '*' in the field to see if it can be the center of a tick of at least size k. We will use a simple nested loop to iterate over the field and check the conditions for forming a tick. The solution will be optimized to handle up to 100 test cases efficiently.\n", "requirement analysis:\nThe requirements focus on determining if a given field can be replicated using ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as fields with isolated asterisks, must be considered to ensure the robustness of the solution.\nrequirement pool:\n- Implement the main algorithm to check tick replication\n- Optimize for performance with large number of test cases\n- Ensure output format is consistent and clear\n- Handle edge cases effectively\n- Provide detailed error messages for invalid inputs\nWe will implement a function to check if the given field can be replicated using ticks of a specified minimum size. The approach involves iterating over each cell in the field and checking if it can be the center of a tick of the required size. We will use a simple nested loop structure to traverse the field and validate tick formation. The solution will be optimized to handle multiple test cases efficiently by processing each test case independently.\n", "requirement analysis:\nThe requirements focus on determining if a given field can be replicated using ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results for each. Edge cases, such as fields with isolated asterisks or insufficient tick sizes, must be addressed.\nrequirement pool:\n- Implement the main algorithm to check tick replication\n- Optimize the solution for performance across multiple test cases\n- Ensure the solution handles edge cases effectively\n- Provide clear and concise output formatting\n- Develop a user-friendly interface for input and output\nWe will implement a function to determine if a given field can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the field and check if it can be the center of a tick of the required size. We will use nested loops to check the potential tick size for each asterisk and ensure that all conditions are met. The solution will handle multiple test cases efficiently by processing each test case independently.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 389, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "add_1_sentence_at_end", "parent_index": 151}
