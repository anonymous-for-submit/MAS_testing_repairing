{"name": "1615_B. And It's Non-Zero", "description": "You are given an array consisting of all integers from [l, r] inclusive. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. What's the minimum number of elements you can delete to make the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array non-zero?\n\nA bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "tags": ["bitmasks", "greedy", "math"], "difficulty": 8, "id": 1615, "sample_io": [{"input": "5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n", "output": ["1\n3\n0\n2\n31072\n"]}], "test_list": [{"input": "5\n1 2\n2 8\n4 5\n2 5\n100000 200000\n", "output": ["1\n3\n0\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n100000 200000\n", "output": ["1\n3\n0\n0\n31072\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 5\n100000 200000\n", "output": ["1\n4\n0\n2\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100000 200000\n", "output": ["0\n3\n0\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n110000 200000\n", "output": ["1\n3\n0\n0\n21072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100100 200000\n", "output": ["0\n3\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 10\n110000 200000\n", "output": ["1\n3\n0\n3\n21072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n1 5\n100001 200000\n", "output": ["1\n3\n0\n2\n31071\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n100000 104325\n", "output": ["1\n3\n0\n0\n0\n"]}, {"input": "5\n2 2\n2 8\n1 5\n2 5\n100000 200000\n", "output": ["0\n3\n2\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 12\n110000 200000\n", "output": ["1\n3\n0\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n100100 200000\n", "output": ["0\n3\n1\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n4 9\n1 5\n100000 200000\n", "output": ["1\n3\n2\n2\n31072\n"]}, {"input": "5\n2 2\n2 12\n1 5\n2 5\n100000 200000\n", "output": ["0\n5\n2\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n110000 200000\n", "output": ["2\n3\n0\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 7\n100100 200000\n", "output": ["1\n3\n0\n2\n30972\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n101100 200000\n", "output": ["0\n3\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n100000 200000\n", "output": ["1\n3\n1\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 7\n100100 200000\n", "output": ["1\n2\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101000 200000\n", "output": ["1\n3\n1\n2\n30072\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n101000 200000\n", "output": ["1\n2\n1\n2\n30072\n"]}, {"input": "5\n2 4\n1 8\n4 5\n2 7\n100100 200000\n", "output": ["1\n4\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n101100 200000\n", "output": ["1\n2\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n4 5\n3 5\n100000 200000\n", "output": ["1\n3\n0\n1\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n4 5\n100000 200000\n", "output": ["0\n3\n0\n0\n31072\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 1\n100000 200000\n", "output": ["1\n4\n0\n0\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n4 5\n110000 200000\n", "output": ["0\n3\n0\n0\n21072\n"]}, {"input": "5\n2 2\n2 16\n4 5\n2 5\n100100 200000\n", "output": ["0\n7\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 7\n4 5\n4 10\n110000 200000\n", "output": ["1\n2\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 7\n4 6\n2 5\n100100 200000\n", "output": ["0\n2\n0\n2\n30972\n"]}, {"input": "5\n2 2\n2 8\n1 5\n4 5\n100000 200000\n", "output": ["0\n3\n2\n0\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 6\n4 5\n110001 200000\n", "output": ["1\n3\n0\n0\n21071\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 7\n100110 200000\n", "output": ["0\n3\n0\n2\n30962\n"]}, {"input": "5\n1 2\n2 8\n4 5\n7 12\n110000 200000\n", "output": ["1\n3\n0\n1\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 4\n100100 200000\n", "output": ["0\n3\n1\n1\n30972\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 5\n100000 200000\n", "output": ["1\n3\n3\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n010000 200000\n", "output": ["2\n3\n0\n0\n91697\n"]}, {"input": "5\n1 2\n2 4\n4 5\n4 13\n110000 200000\n", "output": ["1\n1\n0\n4\n21072\n"]}, {"input": "5\n2 2\n1 8\n3 6\n2 5\n101100 200000\n", "output": ["0\n4\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n100000 200000\n", "output": ["1\n3\n1\n5\n31072\n"]}, {"input": "5\n1 4\n1 7\n4 5\n2 7\n100100 200000\n", "output": ["2\n3\n0\n2\n30972\n"]}, {"input": "5\n1 4\n1 8\n4 5\n2 7\n100100 200000\n", "output": ["2\n4\n0\n2\n30972\n"]}, {"input": "5\n2 4\n2 5\n4 5\n2 7\n100100 123776\n", "output": ["1\n2\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 10\n110000 200000\n", "output": ["1\n2\n0\n2\n21072\n"]}, {"input": "5\n2 2\n2 8\n1 6\n4 5\n100000 200000\n", "output": ["0\n3\n3\n0\n31072\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 7\n100110 200000\n", "output": ["0\n4\n0\n2\n30962\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 4\n100101 200000\n", "output": ["0\n3\n1\n1\n30971\n"]}, {"input": "5\n2 2\n1 1\n3 6\n2 5\n101100 200000\n", "output": ["0\n0\n1\n2\n29972\n"]}, {"input": "5\n1 2\n1 8\n7 9\n1 10\n100000 200000\n", "output": ["1\n4\n1\n5\n31072\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101010 188450\n", "output": ["1\n3\n1\n2\n30062\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 20\n110000 200000\n", "output": ["1\n2\n0\n7\n21072\n"]}, {"input": "5\n2 2\n2 8\n1 2\n4 5\n100000 200000\n", "output": ["0\n3\n1\n0\n31072\n"]}, {"input": "5\n2 2\n2 5\n3 6\n2 4\n100101 200000\n", "output": ["0\n2\n1\n1\n30971\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101011 188450\n", "output": ["1\n3\n1\n2\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 5\n101000 200000\n", "output": ["1\n1\n1\n2\n30072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 5\n101011 188450\n", "output": ["1\n3\n3\n2\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 5\n101001 200000\n", "output": ["1\n1\n1\n2\n30071\n"]}, {"input": "5\n1 1\n1 8\n7 10\n1 10\n100000 186611\n", "output": ["0\n4\n1\n5\n31072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 2\n101011 188450\n", "output": ["1\n3\n3\n1\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 7\n101001 200000\n", "output": ["1\n1\n1\n3\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n101001 200000\n", "output": ["2\n1\n1\n3\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n111001 200000\n", "output": ["2\n1\n1\n3\n20071\n"]}, {"input": "5\n1 4\n1 6\n7 9\n1 7\n111001 200000\n", "output": ["2\n3\n1\n3\n20071\n"]}, {"input": "5\n1 4\n2 6\n7 9\n1 7\n111001 200000\n", "output": ["2\n2\n1\n3\n20071\n"]}, {"input": "5\n2 4\n3 6\n7 9\n1 7\n111001 200000\n", "output": ["1\n1\n1\n3\n20071\n"]}, {"input": "5\n2 8\n3 6\n7 9\n1 7\n111001 200000\n", "output": ["3\n1\n1\n3\n20071\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 4\n100001 200000\n", "output": ["1\n3\n0\n0\n31071\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100000 101573\n", "output": ["0\n3\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 4\n4 5\n4 5\n110000 200000\n", "output": ["1\n1\n0\n0\n21072\n"]}, {"input": "5\n1 2\n1 8\n4 5\n4 10\n110000 200000\n", "output": ["1\n4\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n100100 200000\n", "output": ["0\n6\n0\n2\n30972\n"]}, {"input": "5\n1 2\n4 8\n4 5\n1 5\n100000 200000\n", "output": ["1\n1\n0\n2\n31072\n"]}, {"input": "5\n2 2\n2 8\n1 5\n2 5\n100000 161404\n", "output": ["0\n3\n2\n2\n30333\n"]}, {"input": "5\n1 2\n2 8\n3 6\n4 5\n110000 200000\n", "output": ["1\n3\n1\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 10\n100100 200000\n", "output": ["1\n3\n0\n4\n30972\n"]}, {"input": "5\n1 1\n2 8\n4 5\n4 12\n110000 200000\n", "output": ["0\n3\n0\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n100101 200000\n", "output": ["0\n3\n1\n2\n30971\n"]}, {"input": "5\n1 1\n2 8\n7 9\n1 5\n100000 200000\n", "output": ["0\n3\n1\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 11\n4 5\n110000 200000\n", "output": ["2\n3\n4\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 7\n100101 200000\n", "output": ["1\n3\n0\n2\n30971\n"]}, {"input": "5\n1 2\n2 8\n2 5\n4 13\n110000 200000\n", "output": ["1\n3\n2\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 11\n2 5\n101100 200000\n", "output": ["0\n3\n4\n2\n29972\n"]}, {"input": "5\n1 2\n2 13\n7 9\n1 5\n100000 200000\n", "output": ["1\n6\n1\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 7\n000100 200000\n", "output": ["1\n2\n0\n2\n99933\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101000 135172\n", "output": ["1\n3\n1\n2\n4101\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n100000 200000\n", "output": ["1\n2\n1\n2\n31072\n"]}, {"input": "5\n1 4\n2 7\n7 9\n1 5\n101100 200000\n", "output": ["2\n2\n1\n2\n29972\n"]}, {"input": "5\n2 2\n2 10\n4 5\n4 5\n100000 200000\n", "output": ["0\n4\n0\n0\n31072\n"]}, {"input": "5\n2 4\n2 16\n4 5\n2 5\n100100 200000\n", "output": ["1\n7\n0\n2\n30972\n"]}, {"input": "5\n1 3\n2 2\n4 6\n2 5\n100000 200000\n", "output": ["1\n0\n0\n2\n31072\n"]}, {"input": "5\n2 2\n1 8\n1 5\n4 5\n100000 200000\n", "output": ["0\n4\n2\n0\n31072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n4 4\n100100 200000\n", "output": ["0\n3\n1\n0\n30972\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 8\n100000 200000\n", "output": ["1\n3\n3\n4\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n010001 200000\n", "output": ["2\n3\n0\n0\n91696\n"]}, {"input": "5\n2 2\n1 15\n3 6\n2 5\n101100 200000\n", "output": ["0\n7\n1\n2\n29972\n"]}, {"input": "5\n1 4\n1 8\n4 5\n4 7\n100100 200000\n", "output": ["2\n4\n0\n0\n30972\n"]}, {"input": "5\n4 4\n2 5\n4 5\n2 7\n100100 123776\n", "output": ["0\n2\n0\n2\n0\n"]}, {"input": "5\n1 2\n3 7\n4 5\n6 10\n110000 200000\n", "output": ["1\n1\n0\n2\n21072\n"]}, {"input": "5\n2 2\n2 7\n4 6\n2 11\n100100 200000\n", "output": ["0\n2\n0\n4\n30972\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 3\n100110 200000\n", "output": ["0\n4\n0\n0\n30962\n"]}, {"input": "5\n2 2\n2 10\n3 6\n2 4\n100101 200000\n", "output": ["0\n4\n1\n1\n30971\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 20\n100000 200000\n", "output": ["1\n2\n0\n7\n31072\n"]}, {"input": "5\n2 2\n2 5\n3 6\n2 4\n100101 108244\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 3\n1 1\n3 6\n2 5\n111100 200000\n", "output": ["0\n0\n1\n2\n19972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n101011 188450\n", "output": ["1\n3\n1\n5\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 14\n101001 200000\n", "output": ["1\n1\n1\n7\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n110001 200000\n", "output": ["2\n1\n1\n3\n21071\n"]}, {"input": "5\n1 4\n3 6\n7 9\n1 13\n111001 200000\n", "output": ["2\n1\n1\n6\n20071\n"]}, {"input": "5\n1 2\n2 13\n4 5\n1 2\n100000 200000\n", "output": ["1\n6\n0\n1\n31072\n"]}, {"input": "5\n2 2\n2 8\n3 5\n2 5\n100000 101573\n", "output": ["0\n3\n1\n2\n0\n"]}, {"input": "5\n1 2\n1 13\n4 5\n4 10\n110000 200000\n", "output": ["1\n6\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n100100 138386\n", "output": ["0\n6\n0\n2\n7315\n"]}, {"input": "5\n1 2\n2 8\n3 8\n4 5\n110000 200000\n", "output": ["1\n3\n2\n0\n21072\n"]}, {"input": "5\n2 2\n2 2\n3 6\n2 5\n100101 200000\n", "output": ["0\n0\n1\n2\n30971\n"]}, {"input": "5\n1 4\n2 5\n4 11\n4 5\n110000 200000\n", "output": ["2\n2\n4\n0\n21072\n"]}, {"input": "5\n1 4\n2 8\n4 5\n2 7\n100101 200000\n", "output": ["2\n3\n0\n2\n30971\n"]}, {"input": "5\n2 2\n1 8\n3 11\n2 5\n101100 200000\n", "output": ["0\n4\n4\n2\n29972\n"]}, {"input": "5\n2 4\n2 7\n4 5\n1 7\n000100 200000\n", "output": ["1\n2\n0\n3\n99933\n"]}, {"input": "5\n1 2\n2 4\n7 9\n1 5\n101000 135172\n", "output": ["1\n1\n1\n2\n4101\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n100001 200000\n", "output": ["1\n2\n1\n2\n31071\n"]}, {"input": "5\n2 2\n2 8\n2 4\n4 5\n110000 200000\n", "output": ["0\n3\n1\n0\n21072\n"]}, {"input": "5\n2 4\n1 16\n4 5\n2 5\n100100 200000\n", "output": ["1\n8\n0\n2\n30972\n"]}, {"input": "5\n2 2\n1 8\n1 5\n4 5\n100000 150693\n", "output": ["0\n4\n2\n0\n19622\n"]}, {"input": "5\n1 2\n2 8\n3 5\n4 5\n110001 200000\n", "output": ["1\n3\n1\n0\n21071\n"]}, {"input": "5\n1 3\n2 8\n4 5\n2 12\n110000 200000\n", "output": ["1\n3\n0\n5\n21072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 8\n100010 200000\n", "output": ["1\n3\n3\n4\n31062\n"]}, {"input": "5\n1 1\n2 4\n4 5\n4 15\n110000 200000\n", "output": ["0\n1\n0\n4\n21072\n"]}, {"input": "5\n1 4\n1 8\n4 5\n3 7\n100100 200000\n", "output": ["2\n4\n0\n1\n30972\n"]}, {"input": "5\n2 2\n3 7\n4 5\n6 10\n110000 200000\n", "output": ["0\n1\n0\n2\n21072\n"]}, {"input": "5\n2 3\n2 8\n1 6\n4 5\n100100 200000\n", "output": ["0\n3\n3\n0\n30972\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 3\n101110 200000\n", "output": ["0\n4\n0\n0\n29962\n"]}, {"input": "5\n1 2\n4 8\n7 9\n2 5\n101011 188450\n", "output": ["1\n1\n1\n2\n30061\n"]}, {"input": "5\n1 2\n4 7\n4 5\n6 20\n100000 200000\n", "output": ["1\n0\n0\n7\n31072\n"]}, {"input": "5\n2 3\n1 2\n3 6\n2 5\n111100 200000\n", "output": ["0\n1\n1\n2\n19972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n101010 188450\n", "output": ["1\n3\n1\n5\n30062\n"]}, {"input": "5\n1 4\n1 3\n7 15\n1 5\n101000 200000\n", "output": ["2\n1\n1\n2\n30072\n"]}, {"input": "5\n1 1\n1 8\n7 8\n1 10\n100010 186611\n", "output": ["0\n4\n1\n5\n31062\n"]}, {"input": "5\n1 2\n1 4\n7 9\n1 14\n101001 200000\n", "output": ["1\n2\n1\n7\n30071\n"]}, {"input": "5\n1 4\n1 3\n9 9\n1 7\n110001 200000\n", "output": ["2\n1\n0\n3\n21071\n"]}, {"input": "5\n1 4\n1 8\n7 9\n1 7\n111001 200000\n", "output": ["2\n4\n1\n3\n20071\n"]}, {"input": "5\n1 4\n3 6\n7 9\n1 9\n111001 200000\n", "output": ["2\n1\n1\n4\n20071\n"]}, {"input": "5\n2 3\n1 8\n4 5\n2 5\n100100 185068\n", "output": ["0\n4\n0\n2\n30972\n"]}, {"input": "5\n1 2\n1 13\n4 5\n1 10\n110000 200000\n", "output": ["1\n6\n0\n5\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n000100 138386\n", "output": ["0\n6\n0\n2\n69139\n"]}, {"input": "5\n1 2\n2 14\n3 8\n4 5\n110000 200000\n", "output": ["1\n6\n2\n0\n21072\n"]}, {"input": "5\n1 2\n2 5\n4 11\n4 5\n110000 200000\n", "output": ["1\n2\n4\n0\n21072\n"]}, {"input": "5\n1 4\n2 5\n4 5\n2 7\n100101 200000\n", "output": ["2\n2\n0\n2\n30971\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 8\n100001 200000\n", "output": ["1\n2\n1\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 4\n4 5\n110000 200000\n", "output": ["0\n0\n1\n0\n21072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 14\n100010 200000\n", "output": ["1\n3\n3\n7\n31062\n"]}, {"input": "5\n1 1\n2 5\n4 5\n4 15\n110000 200000\n", "output": ["0\n2\n0\n4\n21072\n"]}, {"input": "5\n2 2\n3 9\n4 5\n6 10\n110000 200000\n", "output": ["0\n3\n0\n2\n21072\n"]}, {"input": "5\n1 2\n4 8\n7 9\n3 5\n101011 188450\n", "output": ["1\n1\n1\n1\n30061\n"]}, {"input": "5\n1 4\n4 7\n4 5\n6 20\n100000 200000\n", "output": ["2\n0\n0\n7\n31072\n"]}, {"input": "5\n2 3\n1 2\n1 6\n2 5\n111100 200000\n", "output": ["0\n1\n3\n2\n19972\n"]}, {"input": "5\n1 1\n1 8\n7 8\n2 10\n100010 186611\n", "output": ["0\n4\n1\n4\n31062\n"]}, {"input": "5\n1 2\n1 4\n7 9\n1 14\n100001 200000\n", "output": ["1\n2\n1\n7\n31071\n"]}, {"input": "5\n1 4\n1 3\n9 9\n2 7\n110001 200000\n", "output": ["2\n1\n0\n2\n21071\n"]}, {"input": "5\n1 4\n1 8\n7 9\n1 2\n111001 200000\n", "output": ["2\n4\n1\n1\n20071\n"]}, {"input": "5\n1 2\n3 14\n3 8\n4 5\n110000 200000\n", "output": ["1\n5\n2\n0\n21072\n"]}, {"input": "5\n1 4\n2 5\n4 5\n2 8\n100101 200000\n", "output": ["2\n2\n0\n3\n30971\n"]}, {"input": "5\n1 2\n2 12\n7 9\n1 8\n100001 200000\n", "output": ["1\n5\n1\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 4\n4 5\n110100 200000\n", "output": ["0\n0\n1\n0\n20972\n"]}, {"input": "5\n1 1\n4 5\n4 5\n4 15\n110000 200000\n", "output": ["0\n0\n0\n4\n21072\n"]}, {"input": "5\n1 4\n1 16\n4 7\n3 7\n100100 200000\n", "output": ["2\n8\n0\n1\n30972\n"]}, {"input": "5\n1 2\n3 9\n4 5\n6 10\n110000 200000\n", "output": ["1\n3\n0\n2\n21072\n"]}, {"input": "5\n2 3\n1 2\n1 6\n2 5\n101100 200000\n", "output": ["0\n1\n3\n2\n29972\n"]}, {"input": "5\n1 4\n1 3\n9 9\n2 7\n111001 200000\n", "output": ["2\n1\n0\n2\n20071\n"]}, {"input": "5\n1 4\n1 5\n7 9\n1 2\n111001 200000\n", "output": ["2\n2\n1\n1\n20071\n"]}, {"input": "5\n2 2\n2 5\n3 5\n2 5\n101000 129464\n", "output": ["0\n2\n1\n2\n0\n"]}, {"input": "5\n1 2\n2 12\n4 9\n1 8\n100001 200000\n", "output": ["1\n5\n2\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 8\n4 5\n110100 200000\n", "output": ["0\n0\n3\n0\n20972\n"]}, {"input": "5\n1 2\n4 8\n3 5\n4 7\n110001 200000\n", "output": ["1\n1\n1\n0\n21071\n"]}, {"input": "5\n2 3\n2 8\n3 5\n4 12\n110000 200000\n", "output": ["0\n3\n1\n4\n21072\n"]}, {"input": "5\n1 1\n4 5\n4 5\n4 15\n110010 200000\n", "output": ["0\n0\n0\n4\n21062\n"]}, {"input": "5\n1 1\n1 8\n7 14\n2 16\n100010 186611\n", "output": ["0\n4\n1\n7\n31062\n"]}, {"input": "5\n1 6\n1 5\n7 9\n1 2\n111001 200000\n", "output": ["3\n2\n1\n1\n20071\n"]}, {"input": "5\n2 2\n2 5\n3 9\n2 5\n101000 129464\n", "output": ["0\n2\n3\n2\n0\n"]}, {"input": "5\n1 1\n2 12\n4 9\n1 8\n100001 200000\n", "output": ["0\n5\n2\n4\n31071\n"]}, {"input": "5\n1 2\n4 8\n3 5\n1 7\n110001 200000\n", "output": ["1\n1\n1\n3\n21071\n"]}, {"input": "5\n2 3\n2 8\n3 5\n4 12\n010000 200000\n", "output": ["0\n3\n1\n4\n91697\n"]}, {"input": "5\n2 3\n1 3\n1 6\n2 8\n101100 200000\n", "output": ["0\n1\n3\n3\n29972\n"]}, {"input": "5\n1 1\n1 8\n6 14\n2 16\n100010 186611\n", "output": ["0\n4\n2\n7\n31062\n"]}, {"input": "5\n1 6\n1 10\n7 9\n1 2\n111001 200000\n", "output": ["3\n5\n1\n1\n20071\n"]}, {"input": "5\n1 1\n2 12\n4 13\n1 8\n100001 200000\n", "output": ["0\n5\n4\n4\n31071\n"]}, {"input": "5\n1 2\n4 4\n3 5\n1 7\n110001 200000\n", "output": ["1\n0\n1\n3\n21071\n"]}, {"input": "5\n2 3\n1 5\n1 6\n2 8\n101100 200000\n", "output": ["0\n2\n3\n3\n29972\n"]}, {"input": "5\n1 6\n1 10\n9 9\n1 2\n111001 200000\n", "output": ["3\n5\n0\n1\n20071\n"]}, {"input": "5\n1 1\n2 12\n4 13\n1 8\n100000 200000\n", "output": ["0\n5\n4\n4\n31072\n"]}, {"input": "5\n1 2\n4 4\n3 8\n1 7\n110001 200000\n", "output": ["1\n0\n2\n3\n21071\n"]}, {"input": "5\n1 2\n4 4\n3 8\n2 7\n110001 200000\n", "output": ["1\n0\n2\n2\n21071\n"]}, {"input": "5\n2 3\n2 5\n1 6\n2 8\n101101 200000\n", "output": ["0\n2\n3\n3\n29971\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 5\n100000 121445\n", "output": ["1\n4\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n110010 200000\n", "output": ["1\n3\n0\n0\n21062\n"]}, {"input": "5\n1 2\n2 10\n4 5\n4 12\n110000 200000\n", "output": ["1\n4\n0\n4\n21072\n"]}, {"input": "5\n2 2\n4 8\n3 6\n2 5\n100100 200000\n", "output": ["0\n1\n1\n2\n30972\n"]}, {"input": "5\n2 2\n2 7\n1 5\n2 5\n100000 200000\n", "output": ["0\n2\n2\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 13\n100100 200000\n", "output": ["1\n2\n0\n6\n30972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 1\n101000 200000\n", "output": ["1\n3\n1\n0\n30072\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n111100 200000\n", "output": ["1\n2\n1\n2\n19972\n"]}], "task_id": "codecontest/120", "prompt": "You have an array that includes all integers between l and r, inclusive. For instance, if l = 2 and r = 5, the array is [2, 3, 4, 5]. What's the minimum number of elements you can remove in order for the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array to be non-zero?\n\nA bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits, considering each pair of corresponding bits individually. Understanding the properties of binary numbers and their bitwise operations is crucial to solve this problem efficiently.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "repair_prompt": ["You have an array that includes all integers between l and r, inclusive. For instance, if l = 2 and r = 5, the array is [2, 3, 4, 5]. What's the minimum number of elements you can remove in order for the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array to be non-zero?\n\nA bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits, considering each pair of corresponding bits individually. Understanding the properties of binary numbers and their bitwise operations is crucial to solve this problem efficiently.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_elements_to_remove(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from the array to achieve a non-zero bitwise AND.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of elements to remove for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum number of elements to remove as the size of the array\n        min_removals = r - l + 1\n        \n        # Iterate over possible bit positions\n        for bit_position in range(20):  # 20 bits are enough for numbers up to 2 * 10^5\n            # Calculate the mask for the current bit position\n            mask = 1 << bit_position\n            \n            # Count numbers in the range [l, r] that have the current bit set\n            count_with_bit_set = 0\n            for number in range(l, r + 1):\n                if number & mask:\n                    count_with_bit_set += 1\n            \n            # Calculate the number of elements to remove to make the AND non-zero\n            removals_for_bit = (r - l + 1) - count_with_bit_set\n            \n            # Update the minimum removals\n            min_removals = min(min_removals, removals_for_bit)\n        \n        results.append(min_removals)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresults = min_elements_to_remove(n, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_removals_for_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from each range to achieve a non-zero bitwise AND.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples, each containing the range (l, r).\n\n    Returns:\n        List[int]: List of minimum removals for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Initialize the minimum removals to the maximum possible, which is the size of the array\n        min_removals = r - l + 1\n        \n        # Iterate over possible starting points of subarrays\n        for start in range(l, r + 1):\n            current_and = start\n            removals = 0\n            \n            # Iterate over the subarray starting from 'start'\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    removals += 1\n                else:\n                    # If the AND is non-zero, update the minimum removals\n                    min_removals = min(min_removals, removals)\n                    break\n        \n        results.append(min_removals)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Call the function and print results\n    results = min_removals_for_non_zero_and(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef min_elements_to_remove(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from the array such that the bitwise AND of the remaining elements is non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of elements to remove for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum number of elements to remove\n        min_removals = r - l + 1\n        \n        # Iterate over possible bit positions\n        for bit_position in range(20):  # 20 bits are enough for numbers up to 2 * 10^5\n            # Calculate the mask for the current bit position\n            mask = 1 << bit_position\n            \n            # Count numbers in the range [l, r] that have the current bit set\n            count_with_bit_set = 0\n            for number in range(l, r + 1):\n                if number & mask:\n                    count_with_bit_set += 1\n            \n            # Calculate the number of elements to remove to make the AND non-zero\n            removals_for_current_bit = (r - l + 1) - count_with_bit_set\n            \n            # Update the minimum removals\n            min_removals = min(min_removals, removals_for_current_bit)\n        \n        results.append(min_removals)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresults = min_elements_to_remove(n, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_removals_for_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from the array such that the bitwise AND of the remaining elements is non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples, each containing two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of elements to remove for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Initialize the minimum removals to the size of the array\n        min_removals = r - l + 1\n        \n        # Iterate over all possible numbers in the range [l, r]\n        for i in range(l, r + 1):\n            current_and = i\n            removals = 0\n            \n            for j in range(l, r + 1):\n                if (current_and & j) == 0:\n                    removals += 1\n                else:\n                    current_and &= j\n            \n            if current_and != 0:\n                min_removals = min(min_removals, removals)\n        \n        results.append(min_removals)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    results = min_removals_for_non_zero_and(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_removals_for_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from each range [l, r]\n    such that the bitwise AND of the remaining elements is non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples, each containing two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of elements to remove for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Initialize the minimum removals to the maximum possible, which is the size of the range\n        min_removals = r - l + 1\n        \n        # Iterate over each possible starting point in the range\n        for start in range(l, r + 1):\n            current_and = start\n            removals = 0\n            \n            # Iterate over the rest of the range to calculate the AND\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                removals += 1\n                \n                # If the AND becomes non-zero, update the minimum removals\n                if current_and != 0:\n                    min_removals = min(min_removals, removals)\n                    break\n        \n        results.append(min_removals)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Output interface\n    results = min_removals_for_non_zero_and(t, cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_removals_for_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from the array to achieve a non-zero bitwise AND.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of removals for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum removals to a large number\n        min_removals = r - l + 1\n        \n        # Iterate over possible bit positions\n        for bit in range(20):  # 20 bits are enough for numbers up to 2 * 10^5\n            # Calculate the mask for the current bit\n            mask = 1 << bit\n            \n            # Count numbers in the range [l, r] that have the current bit set\n            count_set_bit = 0\n            for num in range(l, r + 1):\n                if num & mask:\n                    count_set_bit += 1\n            \n            # Calculate the number of removals needed to make the AND non-zero\n            removals = (r - l + 1) - count_set_bit\n            min_removals = min(min_removals, removals)\n        \n        results.append(min_removals)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    results = min_removals_for_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_elements_to_remove(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from each range [l, r]\n    to make the bitwise AND of the remaining elements non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains\n                                            two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of elements\n                   to remove for each test case.\n    \"\"\"\n    results = []\n    for l, r in test_cases:\n        # Initialize the minimum number of elements to remove as the size of the range\n        min_remove = r - l + 1\n        \n        # Iterate over each possible bit position\n        for bit in range(20):  # Since r <= 2 * 10^5, we only need to consider up to 19 bits\n            # Calculate the start of the next block of numbers with the current bit set\n            start = (l + (1 << bit) - 1) // (1 << bit) * (1 << bit)\n            # Calculate the end of the current block of numbers with the current bit set\n            end = (r // (1 << bit)) * (1 << bit) + (1 << bit) - 1\n            \n            # If the block is within the range [l, r]\n            if start <= r:\n                # Calculate the number of elements to remove to make the AND non-zero\n                remove_count = max(0, start - l) + max(0, r - end)\n                # Update the minimum number of elements to remove\n                min_remove = min(min_remove, remove_count)\n        \n        results.append(min_remove)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_elements_to_remove(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_elements_to_remove(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from the array to achieve a non-zero bitwise AND.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of elements to remove for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum number of elements to remove as the size of the array\n        min_removals = r - l + 1\n        \n        # Iterate over possible bit positions\n        for bit in range(20):  # 20 bits are enough for numbers up to 200,000\n            # Calculate the mask for the current bit position\n            mask = 1 << bit\n            \n            # Count numbers in the range [l, r] that have the current bit set\n            count_set_bit = 0\n            for num in range(l, r + 1):\n                if num & mask:\n                    count_set_bit += 1\n            \n            # Calculate the number of elements to remove to make the AND non-zero\n            removals = (r - l + 1) - count_set_bit\n            \n            # Update the minimum removals\n            min_removals = min(min_removals, removals)\n        \n        results.append(min_removals)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Call the function and get results\n    results = min_elements_to_remove(n, test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_elements_to_remove(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove for each test case\n    to ensure the bitwise AND of the array is non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples containing l and r for each test case.\n\n    Returns:\n        List[int]: List of minimum elements to remove for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Find the largest power of two less than or equal to r\n        largest_power_of_two = 1\n        while largest_power_of_two <= r:\n            largest_power_of_two <<= 1\n        largest_power_of_two >>= 1\n        \n        # Calculate the minimum elements to remove\n        if largest_power_of_two < l:\n            results.append(0)\n        else:\n            results.append(min(r - largest_power_of_two, largest_power_of_two - l))\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresults = min_elements_to_remove(n, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_removals_for_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of elements to remove from each range to ensure the bitwise AND is non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples, each containing two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of elements to remove for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Calculate the bitwise AND of the entire range\n        current_and = l\n        for num in range(l + 1, r + 1):\n            current_and &= num\n            if current_and == 0:\n                break\n        \n        # If the AND is already non-zero, no removals are needed\n        if current_and != 0:\n            results.append(0)\n            continue\n        \n        # Find the minimum number of removals\n        min_removals = r - l + 1\n        for start in range(l, r + 1):\n            current_and = start\n            removals = 0\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                removals += 1\n                if current_and != 0:\n                    min_removals = min(min_removals, removals)\n                    break\n        \n        results.append(min_removals)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    results = min_removals_for_non_zero_and(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must minimize the number of elements removed to achieve a non-zero bitwise AND result.\nrequirement pool:\n- Implement the main algorithm to solve the problem using bitwise operations\n- Optimize the solution to handle large input sizes efficiently\n- Ensure the solution is tested against multiple test cases\n- Provide clear documentation and comments within the code\n- Explore alternative approaches to further optimize the solution\nWe will use bitwise operations to efficiently determine the minimum number of elements to remove from the array to achieve a non-zero bitwise AND. The approach involves iterating over the range and checking the bitwise properties of the numbers. We will utilize Python's built-in bitwise operators and optimize the solution to handle large input sizes by focusing on the properties of binary numbers.\n", "requirement analysis:\nThe problem requires determining the minimum number of elements to remove from a range of integers such that the bitwise AND of the remaining elements is non-zero. This involves understanding the properties of bitwise operations and efficiently handling large input sizes.\nrequirement pool:\n- Implement the main algorithm to compute the minimum number of elements to remove.\n- Optimize the solution for large input ranges to ensure quick computation.\n- Ensure the output format is consistent with the problem requirements.\n- Test the solution against edge cases and large datasets.\n- Document the solution approach and any assumptions made.\nWe will use a bitwise approach to determine the minimum number of elements to remove from the array such that the bitwise AND of the remaining elements is non-zero. The key observation is that the bitwise AND of a range of numbers is non-zero if there exists a number in the range that has all bits set in positions where the AND result is expected to be non-zero. We will iterate over the range and calculate the AND for each possible subarray, keeping track of the minimum number of elements to remove.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must ensure that the bitwise AND of the array is non-zero by removing the minimum number of elements. The output must be accurate and follow the specified format.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Ensure the solution handles up to 10^4 test cases effectively\n- Optimize the solution for large ranges between l and r\n- Provide clear and concise output for each test case\n- Document the solution for better understanding of bitwise operations\nWe will use bitwise operations to efficiently determine the minimum number of elements to remove from the array such that the bitwise AND of the remaining elements is non-zero. The approach involves iterating over the range and checking the bitwise properties of the numbers. We will utilize Python's built-in bitwise operators and optimize the solution to handle large input sizes effectively.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must be able to determine the minimum number of elements to remove for the bitwise AND to be non-zero, across multiple test cases. The algorithm should be optimized for performance and scalability.\nrequirement pool:\n- Implement the main algorithm to solve the problem using bitwise operations\n- Ensure the solution handles large input sizes efficiently\n- Optimize the algorithm for performance and scalability\n- Provide clear and concise output for each test case\n- Integrate the solution into existing systems easily\nWe will use bitwise operations to determine the minimum number of elements to remove from the array such that the bitwise AND of the remaining elements is non-zero. The key observation is that the bitwise AND of a range of numbers is non-zero if there exists a number in the range that has all bits set in positions where the AND result is expected to be non-zero. We will iterate over the range and calculate the AND, keeping track of the minimum number of elements to remove to achieve a non-zero result.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must be able to determine the minimum number of elements to remove for the bitwise AND to be non-zero, across multiple test cases.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Ensure the solution handles up to 10^4 test cases\n- Optimize for large ranges up to 2 \u22c5 10^5\n- Provide clear output format as specified\n- Include comments and documentation for clarity\nWe will use bitwise operations to determine the minimum number of elements to remove from the array such that the bitwise AND of the remaining elements is non-zero. The key observation is that the bitwise AND of a range of numbers is non-zero if there exists a number in the range that has all bits set in positions where the AND result is non-zero. We will iterate over the range and calculate the bitwise AND, keeping track of the minimum number of elements to remove.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must ensure that the bitwise AND of the array is non-zero by removing the minimum number of elements. The output must be accurate and follow the specified format for multiple test cases.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Ensure the solution handles large input sizes effectively\n- Provide clear and accurate output for each test case\n- Optimize the solution for performance\n- Document the solution approach and edge cases\nWe will use bitwise operations to efficiently determine the minimum number of elements to remove from the array to achieve a non-zero bitwise AND. The approach involves iterating over the range and checking the bitwise AND of subsets to find the optimal solution. Given the constraints, we will ensure the solution is optimized for performance using Python's built-in capabilities.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must minimize the number of elements removed to achieve a non-zero bitwise AND result. The constraints on input size necessitate an optimized approach to ensure quick processing.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Ensure the solution handles up to 10,000 test cases effectively\n- Optimize the solution for large ranges between l and r\n- Provide clear documentation and examples for understanding\n- Enhance the solution to handle edge cases and unusual inputs\nWe will use bitwise operations to efficiently determine the minimum number of elements to remove from the array to achieve a non-zero bitwise AND. The approach involves iterating over the range and checking the bitwise AND of subsets to find the optimal solution. Given the constraints, we will optimize the solution to handle up to 10,000 test cases and large ranges using efficient algorithms.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must ensure that the bitwise AND of the array is non-zero by removing the minimum number of elements. The challenge lies in optimizing the solution to handle up to 10,000 test cases with values up to 200,000.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Optimize the solution to handle large input sizes\n- Ensure the solution is scalable for multiple test cases\n- Provide clear and concise output for each test case\n- Document the solution for better understanding\nWe will use bitwise operations to efficiently determine the minimum number of elements to remove from the array to achieve a non-zero bitwise AND. The approach involves iterating over the range and checking the bitwise AND of subsets to find the optimal solution. Given the constraints, we will optimize the solution to handle up to 10,000 test cases with values up to 200,000 using efficient algorithms.\n", "requirement analysis:\nThe problem requires finding the minimum number of elements to remove from an array of consecutive integers such that the bitwise AND of the remaining elements is non-zero. The solution must efficiently handle up to 10,000 test cases with integer ranges up to 200,000.\nrequirement pool:\n- Develop an algorithm to compute the minimum number of elements to remove for a non-zero bitwise AND.\n- Ensure the solution is optimized for large input sizes and constraints.\n- Provide detailed comments and documentation for the solution.\n- Implement test cases to validate the solution's accuracy.\n- Explore alternative algorithms for potential efficiency improvements.\nWe will use a mathematical approach to determine the minimum number of elements to remove. The key observation is that the bitwise AND of a range of consecutive integers is zero if the range includes a power of two. Therefore, we need to find the largest power of two within the range and remove elements to ensure the AND operation results in a non-zero value. This can be efficiently calculated using bit manipulation techniques.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must ensure that the bitwise AND of the array is non-zero by removing the minimum number of elements. The challenge lies in optimizing the solution to handle up to 10,000 test cases with potentially large ranges.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Ensure the solution handles large input sizes effectively\n- Optimize the algorithm for performance\n- Provide clear and concise output for each test case\n- Document the solution for better understanding\nWe will use bitwise operations to determine the minimum number of elements to remove from the array to ensure the bitwise AND is non-zero. The key observation is that the bitwise AND of a range of numbers is non-zero if there exists a number in the range that has all bits set in positions where the AND result is non-zero. We will iterate over the range and calculate the bitwise AND, keeping track of the minimum number of elements to remove to achieve a non-zero result.\n"], "scores": [], "pass_results": [true, true, false, true, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 479, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "mutate_method": "condense_two2one", "parent_index": 264}
