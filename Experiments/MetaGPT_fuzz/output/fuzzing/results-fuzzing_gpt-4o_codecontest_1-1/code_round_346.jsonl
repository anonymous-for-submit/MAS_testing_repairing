{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. The title of each book is provided with a fixed length m. It means that every title is guaranteed to have the same length so comparison will be consistent. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. The title of each book is provided with a fixed length m. It means that every title is guaranteed to have the same length so comparison will be consistent. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc_ending(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order rules.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order\n                key.append(ord(char))\n        return key\n\n    # Generate a list of indices and sort them based on the custom key\n    indices = list(range(1, n + 1))\n    sorted_indices = sorted(indices, key=lambda i: custom_sort_key(book_titles[i - 1]))\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc_ending(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef asc_desc_ending_sort(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order rules.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the book titles sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given title based on asc-desc-ending rules.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list of tuples representing the custom sort key.\n        \"\"\"\n        return [(title[i], -ord(title[i])) if i % 2 == 0 else (-ord(title[i]), title[i]) for i in range(m)]\n\n    # Create a list of tuples (index, title) to maintain original indices\n    indexed_titles = list(enumerate(book_titles, start=1))\n    \n    # Sort using the custom key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Call the sorting function\nsorted_indices = asc_desc_ending_sort(n, m, book_titles)\n\n# Output interface\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom functools import cmp_to_key\n\ndef sort_books(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of book titles.\n    \"\"\"\n    def custom_comparator(title_a: str, title_b: str) -> int:\n        \"\"\"Compares two book titles based on asc-desc-ending order.\n\n        Args:\n            title_a (str): First book title.\n            title_b (str): Second book title.\n\n        Returns:\n            int: Negative if title_a < title_b, positive if title_a > title_b, zero if equal.\n        \"\"\"\n        for i in range(m):\n            if title_a[i] != title_b[i]:\n                if i % 2 == 0:\n                    # Even index: descending order\n                    return ord(title_b[i]) - ord(title_a[i])\n                else:\n                    # Odd index: ascending order\n                    return ord(title_a[i]) - ord(title_b[i])\n        return 0\n\n    # Create a list of tuples (index, title) to sort by title and return indices\n    indexed_titles = list(enumerate(book_titles, start=1))\n    indexed_titles.sort(key=cmp_to_key(lambda x, y: custom_comparator(x[1], y[1])))\n\n    # Extract sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef asc_desc_ending_sort(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Odd position (0-based index), ascending order\n                key.append((char, 'asc'))\n            else:\n                # Even position (0-based index), descending order\n                key.append((char, 'desc'))\n        return key\n\n    # Generate sort keys for each title\n    sort_keys = [(custom_sort_key(title), index) for index, title in enumerate(book_titles)]\n\n    # Sort based on custom keys\n    sort_keys.sort(key=lambda x: [(-ord(char) if order == 'desc' else ord(char)) for char, order in x[0]])\n\n    # Extract sorted indices\n    sorted_indices = [index + 1 for _, index in sort_keys]\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = asc_desc_ending_sort(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Odd position (0-based index), sort ascending\n                key.append(char)\n            else:\n                # Even position (0-based index), sort descending\n                key.append(chr(255 - ord(char)))  # Invert character for descending sort\n        return key\n\n    # Generate indices for books\n    indices = list(range(1, n + 1))\n    \n    # Sort indices based on custom sort key\n    sorted_indices = sorted(indices, key=lambda i: custom_sort_key(books[i - 1]))\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of the book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order\n                key.append(ord(char))\n        return key\n\n    # Generate a list of tuples (index, book title)\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the indexed books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc_ending(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the sorted book titles in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd indices (0-based) are sorted ascending\n            if i % 2 == 0:\n                key.append((0, char))\n            # Even indices (0-based) are sorted descending\n            else:\n                key.append((1, -ord(char)))\n        return key\n\n    # Create a list of tuples (index, title) to maintain original indices\n    indexed_titles = list(enumerate(book_titles, start=1))\n    \n    # Sort using the custom key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc_ending(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of the books.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order\n                key.append(ord(char))\n        return key\n\n    # Generate a list of tuples (index, book title)\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the indexed books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles according to asc-desc-ending order rules.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of book titles.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order\n                key.append(ord(char))\n        return key\n\n    # Generate sort keys for each title\n    sort_keys = [(custom_sort_key(title), index) for index, title in enumerate(book_titles)]\n    \n    # Sort based on the custom keys\n    sort_keys.sort()\n\n    # Extract sorted indices\n    sorted_indices = [index + 1 for _, index in sort_keys]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbook_titles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books_asc_desc(n, m, book_titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc_ending(n: int, m: int, book_titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order rules.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        book_titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the book titles sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a given book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd index (0-based) -> Ascending order\n            if i % 2 == 0:\n                key.append((char, 1))\n            # Even index (0-based) -> Descending order\n            else:\n                key.append((char, -1))\n        return key\n\n    # Create a list of tuples (index, title) to maintain original indices\n    indexed_titles = list(enumerate(book_titles, start=1))\n    \n    # Sort using the custom key\n    indexed_titles.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    \n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    book_titles = [input().strip() for _ in range(n)]\n    \n    # Output interface\n    sorted_indices = sort_books_asc_desc_ending(n, m, book_titles)\n    print(' '.join(map(str, sorted_indices)))\n"], "plans": ["requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified character comparison rules. The input size constraint suggests the need for an efficient algorithm to handle large datasets.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Provide clear input and output format adherence\n- Optimize for performance and memory usage\n- Include comprehensive test cases for validation\nWe will implement a custom sorting function that adheres to the asc-desc-ending order rules. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n", "requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified character comparison rules. The input size constraint suggests the need for an efficient algorithm to handle large datasets.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Optimize the algorithm for large input sizes\n- Ensure the output format matches the specified requirements\n- Test the algorithm against multiple test cases\n- Document the code for maintainability\nWe will implement a custom sorting function that adheres to the asc-desc-ending order rules. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n", "requirement analysis:\nThe requirement is to sort book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. This requires a custom comparator function to handle the sorting logic efficiently given the constraints of n and m.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles large inputs efficiently.\n- Provide clear documentation and comments in the code.\n- Optimize for readability and maintainability.\n- Include test cases to validate the sorting logic.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities with a custom comparator function. This function will handle the asc-desc-ending order by checking each character's index and applying the appropriate lexicographical comparison. Given the constraints, we will ensure the solution is efficient and can handle large inputs by leveraging Python's efficient sorting mechanisms.\n", "requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified character comparison rules. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across all test cases.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm for book titles.\n- Ensure the solution handles edge cases, such as minimum and maximum input sizes.\n- Optimize the algorithm for performance given the constraint of 10^6 characters.\n- Provide clear documentation and comments within the code for maintainability.\n- Design a user-friendly interface for input and output handling.\nWe will implement a custom sorting function that adheres to the asc-desc-ending order rules. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n", "requirement analysis:\nThe requirement is to sort book titles based on a unique asc-desc-ending order. This involves comparing characters at odd positions in ascending order and even positions in descending order. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across multiple test cases.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Ensure the solution handles large input sizes efficiently.\n- Validate input format and constraints.\n- Optimize for performance and memory usage.\n- Provide clear error messages for invalid inputs.\nWe will implement a custom sorting function that compares book titles based on the asc-desc-ending order. This involves checking each character position in the strings: odd positions are sorted in ascending order, and even positions are sorted in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n", "requirement analysis:\nThe requirement is to sort book titles based on a custom lexicographical order where odd-indexed characters are sorted ascendingly and even-indexed characters are sorted descendingly. The solution must handle up to 10^6 characters efficiently and output the indices of the sorted titles.\nrequirement pool:\n- Implement the sorting algorithm for asc-desc-ending order.\n- Optimize the algorithm for large input sizes.\n- Ensure the output format matches the specified requirements.\n- Test the algorithm against multiple test cases.\n- Document the code for maintainability.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n", "requirement analysis:\nThe requirement involves sorting book titles based on a unique asc-desc-ending order. This requires implementing a custom sorting algorithm that considers odd-indexed characters for ascending order and even-indexed characters for descending order. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness across multiple test cases.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Test the algorithm against multiple test cases for correctness\n- Optimize the algorithm for performance\n- Document the code for maintainability\nWe will implement a custom sorting algorithm that sorts book titles based on the asc-desc-ending order. This involves comparing characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n", "requirement analysis:\nThe requirement involves sorting book titles based on a unique asc-desc-ending order. This requires implementing a custom sorting algorithm that considers the position of characters in the string and applies different sorting rules based on whether the position is odd or even. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Ensure the solution handles large input sizes efficiently\n- Validate input to ensure all titles are distinct and of fixed length\n- Optimize for performance and memory usage\n- Provide clear error messages for invalid input\nWe will implement a custom sorting function that sorts the book titles based on the specified asc-desc-ending order. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles up to 10^6 characters efficiently.\n", "requirement analysis:\nThe requirement involves sorting book titles based on a unique asc-desc-ending order. This requires implementing a custom sorting algorithm that considers the position of characters in the string and applies different sorting rules based on whether the position is odd or even. The solution must efficiently handle up to 10^6 characters, ensuring performance and correctness.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm for book titles.\n- Ensure the solution handles large input sizes efficiently.\n- Provide clear input and output handling as per the requirements.\n- Optimize the algorithm for performance.\n- Include error handling for edge cases.\nWe will implement a custom sorting function that adheres to the asc-desc-ending order rules. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, we will ensure the solution handles large input sizes by optimizing the comparison logic.\n", "requirement analysis:\nThe requirements focus on sorting book titles based on a unique asc-desc-ending order. The challenge lies in implementing a sorting algorithm that adheres to the specified character comparison rules. The input size constraint (n \u22c5 m \u2264 10^6) suggests the need for an efficient algorithm to handle potentially large datasets.\nrequirement pool:\n- Implement the asc-desc-ending sorting algorithm\n- Optimize the algorithm for large datasets\n- Ensure the output format matches the requirements\n- Test the algorithm against multiple test cases\n- Document the code for maintainability\nWe will implement a custom sorting function that adheres to the asc-desc-ending order rules. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n"], "scores": [], "pass_results": [true, false, false, false, true, true, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 346, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "rephrase_one", "parent_index": 51}
