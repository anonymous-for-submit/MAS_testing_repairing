{"name": "1622_B. Berland Music", "description": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\n\n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "tags": ["data structures", "greedy", "math", "sortings"], "difficulty": 8, "id": 1622, "sample_io": [{"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}], "test_list": [{"input": "1\n7\n1 2 3 4 5 6 7\n0101010\n", "output": ["1 5 2 6 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n10101010101010101010101010101010101010101010101010\n", "output": ["26 1 27 2 28 3 29 4 30 5 31 6 32 7 33 8 34 9 35 10 36 11 37 12 38 13 39 14 40 15 41 16 42 17 43 18 44 19 45 20 46 21 47 22 48 23 49 24 50 25\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 4 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n3 1 2\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["2 1\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101010\n", "output": ["4 5 1 6 2 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 1 2\n1 6 5 8 2 7 4 3\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101000\n", "output": ["5 6 1 7 2 3 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n3 1 2\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n1 2 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 2 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 1 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 7 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["2 1\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01100100\n", "output": ["2 1\n3 2 1\n1 7 6 5 2 8 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n1 2 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 5 2 6 3 4 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 1 6 2 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 1 2 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n1 2 3\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 4 2 5 6 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 7 4 5 6\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111011\n", "output": ["2 1\n1 6 2 7 3 4 5\n3 4 2 8 5 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 2 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 5 6 7 2 3 4\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 6 7 1 2 3\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110100\n", "output": ["2 1\n3 2 1\n5 6 4 8 1 7 3 2\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n2 3 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1001000\n", "output": ["6 1 2 7 3 4 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00100001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 7 6 4 3 5 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n2 3 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 3 2 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n3 2 1\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n1 5 6 7 2 3 4\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010010\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 6 1 8 3 2 7 4\n"]}, {"input": "3\n2\n2 1\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 4 5 6 1 7 2\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 7 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 4 3 8 2 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111101\n", "output": ["2 1\n3 2 1\n1 4 3 8 6 5 2 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n2 3 4 5 6 1 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0110000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 7 2 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n2 1 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 6 4 7 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 3 1\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110110\n", "output": ["2 1\n3 2 1\n1 5 4 8 2 6 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n10010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 2 1 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 2 1\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 2 1\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 2 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 5 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1100010\n", "output": ["5 6 1 2 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110111\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 4 8 3 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n4 5 6 7 1 2 3\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 4 2 5 3 6 7\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 4 1 5 6 7 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110110\n", "output": ["2 1\n3 2 1\n4 5 3 8 1 6 7 2\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["1 2\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n3 4 5 6 7 1 2\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01100001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 7 6 5 3 2 4 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 7 2 3 4 5 6\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11011011\n", "output": ["2 1\n1 5 2 6 3 4 7\n3 4 1 8 5 2 7 6\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}], "task_id": "codecontest/155", "prompt": "Berland Music is a music streaming service built specifically to support Berland local artists, and its developers are currently working on a song recommendation module. So imagine Monocarp got recommended n songs, numbered from 1 to n, and the i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n. Each unique number from 1 to n is present exactly once; in other words, p is a rearrangement of numbers. After listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 implies that he disliked the i-th song, and s_i=1 means that he liked it. Now the service has to re-evaluate the song ratings in such a way that: * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked. Formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold. Among all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x. Print the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "repair_prompt": ["Berland Music is a music streaming service built specifically to support Berland local artists, and its developers are currently working on a song recommendation module. So imagine Monocarp got recommended n songs, numbered from 1 to n, and the i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n. Each unique number from 1 to n is present exactly once; in other words, p is a rearrangement of numbers. After listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 implies that he disliked the i-th song, and s_i=1 means that he liked it. Now the service has to re-evaluate the song ratings in such a way that: * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked. Formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold. Among all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x. Print the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign lowest ratings to disliked songs\n        for i in range(len(disliked)):\n            q[p.index(disliked[i])] = current_rating\n            current_rating += 1\n\n        # Assign highest ratings to liked songs\n        for i in range(len(liked)):\n            q[p.index(liked[i])] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        p = list(map(int, data[index:index + n]))\n        index += n\n        s = data[index]\n        index += 1\n        test_cases.append((n, p, s))\n    \n    # Call the function and get results\n    results = re_evaluate_ratings(t, test_cases)\n    \n    # Output interface\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback using a greedy approach.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): String representing user feedback (likes/dislikes).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked categories\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        liked_index = n - len(liked)\n        disliked_index = 0\n\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                q[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback while maintaining a permutation of ratings.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Permutation of predicted ratings.\n            - s (str): String representing user feedback (0 for dislike, 1 for like).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n    \n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n        \n        # Separate liked and disliked songs based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n        \n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n        \n        # Create new ratings list\n        q = [0] * n\n        liked_index = 0\n        disliked_index = 0\n        \n        # Assign new ratings ensuring liked songs have higher ratings\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = disliked_index + len(disliked) + 1\n                liked_index += 1\n            else:\n                q[i] = disliked_index + 1\n                disliked_index += 1\n        \n        results.append(q)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n    \n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's likes and dislikes.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): String of likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings\n        sorted_p = sorted(p)\n\n        # Assign highest ratings to liked songs\n        liked_ratings = sorted_p[-len(liked_indices):]\n        disliked_ratings = sorted_p[:len(disliked_indices)]\n\n        # Create the new ratings list\n        q = [0] * n\n        for idx, rating in zip(liked_indices, liked_ratings):\n            q[idx] = rating\n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            q[idx] = rating\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user likes and dislikes.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Like/dislike string.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked categories\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Assign ratings: highest to liked, lowest to disliked\n        q = [0] * n\n        liked_index = 0\n        disliked_index = 0\n\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                q[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate liked and disliked songs\n        liked = []\n        disliked = []\n\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for i in range(len(disliked)):\n            q[p.index(disliked[i])] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for i in range(len(liked)):\n            q[p.index(liked[i])] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        p = list(map(int, data[index:index + n]))\n        index += n\n        s = data[index]\n        index += 1\n        test_cases.append((n, p, s))\n    \n    # Call the function and print the results\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's likes and dislikes.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): String of likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings\n        sorted_p = sorted(p)\n\n        # Assign highest ratings to liked songs\n        liked_ratings = sorted_p[-len(liked_indices):]\n        disliked_ratings = sorted_p[:len(disliked_indices)]\n\n        # Create a new ratings list\n        q = [0] * n\n\n        # Assign ratings to liked songs\n        for idx, rating in zip(liked_indices, liked_ratings):\n            q[idx] = rating\n\n        # Assign ratings to disliked songs\n        for idx, rating in zip(disliked_indices, disliked_ratings):\n            q[idx] = rating\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of songs.\n            - p: List of integers representing the permutation of predicted ratings.\n            - s: String representing user feedback ('0' for dislike, '1' for like).\n\n    Returns:\n        A list of lists, where each list contains the re-evaluated ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate liked and disliked songs\n        liked = []\n        disliked = []\n\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        new_ratings = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for i in range(n):\n            if s[i] == '0':\n                new_ratings[i] = disliked.pop(0)\n                current_rating += 1\n\n        # Assign ratings to liked songs\n        for i in range(n):\n            if s[i] == '1':\n                new_ratings[i] = liked.pop(0)\n                current_rating += 1\n\n        results.append(new_ratings)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        p = list(map(int, input().strip().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user likes and dislikes.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): String of likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the predicted ratings for liked and disliked songs\n        liked_ratings = sorted([p[i] for i in liked_indices], reverse=True)\n        disliked_ratings = sorted([p[i] for i in disliked_indices])\n\n        # Assign the highest ratings to liked songs and lowest to disliked songs\n        q = [0] * n\n        for i, idx in enumerate(liked_indices):\n            q[idx] = liked_ratings[i]\n        for i, idx in enumerate(disliked_indices):\n            q[idx] = disliked_ratings[i]\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Vote sequence where '1' is like and '0' is dislike.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate liked and disliked songs\n        for i in range(n):\n            if s[i] == '1':\n                liked.append((p[i], i))\n            else:\n                disliked.append((p[i], i))\n\n        # Sort liked and disliked songs by their predicted ratings\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for _, index in disliked:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for _, index in liked:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        p = list(map(int, input().strip().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to develop a song recommendation module that adjusts song ratings based on user feedback. The algorithm must ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences between predicted and adjusted ratings. The solution should efficiently handle large datasets and provide accurate results.\nrequirement pool:\n- Develop the core algorithm for song recommendation\n- Implement rating adjustment based on user feedback\n- Optimize algorithm for large datasets\n- Ensure accurate permutation of song ratings\n- Integrate with existing music streaming service\nWe will implement a function that processes each test case independently. For each test case, we will separate the songs into two groups based on Monocarp's feedback: liked and disliked. We will then assign the highest available ratings to the liked songs and the lowest available ratings to the disliked songs. This ensures that liked songs have higher ratings than disliked ones. We will use sorting to efficiently assign ratings while minimizing the sum of absolute differences between predicted and adjusted ratings.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. The solution should handle multiple test cases efficiently and adhere to the input-output format.\nrequirement pool:\n- Implement song recommendation algorithm\n- Ensure liked songs have higher ratings than disliked ones\n- Optimize for minimum sum of absolute differences\n- Handle multiple test cases efficiently\n- Integrate with existing music streaming platform\nWe will implement a function to re-evaluate song ratings based on user feedback using a greedy approach. The function will sort the songs into liked and disliked categories, assign the highest available ratings to liked songs, and the lowest to disliked songs. This ensures liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences from predicted ratings. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle multiple test cases.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback.\n- Ensure permutation of ratings is maintained.\n- Optimize algorithm for minimal sum of absolute differences.\n- Develop responsive UI for music exploration.\n- Integrate local artist discovery features.\nWe will implement a function to re-evaluate song ratings based on user feedback while maintaining a permutation of ratings. The function will ensure liked songs have higher ratings than disliked ones and minimize the sum of absolute differences between original and new ratings. We will use Python's built-in sorting capabilities to efficiently handle the permutation and rating adjustments.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that adjusts song ratings based on user feedback. The module must ensure liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. The solution should handle multiple test cases efficiently and adhere to the input-output format.\nrequirement pool:\n- Implement the song recommendation algorithm.\n- Ensure liked songs have higher ratings than disliked ones.\n- Optimize for minimum sum of absolute differences.\n- Handle multiple test cases efficiently.\n- Design a user-friendly interface for feedback.\nWe will implement a function that processes multiple test cases efficiently. For each test case, we will separate the songs into liked and disliked categories based on the input string. We will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring the permutation condition is met. The algorithm will use sorting and simple list operations to achieve this, minimizing the sum of absolute differences.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The re-evaluation must ensure that liked songs have higher ratings than disliked ones, while minimizing the absolute difference from the original predicted ratings. The solution must handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation re-evaluation algorithm.\n- Ensure the algorithm handles up to 10,000 test cases efficiently.\n- Optimize the algorithm for minimal absolute difference in ratings.\n- Validate the output format for multiple test cases.\n- Consider edge cases where all songs are liked or disliked.\nWe will implement a function that processes multiple test cases efficiently. For each test case, we will separate the songs into liked and disliked categories based on the input string. We will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring the permutation condition is met. The algorithm will be optimized to minimize the absolute difference from the original predicted ratings using sorting and greedy assignment techniques.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones, while minimizing the difference between predicted and re-evaluated ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation algorithm\n- Ensure the algorithm handles large input sizes efficiently\n- Develop a user interface for liking/disliking songs\n- Integrate local artist support features\n- Enhance user engagement through personalized experiences\nWe will implement a function that processes multiple test cases to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones, while minimizing the difference between predicted and re-evaluated ratings. We will use sorting and list manipulation to achieve this efficiently, given the constraints on input size.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge is to ensure liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between predicted and actual ratings.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback.\n- Ensure liked songs have higher ratings than disliked songs.\n- Optimize for minimal difference between predicted and actual ratings.\n- Maintain permutation of ratings for all songs.\n- Enhance user interface for better engagement.\nWe will implement a function that processes multiple test cases. For each test case, we will separate the songs into liked and disliked categories based on the input string. We will then assign the highest available ratings to the liked songs and the lowest to the disliked songs, ensuring that the permutation constraint is maintained. The goal is to minimize the sum of absolute differences between the predicted and actual ratings. We will use Python's built-in sorting and list manipulation capabilities to achieve this efficiently.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback.\n- Ensure permutation of song ratings is maintained.\n- Optimize algorithm for large datasets.\n- Develop intuitive UI for liking/disliking songs.\n- Integrate with existing music streaming platform.\nWe will implement a function to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while maintaining a permutation of ratings. We will use sorting to efficiently assign new ratings, minimizing the sum of absolute differences between original and new ratings. The approach will handle edge cases where all songs are liked or disliked by simply returning the original permutation or a sorted permutation respectively.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, with minimal deviation from predicted ratings.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback\n- Ensure permutation of song ratings with minimal deviation\n- Develop responsive UI for seamless user experience\n- Integrate local artist support features\n- Enhance algorithm efficiency for large datasets\nWe will implement a function that processes each test case independently. For each test case, we will separate the songs into two groups based on whether they were liked or disliked. We will then assign the highest available ratings to the liked songs and the lowest available ratings to the disliked songs, ensuring that the permutation constraint is satisfied. This approach ensures that the sum of absolute differences between the predicted and new ratings is minimized.\n", "requirement analysis:\nThe requirement focuses on re-evaluating song ratings based on user feedback while maintaining a permutation of ratings. The challenge lies in ensuring liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement song recommendation algorithm based on user feedback\n- Ensure permutation of song ratings is maintained\n- Optimize algorithm for large datasets\n- Develop user interface for liking/disliking songs\n- Integrate local artist discovery features\nWe will implement a function that processes multiple test cases to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while maintaining a permutation of ratings. We will use sorting and list manipulation techniques to achieve this efficiently.\n"], "scores": [], "pass_results": [false, true, false, false, false, false, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 477, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "mutate_method": "rephrase_one", "parent_index": 274}
