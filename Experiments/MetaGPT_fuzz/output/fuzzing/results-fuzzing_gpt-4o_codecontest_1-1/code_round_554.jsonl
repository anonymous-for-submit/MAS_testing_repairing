{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. They are connected by n - 1 tunnels such that it is possible to travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and to go from the x-th room to the y-th room, there must exist a tunnel between x and y, which takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Assume all queries are given in a sequence and must be answered in that order.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. They are connected by n - 1 tunnels such that it is possible to travel between each pair of rooms through several tunnels. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate, and to go from the x-th room to the y-th room, there must exist a tunnel between x and y, which takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Assume all queries are given in a sequence and must be answered in that order.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"A class to represent a Segment Tree for efficient range queries and updates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        \"\"\"Initialize the Segment Tree with the given data.\"\"\"\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Build the Segment Tree.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Update the value at position pos to value.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Query the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], seg_tree: SegmentTree) -> None:\n    \"\"\"Update the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    seg_tree.update(room - 1, new_rate)\n\ndef find_min_energy_path(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Find the minimum energy path between two rooms using DFS.\"\"\"\n    from collections import defaultdict, deque\n    \n    # Build adjacency list for the tree\n    graph = defaultdict(list)\n    for s, t in tunnels:\n        graph[s].append(t)\n        graph[t].append(s)\n    \n    # Perform DFS to find the path from u to v\n    def dfs(current, target, visited, path):\n        if current == target:\n            return True\n        visited.add(current)\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                path.append(neighbor)\n                if dfs(neighbor, target, visited, path):\n                    return True\n                path.pop()\n        return False\n    \n    path = [u]\n    visited = set()\n    dfs(u, v, visited, path)\n    \n    # Calculate the energy for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n    \n    return energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n    \n    seg_tree = SegmentTree(illusion_rates)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room = int(data[index + 1])\n            new_rate = int(data[index + 2])\n            update_illusion_rate(room, new_rate, illusion_rates, seg_tree)\n            index += 3\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            result = find_min_energy_path(u, v, illusion_rates, tunnels)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at the given index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef find_path(tree: List[List[int]], start: int, end: int) -> List[int]:\n    \"\"\"Finds the path from start to end using DFS.\"\"\"\n    path = []\n    stack = [(start, [start])]\n    visited = set()\n    \n    while stack:\n        node, current_path = stack.pop()\n        if node in visited:\n            continue\n        visited.add(node)\n        if node == end:\n            path = current_path\n            break\n        for neighbor in tree[node]:\n            if neighbor not in visited:\n                stack.append((neighbor, current_path + [neighbor]))\n    \n    return path\n\ndef calculate_energy(path: List[int], illusion_rates: List[int]) -> int:\n    \"\"\"Calculates the energy required for the given path.\"\"\"\n    energy = 0\n    for i in range(len(path) - 1):\n        u, v = path[i], path[i + 1]\n        energy += max(abs(illusion_rates[u - 1] + illusion_rates[v - 1]), abs(illusion_rates[u - 1] - illusion_rates[v - 1]))\n    return energy\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Processes the queries and calculates the required energy.\"\"\"\n    # Build the tree structure\n    tree = [[] for _ in range(n + 1)]\n    for u, v in tunnels:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Initialize segment tree for illusion rates\n    segment_tree = SegmentTree(illusion_rates)\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query: change illusion rate\n            u, c = query[1], query[2]\n            segment_tree.update(u - 1, c)\n            illusion_rates[u - 1] = c\n        elif query[0] == 2:\n            # Query for minimum energy from u to v\n            u, v = query[1], query[2]\n            path = find_path(tree, u, v)\n            energy = calculate_energy(path, illusion_rates)\n            results.append(energy)\n    \n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room.\n\n    Args:\n        room: The room number whose illusion rate needs to be updated.\n        new_rate: The new illusion rate to be set for the room.\n        illusion_rates: A list containing the illusion rates of all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy_path(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy path between two rooms using DFS.\n\n    Args:\n        u: The starting room number.\n        v: The destination room number.\n        illusion_rates: A list containing the illusion rates of all rooms.\n        tree: An adjacency list representing the tree structure of the maze.\n\n    Returns:\n        The minimum energy required to travel from room u to room v.\n    \"\"\"\n    def dfs(current: int, target: int, visited: List[bool], current_energy: int) -> int:\n        if current == target:\n            return current_energy\n        visited[current] = True\n        min_energy = float('inf')\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                energy_cost = max(abs(illusion_rates[current - 1] + illusion_rates[neighbor - 1]),\n                                  abs(illusion_rates[current - 1] - illusion_rates[neighbor - 1]))\n                min_energy = min(min_energy, dfs(neighbor, target, visited, current_energy + energy_cost))\n        visited[current] = False\n        return min_energy\n\n    visited = [False] * (len(tree))\n    return dfs(u, v, visited, 0)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            update_illusion_rate(u, c, illusion_rates)\n            index += 3\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            result = calculate_min_energy_path(u, v, illusion_rates, tree)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"\n    Process the queries to either update the illusion rate of a room or calculate the minimum energy required\n    to move from one room to another in the maze.\n\n    Args:\n        n (int): Number of rooms in the maze.\n        q (int): Number of queries.\n        illusion_rates (List[int]): Initial illusion rates of each room.\n        tunnels (List[Tuple[int, int]]): List of tunnels connecting the rooms.\n        queries (List[Tuple[int, int, int]]): List of queries to process.\n\n    Returns:\n        List[int]: Results of type 2 queries, which are the minimum energy required for the specified movements.\n    \"\"\"\n    # Initialize adjacency list for the tree\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in tunnels:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Preprocess the tree to find LCA and prepare for queries\n    parent = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n    max_depth = 0\n    euler_tour = []\n    first_occurrence = [-1] * (n + 1)\n\n    def dfs(node: int, par: int, dep: int):\n        nonlocal max_depth\n        parent[node] = par\n        depth[node] = dep\n        euler_tour.append(node)\n        first_occurrence[node] = len(euler_tour) - 1\n        max_depth = max(max_depth, dep)\n        for neighbor in adj_list[node]:\n            if neighbor != par:\n                dfs(neighbor, node, dep + 1)\n                euler_tour.append(node)\n\n    # Start DFS from node 1 (assuming 1 is the root)\n    dfs(1, -1, 0)\n\n    # Build Segment Tree for LCA\n    m = len(euler_tour)\n    segment_tree = [0] * (4 * m)\n\n    def build_segment_tree(node: int, start: int, end: int):\n        if start == end:\n            segment_tree[node] = euler_tour[start]\n        else:\n            mid = (start + end) // 2\n            build_segment_tree(2 * node + 1, start, mid)\n            build_segment_tree(2 * node + 2, mid + 1, end)\n            left = segment_tree[2 * node + 1]\n            right = segment_tree[2 * node + 2]\n            segment_tree[node] = left if depth[left] < depth[right] else right\n\n    build_segment_tree(0, 0, m - 1)\n\n    def query_segment_tree(node: int, start: int, end: int, L: int, R: int) -> int:\n        if start > R or end < L:\n            return -1\n        if L <= start and end <= R:\n            return segment_tree[node]\n        mid = (start + end) // 2\n        left = query_segment_tree(2 * node + 1, start, mid, L, R)\n        right = query_segment_tree(2 * node + 2, mid + 1, end, L, R)\n        if left == -1:\n            return right\n        if right == -1:\n            return left\n        return left if depth[left] < depth[right] else right\n\n    def find_lca(u: int, v: int) -> int:\n        if first_occurrence[u] > first_occurrence[v]:\n            u, v = v, u\n        return query_segment_tree(0, 0, m - 1, first_occurrence[u], first_occurrence[v])\n\n    # Process each query\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query: 1 u c\n            u, c = query[1], query[2]\n            illusion_rates[u - 1] = c\n        elif query[0] == 2:\n            # Path query: 2 u v\n            u, v = query[1], query[2]\n            lca = find_lca(u, v)\n            # Calculate the energy cost from u to v via LCA\n            def calculate_energy(x: int, y: int) -> int:\n                return max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n\n            def path_energy(x: int, y: int) -> int:\n                energy = 0\n                while x != y:\n                    energy += calculate_energy(x, parent[x])\n                    x = parent[x]\n                return energy\n\n            energy = path_energy(u, lca) + path_energy(v, lca)\n            results.append(energy)\n\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\nsys.setrecursionlimit(200000)\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.preprocess()\n\n    def preprocess(self):\n        \"\"\"Preprocess the tree to calculate parent and depth for each node.\"\"\"\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int):\n        \"\"\"Depth First Search to set parent and depth.\"\"\"\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def update_illusion_rate(self, room: int, new_rate: int) -> None:\n        \"\"\"Update the illusion rate of a specific room.\"\"\"\n        self.illusion_rates[room - 1] = new_rate\n\n    def calculate_min_energy_path(self, u: int, v: int) -> int:\n        \"\"\"Calculate the minimum energy path from room u to room v.\"\"\"\n        path_u = self.get_path_to_root(u)\n        path_v = self.get_path_to_root(v)\n        lca = self.find_lca(path_u, path_v)\n        return self.calculate_energy(path_u, lca) + self.calculate_energy(path_v, lca)\n\n    def get_path_to_root(self, node: int) -> List[int]:\n        \"\"\"Get the path from a node to the root.\"\"\"\n        path = []\n        while node != -1:\n            path.append(node)\n            node = self.parent[node]\n        return path\n\n    def find_lca(self, path_u: List[int], path_v: List[int]) -> int:\n        \"\"\"Find the Lowest Common Ancestor (LCA) of two paths.\"\"\"\n        path_u.reverse()\n        path_v.reverse()\n        lca = -1\n        for u, v in zip(path_u, path_v):\n            if u == v:\n                lca = u\n            else:\n                break\n        return lca\n\n    def calculate_energy(self, path: List[int], lca: int) -> int:\n        \"\"\"Calculate the energy required to traverse a path to the LCA.\"\"\"\n        energy = 0\n        for i in range(len(path) - 1):\n            if path[i] == lca:\n                break\n            u, v = path[i], path[i + 1]\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[v - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[v - 1]))\n        return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n\n    maze = Maze(n, illusion_rates, tunnels)\n\n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            maze.update_illusion_rate(room, new_rate)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = maze.calculate_min_energy_path(u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree to handle updates and queries efficiently.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at a specific index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], node: int, parent: int, illusion_rates: List[int], path_energy: List[int]):\n    \"\"\"Performs DFS to calculate path energy.\"\"\"\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            path_energy[neighbor] = path_energy[node] + max(abs(illusion_rates[node] + illusion_rates[neighbor]), abs(illusion_rates[node] - illusion_rates[neighbor]))\n            dfs(tree, neighbor, node, illusion_rates, path_energy)\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Processes the queries and calculates the required energy.\"\"\"\n    # Build the tree structure\n    tree = [[] for _ in range(n + 1)]\n    for u, v in tunnels:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Initialize path energy using DFS\n    path_energy = [0] * (n + 1)\n    dfs(tree, 1, -1, illusion_rates, path_energy)\n    \n    # Initialize segment tree for illusion rates\n    segment_tree = SegmentTree(illusion_rates)\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update query\n            u, c = query[1], query[2]\n            segment_tree.update(u - 1, c)\n            illusion_rates[u - 1] = c\n            # Recalculate path energy from the updated node\n            path_energy = [0] * (n + 1)\n            dfs(tree, 1, -1, illusion_rates, path_energy)\n        elif query[0] == 2:\n            # Energy query\n            u, v = query[1], query[2]\n            results.append(path_energy[v] - path_energy[u])\n    \n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output interface\nresults = process_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree for efficient updates and queries on illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int):\n        \"\"\"Updates the value at a specific index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef dfs(tree: List[List[int]], current: int, parent: int, path: List[int], paths: List[List[int]]):\n    \"\"\"Performs DFS to find all paths in the tree.\"\"\"\n    path.append(current)\n    for neighbor in tree[current]:\n        if neighbor != parent:\n            dfs(tree, neighbor, current, path, paths)\n    if len(tree[current]) == 1 and current != 0:\n        paths.append(path.copy())\n    path.pop()\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    n = len(illusion_rates)\n    tree = [[] for _ in range(n)]\n    for s, t in tunnels:\n        tree[s - 1].append(t - 1)\n        tree[t - 1].append(s - 1)\n    \n    paths = []\n    dfs(tree, u - 1, -1, [], paths)\n    \n    min_energy = float('inf')\n    for path in paths:\n        if v - 1 in path:\n            energy = 0\n            for i in range(len(path) - 1):\n                x, y = path[i], path[i + 1]\n                energy += max(abs(illusion_rates[x] + illusion_rates[y]), abs(illusion_rates[x] - illusion_rates[y]))\n            min_energy = min(min_energy, energy)\n    \n    return min_energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"Segment Tree for efficient range updates and queries.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]) -> None:\n        \"\"\"Builds the segment tree.\"\"\"\n        for i in range(self.n):\n            self.tree[i + self.n] = data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]\n    \n    def update(self, index: int, value: int) -> None:\n        \"\"\"Updates the value at a specific index.\"\"\"\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index //= 2\n            self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a specific room.\"\"\"\n    illusion_rates[room - 1] = new_rate\n    segment_tree.update(room - 1, new_rate)\n\ndef dfs(u: int, v: int, parent: int, graph: List[List[int]], illusion_rates: List[int], path_energy: List[int]) -> None:\n    \"\"\"Performs DFS to calculate the path energy from u to v.\"\"\"\n    if u == v:\n        return\n    for neighbor in graph[u]:\n        if neighbor != parent:\n            energy = max(abs(illusion_rates[u] + illusion_rates[neighbor]), abs(illusion_rates[u] - illusion_rates[neighbor]))\n            path_energy[0] += energy\n            dfs(neighbor, v, u, graph, illusion_rates, path_energy)\n            if path_energy[0] != 0:\n                return\n\ndef min_energy_path(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculates the minimum energy path between two rooms.\"\"\"\n    graph = [[] for _ in range(len(illusion_rates))]\n    for s, t in tunnels:\n        graph[s - 1].append(t - 1)\n        graph[t - 1].append(s - 1)\n    \n    path_energy = [0]\n    dfs(u - 1, v - 1, -1, graph, illusion_rates, path_energy)\n    return path_energy[0]\n\ndef main() -> None:\n    \"\"\"Main function to process input and execute queries.\"\"\"\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    queries = [input().split() for _ in range(q)]\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    for query in queries:\n        if query[0] == '1':\n            room, new_rate = int(query[1]), int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u, v = int(query[1]), int(query[2])\n            result = min_energy_path(u, v, illusion_rates, tunnels)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\n\n    Args:\n        room (int): The room number whose illusion rate is to be updated.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): List of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (List[int]): List of current illusion rates for all rooms.\n        tree (List[List[int]]): Adjacency list representation of the tree.\n\n    Returns:\n        int: The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Helper function to perform DFS and find path from u to v\n    def dfs(current: int, target: int, visited: List[bool], path: List[int]) -> bool:\n        visited[current] = True\n        path.append(current)\n        if current == target:\n            return True\n        for neighbor in tree[current]:\n            if not visited[neighbor]:\n                if dfs(neighbor, target, visited, path):\n                    return True\n        path.pop()\n        return False\n\n    # Find path from u to v using DFS\n    visited = [False] * (len(tree))\n    path = []\n    dfs(u, v, visited, path)\n\n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        x = path[i]\n        y = path[i + 1]\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n\n    return energy\n\ndef main():\n    # Read input values\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    # Process each query\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            update_illusion_rate(u, c, illusion_rates)\n        elif query[0] == 2:\n            _, u, v = query\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass MazeSolver:\n    def __init__(self, n: int, illusion_rates: List[int], tree: List[List[int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.tree = tree\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.segment_tree = [0] * (4 * n)\n        self.build_tree()\n        self.build_segment_tree(1, 1, n)\n\n    def build_tree(self):\n        \"\"\"Builds the parent and depth arrays using DFS.\"\"\"\n        def dfs(node: int, parent: int, depth: int):\n            self.parent[node] = parent\n            self.depth[node] = depth\n            for neighbor in self.tree[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node, depth + 1)\n\n        dfs(1, -1, 0)\n\n    def build_segment_tree(self, node: int, start: int, end: int):\n        \"\"\"Builds the segment tree for efficient updates.\"\"\"\n        if start == end:\n            self.segment_tree[node] = self.illusion_rates[start - 1]\n        else:\n            mid = (start + end) // 2\n            self.build_segment_tree(2 * node, start, mid)\n            self.build_segment_tree(2 * node + 1, mid + 1, end)\n            self.segment_tree[node] = max(self.segment_tree[2 * node], self.segment_tree[2 * node + 1])\n\n    def update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int):\n        \"\"\"Updates the segment tree with a new illusion rate.\"\"\"\n        if start == end:\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update_segment_tree(2 * node, start, mid, idx, value)\n            else:\n                self.update_segment_tree(2 * node + 1, mid + 1, end, idx, value)\n            self.segment_tree[node] = max(self.segment_tree[2 * node], self.segment_tree[2 * node + 1])\n\n    def query_segment_tree(self, node: int, start: int, end: int, L: int, R: int) -> int:\n        \"\"\"Queries the segment tree for the maximum illusion rate in a range.\"\"\"\n        if R < start or end < L:\n            return float('-inf')\n        if L <= start and end <= R:\n            return self.segment_tree[node]\n        mid = (start + end) // 2\n        left_query = self.query_segment_tree(2 * node, start, mid, L, R)\n        right_query = self.query_segment_tree(2 * node + 1, mid + 1, end, L, R)\n        return max(left_query, right_query)\n\n    def update_illusion_rate(self, room: int, new_rate: int):\n        \"\"\"Updates the illusion rate of a specific room.\"\"\"\n        self.illusion_rates[room - 1] = new_rate\n        self.update_segment_tree(1, 1, self.n, room, new_rate)\n\n    def min_energy_path(self, u: int, v: int) -> int:\n        \"\"\"Calculates the minimum energy path between two rooms.\"\"\"\n        def lca(u: int, v: int) -> int:\n            \"\"\"Finds the Lowest Common Ancestor of two nodes.\"\"\"\n            if self.depth[u] < self.depth[v]:\n                u, v = v, u\n            while self.depth[u] > self.depth[v]:\n                u = self.parent[u]\n            while u != v:\n                u = self.parent[u]\n                v = self.parent[v]\n            return u\n\n        ancestor = lca(u, v)\n        energy = 0\n        while u != ancestor:\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[self.parent[u] - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[self.parent[u] - 1]))\n            u = self.parent[u]\n        while v != ancestor:\n            energy += max(abs(self.illusion_rates[v - 1] + self.illusion_rates[self.parent[v] - 1]),\n                          abs(self.illusion_rates[v - 1] - self.illusion_rates[self.parent[v] - 1]))\n            v = self.parent[v]\n        return energy\n\ndef main():\n    n, q = map(int, input().split())\n    illusion_rates = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s, t = map(int, input().split())\n        tree[s].append(t)\n        tree[t].append(s)\n\n    solver = MazeSolver(n, illusion_rates, tree)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            _, u, c = query\n            solver.update_illusion_rate(u, c)\n        elif query[0] == 2:\n            _, u, v = query\n            result = solver.min_energy_path(u, v)\n            print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe main challenge is to efficiently handle both types of queries, especially given the constraints on n and q. The tree structure allows for efficient traversal, but updating and querying must be optimized to handle the maximum input sizes. The energy calculation based on illusion rates requires careful management of absolute values and maximum operations.\nrequirement pool:\n- Efficiently handle type 2 queries to find minimum energy paths.\n- Implement fast updates for type 1 queries to change illusion rates.\n- Optimize data structures to manage large input sizes.\n- Ensure the solution is robust against edge cases and invalid inputs.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree and finding paths, while Segment Tree will allow us to update and query the illusion rates efficiently. This approach leverages the tree structure to optimize pathfinding and updates.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to changing room attributes and calculating energy requirements. The solution must handle large input sizes and ensure quick response times while maintaining accuracy.\nrequirement pool:\n- Efficient query processing for changing room attributes\n- Accurate calculation of energy requirements between rooms\n- Handling large input sizes without performance degradation\n- Robust solution to ensure reliability\n- User-friendly interface for input and output\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate the path energy, while Segment Tree will allow us to update and query the illusion rates efficiently.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and fast computation of minimum energy paths. The tree structure of the maze allows for efficient traversal algorithms, and the constraints on illusion rates and query types ensure predictable input handling.\nrequirement pool:\n- Implement efficient data structures for maze representation\n- Develop algorithms for quick illusion rate updates\n- Create a method for calculating minimum energy paths\n- Ensure robustness against invalid input formats\n- Optimize for large input sizes and query counts\nWe will use a tree data structure to represent the maze, leveraging adjacency lists for efficient traversal. For handling queries, we will use Depth First Search (DFS) to compute paths and update illusion rates. The use of DFS ensures that we can efficiently calculate the minimum energy path between rooms. We will also use a dictionary to store and update the illusion rates quickly.\n", "requirement analysis:\nThe solution must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and accurate energy calculations for room transitions. The tree structure of the maze allows for optimized traversal algorithms.\nrequirement pool:\n- Implement efficient query processing for type 1 and type 2 queries\n- Ensure accurate energy calculation using the given formula\n- Optimize data structures to handle large input sizes\n- Provide clear output format as specified\n- Consider edge cases and validate input data\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to quickly find the path between any two nodes. We will also use a Segment Tree to handle the updates of the illusion rates efficiently.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring that updates to room properties and path calculations are performed in optimal time. The tree structure of the maze allows for efficient traversal algorithms, and the dynamic nature of the queries requires a robust data structure to manage updates and queries seamlessly.\nrequirement pool:\n- Implement efficient pathfinding algorithm for tree structures.\n- Develop a system to handle dynamic updates to room properties.\n- Optimize for large input sizes to ensure performance.\n- Create a user-friendly interface for input and output.\n- Include error handling for invalid inputs.\nWe will use Depth First Search (DFS) to traverse the tree structure efficiently. For handling dynamic updates and queries, we will utilize a Segment Tree or Fenwick Tree (Binary Indexed Tree) to manage the illusion rates and calculate the minimum energy path efficiently. This approach ensures optimal performance for both updates and path calculations.\n", "requirement analysis:\nThe requirements focus on efficiently handling queries related to changing room properties and calculating energy costs between rooms. The solution must be robust enough to handle large input sizes and ensure quick response times for each query.\nrequirement pool:\n- Efficient query processing for room property changes\n- Accurate calculation of energy requirements between rooms\n- Handling large input sizes without performance degradation\n- Ensuring the solution is robust and error-free\n- Providing clear output format for energy calculations\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate the path energy, while Segment Tree will allow us to update and query the illusion rates efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to changing room properties and calculating energy requirements for moving between rooms. The solution must handle large input sizes and ensure accurate calculations.\nrequirement pool:\n- Efficient query processing for room property changes\n- Accurate energy calculation for room transitions\n- Handle large input sizes effectively\n- Ensure robustness and reliability of the solution\n- Optimize for quick response times\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to calculate paths, while Segment Tree will allow us to update and query the illusion rates efficiently.\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree structure representing a maze with dynamic updates to room properties and path queries. The main challenge is to ensure that the solution can handle up to 100,000 rooms and queries efficiently, given the constraints on illusion rates and energy calculations.\nrequirement pool:\n- Efficiently process type 1 queries to update room illusion rates.\n- Accurately compute the minimum energy path for type 2 queries.\n- Optimize data structures to handle large input sizes.\n- Ensure robustness and handle edge cases in input data.\n- Provide detailed error messages for invalid inputs.\nWe will use a combination of Depth First Search (DFS) and Segment Tree to efficiently handle the queries. DFS will help in traversing the tree structure to compute paths, while Segment Tree will allow us to update and query the illusion rates efficiently. This approach ensures that both types of queries are handled in logarithmic time, which is crucial given the constraints.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring that updates to illusion rates and energy calculations are processed swiftly. The tree structure of the maze allows for efficient traversal algorithms, which should be leveraged to minimize energy calculations. The solution should be robust to handle edge cases and invalid inputs gracefully.\nrequirement pool:\n- Implement efficient data structures for room and tunnel management.\n- Develop algorithms to quickly update and calculate energy requirements.\n- Ensure the system can handle the maximum input size without performance issues.\n- Create a user-friendly interface for input and output operations.\n- Add visualization features for better user understanding of the maze.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in preprocessing the tree to calculate the necessary paths, and the LCA will be used to quickly find the path between any two nodes. We will also use a Segment Tree to handle updates to the illusion rates efficiently.\n", "requirement analysis:\nThe system must efficiently handle up to 100,000 rooms and queries, ensuring quick updates to illusion rates and fast calculation of minimum energy paths. The tree structure of the maze allows for efficient traversal algorithms, and the absolute value calculations for energy ensure robustness in handling large numbers.\nrequirement pool:\n- Efficiently update illusion rates for rooms\n- Calculate minimum energy paths between rooms\n- Handle large input sizes without performance degradation\n- Ensure accurate calculations for all queries\n- Provide user-friendly error messages for invalid inputs\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure of the maze. This will allow us to quickly compute the minimum energy path between any two rooms. We will also use a Segment Tree or Fenwick Tree to handle updates to the illusion rates efficiently. The use of these data structures ensures that both update and query operations are performed in logarithmic time, which is crucial given the constraints.\n"], "scores": [], "pass_results": [false, true, true, true, true, false, false, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 554, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "add_1_sentence_at_end", "parent_index": 344}
