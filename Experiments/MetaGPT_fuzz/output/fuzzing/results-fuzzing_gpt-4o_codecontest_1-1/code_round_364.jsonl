{"name": "1579_B. Shifting Sort", "description": "The new generation external memory contains an array of integers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n].\n\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\n\nTechnically, each cyclic shift consists of two consecutive actions: \n\n  1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. \n  2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. \n\n\n\nFor example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5].\n\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "tags": ["implementation", "sortings"], "difficulty": 8, "id": 1579, "sample_io": [{"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}], "test_list": [{"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 4 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 2 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 6 1 4 3\n", "output": ["0\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 2 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n2 3 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 6 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 0 5\n5\n2 10 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 4 1 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 6 0 5\n5\n2 10 2 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 1\n4\n1 4 0 3\n5\n0 5 1 4 0\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 2 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 4 0 5\n5\n2 3 1 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n4 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 4 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 3 1\n4\n2 13 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n2 13 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 0 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 0 -1 1 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 4\n5\n2 8 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 2 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n-1 2 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 4 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 1 8 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 2 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 0\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n4 3 0\n4\n0 6 1 3\n5\n2 3 1 4 3\n", "output": ["1\n1 2 1\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 0 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n0\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 0 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 0\n3\n2 4 0\n4\n0 15 1 0\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 4 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n0 5 1 4 11\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 1 0 5\n5\n2 3 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n2 3 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 8 -1 3\n5\n0 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n1 9 1 3\n5\n1 5 2 4 0\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 5 4\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n4 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n2 4 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n1 28 -1 4 5\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n0 2 -1 3\n5\n2 0 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n1 3 2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 4 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 4 0 3\n5\n0 10 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n4 1\n3\n1 5 0\n4\n0 6 1 3\n5\n2 5 1 7 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 8 1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 4 1\n4\n2 4 0 5\n5\n2 10 2 4 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 2 1 3\n5\n4 5 1 0 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n4 5 1 6 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 6 5\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n2 7 0 5\n5\n2 10 2 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n4 2\n3\n0 2 0\n4\n-1 2 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n2 3 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 7 0 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n0 4 0\n4\n0 9 0 3\n5\n1 6 2 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 1 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["0\n0\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 0\n4\n0 0 1 3\n5\n2 5 0 4 3\n", "output": ["0\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 8 1 3\n5\n4 5 1 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n0 1\n3\n1 4 0\n4\n0 2 1 3\n5\n4 5 1 0 3\n", "output": ["0\n1\n1 3 2\n1\n2 3 1\n3\n1 4 3\n2 4 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n1 5 1 6 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n0 4 -1\n4\n-1 6 1 3\n5\n0 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 1 -1 3\n5\n0 5 0 8 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 2 2 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n0\n0\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 1\n3\n1 2 0\n4\n0 0 1 3\n5\n2 5 0 6 3\n", "output": ["0\n1\n1 3 2\n0\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n3 1\n3\n1 2 2\n4\n0 8 1 3\n5\n4 5 1 8 3\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n2\n1 3 2\n2 5 3\n"]}, {"input": "4\n2\n2 1\n3\n-2 2 0\n4\n3 8 1 6\n5\n2 5 1 6 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 1 3\n5\n2 0 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 5 1 5 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 5 4\n2 4 2\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n2 4 -1 0\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n2 4 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 2 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 6\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 6 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 2 -1\n4\n2 4 1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n0 4 0\n4\n0 6 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 2 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 1 0\n4\n0 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n2\n1 3 2\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 9 2 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 0 3\n5\n1 8 2 4 1\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 1\n4\n4 18 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n2 4 2\n1\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 1 2\n4\n2 18 -1 3\n5\n0 -1 1 4 3\n", "output": ["1\n1 2 1\n0\n2\n1 3 2\n3 4 1\n2\n1 2 1\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 0\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 2 8 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 0 3\n5\n2 5 1 4 6\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n0 4 -1 4\n5\n2 5 1 8 3\n", "output": ["0\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 1\n3\n1 4 1\n4\n0 2 1 3\n5\n2 5 1 0 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n2 3 1\n3\n1 4 3\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 -1 3\n5\n2 5 1 8 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n2 3 1\n2\n1 3 2\n3 5 2\n"]}, {"input": "4\n2\n2 -1\n3\n2 1 3\n4\n1 18 -1 3\n5\n0 0 1 4 3\n", "output": ["1\n1 2 1\n1\n1 2 1\n2\n1 3 2\n3 4 1\n1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 2\n4\n2 4 2 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n0\n2\n2 3 1\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 2 0 3\n5\n0 10 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n3\n2 5 3\n3 4 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 0 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 1\n4\n1 4 2 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n2 4 0 3\n5\n2 10 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 3 0\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 0\n4\n0 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n1 4 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 1\n4\n1 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n4 1\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 4 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 8 1 6\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 1 1\n4\n2 4 -1 5\n5\n2 6 1 4 3\n", "output": ["1\n1 2 1\n0\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 0\n4\n2 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 1\n4\n0 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n0 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 0\n4\n1 4 -1 2\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 4 0\n4\n0 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 3 1\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n0 2 1\n4\n0 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 4 1\n4\n2 4 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 -1\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 4 -1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 4\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 6\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n0 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n1 2 1\n4\n1 7 0 3\n5\n2 5 1 4 0\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 5 4\n2 4 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 5 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n1 2\n3\n1 2 0\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 4 0\n4\n0 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n2 8 1 6\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 2\n3\n1 2 -1\n4\n1 4 -1 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 4 0\n4\n-1 6 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n2 4 0\n4\n-1 0 0 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n0\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n0 2 0\n4\n-1 11 1 3\n5\n2 5 1 4 3\n", "output": ["0\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 0\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 2\n3\n0 2 0\n4\n2 4 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 4 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 4\n3\n1 2 0\n4\n2 4 0 4\n5\n2 5 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n2 4 1 4\n5\n2 5 1 4 11\n", "output": ["1\n1 2 1\n1\n2 3 1\n1\n1 3 2\n2\n1 3 2\n3 4 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 4\n5\n2 9 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 0\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 9 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 0\n3\n2 3 0\n4\n0 6 1 3\n5\n1 5 1 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 1\n3\n1 2 1\n4\n0 7 1 3\n5\n2 0 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n1 2 1\n2 3 1\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n-1 2 0\n4\n-1 6 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -2\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 -1\n4\n0 15 1 3\n5\n1 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n2 8 -1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 2\n3\n1 2 -1\n4\n2 4 -1 6\n5\n2 9 1 4 3\n", "output": ["0\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 9 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 1\n3\n-1 2 0\n4\n-1 12 1 3\n5\n0 5 1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n1 9 1 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 -2\n3\n2 4 0\n4\n-1 8 1 3\n5\n2 5 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 4 -1\n4\n0 15 1 3\n5\n1 5 1 4 2\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n1 2 0\n4\n2 3 1 3\n5\n2 9 1 4 3\n", "output": ["1\n1 2 1\n1\n1 3 2\n1\n1 3 2\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n2 -1\n3\n1 2 1\n4\n1 4 -1 3\n5\n2 14 -1 4 3\n", "output": ["1\n1 2 1\n1\n2 3 1\n2\n1 3 2\n3 4 1\n3\n1 3 2\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n0 1\n3\n2 4 0\n4\n0 9 0 3\n5\n1 5 2 4 3\n", "output": ["0\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}, {"input": "4\n2\n3 0\n3\n2 6 -1\n4\n0 15 1 3\n5\n1 5 1 4 2\n", "output": ["1\n1 2 1\n1\n1 3 2\n2\n2 3 1\n3 4 1\n3\n2 3 1\n3 5 2\n4 5 1\n"]}], "task_id": "codecontest/14", "prompt": "The latest external memory design contains a sequence of numbers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n]. This type of memory does not support changing the value of an arbitrary element, instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. 2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "repair_prompt": ["The latest external memory design contains a sequence of numbers a[1 \u2026 n] = [a_1, a_2, \u2026, a_n]. This type of memory does not support changing the value of an arbitrary element, instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: 1. You may select arbitrary indices l and r (1 \u2264 l < r \u2264 n) as the boundaries of the segment. 2. Then you replace the segment a[l \u2026 r] with it's cyclic shift to the left by an arbitrary offset d. The concept of a cyclic shift can be also explained by following relations: the sequence [1, 4, 1, 3] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 1 and the sequence [4, 1, 3, 1] is a cyclic shift of the sequence [3, 1, 4, 1] to the left by the offset 2. For example, if a = [1, \\color{blue}{3, 2, 8}, 5], then choosing l = 2, r = 4 and d = 2 yields a segment a[2 \u2026 4] = [3, 2, 8]. This segment is then shifted by the offset d = 2 to the left, and you get a segment [8, 3, 2] which then takes the place of of the original elements of the segment. In the end you get a = [1, \\color{blue}{8, 3, 2}, 5]. Sort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sort arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of actions and a list of actions to sort the array.\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        actions = []\n        sorted_array = sorted(array)\n\n        if array == sorted_array:\n            results.append((0, actions))\n            continue\n\n        # Implement a simple strategy to sort the array using cyclic shifts\n        for i in range(n - 1):\n            if array[i] > array[i + 1]:\n                # Find the smallest element in the unsorted part\n                min_index = i + 1\n                for j in range(i + 1, n):\n                    if array[j] < array[min_index]:\n                        min_index = j\n\n                # Perform a cyclic shift to bring the smallest element to the correct position\n                if min_index > i + 1:\n                    actions.append((i + 1, min_index + 1, min_index - i))\n                    segment = array[i:min_index + 1]\n                    offset = min_index - i\n                    shifted_segment = segment[offset:] + segment[:offset]\n                    array[i:min_index + 1] = shifted_segment\n\n        results.append((len(actions), actions))\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append((n, array))\n\n    results = sort_with_cyclic_shifts(t, test_cases)\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(*action)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef cyclic_shift_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of actions and a list of actions to sort the array.\n    \"\"\"\n    results = []\n    \n    for n, array in test_cases:\n        actions = []\n        sorted_array = sorted(array)\n        \n        if array == sorted_array:\n            results.append((0, actions))\n            continue\n        \n        # Simple strategy: perform cyclic shifts to move the smallest unsorted element to its correct position\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the correct position of the current element\n                correct_pos = sorted_array.index(array[i])\n                \n                # Perform a cyclic shift to move the element to its correct position\n                if correct_pos > i:\n                    # Calculate the offset for the cyclic shift\n                    offset = correct_pos - i\n                    # Perform the cyclic shift\n                    segment = array[i:correct_pos+1]\n                    shifted_segment = segment[offset:] + segment[:offset]\n                    array[i:correct_pos+1] = shifted_segment\n                    actions.append((i+1, correct_pos+1, offset))\n        \n        results.append((len(actions), actions))\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append((n, array))\n\n# Output interface\nresults = cyclic_shift_sort(t, test_cases)\nfor k, actions in results:\n    print(k)\n    for l, r, d in actions:\n        print(l, r, d)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef cyclic_shift_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts and returns the number of shifts and details of each shift.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing the length of the array and the array itself.\n\n    Returns:\n        List[Tuple[int, List[Tuple[int, int, int]]]]: List of results for each test case, each containing the number of shifts and the details of each shift.\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        actions = []\n        sorted_a = sorted(a)\n\n        if a == sorted_a:\n            results.append((0, actions))\n            continue\n\n        # Implement a simple sorting using cyclic shifts\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the correct position of the current element\n                correct_pos = a.index(sorted_a[i], i)\n                # Perform cyclic shift\n                if correct_pos > i:\n                    # Calculate the offset for cyclic shift\n                    offset = correct_pos - i\n                    # Perform the cyclic shift\n                    a[i:correct_pos+1] = a[i+offset:correct_pos+1] + a[i:i+offset]\n                    actions.append((i+1, correct_pos+1, offset))\n\n        results.append((len(actions), actions))\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Output interface\n    results = cyclic_shift_sort(t, test_cases)\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(' '.join(map(str, action)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef cyclic_shift_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of actions and a list of actions to sort the array.\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        actions = []\n        sorted_array = sorted(array)\n\n        if array == sorted_array:\n            results.append((0, actions))\n            continue\n\n        # Implement a simple strategy to sort the array using cyclic shifts\n        for i in range(n - 1):\n            if array[i] > array[i + 1]:\n                # Find the segment to shift\n                l = i + 1\n                r = n\n                d = 1\n\n                # Perform the cyclic shift\n                segment = array[l - 1:r]\n                shifted_segment = segment[d:] + segment[:d]\n                array[l - 1:r] = shifted_segment\n\n                # Record the action\n                actions.append((l, r, d))\n\n        results.append((len(actions), actions))\n\n    return results\n\n# Input interface\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append((n, array))\n\n# Call the function and get the result\nresults = cyclic_shift_sort(t, test_cases)\n\n# Output interface\nfor result in results:\n    k, actions = result\n    print(k)\n    for action in actions:\n        print(action[0], action[1], action[2])\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts and returns the operations performed.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of operations and a list of operations.\n        Each operation is represented as a tuple (l, r, d).\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        actions = []\n        sorted_a = sorted(a)\n\n        if a == sorted_a:\n            results.append((0, []))\n            continue\n\n        # Simple strategy: perform cyclic shifts to sort the array\n        for i in range(n):\n            if a[i] != sorted_a[i]:\n                # Find the correct position of the current element\n                correct_pos = a.index(sorted_a[i], i)\n                if correct_pos != i:\n                    # Perform a cyclic shift\n                    l = i + 1\n                    r = correct_pos + 1\n                    d = r - l\n                    a[l-1:r] = a[l-1+d:r] + a[l-1:l-1+d]\n                    actions.append((l, r, d))\n\n        results.append((len(actions), actions))\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Output interface\n    results = sort_with_cyclic_shifts(t, test_cases)\n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sort arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of actions and a list of actions (l, r, d).\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        actions = []\n        sorted_array = sorted(array)\n\n        # If the array is already sorted, no actions are needed\n        if array == sorted_array:\n            results.append((0, actions))\n            continue\n\n        # Perform cyclic shifts to sort the array\n        for i in range(n):\n            if array[i] != sorted_array[i]:\n                # Find the position of the correct element\n                correct_pos = array.index(sorted_array[i], i)\n                # Perform a cyclic shift\n                l = i + 1\n                r = correct_pos + 1\n                d = r - l\n                array[l-1:r] = array[l-1:r][d:] + array[l-1:r][:d]\n                actions.append((l, r, d))\n\n        results.append((len(actions), actions))\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append((n, array))\n\n    results = sort_with_cyclic_shifts(t, test_cases)\n    for k, actions in results:\n        print(k)\n        for l, r, d in actions:\n            print(l, r, d)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport typing\n\ndef cyclic_shift_sort(t: int, test_cases: typing.List[typing.Tuple[int, typing.List[int]]]) -> typing.List[typing.Tuple[int, typing.List[typing.Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of actions and a list of actions.\n        Each action is represented as a tuple (l, r, d).\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        actions = []\n        sorted_array = sorted(array)\n\n        # If the array is already sorted, no actions are needed\n        if array == sorted_array:\n            results.append((0, actions))\n            continue\n\n        # Simple approach: perform cyclic shifts to sort the array\n        for i in range(n - 1):\n            if array[i] > array[i + 1]:\n                # Find the segment to shift\n                l = i + 1\n                r = n\n                d = 1\n\n                # Perform the cyclic shift\n                segment = array[l - 1:r]\n                shifted_segment = segment[d:] + segment[:d]\n                array[l - 1:r] = shifted_segment\n\n                # Record the action\n                actions.append((l, r, d))\n\n        # Append the result for the current test case\n        results.append((len(actions), actions))\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append((n, array))\n\n    results = cyclic_shift_sort(t, test_cases)\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(action[0], action[1], action[2])\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef cyclic_shift_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts each test case array using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of actions and a list of actions (l, r, d).\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        actions = []\n        sorted_a = sorted(a)\n\n        if a == sorted_a:\n            results.append((0, []))\n            continue\n\n        # We will perform at most n cyclic shifts\n        for i in range(n):\n            if a == sorted_a:\n                break\n\n            # Find the first element that is out of order\n            for j in range(n - 1):\n                if a[j] > a[j + 1]:\n                    # Perform a cyclic shift to correct the order\n                    l = j + 1\n                    r = n\n                    d = 1\n                    a = a[:l-1] + a[l-1+1:r] + a[l-1:l-1+1] + a[r:]\n                    actions.append((l, r, d))\n                    break\n\n        results.append((len(actions), actions))\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Call the function\n    results = cyclic_shift_sort(t, test_cases)\n\n    # Output interface\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(f\"{action[0]} {action[1]} {action[2]}\")\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef sort_with_cyclic_shifts(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, List[Tuple[int, int, int]]]]:\n    \"\"\"Sorts arrays using cyclic shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of actions and a list of actions.\n        Each action is represented as a tuple (l, r, d).\n    \"\"\"\n    results = []\n\n    for n, a in test_cases:\n        actions = []\n        sorted_a = sorted(a)\n\n        if a == sorted_a:\n            results.append((0, actions))\n            continue\n\n        # Implement a simple sorting using cyclic shifts\n        for i in range(n - 1):\n            if a[i] > a[i + 1]:\n                # Find the smallest element in the unsorted part\n                min_index = i + 1\n                for j in range(i + 1, n):\n                    if a[j] < a[min_index]:\n                        min_index = j\n\n                # Perform cyclic shift to bring the smallest element to the correct position\n                if min_index != i + 1:\n                    l = i + 1\n                    r = min_index + 1\n                    d = r - l\n                    a[l-1:r] = a[l-1:r][d:] + a[l-1:r][:d]\n                    actions.append((l, r, d))\n\n        results.append((len(actions), actions))\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append((n, a))\n\n    # Call the function\n    results = sort_with_cyclic_shifts(t, test_cases)\n\n    # Output interface\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(f\"{action[0]} {action[1]} {action[2]}\")\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport typing\n\ndef sort_with_cyclic_shifts(\n    t: int, \n    test_cases: typing.List[typing.Tuple[int, typing.List[int]]]\n) -> typing.List[typing.Tuple[int, typing.List[typing.Tuple[int, int, int]]]]:\n    \"\"\"Sort arrays using cyclic shifts within the constraints of n shifts.\n\n    Args:\n        t: Number of test cases.\n        test_cases: List of tuples, each containing the length of the array and the array itself.\n\n    Returns:\n        A list of tuples, each containing the number of actions and a list of actions.\n        Each action is represented as a tuple (l, r, d) indicating the segment boundaries and the shift offset.\n    \"\"\"\n    results = []\n\n    for n, array in test_cases:\n        actions = []\n        sorted_array = sorted(array)\n\n        # If the array is already sorted, no actions are needed\n        if array == sorted_array:\n            results.append((0, actions))\n            continue\n\n        # Implement a simple strategy to sort the array using cyclic shifts\n        # This strategy does not guarantee the minimum number of shifts but ensures n or fewer shifts\n        for i in range(n - 1):\n            if array[i] > array[i + 1]:\n                # Find the smallest element in the unsorted part of the array\n                min_index = i + 1\n                for j in range(i + 1, n):\n                    if array[j] < array[min_index]:\n                        min_index = j\n\n                # Perform a cyclic shift to bring the smallest element to the correct position\n                if min_index > i + 1:\n                    # Calculate the offset for the cyclic shift\n                    offset = min_index - i\n                    # Perform the cyclic shift\n                    segment = array[i:min_index + 1]\n                    shifted_segment = segment[offset:] + segment[:offset]\n                    array[i:min_index + 1] = shifted_segment\n                    actions.append((i + 1, min_index + 1, offset))\n\n        results.append((len(actions), actions))\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append((n, array))\n\n    # Call the function and get the result\n    results = sort_with_cyclic_shifts(t, test_cases)\n\n    # Output results for each test case\n    for result in results:\n        k, actions = result\n        print(k)\n        for action in actions:\n            print(f\"{action[0]} {action[1]} {action[2]}\")\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on sorting arrays using cyclic shifts within a specified number of operations. The solution must handle multiple test cases and provide output in a specific format. Efficiency and clarity are key, with support for edge cases where arrays are already sorted.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure output format compliance\n- Support multiple test cases\n- Handle already sorted arrays efficiently\n- Optimize for performance within constraints\nWe will implement a function to sort arrays using cyclic shifts. The approach will involve identifying segments of the array that can be cyclically shifted to achieve a sorted order. We will use Python's list slicing and manipulation capabilities to perform the cyclic shifts efficiently. The solution will handle multiple test cases and provide output in the specified format. We will not use any external libraries as Python's built-in capabilities are sufficient for this task.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases efficiently and provide the correct output format. The focus is on using cyclic shifts rather than traditional sorting methods.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles up to 1000 test cases\n- Optimize for performance within given constraints\n- Provide clear output format for actions\n- Consider edge cases like already sorted arrays\nWe will implement a function that sorts arrays using cyclic shifts. The approach will involve identifying segments of the array that can be cyclically shifted to move elements into their correct positions. We will use Python's list slicing and manipulation capabilities to perform the cyclic shifts efficiently. The solution will handle multiple test cases and provide the correct output format.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases efficiently and provide outputs in the specified format. The focus is on ensuring the solution is scalable and can handle edge cases, such as already sorted arrays or arrays with repeated elements.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles multiple test cases efficiently\n- Provide clear and correct output format\n- Optimize for scalability and edge cases\n- Document the solution for user understanding\nWe will implement a function that sorts an array using cyclic shifts. The function will iterate over the array and perform cyclic shifts to move elements into their correct positions. We will use Python's list slicing to perform the cyclic shifts efficiently. The solution will handle multiple test cases and output the number of shifts and the details of each shift in the required format.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases efficiently and adhere to the input-output format strictly.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles up to 1000 test cases\n- Optimize for performance within given constraints\n- Maintain simplicity and readability of code\n- Provide detailed documentation and examples\nWe will implement a function that sorts arrays using cyclic shifts. The approach will involve identifying segments that can be shifted to bring elements into their correct positions. We will use Python's list slicing and manipulation capabilities to perform cyclic shifts efficiently. The solution will handle multiple test cases as specified and adhere to the input-output format strictly.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases and provide outputs in the specified format. The focus is on achieving the sorting using cyclic shifts without exceeding the number of allowed operations.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles multiple test cases\n- Optimize for performance and scalability\n- Maintain simplicity and readability of code\n- Provide detailed documentation and examples\nWe will implement a function that sorts an array using cyclic shifts. The function will iterate over the array and perform cyclic shifts to move elements into their correct positions. We will use a simple approach that ensures the number of shifts does not exceed the length of the array. The function will handle multiple test cases and output the results in the specified format. We will use Python's built-in list operations to perform the cyclic shifts efficiently.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases efficiently and adhere to the specified input-output format.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles up to 1000 test cases\n- Optimize for performance within n operations\n- Maintain simplicity in code structure\n- Provide clear documentation for the solution\nWe will implement a function to sort arrays using cyclic shifts. The approach will involve iterating through the array and performing cyclic shifts to move elements into their correct positions. We will use Python's list slicing capabilities to perform the cyclic shifts efficiently. The solution will handle multiple test cases as specified and ensure the output format is consistent with the requirements.\n", "requirement analysis:\nThe requirement is to sort an array using cyclic shifts within a given number of operations. The constraints allow for a maximum of n operations, where n is the length of the array. The solution should be able to handle multiple test cases efficiently and should not exceed the operation limit. The input and output formats are strict and must be adhered to.\nrequirement pool:\n- Implement the cyclic shift sorting algorithm.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm to use the least number of operations where possible.\n- Validate the solution against edge cases, including arrays with repeated elements.\n- Document the solution approach and edge case handling.\nWe will implement a function that sorts an array using cyclic shifts. The approach will involve identifying segments of the array that can be cyclically shifted to move elements into their correct positions. We will use a simple algorithm that performs at most n cyclic shifts, where n is the length of the array. The function will handle multiple test cases efficiently and adhere to the input/output format specified.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases efficiently and ensure that the number of shifts does not exceed the length of the array. The implementation should be straightforward and easy to understand.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles multiple test cases\n- Optimize for performance within given constraints\n- Provide clear output format as specified\n- Consider edge cases like already sorted arrays\nWe will implement a function that sorts an array using cyclic shifts. The function will iterate over the array and perform cyclic shifts to move elements into their correct positions. The approach will ensure that the number of shifts does not exceed the length of the array. We will use Python's list slicing capabilities to perform the cyclic shifts efficiently.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within a given number of operations. The solution should handle multiple test cases efficiently and adhere to the input-output format strictly. The focus is on achieving the sorting using cyclic shifts without minimizing the number of shifts.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles up to 1000 test cases\n- Optimize for performance within given constraints\n- Maintain code simplicity and readability\n- Provide detailed documentation and examples\nWe will implement a function that sorts an array using cyclic shifts. The approach involves iterating over the array and performing cyclic shifts to move elements into their correct positions. We will use Python's list slicing capabilities to perform the cyclic shifts efficiently. The solution will handle multiple test cases as specified, and we will ensure that the number of cyclic shifts does not exceed the length of the array for each test case.\n", "requirement analysis:\nThe requirement is to sort arrays using cyclic shifts within the constraints of n shifts. The solution should handle multiple test cases efficiently and provide output in the specified format. The focus is on ensuring the solution is scalable and optimized for performance.\nrequirement pool:\n- Implement cyclic shift sorting algorithm\n- Ensure solution handles up to 1000 test cases\n- Optimize for performance\n- Provide clear output format\n- Handle edge cases effectively\nWe will implement a function to sort arrays using cyclic shifts within the constraints of n shifts. The approach will involve identifying segments of the array that can be cyclically shifted to move elements into their correct positions. We will use Python's list slicing and manipulation capabilities to perform the cyclic shifts efficiently. The solution will handle multiple test cases and provide output in the specified format.\n"], "scores": [], "pass_results": [true, true, false, false, true, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 364, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe next 2t lines contain the descriptions of the test cases. \n\nThe first line of each test case description contains an integer n (2 \u2264 n \u2264 50) \u2014 the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 \u2264 a_i \u2264 10^9). Elements of array a may repeat and don't have to be unique.\n\nOutput\n\nPrint t answers to all input test cases. \n\nThe first line of the answer of each test case should contain an integer k (0 \u2264 k \u2264 n) \u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l r d\" (without quotes) where l and r (1 \u2264 l < r \u2264 n) are the boundaries of the segment being shifted, while d (1 \u2264 d \u2264 r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\n\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\n\nIf the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.\n\nIf there are several possible answers, you may print any of them.\n\nExample\n\nInput\n\n\n4\n2\n2 1\n3\n1 2 1\n4\n2 4 1 3\n5\n2 5 1 4 3\n\n\nOutput\n\n\n1\n1 2 1\n1\n1 3 2\n3\n2 4 1\n2 3 1\n1 3 2\n4\n2 4 2\n1 5 3\n1 2 1\n1 3 1\n\nNote\n\nExplanation of the fourth data set in the example: \n\n  1. The segment a[2 \u2026 4] is selected and is shifted to the left by 2: [2, \\color{blue}{5, 1, 4}, 3] \\longrightarrow [2, \\color{blue}{4, 5, 1}, 3] \n  2. The segment a[1 \u2026 5] is then selected and is shifted to the left by 3: [\\color{blue}{2, 4, 5, 1, 3}] \\longrightarrow [\\color{blue}{1, 3, 2, 4, 5}] \n  3. After that the segment a[1 \u2026 2] is selected and is shifted to the left by 1: [\\color{blue}{1, 3}, 2, 4, 5] \\longrightarrow [\\color{blue}{3, 1}, 2, 4, 5] \n  4. And in the end the segment a[1 \u2026 3] is selected and is shifted to the left by 1: [\\color{blue}{3, 1, 2}, 4, 5] \\longrightarrow [\\color{blue}{1, 2, 3}, 4, 5] ", "mutate_method": "condense_two2one", "parent_index": 177}
