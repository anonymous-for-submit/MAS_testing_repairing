{"name": "1607_C. Minimum Extraction", "description": "Yelisey has an array a of n integers.\n\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \n\n  1. First, Yelisei finds the minimal number m in the array. If there are several identical minima, Yelisey can choose any of them. \n  2. Then the selected minimal element is removed from the array. After that, m is subtracted from each remaining element. \n\n\n\nThus, after each operation, the length of the array is reduced by 1.\n\nFor example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0].\n\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\n\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\n\nHelp him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "tags": ["brute force", "sortings"], "difficulty": 9, "id": 1607, "sample_io": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}], "test_list": [{"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 2 0 -2 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["10\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 19 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n12\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 7\n2\n1 6\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n4\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n8\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 14\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n7\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 1\n5\n3 2 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 12\n2\n2 4\n5\n3 3 -5 -4 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n8\n2\n5\n2\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n3\n1\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -6 -1 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n5\n3\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -1 -1 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n5\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-2 2\n1\n-3\n", "output": ["10\n0\n2\n4\n2\n3\n4\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -1\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n1\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-1 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n2\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 12\n5\n3 2 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n10\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n0\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n2\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["8\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 0 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n2 18 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n11\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-1 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n0\n2\n4\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n6\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n1\n3\n3\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n2 2\n5\n3 3 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -4 -1 2\n2\n0 0\n1\n-2\n", "output": ["10\n0\n2\n5\n1\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 6\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 4\n5\n3 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n2\n4\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 0\n3\n0 3 -1\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n0\n3\n5\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 1\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n1\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n2 17 1 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n5\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n3\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 10 1 0\n2\n2 6\n5\n3 2 -1 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n2\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n4\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n2\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 7\n2\n2 4\n5\n3 3 -4 -2 1\n2\n-2 1\n1\n0\n", "output": ["10\n0\n2\n3\n2\n3\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["15\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 10 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n8\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n3 10 1 7\n2\n0 4\n5\n3 2 -4 0 -1\n2\n-2 2\n1\n-2\n", "output": ["10\n1\n2\n4\n4\n3\n4\n-2\n"]}, {"input": "8\n1\n7\n2\n0 -1\n3\n-2 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-4\n", "output": ["7\n1\n2\n8\n2\n2\n0\n-4\n"]}, {"input": "8\n1\n10\n2\n0 -2\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -7 -2 0\n2\n0 -1\n1\n0\n", "output": ["10\n2\n2\n8\n2\n5\n1\n0\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 14\n2\n2 1\n5\n0 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n1\n2\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n3 2 -4 -2 2\n2\n-2 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 1 0\n4\n2 10 1 7\n2\n2 6\n5\n3 4 -4 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n1\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n1\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 10 1 7\n2\n0 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n4\n4\n2\n-3\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n0 10 1 7\n2\n4 3\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["17\n0\n3\n6\n3\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 2\n1\n0\n", "output": ["10\n1\n2\n5\n2\n5\n3\n0\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n4 15 1 14\n2\n0 4\n5\n3 2 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n2\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 -1\n3\n0 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n1\n2\n5\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 18 1 -1\n2\n3 8\n5\n3 2 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["10\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n4\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n7\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 16 1 11\n2\n2 1\n5\n3 2 -1 -2 1\n2\n-1 2\n1\n-1\n", "output": ["18\n1\n2\n8\n1\n2\n3\n-1\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n2 2\n5\n3 1 -4 -1 1\n2\n-1 0\n1\n-1\n", "output": ["18\n1\n2\n7\n2\n3\n1\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n8\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -2 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n2\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 12\n2\n2 4\n5\n3 4 -4 -2 -1\n2\n1 2\n1\n-2\n", "output": ["10\n0\n2\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n12\n2\n0 -4\n3\n-1 2 0\n4\n2 10 1 0\n2\n2 4\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n0\n", "output": ["12\n4\n2\n8\n2\n2\n0\n0\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-2\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n5\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 0 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n3 10 1 10\n2\n1 3\n5\n3 4 -4 -2 -1\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n3\n7\n2\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 0\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n2\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n4\n2\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n4 10 0 7\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n4\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 4\n5\n4 3 0 -1 1\n2\n-1 1\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n3 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n4\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n0 0\n3\n-1 2 0\n4\n0 18 1 9\n2\n2 6\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["8\n0\n2\n9\n4\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n2 10 1 7\n2\n2 4\n5\n3 3 -4 -4 1\n2\n-1 0\n1\n0\n", "output": ["10\n0\n2\n5\n2\n5\n1\n0\n"]}, {"input": "8\n1\n19\n2\n0 0\n3\n-1 2 0\n4\n1 18 1 -1\n2\n3 6\n5\n6 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["19\n0\n2\n17\n3\n4\n0\n-2\n"]}, {"input": "8\n1\n18\n2\n-2 -1\n3\n-1 2 0\n4\n3 10 1 7\n2\n2 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n4\n2\n2\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n2 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n5\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 2 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n2\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n0\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 2 0\n4\n3 12 1 7\n2\n2 3\n5\n3 2 -4 -2 1\n2\n-1 2\n1\n-2\n", "output": ["14\n0\n2\n5\n2\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 10\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n8\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n2\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n2 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n6\n3\n3\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-1 2 0\n4\n2 4 1 4\n2\n2 6\n5\n5 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n2\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n17\n2\n-1 0\n3\n-1 2 -1\n4\n4 10 1 7\n2\n2 2\n5\n3 2 -4 0 -1\n2\n0 2\n1\n-3\n", "output": ["17\n1\n3\n3\n2\n3\n2\n-3\n"]}, {"input": "8\n1\n11\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 4\n5\n4 3 1 -3 1\n2\n-1 1\n1\n-2\n", "output": ["11\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 2 1\n4\n2 10 2 7\n2\n2 6\n5\n3 2 -4 -1 1\n2\n-1 0\n1\n-3\n", "output": ["10\n1\n1\n5\n4\n3\n1\n-3\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n2 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 0\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n2\n0\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 2 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n4\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-2 0 0\n4\n0 10 1 7\n2\n2 4\n5\n3 2 -4 -2 -1\n2\n0 2\n1\n-2\n", "output": ["10\n1\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 2 0\n4\n4 10 1 7\n2\n-1 4\n5\n3 2 -4 -4 -2\n2\n0 2\n1\n-3\n", "output": ["10\n0\n2\n3\n5\n4\n2\n-3\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 14\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n10\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n0\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 -1\n3\n-1 2 0\n4\n3 10 1 11\n2\n0 4\n5\n0 2 -4 -3 1\n2\n-1 2\n1\n-2\n", "output": ["18\n1\n2\n7\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n6\n2\n0 1\n3\n-1 2 -1\n4\n0 10 1 7\n2\n2 6\n5\n6 2 -8 -2 0\n2\n-1 1\n1\n-2\n", "output": ["6\n1\n3\n6\n4\n6\n2\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 10 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n10\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n2\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 2\n3\n-1 2 0\n4\n2 10 1 8\n2\n2 4\n5\n3 3 -4 -1 1\n2\n-1 1\n1\n-2\n", "output": ["10\n2\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 17 1 11\n2\n4 8\n5\n3 2 -4 -1 1\n2\n-1 2\n1\n-2\n", "output": ["10\n0\n2\n9\n4\n3\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 -2\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 -1\n3\n-1 2 0\n4\n2 2 1 0\n2\n1 6\n5\n3 2 -4 -2 1\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n2\n1\n5\n3\n1\n-2\n"]}, {"input": "8\n1\n14\n2\n0 0\n3\n-1 1 0\n4\n2 2 1 -1\n2\n3 6\n5\n3 2 -4 -2 -1\n2\n-1 -1\n1\n-2\n", "output": ["14\n0\n1\n2\n3\n3\n0\n-2\n"]}, {"input": "8\n1\n17\n2\n0 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 2\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n0\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-2\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-2\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -7 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n3\n2\n-2\n"]}, {"input": "8\n1\n8\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["8\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n10\n2\n-1 0\n3\n0 4 -2\n4\n2 10 1 7\n2\n2 1\n5\n3 1 -6 -1 2\n2\n-1 0\n1\n-2\n", "output": ["10\n1\n4\n5\n1\n5\n1\n-2\n"]}, {"input": "8\n1\n18\n2\n0 0\n3\n-1 1 0\n4\n3 11 1 20\n2\n2 0\n5\n3 2 -4 -2 1\n2\n-2 2\n1\n-1\n", "output": ["18\n0\n1\n9\n2\n3\n4\n-1\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 3\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 7\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n3\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 1 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n0 1\n3\n-1 2 0\n4\n6 10 2 7\n2\n3 4\n5\n3 1 -4 -2 -1\n2\n-1 2\n1\n-2\n", "output": ["10\n1\n2\n4\n3\n2\n3\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 6\n5\n5 0 -4 -2 2\n2\n0 1\n1\n-4\n", "output": ["0\n0\n2\n5\n4\n3\n1\n-4\n"]}, {"input": "8\n1\n10\n2\n0 0\n3\n-1 2 -1\n4\n4 15 1 12\n2\n0 4\n5\n3 1 -12 -4 -1\n2\n0 2\n1\n-2\n", "output": ["10\n0\n3\n8\n4\n8\n2\n-2\n"]}, {"input": "8\n1\n1\n2\n1 0\n3\n-1 2 -2\n4\n2 18 1 -1\n2\n3 8\n5\n3 1 -4 -1 0\n2\n-1 -1\n1\n-2\n", "output": ["1\n1\n3\n16\n5\n3\n0\n-2\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 1\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n2\n-2\n"]}, {"input": "8\n1\n10\n2\n1 0\n3\n-2 2 -1\n4\n2 17 0 7\n2\n1 6\n5\n3 4 -4 -2 0\n2\n-1 1\n1\n-2\n", "output": ["10\n1\n3\n10\n5\n3\n2\n-2\n"]}, {"input": "8\n1\n15\n2\n0 0\n3\n-1 2 0\n4\n3 6 1 12\n2\n2 4\n5\n3 2 -4 -2 1\n2\n-1 1\n1\n-2\n", "output": ["15\n0\n2\n6\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n0\n2\n0 0\n3\n-1 0 0\n4\n0 10 0 7\n2\n2 3\n5\n3 2 -4 -3 0\n2\n-1 1\n1\n-2\n", "output": ["0\n0\n1\n7\n2\n3\n2\n-2\n"]}, {"input": "8\n1\n17\n2\n1 0\n3\n-1 3 0\n4\n3 10 0 9\n2\n2 0\n5\n3 2 -4 -2 0\n2\n0 2\n1\n-4\n", "output": ["17\n1\n3\n6\n2\n2\n2\n-4\n"]}, {"input": "8\n1\n11\n2\n0 1\n3\n0 2 1\n4\n2 10 1 7\n2\n3 3\n5\n3 2 -4 0 0\n2\n-1 0\n1\n-2\n", "output": ["11\n1\n1\n5\n3\n4\n1\n-2\n"]}], "task_id": "codecontest/100", "prompt": "Yelisey possesses an array a composed of n integers. If a has length strictly greater than 1, then Yelisey can apply an operation called minimum extraction to it: First, Yelisei finds the minimal number m in the array and, if there are several identical minima, Yelisey can choose any of them; then the selected minimal element is removed from the array, and afterwards, m is subtracted from each remaining element, diminishing the length of the array by 1. For example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0]. Since Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible. Formally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1. Help him determine what maximum achievable value can the smallest element of the array reach after applying several (possibly, zero) minimum extraction operations to the array. Analyze the variations in the array across different operation sequences, as each sequence can lead to different final outcomes. Remember to account for negative numbers and zero values in the array during your analysis.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "repair_prompt": ["Yelisey possesses an array a composed of n integers. If a has length strictly greater than 1, then Yelisey can apply an operation called minimum extraction to it: First, Yelisei finds the minimal number m in the array and, if there are several identical minima, Yelisey can choose any of them; then the selected minimal element is removed from the array, and afterwards, m is subtracted from each remaining element, diminishing the length of the array by 1. For example, if a = [1, 6, -4, -2, -4], then the minimum element in it is a_3 = -4, which means that after this operation the array will be equal to a=[1 {- (-4)}, 6 {- (-4)}, -2 {- (-4)}, -4 {- (-4)}] = [5, 10, 2, 0]. Since Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible. Formally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1. Help him determine what maximum achievable value can the smallest element of the array reach after applying several (possibly, zero) minimum extraction operations to the array. Analyze the variations in the array across different operation sequences, as each sequence can lead to different final outcomes. Remember to account for negative numbers and zero values in the array during your analysis.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nimport heapq\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Convert the list into a min-heap\n        heapq.heapify(case)\n        \n        # Initialize the maximum possible minimum value\n        max_min_value = float('-inf')\n        \n        # Perform the minimum extraction operation\n        previous_min = 0\n        while len(case) > 1:\n            current_min = heapq.heappop(case)\n            max_min_value = max(max_min_value, current_min - previous_min)\n            previous_min = current_min\n        \n        # After the loop, check the last element in the heap\n        max_min_value = max(max_min_value, case[0] - previous_min)\n        \n        results.append(max_min_value)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case after\n    applying the minimum extraction operation.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the maximum possible minimum value.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the greedy approach.\n        case.sort()\n        \n        # Initialize the maximum possible minimum value.\n        max_minimum = case[0]\n        \n        # Iterate through the sorted array to find the maximum possible minimum.\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements.\n            difference = case[i] - case[i - 1]\n            # Update the maximum possible minimum value.\n            max_minimum = max(max_minimum, difference)\n        \n        results.append(max_minimum)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append(array)\n\n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: A list of integers representing the maximum possible minimum value for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the greedy approach\n        case.sort()\n        \n        # Initialize the maximum possible minimum\n        max_min = case[0]\n        \n        # Iterate through the sorted array to find the maximum possible minimum\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements\n            diff = case[i] - case[i - 1]\n            # Update the maximum possible minimum\n            max_min = max(max_min, diff)\n        \n        results.append(max_min)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum achievable minimum for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum achievable minimums for each test case.\n    \"\"\"\n    results = []\n    \n    for array in test_cases:\n        if len(array) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(array[0])\n            continue\n        \n        # Sort the array to facilitate the minimum extraction operation.\n        array.sort()\n        \n        # Initialize the maximum achievable minimum.\n        max_minimum = array[0]\n        \n        # Iterate through the sorted array to simulate the minimum extraction operation.\n        for i in range(1, len(array)):\n            # Calculate the difference between the current element and the previous minimum.\n            difference = array[i] - array[i - 1]\n            # Update the maximum achievable minimum.\n            max_minimum = max(max_minimum, difference)\n        \n        results.append(max_minimum)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append(array)\n    \n    results = maximize_minimum(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum achievable minimum for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum achievable minimums for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the minimum extraction operation.\n        case.sort()\n        \n        # Initialize the maximum achievable minimum with the first element.\n        max_minimum = case[0]\n        \n        # Iterate through the sorted array to calculate the maximum achievable minimum.\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements.\n            difference = case[i] - case[i - 1]\n            # Update the maximum achievable minimum.\n            max_minimum = max(max_minimum, difference)\n        \n        results.append(max_minimum)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Process the test cases and get results\n    results = maximize_minimum(t, test_cases)\n    \n    # Output interface\n    for result in results:\n        print(result)\n\n# Entry point for the program\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum possible minimum value for each test case after applying\n    the minimum extraction operation multiple times.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum possible minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the minimum extraction operation.\n        case.sort()\n        \n        # Initialize the maximum possible minimum value.\n        max_minimum = case[0]\n        \n        # Iterate through the sorted array and calculate the differences.\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements.\n            difference = case[i] - case[i - 1]\n            # Update the maximum possible minimum value.\n            max_minimum = max(max_minimum, difference)\n        \n        results.append(max_minimum)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum achievable minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum achievable minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the greedy approach.\n        case.sort()\n        \n        # Initialize the maximum minimum value.\n        max_min_value = case[0]\n        \n        # Perform the minimum extraction operation.\n        for i in range(1, len(case)):\n            # Calculate the difference between the current element and the previous minimum.\n            difference = case[i] - case[i - 1]\n            # Update the maximum minimum value.\n            max_min_value = max(max_min_value, difference)\n        \n        results.append(max_min_value)\n    \n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print the results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum achievable minimum for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results, each representing the maximum achievable minimum for the corresponding test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the minimum extraction process.\n        case.sort()\n        \n        # Initialize the maximum achievable minimum.\n        max_minimum = case[0]\n        \n        # Iterate through the sorted array and calculate the differences.\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements.\n            difference = case[i] - case[i - 1]\n            # Update the maximum achievable minimum.\n            max_minimum = max(max_minimum, difference)\n        \n        results.append(max_minimum)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    # Read number of test cases\n    t = int(input().strip())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        array = list(map(int, input().strip().split()))\n        test_cases.append(array)\n    \n    # Call the function and print the results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport heapq\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the maximum achievable minimum value for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of maximum achievable minimum values for each test case.\n    \"\"\"\n    results = []\n    \n    for array in test_cases:\n        if len(array) == 1:\n            # If the array length is 1, the operation cannot be applied.\n            results.append(array[0])\n            continue\n        \n        # Convert the array into a min-heap.\n        heapq.heapify(array)\n        \n        # Initialize the maximum minimum value.\n        max_minimum = float('-inf')\n        \n        # Perform the minimum extraction operation until the array length is 1.\n        while len(array) > 1:\n            # Extract the minimum element.\n            min_element = heapq.heappop(array)\n            \n            # Update the maximum minimum value.\n            max_minimum = max(max_minimum, min_element)\n            \n            # Subtract the minimum element from each remaining element.\n            for i in range(len(array)):\n                array[i] -= min_element\n            \n            # Re-heapify the array after modification.\n            heapq.heapify(array)\n        \n        # The last remaining element in the heap is the final minimum.\n        max_minimum = max(max_minimum, array[0])\n        \n        results.append(max_minimum)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append(array)\n\n# Output interface\nresults = maximize_minimum(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef maximize_minimum(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Maximize the minimum value in each test case array after performing\n    the minimum extraction operation.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results, each representing the maximum achievable minimum value\n                   for the corresponding test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        if len(case) == 1:\n            # If the array length is 1, the minimum extraction cannot be applied.\n            results.append(case[0])\n            continue\n        \n        # Sort the array to facilitate the greedy approach\n        case.sort()\n        \n        # Initialize the maximum minimum value\n        max_minimum = case[0]\n        \n        # Iterate through the sorted array and calculate the differences\n        for i in range(1, len(case)):\n            # Calculate the difference between consecutive elements\n            difference = case[i] - case[i - 1]\n            # Update the maximum minimum value\n            max_minimum = max(max_minimum, difference)\n        \n        results.append(max_minimum)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Process and output results\n    results = maximize_minimum(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires developing an algorithm that can efficiently determine the maximum possible minimum value of an array after applying a series of minimum extraction operations. The solution must handle multiple test cases and large input sizes, ensuring that the operations are performed optimally to achieve the desired outcome. Special attention should be given to edge cases, such as arrays with negative numbers or zeros, to ensure accuracy.\nrequirement pool:\n- Develop an efficient algorithm to handle up to 10^4 test cases.\n- Ensure the solution can process arrays with up to 2 \u22c5 10^5 elements.\n- Optimize the algorithm to handle negative numbers and zeros effectively.\n- Provide clear and concise output for each test case.\n- Document the solution to aid understanding and future maintenance.\nWe will implement a function that processes each test case independently. The function will iterate through the array, applying the minimum extraction operation and keeping track of the maximum possible minimum value. We will use a priority queue (min-heap) to efficiently find and remove the minimum element from the array. This approach ensures that the solution is efficient and can handle large inputs within the constraints.\n", "requirement analysis:\nThe task requires developing an algorithm that can efficiently determine the maximum possible minimum value of an array after applying a series of minimum extraction operations. The solution must handle up to 10,000 test cases with a total of up to 200,000 elements across all test cases. The algorithm should be optimized to handle large input sizes and edge cases, including negative numbers and zero values.\nrequirement pool:\n- Develop an efficient algorithm to maximize the minimum value in the array\n- Ensure the solution handles large input sizes within constraints\n- Provide clear and correct output for each test case\n- Optimize the solution for performance\n- Handle edge cases, such as arrays with negative numbers\nWe will use a greedy approach to solve the problem efficiently. The idea is to sort the array and then perform the minimum extraction operation iteratively, keeping track of the maximum possible minimum value. This approach ensures that we handle large input sizes within constraints and efficiently manage edge cases, including negative numbers.\n", "requirement analysis:\nThe problem requires finding the maximum possible minimum value of an array after applying a series of operations. The operations involve removing the minimum element and adjusting the remaining elements. The solution must efficiently handle up to 200,000 elements across multiple test cases, considering both positive and negative numbers.\nrequirement pool:\n- Develop an efficient algorithm to maximize the minimum value\n- Ensure the solution handles large input sizes within constraints\n- Optimize the algorithm for speed and accuracy\n- Provide clear documentation and output format\n- Consider edge cases and test thoroughly\nWe will use a greedy approach to solve the problem efficiently. The key idea is to sort the array and then calculate the maximum possible minimum by iteratively subtracting the smallest element from the rest of the array. This approach ensures that we maximize the minimum value by always removing the smallest element and adjusting the rest accordingly. We will use Python's built-in sorting capabilities to handle large inputs efficiently.\n", "requirement analysis:\nThe requirements focus on maximizing the minimum value in an array after applying a series of operations. The solution must efficiently handle multiple test cases and large arrays, ensuring accurate results even with negative numbers and zeros. The operation involves removing the minimum element and adjusting the remaining elements, which requires careful handling to achieve the desired outcome.\nrequirement pool:\n- Efficiently process large arrays and multiple test cases\n- Accurately compute the maximum achievable minimum\n- Optimize performance for negative numbers and zeros\n- Ensure robustness in handling edge cases\n- Provide clear output format for each test case\nWe will implement a function that processes each test case independently. The function will iterate through the array, applying the minimum extraction operation and keeping track of the maximum achievable minimum. We will use efficient sorting and iteration techniques to ensure performance across large datasets. The solution will handle negative numbers and zeros by carefully managing the subtraction operation.\n", "requirement analysis:\nThe task requires developing an algorithm that can efficiently perform the minimum extraction operation on arrays of integers, maximizing the minimum value achievable. The solution must handle multiple test cases, large arrays, and account for negative numbers and zeros. The algorithm should be optimized to run within the constraints provided, ensuring accurate results for each test case.\nrequirement pool:\n- Develop an efficient algorithm for minimum extraction operation\n- Ensure the solution handles large input sizes within constraints\n- Optimize the algorithm for arrays with negative numbers and zeros\n- Provide clear and accurate output for each test case\n- Test the solution against various edge cases\nWe will implement a function that processes each test case independently. For each array, we will sort the array and then calculate the maximum achievable minimum by iterating through the sorted array and computing the difference between consecutive elements. This approach ensures that we efficiently handle large arrays and account for negative numbers and zeros.\n", "requirement analysis:\nThe requirement involves processing multiple test cases to determine the maximum achievable minimum of an array after applying a specific operation. The operation involves removing the minimum element and subtracting it from the remaining elements. The solution must efficiently handle large arrays and multiple test cases, ensuring accurate results even with negative numbers and zero values.\nrequirement pool:\n- Efficiently process large arrays and multiple test cases\n- Accurately compute the maximum achievable minimum\n- Optimize performance for quick processing\n- Handle negative numbers and zero values correctly\n- Ensure robustness and handle edge cases\nWe will implement a function that processes each test case independently. For each test case, we will sort the array and then iteratively apply the minimum extraction operation, keeping track of the maximum possible minimum value. The sorting step ensures that we can efficiently find and remove the minimum element, and the subtraction operation is straightforward. We will use Python's built-in sorting and list operations to achieve this efficiently.\n", "requirement analysis:\nThe task requires developing an algorithm that can efficiently determine the maximum achievable minimum value in an array after applying a series of minimum extraction operations. The solution must handle multiple test cases and large input sizes, ensuring that the time complexity is kept within acceptable limits. Special attention should be given to edge cases, such as arrays with negative numbers or zeros.\nrequirement pool:\n- Develop an efficient algorithm to handle up to 10^4 test cases.\n- Ensure the solution can process arrays with up to 2 \u22c5 10^5 elements.\n- Optimize the algorithm to minimize time complexity.\n- Handle edge cases, including negative numbers and zeros.\n- Provide clear and concise output for each test case.\nWe will use a greedy approach to solve the problem efficiently. The key idea is to sort the array and then perform the minimum extraction operation in a way that maximizes the minimum value of the array. By sorting the array, we can easily track the changes in the minimum value as we perform the operations. This approach ensures that we handle large inputs efficiently and correctly manage edge cases such as negative numbers and zeros.\n", "requirement analysis:\nThe requirement involves processing multiple test cases to determine the maximum achievable minimum of an array after applying a specific operation. The operation involves removing the minimum element and subtracting it from the remaining elements. The solution must efficiently handle large arrays and multiple test cases, ensuring accurate results even with negative numbers and zero values.\nrequirement pool:\n- Implement efficient array processing for large datasets\n- Ensure accurate computation of maximum achievable minimum\n- Optimize performance for high number of test cases\n- Handle edge cases involving negative numbers and zeros\n- Provide clear input/output instructions\nWe will implement a function that processes each test case independently. For each test case, we will sort the array and then iteratively apply the minimum extraction operation, keeping track of the maximum achievable minimum. The sorting step ensures that we can efficiently find and remove the minimum element, and the subtraction operation is straightforward. We will use Python's built-in list and sorting functionalities to achieve this efficiently.\n", "requirement analysis:\nThe task involves determining the maximum achievable minimum value in an array after applying a series of operations. The operation involves removing the minimum element and subtracting it from the rest of the array. The challenge is to find the sequence of operations that maximizes the minimum value in the array. The solution must handle multiple test cases efficiently, considering constraints on the size and values of the array elements.\nrequirement pool:\n- Implement the minimum extraction operation efficiently.\n- Ensure the solution handles up to 10,000 test cases.\n- Optimize for large arrays with up to 200,000 elements in total.\n- Account for negative numbers and zero values in the array.\n- Provide clear and concise output for each test case.\nWe will implement a function that processes each test case independently. The function will iterate through the array, applying the minimum extraction operation efficiently using a priority queue (min-heap) to always access the smallest element quickly. This approach ensures that the solution is optimized for large arrays and handles negative numbers and zero values correctly.\n", "requirement analysis:\nThe requirement is to maximize the minimum value in an array after applying a series of operations. The operations involve removing the minimum element and subtracting it from the remaining elements. The solution must handle multiple test cases efficiently, considering constraints on array size and element values.\nrequirement pool:\n- Implement the minimum extraction operation efficiently.\n- Ensure the solution handles large input sizes within constraints.\n- Optimize the algorithm for arrays with negative numbers and zeros.\n- Provide clear and accurate output for each test case.\n- Test the solution against edge cases and maximum constraints.\nWe will use a greedy approach to solve the problem efficiently. The idea is to sort the array and then perform the minimum extraction operation iteratively. By sorting the array, we can easily access the minimum element and subtract it from the rest of the elements. This approach ensures that we maximize the minimum value in the array after performing the operations. We will use Python's built-in sorting capabilities to handle large input sizes efficiently.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 443, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases.\n\nThe next 2t lines contain descriptions of the test cases.\n\nIn the description of each test case, the first line contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the original length of the array a. The second line of the description lists n space-separated integers a_i (-10^9 \u2264 a_i \u2264 10^9) \u2014 elements of the array a.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer \u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\n\nExample\n\nInput\n\n\n8\n1\n10\n2\n0 0\n3\n-1 2 0\n4\n2 10 1 7\n2\n2 3\n5\n3 2 -4 -2 0\n2\n-1 1\n1\n-2\n\n\nOutput\n\n\n10\n0\n2\n5\n2\n2\n2\n-2\n\nNote\n\nIn the first example test case, the original length of the array n = 1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a_1 = 10.\n\nIn the second set of input data, the array will always consist only of zeros.\n\nIn the third set, the array will be changing as follows: [\\color{blue}{-1}, 2, 0] \u2192 [3, \\color{blue}{1}] \u2192 [\\color{blue}{2}]. The minimum elements are highlighted with \\color{blue}{blue}. The maximal one is 2.\n\nIn the fourth set, the array will be modified as [2, 10, \\color{blue}{1}, 7] \u2192 [\\color{blue}{1}, 9, 6] \u2192 [8, \\color{blue}{5}] \u2192 [\\color{blue}{3}]. Similarly, the maximum of the minimum elements is 5.", "mutate_method": "condense_two2one", "parent_index": 259}
