{"name": "1582_C. Grandma Capa Knits a Scarf", "description": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "tags": ["brute force", "data structures", "greedy", "strings", "two pointers"], "difficulty": 9, "id": 1582, "sample_io": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}], "test_list": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["3\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhhyhhyyky\n", "output": ["-1\n-1\n1\n3\n3\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyzxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabcaacba\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhkhhhy\n", "output": ["-1\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nxkhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxzxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrpparlar\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxxzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyyxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nyyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcbacaa\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabbaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabca\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyzyhhhhky\n", "output": ["2\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhhyky\n", "output": ["2\n1\n1\n3\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxzzxyy\n4\nbaba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwxz\n4\nbaba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n1\n1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyx\n4\nacbb\n8\nsakparpr\n10\nkyyyhhhhky\n", "output": ["2\n1\n-1\n-1\n4\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["-1\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\naabb\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n2\n-1\n4\n"]}, {"input": "5\n8\nabcaacba\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["0\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbcaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n-1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyx\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbabca\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzzyx\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n0\n0\n-1\n-1\n"]}, {"input": "5\n8\naacaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["-1\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["3\n1\n1\n3\n2\n"]}, {"input": "5\n8\naccabcaa\n6\nxyzxyy\n4\nabbc\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["3\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nacba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nbbcaacbb\n6\nzyxzyx\n4\nabba\n8\nroqarlap\n10\nykhxhhyyhk\n", "output": ["0\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyhyhyhhky\n", "output": ["2\n1\n1\n-1\n3\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhiyyhk\n", "output": ["-1\n2\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzxx\n4\nabbb\n8\nqprarlap\n10\nkhhyyhyhky\n", "output": ["2\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nbabb\n8\nrpqapkas\n10\njyyyhhhhky\n", "output": ["2\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nzzzxyx\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyxzyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhhyky\n", "output": ["3\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkgyyhhyhky\n", "output": ["3\n1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcabcba\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbabaadba\n6\nxyyxxy\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n3\n-1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nyzywyz\n4\nacda\n8\napqrrlap\n10\nykhxhhyyhk\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbabaadba\n6\nyxxxyx\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n1\n-1\n-1\n-1\n"]}, {"input": "5\n8\ncbabacbb\n6\nyyzyxx\n4\naabb\n8\nrpqarlap\n10\nkyyyhhhhkx\n", "output": ["3\n-1\n2\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhghhyyyk\n", "output": ["2\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n0\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyyhyhhk\n", "output": ["-1\n-1\n2\n-1\n3\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaslap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqpr\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbbaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nacba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrplarqap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\ncaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrpsarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlbp\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\npalraqps\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpparlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naaba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxghyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\njhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrpraqlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\naaba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbbcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nylhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykgk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyxxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\naaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nzxxzyw\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxzxxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\ncbcaaaab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqlraap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqaralp\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaaa\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqor\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabbb\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzzx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\npalrarpr\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nzywzxx\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nacba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nzyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nyhkyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqaalrp\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacba\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}], "task_id": "codecontest/30", "prompt": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, and Grandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome; she wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and will then erase some (at her choice, possibly none or all) occurrences of that letter in string s. She also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose. A string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "repair_prompt": ["Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, and Grandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome; she wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and will then erase some (at her choice, possibly none or all) occurrences of that letter in string s. She also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose. A string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make a string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum removals required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_letter(s: str, letter: str) -> int:\n        \"\"\"Calculate the minimum removals required to make the string a palindrome by removing a specific letter.\n\n        Args:\n            s (str): The string to process.\n            letter (str): The letter to remove.\n\n        Returns:\n            int: Minimum number of removals required, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == letter:\n                left += 1\n                removals += 1\n            elif s[right] == letter:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        min_removals = float('inf')\n        for letter in set(s):\n            removals = min_removals_for_letter(s, letter)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings to be processed.\n\n    Returns:\n        List[int]: List of minimum deletions required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a given string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum deletions required, or float('inf') if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                deletions += 1\n            elif s[right] == char:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')\n        \n        return deletions\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = min_deletions_for_char(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        results.append(min_deletions if min_deletions != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Call the function and print results\nresults = min_deletions_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[str]): A list of strings for each test case.\n\n    Returns:\n        List[int]: A list of integers representing the minimum number of deletions for each test case,\n                   or -1 if it's impossible to form a palindrome.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a given string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to consider for removal.\n\n        Returns:\n            int: The minimum number of deletions required, or float('inf') if not possible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                deletions += 1\n            elif s[right] == char:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')\n\n        return deletions\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = min_deletions_for_char(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        results.append(min_deletions if min_deletions != float('inf') else -1)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_deletions_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings to be processed.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_letter(s: str, letter: str) -> int:\n        \"\"\"Calculate the minimum removals required to make the string a palindrome by removing a specific letter.\n\n        Args:\n            s (str): The string to process.\n            letter (str): The letter to remove.\n\n        Returns:\n            int: Minimum number of removals, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == letter:\n                left += 1\n                removals += 1\n            elif s[right] == letter:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        min_removals = float('inf')\n        for letter in set(s):\n            removals = min_removals_for_letter(s, letter)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals required to make each string a palindrome\n    by removing occurrences of a single chosen letter.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string\n                                  and the string itself.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome\n        by removing occurrences of the specified character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome with this char\n\n        return removals\n\n    results = []\n    for _, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append((n, s))\n\n    # Output interface\n    results = min_removals_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_erase_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of characters to erase to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings to be processed.\n\n    Returns:\n        List[int]: List of minimum number of erasures required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals of a specific character to make the string a palindrome.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        min_removals = float('inf')\n        unique_chars = set(s)\n\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_erase_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erased_symbols(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of symbols to erase to make a string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum number of symbols to erase for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make a string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        min_removals = float('inf')\n        unique_chars = set(s)\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_erased_symbols(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples where each tuple contains the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum deletions required for each test case or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum deletions required or float('inf') if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                deletions += 1\n            elif s[right] == char:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')\n        \n        return deletions\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        min_deletions = float('inf')\n        unique_chars = set(s)\n\n        for char in unique_chars:\n            deletions = min_deletions_for_char(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        results.append(min_deletions if min_deletions != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_deletions_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum erasures required for each test case, or -1 if impossible.\n    \"\"\"\n    def can_form_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Check if a string can be transformed into a palindrome by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to check.\n            char_to_remove (str): The character to remove.\n\n        Returns:\n            int: Minimum number of erasures required, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        erasures = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                erasures += 1\n                left += 1\n            elif s[right] == char_to_remove:\n                erasures += 1\n                right -= 1\n            else:\n                return -1\n\n        return erasures\n\n    results = []\n\n    for n, s in test_cases:\n        unique_chars = set(s)\n        min_erasures = float('inf')\n\n        for char in unique_chars:\n            erasures = can_form_palindrome(s, char)\n            if erasures != -1:\n                min_erasures = min(min_erasures, erasures)\n\n        results.append(min_erasures if min_erasures != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_erasures_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_deletions_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings to be processed.\n\n    Returns:\n        List[int]: List of minimum deletions required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_deletions_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum deletions required to make the string a palindrome by removing a specific character.\n\n        Args:\n            s (str): The string to process.\n            char (str): The character to remove.\n\n        Returns:\n            int: Minimum deletions required, or float('inf') if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        deletions = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                deletions += 1\n            elif s[right] == char:\n                right -= 1\n                deletions += 1\n            else:\n                return float('inf')\n        \n        return deletions\n\n    results = []\n    for s in test_cases:\n        unique_chars = set(s)\n        min_deletions = float('inf')\n\n        for char in unique_chars:\n            deletions = min_deletions_for_char(s, char)\n            min_deletions = min(min_deletions, deletions)\n\n        if min_deletions == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_deletions)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_deletions_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum number of erasures needed to make a string a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with string lengths up to 100,000, ensuring the total number of characters across all test cases does not exceed 200,000. The output should be the minimum number of erasures or -1 if it's impossible to achieve a palindrome.\nrequirement pool:\n- Implement the main algorithm to determine the minimum erasures for palindrome.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm for performance improvements.\n- Provide clear and concise output for each test case.\n- Enhance user experience with detailed error messages if needed.\nWe will implement a function that checks if a string can be transformed into a palindrome by removing occurrences of a single chosen letter. The function will iterate over each possible letter and attempt to make the string a palindrome by removing occurrences of that letter. We will use a two-pointer technique to efficiently check for palindromes and count the number of removals required. If a palindrome can be formed, we will return the minimum number of removals; otherwise, we will return -1. This approach ensures that we handle large inputs efficiently within the given constraints.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions of a single character type to make a string a palindrome. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000. The algorithm should be optimized for time complexity to ensure quick execution.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions required.\n- Ensure the solution handles edge cases, such as already palindromic strings.\n- Optimize the solution for large input sizes.\n- Provide clear error messages for impossible cases.\n- Include detailed comments and documentation in the code.\nWe will iterate over each test case and for each string, try to make it a palindrome by choosing one character to remove. We will use a two-pointer technique to check if the string can be a palindrome by removing occurrences of a single character. If a mismatch is found, we will attempt to remove either the left or right character and check if the remaining string can be a palindrome. This approach ensures that we only remove the minimum number of characters necessary.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions of a single character type to make a string a palindrome. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000. The algorithm should consider all possible single character deletions and determine if a palindrome can be formed, returning the minimum deletions or -1 if impossible.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions for palindrome formation.\n- Ensure the solution handles the maximum input constraints effectively.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm to minimize computational complexity.\n- Include edge case handling for very short or already palindromic strings.\nWe will iterate over each character in the string and consider it as the character to be erased. For each character, we will attempt to form a palindrome by erasing occurrences of that character and checking if the remaining string can be a palindrome. We will use a two-pointer technique to check for palindromes efficiently. The minimum number of deletions required will be tracked, and if no palindrome can be formed, we will return -1.\n", "requirement analysis:\nThe task requires developing an algorithm that can determine the minimum number of characters to erase from a string to make it a palindrome, or determine if it's impossible. The solution must handle up to 100 test cases with a total of up to 200,000 characters efficiently. The algorithm should focus on minimizing erasures and provide clear outputs for each test case.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum erasures needed to form a palindrome.\n- Ensure the solution handles the maximum input constraints effectively.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm to minimize the number of erased symbols.\n- Include detailed comments and documentation for the code.\nWe will implement a function that iterates over each possible letter choice and attempts to make the string a palindrome by removing occurrences of that letter. The function will use a two-pointer technique to check if the string can be transformed into a palindrome by removing the chosen letter. If it is possible, it will calculate the minimum number of removals required. If no letter choice results in a palindrome, it will return -1. This approach ensures efficiency even for large strings.\n", "requirement analysis:\nThe problem requires determining the minimum number of erasures needed to make a string a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with string lengths summing up to 200,000. The algorithm should be optimized to minimize erasures and determine if making a palindrome is impossible.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum erasures needed for a palindrome.\n- Ensure the solution handles the maximum input constraints effectively.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm to minimize computational complexity.\n- Include edge case handling for strings that are already palindromes.\nWe will use a two-pointer technique to check if a string can be transformed into a palindrome by removing occurrences of a single chosen letter. For each letter in the string, we will attempt to make the string a palindrome by removing occurrences of that letter, and calculate the minimum number of removals required. If no letter can make the string a palindrome, we return -1. This approach ensures efficiency even for large strings.\n", "requirement analysis:\nThe requirements focus on transforming a given string into a palindrome by erasing occurrences of a single chosen letter. The solution must efficiently handle multiple test cases and large input sizes, ensuring minimal erasure while providing clear output for each case.\nrequirement pool:\n- Efficiently process up to 100 test cases with large input sizes\n- Determine the minimum number of erasures needed for palindrome transformation\n- Handle edge cases where transformation is impossible\n- Ensure consistent and clear output format\n- Optimize for minimal computational complexity\nWe will implement a function that iterates over each character in the string, attempting to make the string a palindrome by removing occurrences of that character. For each character, we will use a two-pointer technique to check if the string can be transformed into a palindrome by removing the minimum number of that character. If a palindrome is possible, we will track the minimum number of removals required. If no character can be removed to form a palindrome, we will return -1 for that test case. This approach ensures that we efficiently handle large inputs and multiple test cases.\n", "requirement analysis:\nThe task requires developing an algorithm that can determine the minimum number of characters to erase from a string to make it a palindrome, or determine if it's impossible. The solution must handle up to 100 test cases efficiently, with each string having a length of up to 100,000 characters. The total length of all strings combined will not exceed 200,000 characters, necessitating an optimized approach.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum number of erasures needed to make a string a palindrome.\n- Ensure the solution handles edge cases, such as strings that are already palindromes or cannot be made into palindromes.\n- Optimize the algorithm to handle the maximum input size within the given constraints.\n- Provide clear and concise output for each test case.\n- Document the solution approach and edge cases considered.\nWe will use a two-pointer technique to check if a string can be converted into a palindrome by removing occurrences of a single character. For each character in the string, we will attempt to make the string a palindrome by removing occurrences of that character. This approach will be efficient given the constraints, as it will iterate over the string multiple times but within acceptable limits.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions of a single character type to make a string a palindrome. The solution must efficiently handle up to 200,000 characters across multiple test cases. The algorithm should be optimized to minimize deletions and handle edge cases, such as strings that are already palindromes or cannot be transformed into one.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions required to make a string a palindrome.\n- Ensure the solution handles the maximum input size within the given constraints.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm to minimize the number of erased symbols.\n- Handle edge cases, such as already palindromic strings, efficiently.\nWe will use a two-pointer approach to check if a string can be transformed into a palindrome by removing occurrences of a single character. For each character in the string, we will attempt to make the string a palindrome by removing occurrences of that character, and calculate the minimum number of deletions required. If no character can be removed to make the string a palindrome, we will return -1 for that test case.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to convert a given string into a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results and minimal erasures.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum erasures for palindrome conversion\n- Ensure the solution handles up to 100 test cases and large strings efficiently\n- Provide clear output indicating the number of erasures or impossibility\n- Optimize the solution for minimal computational complexity\n- Include edge case handling for strings already palindromes or impossible cases\nWe will implement a function that iterates over each test case, checking if the string can be transformed into a palindrome by removing occurrences of a single chosen letter. The function will use a two-pointer technique to efficiently check palindrome possibilities and calculate the minimum number of erasures required. If no single letter can be chosen to make the string a palindrome, the function will return -1 for that test case.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions of a single character type to make a string a palindrome. The solution must efficiently handle up to 100 test cases with a total character count of up to 200,000. The algorithm should consider all possible single character deletions and determine if a palindrome can be formed, returning the minimum deletions or -1 if impossible.\nrequirement pool:\n- Develop an efficient algorithm to determine the minimum deletions required to form a palindrome.\n- Ensure the solution handles the maximum input constraints efficiently.\n- Provide clear output for each test case, indicating the minimum deletions or impossibility.\n- Optimize the algorithm to minimize computational complexity.\n- Consider edge cases such as already palindromic strings or strings with no possible solution.\nWe will iterate over each character in the string and attempt to make the string a palindrome by removing occurrences of that character. For each character, we will use a two-pointer technique to check if the string can be made a palindrome by removing that character. We will keep track of the minimum number of deletions required. If no character can be removed to make the string a palindrome, we will return -1 for that test case. This approach ensures that we efficiently handle the constraints of the problem.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 806, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "mutate_method": "condense_two2one", "parent_index": 488}
