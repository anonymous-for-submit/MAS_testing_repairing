{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n \u00d7 m, consisting of n rows and m columns of blocks, where each block within this rectangle is either an obsidian block or empty, and CQXYM has the ability to transform an obsidian block into an empty block or vice versa with a single operation. A rectangle M with dimensions a \u00d7 b is defined as a portal if it meets the following criteria: a must be at least 5, and b must be at least 4, and for every 1 < x < a, the blocks located at M_{x,1} and M_{x,b} must be obsidian blocks, while for every 1 < x < b, the blocks at M_{1,x} and M_{a,x} need to be obsidian blocks, plus for all 1 < x < a, 1 < y < b, block M_{x,y} must be empty, and the blocks located at M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type. It's important to note that the arrangement must include a rows and b columns, instead of b rows and a columns, and the blocks at the corners can be of any type. CQXYM is curious about the minimum number of changes he must perform for at least one sub-rectangle to become a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n \u00d7 m, consisting of n rows and m columns of blocks, where each block within this rectangle is either an obsidian block or empty, and CQXYM has the ability to transform an obsidian block into an empty block or vice versa with a single operation. A rectangle M with dimensions a \u00d7 b is defined as a portal if it meets the following criteria: a must be at least 5, and b must be at least 4, and for every 1 < x < a, the blocks located at M_{x,1} and M_{x,b} must be obsidian blocks, while for every 1 < x < b, the blocks at M_{1,x} and M_{a,x} need to be obsidian blocks, plus for all 1 < x < a, 1 < y < b, block M_{x,y} must be empty, and the blocks located at M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type. It's important to note that the arrangement must include a rows and b columns, instead of b rows and a columns, and the blocks at the corners can be of any type. CQXYM is curious about the minimum number of changes he must perform for at least one sub-rectangle to become a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        list[int]: List of integers representing the minimum changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid_array, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions for portal\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the inner conditions for portal\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    results = min_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings representing the rectangle\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible top-left corners of the sub-rectangle\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of changes needed for the current sub-rectangle\n                        changes = calculate_changes(matrix, i, j, a, b)\n                        # Update the minimum changes if the current changes are less\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(matrix: np.ndarray, i: int, j: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    :param matrix: The numpy array representing the grid\n    :param i: The row index of the top-left corner of the sub-rectangle\n    :param j: The column index of the top-left corner of the sub-rectangle\n    :param a: The number of rows in the sub-rectangle\n    :param b: The number of columns in the sub-rectangle\n    :return: The number of changes required\n    \"\"\"\n    changes = 0\n    \n    # Check the borders and inner area of the sub-rectangle\n    for x in range(a):\n        for y in range(b):\n            if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                # Border conditions\n                if (x > 0 and x < a - 1 and (y == 0 or y == b - 1)) or (y > 0 and y < b - 1 and (x == 0 or x == a - 1)):\n                    # Should be obsidian (1)\n                    if matrix[i + x, j + y] != 1:\n                        changes += 1\n            else:\n                # Inner area should be empty (0)\n                if matrix[i + x, j + y] != 0:\n                    changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        list[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = matrix[i:i+a, j:j+b]\n                        changes = calculate_changes(sub_rect, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): Sub-rectangle of the grid.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check and count changes for the portal criteria\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\n# Read number of test cases\nt = int(input())\n\n# Read each test case\n# Each test case consists of dimensions n, m and the grid\n# Store test cases in a list\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Call the function and print results\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list[tuple[int, int, list[str]]]) -> list[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, list[str]]]): List of test cases, each containing dimensions and grid.\n\n    Returns:\n        list[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i + a, j:j + b]\n                        changes = calculate_changes(sub_rect, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to be transformed.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n\n    # Check the inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Call the function and print results\n    results = min_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(n: int, m: int, grid: list[list[int]]) -> int:\n    \"\"\"Calculate the minimum number of changes required to form a portal in the grid.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (list[list[int]]): 2D list representing the grid with 0s and 1s.\n\n    Returns:\n        int: Minimum number of changes required to form a portal.\n    \"\"\"\n    min_changes = float('inf')\n\n    # Iterate over all possible sub-rectangles of size at least 5x4\n    for start_row in range(n - 4):\n        for start_col in range(m - 3):\n            for end_row in range(start_row + 4, n):\n                for end_col in range(start_col + 3, m):\n                    changes = calculate_changes(grid, start_row, start_col, end_row, end_col)\n                    min_changes = min(min_changes, changes)\n\n    return min_changes\n\ndef calculate_changes(grid: list[list[int]], start_row: int, start_col: int, end_row: int, end_col: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (list[list[int]]): 2D list representing the grid with 0s and 1s.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        end_row (int): Ending row index of the sub-rectangle.\n        end_col (int): Ending column index of the sub-rectangle.\n\n    Returns:\n        int: Number of changes required to transform the sub-rectangle into a portal.\n    \"\"\"\n    changes = 0\n    # Check the top and bottom borders\n    for col in range(start_col + 1, end_col):\n        if grid[start_row][col] != 1:\n            changes += 1\n        if grid[end_row][col] != 1:\n            changes += 1\n\n    # Check the left and right borders\n    for row in range(start_row + 1, end_row):\n        if grid[row][start_col] != 1:\n            changes += 1\n        if grid[row][end_col] != 1:\n            changes += 1\n\n    # Check the inner area\n    for row in range(start_row + 1, end_row):\n        for col in range(start_col + 1, end_col):\n            if grid[row][col] != 0:\n                changes += 1\n\n    return changes\n\ndef main():\n    \"\"\"Main function to read input, process each test case, and output results.\"\"\"\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [list(map(int, input().strip())) for _ in range(n)]\n        result = min_changes_to_portal(n, m, grid)\n        results.append(result)\n\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_transformations_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of transformations needed for each test case to form a portal.\n    \n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing (n, m, grid) where grid is a list of strings.\n    \n    Returns:\n        list: List of integers representing the minimum transformations for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        \n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_matrix = matrix[i:i+a, j:j+b]\n                        changes = calculate_changes_to_portal(sub_matrix, a, b)\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes_to_portal(sub_matrix: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-matrix into a portal.\n    \n    Args:\n        sub_matrix (np.ndarray): The sub-matrix to be transformed.\n        a (int): Number of rows in the sub-matrix.\n        b (int): Number of columns in the sub-matrix.\n    \n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n    \n    # Check the borders and inner area according to portal criteria\n    for x in range(1, a - 1):\n        if sub_matrix[x, 0] != 1:\n            changes += 1\n        if sub_matrix[x, b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if sub_matrix[0, y] != 1:\n            changes += 1\n        if sub_matrix[a - 1, y] != 1:\n            changes += 1\n    \n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_matrix[x, y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_transformations_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_transformations(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of transformations for each test case.\n    \n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing n, m, and the grid.\n        \n    Returns:\n        list: List of minimum transformations for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = grid_array[i:i+a, j:j+b]\n                        \n                        # Calculate number of changes needed to make it a portal\n                        changes = calculate_changes_to_portal(sub_rect, a, b)\n                        \n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n    \n    Args:\n        sub_rect (np.ndarray): The sub-rectangle to transform.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n        \n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n    \n    # Check and transform the borders\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n    \n    # Check and transform the inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_transformations(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate changes needed for sub-rectangle starting at (i, j) with size a x b\n                        changes = calculate_changes(grid, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of '0's and '1's.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions\n    for x in range(a):\n        for y in range(b):\n            current_block = grid[start_row + x][start_col + y]\n            if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                # Border conditions\n                if (x == 0 or x == a - 1) and (1 <= y < b - 1):\n                    # Top and bottom borders except corners\n                    if current_block != '1':\n                        changes += 1\n                elif (y == 0 or y == b - 1) and (1 <= x < a - 1):\n                    # Left and right borders except corners\n                    if current_block != '1':\n                        changes += 1\n            else:\n                # Inner blocks must be '0'\n                if current_block != '0':\n                    changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required for each test case to transform a sub-rectangle into a portal.\n    \n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing dimensions (n, m) and the grid as a list of strings\n    :return: List of integers representing the minimum number of changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient manipulation\n        matrix = np.array([list(row) for row in grid], dtype=int)\n        \n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract sub-rectangle\n                        sub_rect = matrix[i:i+a, j:j+b]\n                        \n                        # Calculate changes needed to transform sub-rectangle into a portal\n                        changes = calculate_changes_to_portal(sub_rect, a, b)\n                        \n                        # Update minimum changes\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a sub-rectangle into a portal.\n    \n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes required\n    \"\"\"\n    changes = 0\n    \n    # Check and count changes for the portal conditions\n    # Top and bottom rows\n    for x in range(1, b - 1):\n        if sub_rect[0, x] != 1:\n            changes += 1\n        if sub_rect[a - 1, x] != 1:\n            changes += 1\n    \n    # Left and right columns\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n    \n    # Inner blocks\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input()) for i in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_changes = float('inf')\n\n        # Iterate over all possible top-left corners of sub-rectangles\n        for i in range(n - 4 + 1):\n            for j in range(m - 3 + 1):\n                # Iterate over all possible bottom-right corners of sub-rectangles\n                for a in range(i + 4, n + 1):\n                    for b in range(j + 3, m + 1):\n                        changes = calculate_changes(grid, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: List[str], i: int, j: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of '0's and '1's.\n        i (int): Top-left row index of the sub-rectangle.\n        j (int): Top-left column index of the sub-rectangle.\n        a (int): Bottom-right row index of the sub-rectangle.\n        b (int): Bottom-right column index of the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions for the portal\n    for x in range(i + 1, a):\n        if grid[x][j] != '1':\n            changes += 1\n        if grid[x][b - 1] != '1':\n            changes += 1\n\n    for y in range(j + 1, b):\n        if grid[i][y] != '1':\n            changes += 1\n        if grid[a - 1][y] != '1':\n            changes += 1\n\n    # Check the inner part of the portal\n    for x in range(i + 1, a - 1):\n        for y in range(j + 1, b - 1):\n            if grid[x][y] != '0':\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are clearly defined, ensuring that the solution must efficiently handle the transformation process while adhering to these rules. The challenge lies in optimizing the number of operations required and ensuring the solution is scalable for larger inputs.\nrequirement pool:\n- Implement efficient algorithm to transform rectangle into portal\n- Optimize for minimal operations\n- Ensure solution scalability for large inputs\n- Provide clear output format\n- Include detailed explanation of transformation process\nWe will implement a function to determine the minimum number of changes required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of the given dimensions and calculate the number of changes needed for each. We will use numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the operations needed. The solution must efficiently handle multiple test cases and large inputs, ensuring quick computation and accurate results.\nrequirement pool:\n- Implement efficient algorithm to transform rectangles into portals\n- Optimize for minimal operations required\n- Ensure solution handles large inputs efficiently\n- Provide clear output format for multiple test cases\n- Develop user-friendly interface for input and output\nWe will implement a function to transform rectangles into portals using a dynamic programming approach to efficiently calculate the minimum number of changes required. We will utilize numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific block arrangements. The challenge lies in minimizing the number of changes required to achieve this transformation. The constraints on dimensions and the number of test cases ensure the problem remains computationally feasible.\nrequirement pool:\n- Implement efficient block transformation algorithm.\n- Optimize for minimum changes required.\n- Ensure clear and correct output for each test case.\n- Handle large inputs within given constraints.\n- Provide detailed user stories for better understanding.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific block arrangements. The challenge lies in minimizing the number of transformations needed while adhering to the constraints of block positions and dimensions. The solution must efficiently handle multiple test cases and provide clear outputs for each.\nrequirement pool:\n- Implement efficient block transformation algorithm.\n- Optimize for minimum operations required.\n- Ensure solution handles maximum input constraints.\n- Provide clear and concise output for each test case.\n- Develop user-friendly interface for input and output.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific criteria. The challenge lies in minimizing the number of changes needed while ensuring the portal's structure is maintained. The solution must efficiently handle multiple test cases and large input sizes, providing accurate results for each scenario.\nrequirement pool:\n- Implement the main algorithm to transform rectangles into portals.\n- Optimize the solution to minimize the number of operations.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Provide clear and concise output for each test case.\n- Develop a user-friendly interface for input and output handling.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and checking the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations and slicing.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific block arrangements. The challenge lies in minimizing the number of transformations needed to achieve the portal configuration. The constraints on dimensions and block types are crucial for ensuring the solution is efficient and meets the problem's criteria.\nrequirement pool:\n- Implement efficient block transformation algorithm.\n- Ensure solution handles maximum input constraints.\n- Provide clear and concise output for each test case.\n- Optimize for minimal operations.\n- Validate input dimensions and block types.\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of changes. The function will use a brute-force approach to evaluate each sub-rectangle, counting the necessary transformations to meet the portal criteria. Given the constraints, this approach will be efficient enough. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific block arrangements. The challenge lies in minimizing the number of transformations needed while adhering to the constraints of the portal dimensions and block types. Efficient handling of multiple test cases and large input sizes is crucial.\nrequirement pool:\n- Implement efficient block transformation algorithm.\n- Optimize for minimum operations required.\n- Ensure clear and concise output for each test case.\n- Handle large input sizes within constraints.\n- Provide user-friendly interface for input and output.\nWe will implement a function to find the minimum number of transformations required to convert a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific criteria. The solution must efficiently handle multiple test cases and large dimensions, ensuring minimal operations and accurate results. The constraints on dimensions and block types are crucial for determining the transformation strategy.\nrequirement pool:\n- Implement the transformation algorithm to convert rectangles into portals.\n- Optimize the solution to minimize the number of changes required.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Provide clear and accurate output for each test case.\n- Develop a user-friendly interface for input and output handling.\nWe will implement a function to determine the minimum number of changes required to transform a given sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of the given dimensions and check if they can be transformed into a portal with the minimum number of changes. We will use a brute-force approach to check each sub-rectangle, as the constraints allow for this approach to be feasible. The function will count the number of changes needed for each sub-rectangle and return the minimum count. We will use Python's built-in capabilities for handling lists and strings to manage the grid and transformations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are clear, and the solution must efficiently handle multiple test cases with potentially large dimensions.\nrequirement pool:\n- Implement efficient transformation algorithm\n- Ensure minimal operations for transformation\n- Handle large dimensions effectively\n- Provide clear and concise output\n- Optimize for speed and performance\nWe will implement a function to determine the minimum number of changes required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 within the given rectangle and calculate the number of changes needed for each. We will use numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle of blocks into a portal with specific criteria. The solution must efficiently calculate the minimum number of changes required for each test case, ensuring that the constraints on dimensions and block types are met. The algorithm should be optimized to handle the maximum input size within the given constraints.\nrequirement pool:\n- Develop an algorithm to identify potential portal sub-rectangles.\n- Calculate the minimum number of changes required for transformation.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Provide clear and concise output for each test case.\n- Optimize the algorithm for performance and scalability.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of size at least 5x4 and calculate the number of changes needed to meet the portal criteria. We will use a brute-force approach with optimizations to ensure the solution is efficient within the given constraints. The function will handle multiple test cases and output the result for each.\n"], "scores": [], "pass_results": [true, true, false, true, false, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 116, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "condense_two2one", "parent_index": 106}
