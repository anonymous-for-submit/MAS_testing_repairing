{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir possesses a rectangular sheet featuring a checkered zone with dimensions n \u00d7 m. At the outset, every cell within the region is white.\n\nLet's assign labels to the cell using vertical coordinate i and horizontal coordinate j as (i, j). We start labeling at the top left by marking the cell as (1, 1). Additionally, the cell at the bottom right will be marked (n, m).\n\nCasimir sketches ticks of various sizes on the area. A tick of size d (d > 0) centered in cell (i, j) is created in the following manner:\n\n1. Initially, the cell at the center (i, j) receives a black paint. \n2. Subsequently, exactly d cells in the top-left diagonal to the center and exactly d cells in the top-right diagonal to the center are also turned black. \n3. That is all the cells with coordinates (i - h, j \u00b1 h) for every h ranging from 0 to d are painted. Specifically, a tick contains a total of 2d + 1 black cells.\n\nA cell that's already painted will remain black if repainted. Below you can see an illustration of the 4 \u00d7 9 grid, showcasing two ticks with sizes 2 and 3.\n\n<image>\n\nYou receive a description of a checkered area sized n \u00d7 m. Casimir states that this area is a result of him drawing several ticks on it. The ticks might vary in sizes, but each tick size is at least k (meaning d \u2265 k for every tick).\n\nDetermine whether this area can genuinely be composed by sketching a few (potentially none) ticks with sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir possesses a rectangular sheet featuring a checkered zone with dimensions n \u00d7 m. At the outset, every cell within the region is white.\n\nLet's assign labels to the cell using vertical coordinate i and horizontal coordinate j as (i, j). We start labeling at the top left by marking the cell as (1, 1). Additionally, the cell at the bottom right will be marked (n, m).\n\nCasimir sketches ticks of various sizes on the area. A tick of size d (d > 0) centered in cell (i, j) is created in the following manner:\n\n1. Initially, the cell at the center (i, j) receives a black paint. \n2. Subsequently, exactly d cells in the top-left diagonal to the center and exactly d cells in the top-right diagonal to the center are also turned black. \n3. That is all the cells with coordinates (i - h, j \u00b1 h) for every h ranging from 0 to d are painted. Specifically, a tick contains a total of 2d + 1 black cells.\n\nA cell that's already painted will remain black if repainted. Below you can see an illustration of the 4 \u00d7 9 grid, showcasing two ticks with sizes 2 and 3.\n\n<image>\n\nYou receive a description of a checkered area sized n \u00d7 m. Casimir states that this area is a result of him drawing several ticks on it. The ticks might vary in sizes, but each tick size is at least k (meaning d \u2265 k for every tick).\n\nDetermine whether this area can genuinely be composed by sketching a few (potentially none) ticks with sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the given grid can be formed using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and grid.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a grid to mark cells that can be part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size at least k can be formed\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells\n                    if size > k:\n                        for h in range(size):\n                            marked[i - h][j - h] = True\n                            marked[i - h][j + h] = True\n\n        # Verify if all '*' cells can be explained by ticks\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append('YES' if can_form else 'NO')\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Output interface\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given grid can be composed of ticks of a minimum size.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - k: Minimum size of the ticks.\n            - grid: A list of strings representing the grid.\n\n    Returns:\n        A list of strings, each being \"YES\" or \"NO\" for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Set to track painted cells\n        painted_cells = set()\n\n        # Function to check if a tick of size d can be centered at (i, j)\n        def can_place_tick(i: int, j: int, d: int) -> bool:\n            for h in range(d + 1):\n                if (i - h < 0 or j - h < 0 or j + h >= m or\n                        grid[i - h][j - h] != '*' or grid[i - h][j + h] != '*'):\n                    return False\n            return True\n\n        # Function to mark cells of a tick of size d centered at (i, j)\n        def mark_tick(i: int, j: int, d: int):\n            for h in range(d + 1):\n                painted_cells.add((i - h, j - h))\n                painted_cells.add((i - h, j + h))\n\n        # Iterate over each cell to find possible tick centers\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Find the maximum size of the tick that can be placed here\n                    max_d = 0\n                    while can_place_tick(i, j, max_d + 1):\n                        max_d += 1\n                    # If the maximum size is at least k, mark the tick\n                    if max_d >= k:\n                        mark_tick(i, j, max_d)\n\n        # Verify if all '*' cells are covered by ticks\n        all_covered = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and (i, j) not in painted_cells:\n                    all_covered = False\n                    break\n            if not all_covered:\n                break\n\n        results.append(\"YES\" if all_covered else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        grid = data[index + 1:index + 1 + n]\n        test_cases.append((n, m, k, grid))\n        index += n + 1\n    \n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if each grid can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to track if a cell can be part of a tick\n        can_be_tick = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick of size at least k\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with center at (i, j)\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells that can be part of a tick\n                        for d in range(k + 1):\n                            can_be_tick[i - d][j - d] = True\n                            can_be_tick[i - d][j + d] = True\n\n        # Verify if all '*' in the grid can be part of a tick\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not can_be_tick[i][j]:\n                    possible = False\n                    break\n            if not possible:\n                break\n\n        results.append(\"YES\" if possible else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a grid can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): Grid representation with '.' for white and '*' for black.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a matrix to track if a cell can be part of a tick\n        can_be_center = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if i >= k and j >= k and j + k < m:\n                        is_valid_tick = True\n                        for h in range(1, k + 1):\n                            if grid[i - h][j - h] != '*' or grid[i - h][j + h] != '*':\n                                is_valid_tick = False\n                                break\n                        if is_valid_tick:\n                            can_be_center[i][j] = True\n\n        # Check if all '*' can be part of a tick\n        is_possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if this '*' can be part of a tick\n                    if not can_be_center[i][j]:\n                        # Check if it can be part of a tick centered above\n                        can_be_part_of_tick = False\n                        for h in range(1, min(i + 1, j + 1, m - j)):\n                            if can_be_center[i - h][j]:\n                                can_be_part_of_tick = True\n                                break\n                        if not can_be_part_of_tick:\n                            is_possible = False\n                            break\n            if not is_possible:\n                break\n\n        results.append(\"YES\" if is_possible else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a grid can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): Grid representation with '.' for unpainted and '*' for painted cells.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a matrix to track if a cell can be part of a tick\n        can_be_center = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if i >= k and j >= k and j + k < m:\n                        valid_tick = True\n                        for h in range(1, k + 1):\n                            if grid[i - h][j - h] != '*' or grid[i - h][j + h] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            can_be_center[i][j] = True\n\n        # Check if all '*' can be part of a tick\n        possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if this '*' can be part of a tick\n                    if not can_be_center[i][j]:\n                        # Check if it can be part of a tick centered above\n                        part_of_tick = False\n                        for d in range(1, min(i + 1, j + 1, m - j)):\n                            if can_be_center[i - d][j]:\n                                part_of_tick = True\n                                break\n                        if not part_of_tick:\n                            possible = False\n                            break\n            if not possible:\n                break\n\n        results.append(\"YES\" if possible else \"NO\")\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Output interface\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each test case grid can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): Grid representation with '*' for painted cells and '.' for unpainted cells.\n\n    Returns:\n        List[str]: List of results for each test case, \"YES\" if the grid can be composed of ticks, \"NO\" otherwise.\n    \"\"\"\n    def is_valid_tick_center(n: int, m: int, k: int, grid: List[str], i: int, j: int) -> bool:\n        \"\"\"Check if the cell (i, j) can be the center of a tick of size at least k.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the ticks.\n            grid (List[str]): Grid representation.\n            i (int): Row index of the potential tick center.\n            j (int): Column index of the potential tick center.\n\n        Returns:\n            bool: True if the cell can be the center of a valid tick, False otherwise.\n        \"\"\"\n        for d in range(k):\n            if i - d < 0 or j - d < 0 or j + d >= m:\n                return False\n            if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                return False\n        return True\n\n    def can_form_ticks_in_grid(n: int, m: int, k: int, grid: List[str]) -> str:\n        \"\"\"Determine if the grid can be composed of ticks of size at least k.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the ticks.\n            grid (List[str]): Grid representation.\n\n        Returns:\n            str: \"YES\" if the grid can be composed of ticks, \"NO\" otherwise.\n        \"\"\"\n        painted = [[False] * m for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and is_valid_tick_center(n, m, k, grid, i, j):\n                    d = 0\n                    while i - d >= 0 and j - d >= 0 and j + d < m and grid[i - d][j - d] == '*' and grid[i - d][j + d] == '*':\n                        painted[i - d][j - d] = True\n                        painted[i - d][j + d] = True\n                        d += 1\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not painted[i][j]:\n                    return \"NO\"\n        return \"YES\"\n\n    results = []\n    for n, m, k, grid in test_cases:\n        results.append(can_form_ticks_in_grid(n, m, k, grid))\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Output interface\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a grid can be formed using ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and grid.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n, m, k, grid = case\n        # Create a 2D list to track if a cell is part of a valid tick\n        valid_tick = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick of size at least k\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                                grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If a valid tick of size at least k is found, mark the cells\n                    if size > k:\n                        for h in range(size):\n                            valid_tick[i - h][j - h] = True\n                            valid_tick[i - h][j + h] = True\n\n        # Verify if all '*' in the grid are part of a valid tick\n        is_possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not valid_tick[i][j]:\n                    is_possible = False\n                    break\n            if not is_possible:\n                break\n\n        results.append(\"YES\" if is_possible else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a grid can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing grid dimensions, minimum tick size, and grid data.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a copy of the grid to mark cells that can be part of a tick\n        marked_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if can_form_tick(i, j, k, n, m, grid, marked_grid):\n                        mark_tick(i, j, k, n, m, marked_grid)\n\n        # Verify if all '*' in the grid can be part of a tick\n        if all(marked_grid[i][j] or grid[i][j] == '.' for i in range(n) for j in range(m)):\n            results.append('YES')\n        else:\n            results.append('NO')\n\n    return results\n\ndef can_form_tick(i: int, j: int, k: int, n: int, m: int, grid: List[str], marked_grid: List[List[bool]]) -> bool:\n    \"\"\"Check if a tick of size k can be formed with (i, j) as the center.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Minimum tick size.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[str]): The grid data.\n        marked_grid (List[List[bool]]): Grid to mark cells that can be part of a tick.\n\n    Returns:\n        bool: True if a tick can be formed, False otherwise.\n    \"\"\"\n    for h in range(1, k + 1):\n        if i - h < 0 or j - h < 0 or j + h >= m:\n            return False\n        if grid[i - h][j - h] != '*' or grid[i - h][j + h] != '*':\n            return False\n    return True\n\ndef mark_tick(i: int, j: int, k: int, n: int, m: int, marked_grid: List[List[bool]]) -> None:\n    \"\"\"Mark cells that are part of a tick of size k with (i, j) as the center.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Minimum tick size.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        marked_grid (List[List[bool]]): Grid to mark cells that can be part of a tick.\n    \"\"\"\n    marked_grid[i][j] = True\n    for h in range(1, k + 1):\n        marked_grid[i - h][j - h] = True\n        marked_grid[i - h][j + h] = True\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a grid can be composed of ticks of a certain minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the grid.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a copy of the grid to mark cells that can be part of a tick\n        marked_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if can_form_tick(i, j, k, n, m, grid, marked_grid):\n                        mark_tick(i, j, k, marked_grid)\n\n        # Verify if all '*' in the grid can be part of a tick\n        if all(grid[i][j] == '.' or marked_grid[i][j] for i in range(n) for j in range(m)):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef can_form_tick(i: int, j: int, k: int, n: int, m: int, grid: List[str], marked_grid: List[List[bool]]) -> bool:\n    \"\"\"Check if a tick of size k can be formed with (i, j) as the center.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Minimum size of the tick.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[str]): The grid representation.\n        marked_grid (List[List[bool]]): Grid to mark cells that can be part of a tick.\n\n    Returns:\n        bool: True if a tick can be formed, False otherwise.\n    \"\"\"\n    # Check top-left diagonal\n    for h in range(1, k + 1):\n        if i - h < 0 or j - h < 0 or grid[i - h][j - h] != '*':\n            return False\n\n    # Check top-right diagonal\n    for h in range(1, k + 1):\n        if i - h < 0 or j + h >= m or grid[i - h][j + h] != '*':\n            return False\n\n    return True\n\ndef mark_tick(i: int, j: int, k: int, marked_grid: List[List[bool]]) -> None:\n    \"\"\"Mark cells that are part of a tick in the marked grid.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Size of the tick.\n        marked_grid (List[List[bool]]): Grid to mark cells that can be part of a tick.\n    \"\"\"\n    marked_grid[i][j] = True\n\n    # Mark top-left diagonal\n    for h in range(1, k + 1):\n        marked_grid[i - h][j - h] = True\n\n    # Mark top-right diagonal\n    for h in range(1, k + 1):\n        marked_grid[i - h][j + h] = True\n\n# Input interface\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Call the function and print results\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if a grid can be composed of ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the ticks.\n            - grid (List[str]): Grid representation with '*' for painted cells and '.' for unpainted cells.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a matrix to track if a cell can be part of a tick\n        can_be_tick = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells as part of a tick\n                    if size > k:\n                        for h in range(size):\n                            can_be_tick[i - h][j - h] = True\n                            can_be_tick[i - h][j + h] = True\n\n        # Check if all '*' cells can be part of a tick\n        is_possible = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not can_be_tick[i][j]:\n                    is_possible = False\n                    break\n            if not is_possible:\n                break\n\n        results.append(\"YES\" if is_possible else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirements focus on determining if a grid can be formed using ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide clear output for each case. Edge cases, such as minimal grid sizes and varying tick sizes, must be considered to ensure robustness.\nrequirement pool:\n- Implement the main algorithm to check tick formation\n- Optimize for handling up to 100 test cases efficiently\n- Ensure output clarity and correctness\n- Handle edge cases and minimal grid sizes\n- Provide detailed error messages for invalid inputs\nWe will implement a function to determine if a given grid can be formed using ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. If a tick can be formed, it will mark the cells as part of a tick. The function will then verify if all '*' cells can be explained by ticks. We will use a simple nested loop approach to ensure clarity and correctness, leveraging Python's built-in data structures for efficient processing.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as grids with minimal painted cells, must be considered. The output should be clear and adhere to the specified format.\nrequirement pool:\n- Implement the main algorithm to check tick composition\n- Optimize for performance across multiple test cases\n- Ensure output format consistency\n- Handle edge cases effectively\n- Provide detailed error messages for invalid inputs\nWe will implement a function to determine if a given grid can be composed of ticks of a minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. If a cell can be the center of such a tick, we will mark the cells that would be painted by this tick. After processing the grid, we will verify if all '*' cells can be explained by the ticks. We will use a simple list to represent the grid and a set to track painted cells for efficient lookup.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases and provide clear outputs. Edge cases, such as small grids or grids with isolated black cells, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case handling\n- Ensure output clarity and correctness\n- Handle edge cases effectively\n- Provide detailed error messages for invalid grids\nWe will implement a function to determine if a grid can be composed of ticks of a minimum size using a straightforward algorithm. The algorithm will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use simple loops and condition checks to ensure performance and clarity. The solution will handle multiple test cases efficiently by processing each grid independently.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as grids with minimal or maximal dimensions, must be considered. The output should be clear and concise, allowing users to easily interpret the results.\nrequirement pool:\n- Implement the main algorithm to check tick composition\n- Optimize for performance across multiple test cases\n- Ensure accurate handling of edge cases\n- Provide clear output formatting\n- Develop user-friendly input method\nWe will implement a function to determine if a grid can be composed of ticks of a minimum size using a straightforward algorithm. The algorithm will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use simple list operations to manage the grid and check conditions. The solution will be optimized for performance by minimizing unnecessary checks and using efficient data structures.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as grids with minimal painted cells, must be considered. The output should be clear and concise, indicating whether the grid can be formed by the specified ticks.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case processing\n- Handle edge cases with minimal painted cells\n- Ensure output clarity and conciseness\n- Provide detailed error messages for invalid grids\nWe will implement a function to determine if a grid can be composed of ticks of a minimum size using a simple algorithm. The algorithm will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use basic Python data structures such as lists to represent the grid and perform checks. The solution will be optimized for multiple test case processing by iterating over each test case independently.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as grids with minimal painted cells, must be considered to ensure robustness.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case handling\n- Ensure output clarity and accuracy\n- Handle edge cases effectively\n- Improve performance for larger grids\nWe will implement a function to determine if a given grid can be composed of ticks of a minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use a simple nested loop to traverse the grid and a helper function to validate potential tick centers. The solution will be optimized for handling multiple test cases efficiently.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be formed using ticks of a minimum size. The solution must handle multiple test cases efficiently and provide accurate results. Edge cases, such as grids with minimal painted cells, must be considered.\nrequirement pool:\n- Implement the main algorithm to check tick formation\n- Optimize for handling multiple test cases\n- Ensure accurate output formatting\n- Handle edge cases effectively\n- Improve performance for larger grids\nWe will implement a function to determine if a grid can be formed using ticks of a minimum size. The function will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use nested loops to check the diagonals and ensure all required cells are painted. The solution will handle multiple test cases efficiently by processing each grid independently. We will use basic Python data structures like lists to represent the grid and perform operations.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as grids with minimal painted cells, must be considered to ensure robustness.\nrequirement pool:\n- Implement the main algorithm to check tick composition\n- Optimize for handling up to 100 test cases efficiently\n- Ensure output format is clear and follows specifications\n- Handle edge cases where minimal cells are painted\n- Provide detailed error messages for invalid inputs\nWe will implement a function to determine if a grid can be composed of ticks of a minimum size using a straightforward algorithm. The algorithm will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use basic Python data structures and avoid complex libraries to ensure the solution is efficient and easy to understand.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a certain minimum size. The solution must efficiently handle multiple test cases and provide clear outputs. Edge cases, such as grids with minimal or no ticks, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case processing\n- Ensure output clarity and correctness\n- Handle edge cases effectively\n- Provide detailed error messages for invalid inputs\nWe will implement a function to determine if a grid can be composed of ticks of a certain minimum size. The function will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use a simple nested loop approach to check the diagonals for each potential tick center. The solution will be optimized for multiple test case processing by handling each test case independently and efficiently.\n", "requirement analysis:\nThe requirements focus on determining if a grid can be composed of ticks of a minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as grids with no ticks or minimal tick sizes, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test case handling\n- Ensure accurate output formatting\n- Handle edge cases gracefully\n- Improve performance for large grids\nWe will implement a function to determine if a grid can be composed of ticks of a minimum size using a straightforward algorithm. The algorithm will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use simple list operations to manage the grid and check conditions efficiently. The solution will handle multiple test cases by iterating over each test case and applying the tick detection logic.\n"], "scores": [], "pass_results": [true, false, false, false, false, false, true, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 341, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "expand_one2two", "parent_index": 151}
