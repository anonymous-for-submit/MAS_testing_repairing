{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir wants to determine whether the pattern he devised can be duplicated using ticks that satisfy the previously mentioned size constraints. The task at hand involves confirming if the predefined criteria for tick dimensions align with the pattern's replication requirements.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir wants to determine whether the pattern he devised can be duplicated using ticks that satisfy the previously mentioned size constraints. The task at hand involves confirming if the predefined criteria for tick dimensions align with the pattern's replication requirements.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_replicate_pattern(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the pattern can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a grid to mark the cells that can be part of a tick\n        tick_grid = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick of size k\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if field[i][j] == '*':\n                    valid_tick = True\n                    # Check if there are k '*' in each direction\n                    for d in range(1, k + 1):\n                        if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells that are part of a valid tick\n                        for d in range(k + 1):\n                            tick_grid[i - d][j - d] = True\n                            tick_grid[i - d][j + d] = True\n\n        # Verify if all '*' in the field are part of a tick\n        can_replicate = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_grid[i][j]:\n                    can_replicate = False\n                    break\n            if not can_replicate:\n                break\n\n        results.append(\"YES\" if can_replicate else \"NO\")\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    field = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, field))\n\n# Output interface\nresults = can_replicate_pattern(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_replicate_pattern(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the pattern can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - k: Minimum size of the ticks.\n            - field: A list of strings representing the grid.\n\n    Returns:\n        A list of strings, each being \"YES\" or \"NO\" for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check for possible ticks starting from the bottom of the grid\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    size -= 1  # Adjust size to the last valid tick size\n\n                    if size >= k:\n                        # Mark the cells of the tick\n                        for s in range(size + 1):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the field are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_replicate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_replicate_pattern(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if the pattern can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell is part of a valid tick\n        tick_covered = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if can_form_tick(i, j, k, n, m, field):\n                        # Mark the cells covered by this tick\n                        mark_tick(i, j, k, tick_covered)\n\n        # Verify if all '*' in the field are covered by valid ticks\n        if all(field[i][j] == '.' or tick_covered[i][j] for i in range(n) for j in range(m)):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef can_form_tick(x: int, y: int, k: int, n: int, m: int, field: List[str]) -> bool:\n    \"\"\"Check if a tick of size k can be formed with (x, y) as the center.\n\n    Args:\n        x (int): Row index of the center.\n        y (int): Column index of the center.\n        k (int): Minimum size of the tick.\n        n (int): Number of rows in the field.\n        m (int): Number of columns in the field.\n        field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        bool: True if a tick can be formed, False otherwise.\n    \"\"\"\n    # Check if there are enough '*' in all four directions\n    for d in range(1, k + 1):\n        if (x - d < 0 or y - d < 0 or y + d >= m or\n            field[x - d][y - d] != '*' or field[x - d][y + d] != '*'):\n            return False\n    return True\n\ndef mark_tick(x: int, y: int, k: int, tick_covered: List[List[bool]]):\n    \"\"\"Mark the cells covered by a tick of size k with (x, y) as the center.\n\n    Args:\n        x (int): Row index of the center.\n        y (int): Column index of the center.\n        k (int): Minimum size of the tick.\n        tick_covered (List[List[bool]]): 2D list to track covered cells.\n    \"\"\"\n    # Mark the center\n    tick_covered[x][y] = True\n    # Mark the arms of the tick\n    for d in range(1, k + 1):\n        tick_covered[x - d][y - d] = True\n        tick_covered[x - d][y + d] = True\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output results\n    results = can_replicate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given pattern can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark the cells that can be part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick of size k\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                                field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If a tick of at least size k can be formed, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the field are part of a tick\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append('YES' if can_form else 'NO')\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    number_of_cases = int(input().strip())\n    test_cases = []\n    for _ in range(number_of_cases):\n        n, m, k = map(int, input().strip().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output interface\n    results = can_form_ticks(number_of_cases, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_replicate_pattern(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the given field can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark cells that can be part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick of size k\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells of the tick\n                        for d in range(k + 1):\n                            marked[i - d][j - d] = True\n                            marked[i - d][j + d] = True\n                        marked[i][j] = True\n\n        # Verify if all '*' in the field are part of a valid tick\n        can_replicate = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    can_replicate = False\n                    break\n            if not can_replicate:\n                break\n\n        results.append(\"YES\" if can_replicate else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output interface\n    results = can_replicate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_replicate_pattern(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determines if the pattern can be replicated using ticks of at least the given size.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the field.\n            - m: Number of columns in the field.\n            - k: Minimum size of the ticks.\n            - field: List of strings representing the field.\n\n    Returns:\n        A list of strings, each being 'YES' or 'NO' for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a '*' can be part of a tick\n        tick_possible = [[False] * m for _ in range(n)]\n\n        # Check each '*' in the field to see if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be centered at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the positions as possible\n                    if size > k:\n                        for s in range(size):\n                            tick_possible[i - s][j - s] = True\n                            tick_possible[i - s][j + s] = True\n\n        # Determine if the field can be replicated by ticks of at least size k\n        can_replicate = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_possible[i][j]:\n                    can_replicate = False\n                    break\n            if not can_replicate:\n                break\n\n        results.append('YES' if can_replicate else 'NO')\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    results = can_replicate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef validate_tick_patterns(test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Validate if the given field can be obtained by drawing ticks of at least the given size.\n\n    Args:\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the field.\n            - m: Number of columns in the field.\n            - k: Minimum size of the ticks.\n            - field: A list of strings representing the field.\n\n    Returns:\n        A list of strings, each being \"YES\" or \"NO\" for the corresponding test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark the positions that can be part of a valid tick\n        can_be_tick = [[False] * m for _ in range(n)]\n\n        # Check for possible tick centers from bottom to top\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    size -= 1  # Adjust size to the last valid tick size\n\n                    if size >= k:\n                        # Mark all positions of this tick as valid\n                        for s in range(size + 1):\n                            can_be_tick[i - s][j - s] = True\n                            can_be_tick[i - s][j + s] = True\n\n        # Verify if all '*' in the field can be part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not can_be_tick[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    results = validate_tick_patterns(test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_replicate_pattern(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if the pattern can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing n, m, k, and the field.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell is part of a valid tick\n        tick_map = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the field\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells as part of a valid tick\n                    if size > k:\n                        for s in range(size):\n                            tick_map[i - s][j - s] = True\n                            tick_map[i - s][j + s] = True\n\n        # Check if all '*' in the field are part of a valid tick\n        is_valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_map[i][j]:\n                    is_valid = False\n                    break\n            if not is_valid:\n                break\n\n        results.append(\"YES\" if is_valid else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_replicate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if the given field can be obtained by drawing ticks of at least the given size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a grid to mark the cells that can be part of a tick\n        tick_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick can be formed with center at (i, j)\n                    size = 0\n                    while True:\n                        if (i - size - 1 >= 0 and j - size - 1 >= 0 and\n                            i - size - 1 >= 0 and j + size + 1 < m and\n                            field[i - size - 1][j - size - 1] == '*' and\n                            field[i - size - 1][j + size + 1] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells\n                    if size >= k:\n                        for s in range(size + 1):\n                            tick_grid[i - s][j - s] = True\n                            tick_grid[i - s][j + s] = True\n\n        # Check if all '*' in the field can be part of a tick\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_grid[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_replicate_pattern(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if the pattern can be replicated using ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the ticks.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check for possible ticks starting from the bottom of the grid\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n\n                    # If a tick of at least size k is found, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the field are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = data[index + 1:index + 1 + n]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n    \n    # Call the function and print results\n    results = can_replicate_pattern(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on determining if a pattern can be replicated using ticks of a specified minimum size. The solution must handle multiple test cases efficiently, ensuring that each test case is evaluated correctly. The output should be a simple YES or NO, indicating whether the pattern can be achieved with the given constraints.\nrequirement pool:\n- Implement the main algorithm to check pattern duplication with ticks.\n- Optimize the solution for performance with multiple test cases.\n- Ensure the solution handles edge cases effectively.\n- Provide clear documentation and comments in the code.\n- Design a user-friendly interface for input and output.\nWe will implement a function to determine if the pattern can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of the required size. We will use a simple nested loop to traverse the grid and check the conditions for forming a tick. The solution will be optimized to handle up to 100 test cases efficiently.\n", "requirement analysis:\nThe task requires determining if a given pattern can be replicated using ticks of a specified minimum size. The solution must efficiently handle up to 100 test cases, each with a field size of up to 10x19. The output should be a simple YES or NO for each test case, indicating whether the pattern can be replicated.\nrequirement pool:\n- Implement the main algorithm to check pattern replication using ticks.\n- Ensure the solution handles all edge cases and provides correct output.\n- Optimize the algorithm for efficiency with larger inputs.\n- Maintain code readability and simplicity for future maintenance.\n- Provide detailed comments and documentation for the code.\nWe will implement a function to determine if a given pattern can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the grid and attempt to form ticks of the required size. We will use a simple nested loop to check for the presence of ticks, ensuring that each tick meets the minimum size requirement. The function will handle multiple test cases efficiently by processing each grid independently. We will use basic Python data structures and avoid any complex libraries to maintain simplicity and readability.\n", "requirement analysis:\nThe main requirement is to determine if a given pattern can be replicated using ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide a clear YES or NO output for each case. The constraints on the field size and tick size must be adhered to, and the solution should be optimized for performance given the potential number of test cases.\nrequirement pool:\n- Implement the core logic to validate pattern replication using ticks.\n- Optimize the solution for handling up to 100 test cases efficiently.\n- Ensure the output format is clear and adheres to the specified requirements.\n- Handle edge cases where patterns cannot be replicated.\n- Provide documentation and comments for maintainability.\nWe will implement a function to determine if a given pattern can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the grid and check if it can be the center of a tick of the required size. We will use a simple nested loop to traverse the grid and check the conditions for forming a tick. The solution will be optimized to handle up to 100 test cases efficiently by processing each test case independently.\n", "requirement analysis:\nThe main requirement is to determine if a given pattern can be replicated using ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide a clear YES or NO output for each case. The constraints on the field size and tick size must be adhered to, ensuring that the solution is both accurate and performant.\nrequirement pool:\n- Implement the main algorithm to check pattern duplication using ticks.\n- Optimize the solution for handling up to 100 test cases efficiently.\n- Ensure the output format is consistent and easy to understand.\n- Handle edge cases where patterns cannot be formed.\n- Improve the user interface for input and output handling.\nWe will implement a function to determine if a given pattern can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of the required size. We will use a simple nested loop to check the conditions for forming a tick, ensuring that the solution is efficient enough to handle up to 100 test cases. The function will return 'YES' if the pattern can be formed and 'NO' otherwise. We will use basic Python data structures and avoid any complex libraries to keep the solution simple and efficient.\n", "requirement analysis:\nThe task requires determining if a given field can be replicated using ticks of a specified minimum size. The solution must efficiently handle up to 100 test cases, each with a field size of up to 10x19. The output should be a simple YES or NO for each test case, indicating whether the pattern can be replicated with the given constraints.\nrequirement pool:\n- Implement the main algorithm to check pattern duplication with ticks.\n- Optimize the solution for performance with multiple test cases.\n- Ensure the solution handles edge cases and provides accurate results.\n- Design a user-friendly output format.\n- Include comprehensive test coverage for various scenarios.\nWe will implement a function to check if the given field can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the field, checking if it can be the center of a tick of the required size. We will use a simple nested loop approach to verify the tick conditions efficiently. Given the constraints, this approach will be performant enough for the input size. We will use basic Python data structures and avoid any complex libraries to keep the solution simple and efficient.\n", "requirement analysis:\nThe requirements focus on validating whether a pattern can be replicated using ticks of a specified minimum size. The solution must efficiently handle multiple test cases, ensuring accurate and clear outputs. Edge cases, such as small field sizes and varying tick sizes, must be considered to ensure robustness.\nrequirement pool:\n- Implement tick size validation logic\n- Ensure accurate pattern replication analysis\n- Optimize performance for large number of test cases\n- Provide clear and concise output format\n- Enhance user interface for better usability\nWe will implement a function to validate tick size using a simple algorithm that checks each '*' in the field to see if it can be the center of a tick of at least the given size. We will use basic Python data structures like lists to represent the field and perform the necessary checks. The solution will be efficient enough to handle up to 100 test cases with the given constraints.\n", "requirement analysis:\nThe requirements focus on validating tick patterns against predefined constraints. The solution must efficiently handle multiple test cases and provide clear outputs. The challenge lies in accurately determining if the field can be replicated using ticks of the specified size.\nrequirement pool:\n- Implement tick size validation logic\n- Ensure accurate pattern replication\n- Optimize performance for large test cases\n- Provide detailed output explanations\n- Enhance user interface for better usability\nWe will implement a function to validate tick patterns using simple iteration and condition checks. The function will analyze each test case to determine if the field can be replicated using ticks of the specified size. We will use basic Python data structures such as lists and strings to handle the input and output efficiently. The solution will focus on simplicity and accuracy, leveraging Python's built-in capabilities without external libraries.\n", "requirement analysis:\nThe task requires determining if a given pattern can be replicated using ticks of a specified minimum size. The solution must efficiently handle up to 100 test cases, each with a field size of up to 10x19. The output should be a simple YES or NO for each test case, indicating whether the pattern can be replicated with the given constraints.\nrequirement pool:\n- Implement the main logic to check pattern replication using ticks.\n- Ensure the solution handles up to 100 test cases efficiently.\n- Optimize the algorithm for edge cases and large inputs.\n- Provide clear and concise output for each test case.\n- Enhance user interface for better usability.\nWe will implement a function to check if the pattern can be replicated using ticks of a specified minimum size. The function will iterate over each test case, analyze the field, and determine if the pattern can be formed using ticks of the given size. We will use simple list operations and loops to efficiently handle the constraints. The solution will focus on performance and clarity, ensuring it can handle up to 100 test cases efficiently.\n", "requirement analysis:\nThe task requires determining if a pattern can be replicated using ticks of a specified minimum size. The solution must efficiently handle up to 100 test cases, each with a grid of up to 10x19 characters. The main challenge is to correctly identify valid tick patterns and ensure all asterisks can be part of such patterns.\nrequirement pool:\n- Implement the main logic to identify valid tick patterns.\n- Ensure the solution handles edge cases effectively.\n- Optimize the solution for performance with large inputs.\n- Provide clear and concise output for each test case.\n- Maintain code readability and simplicity.\nWe will implement a function to check if the given field can be obtained by drawing ticks of at least the given size. The function will iterate over each cell in the grid and attempt to form a tick pattern centered at that cell, checking if the tick can extend to the required size. We will use simple loops and condition checks to ensure efficiency and clarity. The solution will handle edge cases by verifying the tick formation constraints for each asterisk in the grid.\n", "requirement analysis:\nThe requirements focus on validating whether a given pattern can be replicated using ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide a clear YES or NO output for each case. The constraints on field size and tick size must be adhered to, ensuring that the solution is both accurate and performant.\nrequirement pool:\n- Implement the main logic to validate tick patterns against the given constraints.\n- Optimize the solution to handle up to 100 test cases efficiently.\n- Ensure the output format is consistent and clear for each test case.\n- Handle edge cases where ticks cannot be formed due to constraints.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function to validate if the given pattern can be replicated using ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if a tick of the required size can be formed with the current cell as the center. We will use a simple nested loop approach to check the conditions for tick formation. The solution will handle multiple test cases efficiently by processing each test case independently.\n"], "scores": [], "pass_results": [true, false, true, true, false, true, false, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 492, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "rephrase_one", "parent_index": 311}
