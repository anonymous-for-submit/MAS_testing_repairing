{"name": "1580_A. Portal", "description": "CQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "tags": ["brute force", "data structures", "dp", "greedy", "implementation"], "difficulty": 7, "id": 1580, "sample_io": [{"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "output": ["12\n"]}], "test_list": [{"input": "1\n5 4\n1000\n0000\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010110000\n", "output": ["3\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0000\n0010\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n1010\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1000\n", "output": ["9\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0110\n1001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n1001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0001\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0010\n1110\n1001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0110\n1101\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1101\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0011\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n1110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0010\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1110\n0000\n0110\n1011\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1101\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n001011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001111\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1000\n0110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1111\n0001\n0000\n", "output": ["9\n"]}, {"input": "1\n5 4\n1100\n0000\n1110\n0000\n1000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0000\n1100\n", "output": ["9\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0101\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1000\n0010\n0110\n0101\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1100\n0000\n0010\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0000\n1111\n0010\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0110\n0111\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n1100\n", "output": ["7\n"]}, {"input": "1\n7 9\n001010001\n101110100\n000010011\n000000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n000000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1101\n0000\n", "output": ["8\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n1000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001010101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0010\n1110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n0011\n1000\n0010\n1001\n1001\n", "output": ["7\n"]}, {"input": "1\n8 9\n101010001\n101110100\n000010011\n001000001\n001010101\n110001111\n000001111\n110100011\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0010\n1000\n1001\n", "output": ["8\n"]}, {"input": "1\n5 4\n0011\n0000\n0010\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101100001\n101110100\n000010011\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0010\n0001\n0110\n1001\n1101\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n110000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1001\n1100\n", "output": ["6\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n010100000\n", "output": ["4\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110101111\n000001011\n111100000\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n1010\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n0000\n0000\n0010\n0001\n0000\n", "output": ["10\n"]}, {"input": "1\n5 4\n1100\n0010\n1110\n0000\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0100\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1011\n1000\n1010\n0000\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n0110\n0101\n1000\n", "output": ["13\n"]}, {"input": "1\n5 4\n1000\n0000\n1101\n0000\n0010\n", "output": ["8\n"]}, {"input": "1\n5 4\n1101\n0000\n1010\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1001\n0110\n0100\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0010\n0010\n1101\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0111\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1011\n0000\n0010\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n1001\n1010\n", "output": ["6\n"]}, {"input": "1\n5 4\n1010\n0001\n0100\n1001\n0000\n", "output": ["7\n"]}, {"input": "1\n5 4\n0111\n0000\n0011\n1001\n0000\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010011\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0110\n1101\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1110\n0010\n1111\n1001\n0100\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000001\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0000\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n0011\n0001\n0100\n1000\n1100\n", "output": ["7\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n110001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0110\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110000\n000010011\n100000001\n101010101\n110001111\n000001111\n110100100\n000110001\n", "output": ["5\n"]}, {"input": "1\n5 4\n0000\n0011\n0100\n0001\n0001\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0101\n1000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n1000\n1101\n0000\n0010\n", "output": ["7\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0000\n", "output": ["13\n"]}, {"input": "1\n9 9\n001110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0010\n1101\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0110\n0000\n", "output": ["13\n"]}, {"input": "1\n5 4\n0011\n0000\n1010\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n000010001\n010000001\n001010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1100\n0010\n1111\n1001\n0100\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0010\n0110\n1011\n0000\n", "output": ["11\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n001011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n0011\n0001\n0110\n1000\n1100\n", "output": ["8\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111001111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100010\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n110001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n1010\n1110\n0011\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n0010\n0001\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n1001\n0000\n1011\n0110\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n0000\n0011\n0000\n0001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0111\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101010101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n0001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001111\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1000\n0000\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1010\n0001\n1010\n", "output": ["6\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n001110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1011\n0000\n", "output": ["10\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n001000011\n101011101\n110001111\n000001111\n100000010\n010110000\n", "output": ["5\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000000001\n001000001\n001011101\n111101111\n000001101\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n8 9\n101110001\n101110100\n000010001\n101000001\n000011001\n110001111\n001001111\n110100110\n010100000\n", "output": ["3\n"]}, {"input": "1\n8 9\n101110001\n101110000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0000\n1010\n0010\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0000\n1110\n0011\n1000\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010001\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1001\n0110\n0110\n0001\n0001\n", "output": ["13\n"]}, {"input": "1\n9 9\n011110001\n101110100\n000110011\n100000001\n000010101\n110001110\n000001111\n110100000\n010110000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1100\n0000\n0111\n0100\n0000\n", "output": ["11\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1010\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n011000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0000\n", "output": ["9\n"]}, {"input": "1\n8 9\n101110001\n101010000\n000010001\n001000001\n000011001\n010001111\n000001111\n110100010\n000100100\n", "output": ["4\n"]}, {"input": "1\n5 4\n1000\n0110\n0010\n0001\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0010\n1100\n", "output": ["11\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1000\n", "output": ["12\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110110000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1011\n0110\n0110\n0001\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n0000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n0001\n1110\n0001\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010110000\n", "output": ["4\n"]}, {"input": "1\n5 4\n1010\n0011\n0110\n1001\n0001\n", "output": ["9\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1100\n", "output": ["10\n"]}, {"input": "1\n5 4\n1000\n0100\n1110\n0011\n1100\n", "output": ["11\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000010011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["6\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0001\n0001\n", "output": ["11\n"]}, {"input": "1\n5 4\n1100\n0100\n0111\n0100\n1000\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0001\n1000\n", "output": ["7\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1010\n0011\n0111\n1001\n0001\n", "output": ["8\n"]}, {"input": "1\n5 4\n1001\n0010\n1010\n0011\n1101\n", "output": ["10\n"]}, {"input": "1\n9 9\n001010000\n101110100\n000110011\n100000101\n101011101\n110001111\n000000111\n110110000\n110100000\n", "output": ["5\n"]}, {"input": "1\n5 4\n1111\n0110\n0110\n0011\n0001\n", "output": ["12\n"]}, {"input": "1\n5 4\n0011\n1001\n1110\n0011\n1000\n", "output": ["8\n"]}, {"input": "1\n9 9\n101010001\n101110100\n010010011\n001000000\n101110101\n110001111\n000001111\n110100010\n010100100\n", "output": ["5\n"]}], "task_id": "codecontest/20", "prompt": "CQXYM discovered a rectangle A with dimensions n \u00d7 m, consisting of n rows and m columns of blocks, where each block within this rectangle is either an obsidian block or empty, and CQXYM has the ability to transform an obsidian block into an empty block or vice versa with a single operation. A rectangle M with dimensions a \u00d7 b is defined as a portal if it meets the following criteria: a must be at least 5, and b must be no less than 4, and for every 1 < x < a, the blocks located at M_{x,1} and M_{x,b} must be obsidian blocks, while for every 1 < x < b, the blocks at M_{1,x} and M_{a,x} need to be obsidian blocks, plus for all 1 < x < a, 1 < y < b, block M_{x,y} must be empty, and the blocks located at M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type. It's important to note that the arrangement must include a rows and b columns, instead of b rows and a columns, and the blocks at the corners can be of any type. CQXYM is curious about the minimum number of changes he must perform for at least one sub-rectangle to become a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "repair_prompt": ["CQXYM discovered a rectangle A with dimensions n \u00d7 m, consisting of n rows and m columns of blocks, where each block within this rectangle is either an obsidian block or empty, and CQXYM has the ability to transform an obsidian block into an empty block or vice versa with a single operation. A rectangle M with dimensions a \u00d7 b is defined as a portal if it meets the following criteria: a must be at least 5, and b must be no less than 4, and for every 1 < x < a, the blocks located at M_{x,1} and M_{x,b} must be obsidian blocks, while for every 1 < x < b, the blocks at M_{1,x} and M_{a,x} need to be obsidian blocks, plus for all 1 < x < a, 1 < y < b, block M_{x,y} must be empty, and the blocks located at M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be of any type. It's important to note that the arrangement must include a rows and b columns, instead of b rows and a columns, and the blocks at the corners can be of any type. CQXYM is curious about the minimum number of changes he must perform for at least one sub-rectangle to become a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    \n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_changes_to_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of '0's and '1's.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_changes = float('inf')\n\n        # Iterate over all possible top-left corners of the sub-rectangle\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                # Iterate over all possible dimensions of the sub-rectangle\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        changes = calculate_changes(grid, start_row, start_col, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: List[str], start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (List[str]): The grid of '0's and '1's.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions for the portal\n    for x in range(1, a - 1):\n        if grid[start_row + x][start_col] != '1':\n            changes += 1\n        if grid[start_row + x][start_col + b - 1] != '1':\n            changes += 1\n\n    for y in range(1, b - 1):\n        if grid[start_row][start_col + y] != '1':\n            changes += 1\n        if grid[start_row + a - 1][start_col + y] != '1':\n            changes += 1\n\n    # Check the inner part of the portal\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x][start_col + y] != '0':\n                changes += 1\n\n    return changes\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Output interface\n    results = min_changes_to_portal(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required for each test case to form a portal.\n    \n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing (n, m, grid).\n        \n    Returns:\n        list: List of minimum changes for each test case.\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(row) for row in grid], dtype=int)\n        \n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for start_row in range(n - 4):\n            for start_col in range(m - 3):\n                for a in range(5, n - start_row + 1):\n                    for b in range(4, m - start_col + 1):\n                        # Calculate changes needed for current sub-rectangle\n                        changes = calculate_changes(grid_array, start_row, start_col, a, b)\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes needed to transform a sub-rectangle into a portal.\n    \n    Args:\n        grid (np.ndarray): The grid as a numpy array.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n        \n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n    \n    # Check the border conditions\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n    \n    # Check the interior conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, matrix) where matrix is a list of strings\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, matrix in test_cases:\n        # Convert the matrix into a numpy array for efficient manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        \n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid[i:i+a, j:j+b]\n                        \n                        # Calculate the number of changes needed to transform this sub-rectangle into a portal\n                        changes = calculate_changes_to_portal(sub_rect, a, b)\n                        \n                        # Update the minimum changes found\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a given sub-rectangle into a portal.\n\n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes required\n    \"\"\"\n    changes = 0\n    \n    # Check the borders and inner area according to portal rules\n    for x in range(a):\n        for y in range(b):\n            if x == 0 or x == a - 1 or y == 0 or y == b - 1:\n                # Border conditions\n                if (x == 0 or x == a - 1) and (y > 0 and y < b - 1):\n                    # Top and bottom borders except corners\n                    if sub_rect[x, y] != 1:\n                        changes += 1\n                elif (y == 0 or y == b - 1) and (x > 0 and x < a - 1):\n                    # Left and right borders except corners\n                    if sub_rect[x, y] != 1:\n                        changes += 1\n            else:\n                # Inner area\n                if sub_rect[x, y] != 0:\n                    changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Function call\nresults = min_changes_to_portal(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of transformations required to convert a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing the dimensions and matrix of blocks.\n\n    Returns:\n        list: List of integers representing the minimum number of changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate the number of changes needed for the sub-rectangle starting at (i, j)\n                        changes = calculate_changes(matrix, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to convert a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The matrix of blocks.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions\n    for x in range(1, a - 1):\n        if matrix[start_row + x, start_col] != 1:\n            changes += 1\n        if matrix[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if matrix[start_row, start_col + y] != 1:\n            changes += 1\n        if matrix[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().strip())) for _ in range(n)]\n    test_cases.append((n, m, np.array(matrix)))\n\n# Call the function and print results\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_changes_for_portal(t: int, test_cases: List[List[str]]) -> List[int]:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of test cases, each containing a grid of blocks.\n\n    Returns:\n        List[int]: List of minimum changes required for each test case.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        min_changes = float('inf')\n\n        # Precompute the number of obsidian blocks in each row and column\n        row_obsidian_count = [[0] * (m + 1) for _ in range(n + 1)]\n        col_obsidian_count = [[0] * (m + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                row_obsidian_count[i][j] = row_obsidian_count[i][j - 1] + (1 if grid[i - 1][j - 1] == '1' else 0)\n                col_obsidian_count[i][j] = col_obsidian_count[i - 1][j] + (1 if grid[i - 1][j - 1] == '1' else 0)\n\n        # Iterate over all possible sub-rectangles of valid dimensions\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        changes = 0\n\n                        # Calculate changes for the top and bottom borders\n                        for x in range(1, b - 1):\n                            if grid[i][j + x] != '1':\n                                changes += 1\n                            if grid[i + a - 1][j + x] != '1':\n                                changes += 1\n\n                        # Calculate changes for the left and right borders\n                        for y in range(1, a - 1):\n                            if grid[i + y][j] != '1':\n                                changes += 1\n                            if grid[i + y][j + b - 1] != '1':\n                                changes += 1\n\n                        # Calculate changes for the inner area\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[i + x][j + y] != '0':\n                                    changes += 1\n\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append(grid)\n\n# Output interface\nresults = min_changes_for_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of tuples, each containing n, m, and the matrix.\n\n    Returns:\n        list: Minimum number of changes for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, matrix in test_cases:\n        # Convert the matrix into a numpy array for efficient manipulation\n        grid = np.array([list(row) for row in matrix], dtype=int)\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    Args:\n        grid (np.ndarray): The grid representing the matrix.\n        start_row (int): Starting row of the sub-rectangle.\n        start_col (int): Starting column of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes required.\n    \"\"\"\n    changes = 0\n\n    # Check the borders and inner area of the sub-rectangle\n    for x in range(a):\n        for y in range(b):\n            current_value = grid[start_row + x, start_col + y]\n            if x == 0 or x == a - 1:\n                if y > 0 and y < b - 1 and current_value != 1:\n                    changes += 1\n            elif y == 0 or y == b - 1:\n                if x > 0 and x < a - 1 and current_value != 1:\n                    changes += 1\n            else:\n                if current_value != 0:\n                    changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, matrix))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"Calculate the minimum number of transformations required to convert a sub-rectangle into a portal.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list): List of numpy arrays representing each test case matrix.\n\n    Returns:\n        list: List of integers representing the minimum number of changes for each test case.\n    \"\"\"\n    results = []\n\n    for matrix in test_cases:\n        n, m = matrix.shape\n        min_changes = float('inf')\n\n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        changes = calculate_changes(matrix, i, j, a, b)\n                        min_changes = min(min_changes, changes)\n\n        results.append(min_changes)\n\n    return results\n\ndef calculate_changes(matrix: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"Calculate the number of changes needed to convert a sub-rectangle into a portal.\n\n    Args:\n        matrix (np.ndarray): The matrix representing the test case.\n        start_row (int): Starting row index of the sub-rectangle.\n        start_col (int): Starting column index of the sub-rectangle.\n        a (int): Number of rows in the sub-rectangle.\n        b (int): Number of columns in the sub-rectangle.\n\n    Returns:\n        int: Number of changes needed.\n    \"\"\"\n    changes = 0\n\n    # Check the border conditions\n    for x in range(1, a - 1):\n        if matrix[start_row + x, start_col] != 1:\n            changes += 1\n        if matrix[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n\n    for y in range(1, b - 1):\n        if matrix[start_row, start_col + y] != 1:\n            changes += 1\n        if matrix[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n\n    # Check the inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if matrix[start_row + x, start_col + y] != 0:\n                changes += 1\n\n    return changes\n\n# Input interface\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().strip())) for _ in range(n)]\n    test_cases.append(np.array(matrix))\n\n# Call the function and print the results\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required for each test case to form a portal.\n    \n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid)\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        grid = np.array([list(row) for row in grid], dtype=int)\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        sub_rect = grid[i:i+a, j:j+b]\n                        changes = calculate_changes(sub_rect, a, b)\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a sub-rectangle into a portal.\n    \n    :param sub_rect: The sub-rectangle of the grid\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: The number of changes required\n    \"\"\"\n    changes = 0\n    \n    # Check the border conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n    \n    # Check the inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required for each test case to form a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to a numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of size at least 5x4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Extract the sub-rectangle\n                        sub_rect = grid_array[i:i+a, j:j+b]\n                        \n                        # Calculate the number of changes needed to make this sub-rectangle a portal\n                        changes = calculate_changes_to_portal(sub_rect, a, b)\n                        \n                        # Update the minimum changes if this is a better solution\n                        if changes < min_changes:\n                            min_changes = changes\n        \n        # Append the result for this test case\n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes_to_portal(sub_rect: np.ndarray, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    :param sub_rect: The sub-rectangle as a numpy array\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: The number of changes required\n    \"\"\"\n    changes = 0\n    \n    # Check the border conditions\n    for x in range(1, a - 1):\n        if sub_rect[x, 0] != 1:\n            changes += 1\n        if sub_rect[x, b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if sub_rect[0, y] != 1:\n            changes += 1\n        if sub_rect[a - 1, y] != 1:\n            changes += 1\n    \n    # Check the inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if sub_rect[x, y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\n\ndef min_changes_to_portal(t: int, test_cases: list) -> list:\n    \"\"\"\n    Calculate the minimum number of changes required for each test case to form a portal.\n\n    :param t: Number of test cases\n    :param test_cases: List of tuples, each containing (n, m, grid) where grid is a list of strings\n    :return: List of integers representing the minimum changes for each test case\n    \"\"\"\n    results = []\n    \n    for n, m, grid in test_cases:\n        # Convert grid to numpy array for efficient operations\n        grid_array = np.array([list(map(int, row)) for row in grid])\n        \n        # Initialize the minimum changes to a large number\n        min_changes = float('inf')\n        \n        # Iterate over all possible sub-rectangles of valid dimensions\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        # Calculate changes needed for the current sub-rectangle\n                        changes = calculate_changes(grid_array, i, j, a, b)\n                        # Update the minimum changes if the current one is smaller\n                        min_changes = min(min_changes, changes)\n        \n        results.append(min_changes)\n    \n    return results\n\ndef calculate_changes(grid: np.ndarray, start_row: int, start_col: int, a: int, b: int) -> int:\n    \"\"\"\n    Calculate the number of changes required to transform a sub-rectangle into a portal.\n\n    :param grid: The grid as a numpy array\n    :param start_row: Starting row of the sub-rectangle\n    :param start_col: Starting column of the sub-rectangle\n    :param a: Number of rows in the sub-rectangle\n    :param b: Number of columns in the sub-rectangle\n    :return: Number of changes required\n    \"\"\"\n    changes = 0\n    \n    # Check the border conditions\n    for x in range(1, a - 1):\n        if grid[start_row + x, start_col] != 1:\n            changes += 1\n        if grid[start_row + x, start_col + b - 1] != 1:\n            changes += 1\n    \n    for y in range(1, b - 1):\n        if grid[start_row, start_col + y] != 1:\n            changes += 1\n        if grid[start_row + a - 1, start_col + y] != 1:\n            changes += 1\n    \n    # Check the inner conditions\n    for x in range(1, a - 1):\n        for y in range(1, b - 1):\n            if grid[start_row + x, start_col + y] != 0:\n                changes += 1\n    \n    return changes\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresults = min_changes_to_portal(t, test_cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires transforming a given grid into a specific pattern with minimal changes. The constraints on the grid size and the number of test cases suggest that the solution should be efficient and scalable. The main challenge is to identify the sub-rectangle that can be transformed into a portal with the least number of operations.\nrequirement pool:\n- Develop an algorithm to identify the optimal sub-rectangle for transformation.\n- Implement a method to calculate the minimum number of changes required.\n- Ensure the solution handles edge cases and maximum constraints efficiently.\n- Optimize the algorithm for performance on larger grids.\n- Provide detailed output for debugging and analysis.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given grid. For each sub-rectangle, we will calculate the number of changes required to transform it into a portal. The solution will iterate over all possible starting points and dimensions of sub-rectangles, ensuring that the constraints for a portal are met. This approach is feasible given the constraints, as the maximum grid size is 400x400, and the number of test cases is limited.\n", "requirement analysis:\nThe problem requires determining the minimum number of changes needed to transform a sub-rectangle of a given grid into a portal. The portal has specific requirements for its border and interior blocks. The solution must efficiently handle multiple test cases and large grid sizes, ensuring that the constraints are respected.\nrequirement pool:\n- Implement the main algorithm to find the minimum number of changes for a portal.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is tested against various edge cases.\n- Provide clear and concise output for each test case.\n- Consider user interface improvements for better visualization of the grid and changes.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are clear, ensuring the solution must efficiently handle the transformation within the given limits. The output format is crucial for validation against multiple test cases.\nrequirement pool:\n- Implement efficient transformation algorithm\n- Ensure minimal operations for transformation\n- Handle multiple test cases efficiently\n- Provide clear and correct output format\n- Optimize for large input sizes\nWe will implement a function that iterates over all possible sub-rectangles of the given dimensions and checks if they can be transformed into a portal with the minimum number of changes. We will use numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific block arrangements. The challenge lies in minimizing the number of transformations needed while adhering to the constraints of portal dimensions and block types. Efficient handling of multiple test cases and large input sizes is crucial.\nrequirement pool:\n- Implement efficient block transformation algorithm\n- Ensure accurate calculation of minimum changes\n- Optimize performance for large input sizes\n- Provide clear documentation of transformation process\n- Develop user-friendly interface for input and output\nWe will implement a function to determine the minimum number of transformations required to convert a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of the given dimensions and calculate the number of changes needed for each. We will use numpy for efficient matrix operations and manipulation.\n", "requirement analysis:\nThe problem requires finding the minimum number of changes to transform a sub-rectangle into a portal. The constraints are manageable within the given limits, and the solution should focus on efficiently checking all possible sub-rectangles of valid dimensions.\nrequirement pool:\n- Implement the main algorithm to find the minimum number of changes for a portal.\n- Optimize the solution to handle edge cases and large inputs efficiently.\n- Ensure the output format is consistent with the requirements.\n- Test the solution with various test cases to ensure accuracy.\n- Document the code for better understanding and maintenance.\nWe will implement a function to find the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of valid dimensions (at least 5x4) within the given n x m grid. For each sub-rectangle, we will calculate the number of changes needed to meet the portal criteria. The solution will be optimized by precomputing the number of obsidian blocks in each row and column to quickly assess the changes required for each sub-rectangle.\n", "requirement analysis:\nThe problem requires finding the minimum number of changes to transform a sub-rectangle into a portal. The constraints are manageable, allowing for a solution that efficiently checks possible sub-rectangles and calculates the required changes. The solution should focus on minimizing computational complexity while ensuring accuracy.\nrequirement pool:\n- Implement an efficient algorithm to find the minimum changes for a portal.\n- Ensure the solution handles edge cases and maximum constraints.\n- Optimize the solution for speed and memory usage.\n- Provide clear documentation and comments in the code.\n- Include test cases to validate the solution.\nWe will use a brute-force approach to check all possible sub-rectangles of size at least 5x4 within the given n x m rectangle. For each sub-rectangle, we will calculate the number of changes required to transform it into a portal. The solution will iterate over all possible positions and dimensions of sub-rectangles, ensuring that the constraints are met. We will use numpy for efficient matrix manipulation.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with specific block arrangements. The challenge lies in minimizing the number of transformations needed while adhering to the portal criteria. The solution must efficiently handle multiple test cases and large dimensions, ensuring optimal performance.\nrequirement pool:\n- Implement the main algorithm to transform blocks into a portal.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles large dimensions efficiently.\n- Provide clear and concise output for each test case.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine the minimum number of transformations required to convert a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming a grid of blocks to meet specific portal criteria with minimal changes. The constraints on dimensions and block types are clear, and the solution must efficiently handle multiple test cases while adhering to input/output formats.\nrequirement pool:\n- Implement efficient block transformation algorithm\n- Ensure minimal operations for portal formation\n- Optimize for large grid inputs\n- Provide clear and concise output\n- Enhance user interface for input handling\nWe will implement a function to determine the minimum number of changes required to transform a sub-rectangle into a portal. The approach involves iterating over all possible sub-rectangles of size at least 5x4 and calculating the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are clearly defined, ensuring the solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement the transformation logic for blocks.\n- Optimize the solution for minimal operations.\n- Ensure the solution handles maximum input sizes efficiently.\n- Provide clear and concise output for each test case.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine the minimum number of changes required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of valid dimensions and calculate the number of changes needed for each. We will use numpy for efficient matrix operations and slicing.\n", "requirement analysis:\nThe requirements focus on transforming a given rectangle into a portal with minimal changes. The constraints on dimensions and block types are crucial for determining the solution. The problem requires efficient handling of multiple test cases and ensuring the solution adheres to the specified input-output format.\nrequirement pool:\n- Implement the main algorithm to transform blocks efficiently.\n- Ensure the solution handles multiple test cases correctly.\n- Optimize the algorithm for minimal operations.\n- Provide clear and concise output for each test case.\n- Consider edge cases and large inputs within constraints.\nWe will implement a function to determine the minimum number of changes required to transform a sub-rectangle into a portal. The function will iterate over all possible sub-rectangles of valid dimensions and calculate the number of changes needed to meet the portal criteria. We will use numpy for efficient matrix operations.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 266, "examples": "\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111  \n    ", "mutate_method": "rephrase_one", "parent_index": 127}
