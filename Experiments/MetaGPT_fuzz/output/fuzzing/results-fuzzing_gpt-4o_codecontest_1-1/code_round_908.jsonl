{"name": "1575_I. Illusions of the Desert", "description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.\n\nThe map of the labyrinth forms a tree with n rooms numbered from 1 to n and n - 1 tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.\n\nThe i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, and it takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z.\n\nTo prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries.\n\nThere are two types of queries to be done:\n\n  * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). \n  * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). \n\n\n\nHelp them, so you can get a portion of the treasure!\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "tags": ["data structures", "trees"], "difficulty": 15, "id": 1575, "sample_io": [{"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["39\n32\n0\n"]}], "test_list": [{"input": "2 1\n-1000000000 1000000000\n2 1\n2 1 2\n", "output": ["2000000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000000003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["19\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n30\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["9\n12\n"]}, {"input": "2 1\n-1000000000 1010000000\n2 1\n2 1 2\n", "output": ["2010000000\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2102\n0\n1000002003\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["39\n33\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n32\n23\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n32\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["9\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["35\n29\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["9\n32\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["31\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["3\n26\n22\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n40\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n38\n0\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n29\n0\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["17\n0\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["16\n0\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n19\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n22\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n34\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n8\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["9\n13\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 2 3\n", "output": ["8\n11\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000002003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n22\n15\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["1\n4\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["21\n32\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 6 3\n", "output": ["9\n30\n5\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 0\n2 1 2\n2 5 2\n", "output": ["3\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["17\n45\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n24\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n7\n0\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n25\n"]}, {"input": "6 4\n0 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n21\n0\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n15\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["19\n32\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["21\n0\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1100\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["1\n14\n21\n"]}, {"input": "6 4\n0 -9 2 -1 3 -6\n1 5\n6 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["19\n30\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["38\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["3\n24\n22\n"]}, {"input": "6 3\n0 0 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 4\n1 2 3\n", "output": ["19\n12\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["28\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["0\n4\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 5 2\n", "output": ["1\n5\n9\n"]}, {"input": "6 4\n10 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["26\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["0\n5\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 5\n2 3 3\n", "output": ["5\n5\n0\n"]}, {"input": "2 1\n-1000000000 1000000010\n2 1\n2 1 2\n", "output": ["2000000010\n"]}, {"input": "6 4\n0 -9 2 -1 4 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n22\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["9\n12\n21\n"]}, {"input": "2 1\n-651044801 1010000000\n2 1\n2 1 2\n", "output": ["1661044801\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["10\n0\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n2 3 3\n", "output": ["9\n15\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["35\n35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -2\n2 1 2\n1 3 2\n", "output": ["9\n31\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n30\n0\n"]}, {"input": "6 4\n10 -13 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["35\n0\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["0\n26\n22\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["0\n35\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n23\n"]}, {"input": "6 4\n-1 -9 4 0 8 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["17\n0\n13\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n13\n"]}, {"input": "6 4\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n0\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 2 3\n", "output": ["8\n12\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["39\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n31\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 5\n", "output": ["0\n7\n4\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["37\n0\n0\n"]}, {"input": "4 4\n2 -1000 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n21\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n43\n15\n"]}, {"input": "6 4\n3 -9 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["19\n0\n"]}, {"input": "2 1\n-651044801 1010000100\n2 1\n2 1 2\n", "output": ["1661044901\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["28\n30\n14\n"]}, {"input": "6 4\n0 -6 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n20\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["9\n0\n13\n"]}, {"input": "6 3\n10 -15 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["45\n25\n"]}, {"input": "6 3\n0 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 5\n2 2 3\n", "output": ["8\n8\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 4 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["37\n0\n"]}, {"input": "4 4\n2 -1000 110 4\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1110\n0\n1000000004\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n13\n51\n"]}, {"input": "6 4\n0 -9 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["27\n30\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["51\n25\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["28\n10\n48\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["57\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n31\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n55\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 6\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n24\n0\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["37\n40\n"]}, {"input": "2 1\n-1000000000 1010001000\n2 1\n2 1 2\n", "output": ["2010001000\n"]}, {"input": "6 4\n0 -9 2 -1 4 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 2\n", "output": ["9\n26\n17\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["5\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 2\n", "output": ["1\n34\n"]}, {"input": "6 4\n0 -9 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["17\n35\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["10\n38\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n8\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 6\n", "output": ["16\n0\n10\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["16\n0\n"]}, {"input": "6 4\n0 -12 4 0 14 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["28\n0\n16\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 3\n1 1 -3\n2 1 4\n2 3 3\n", "output": ["29\n8\n0\n"]}, {"input": "6 4\n10 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n27\n0\n"]}, {"input": "6 4\n10 -9 1 -1 4 -6\n1 5\n2 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["49\n32\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 1\n", "output": ["9\n0\n25\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 6\n", "output": ["9\n13\n7\n"]}, {"input": "6 4\n0 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n23\n22\n"]}, {"input": "6 4\n0 -14 4 -1 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 1 3\n", "output": ["17\n45\n35\n"]}, {"input": "6 4\n0 -3 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["0\n23\n0\n"]}, {"input": "6 4\n10 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["11\n24\n"]}, {"input": "6 4\n10 -9 2 -1 6 -6\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["42\n0\n"]}, {"input": "6 4\n1 -9 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -1\n2 1 2\n2 5 2\n", "output": ["4\n24\n22\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n15\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 4\n2 4 3\n", "output": ["0\n4\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n1 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 5\n2 3 6\n", "output": ["0\n5\n2\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 4 3\n", "output": ["9\n13\n21\n"]}, {"input": "6 4\n10 -9 2 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 3 -3\n2 1 2\n2 3 3\n", "output": ["31\n31\n0\n"]}, {"input": "6 4\n0 -9 0 -1 4 -5\n1 6\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["28\n22\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["47\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["0\n28\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["37\n0\n23\n"]}, {"input": "6 4\n0 -9 4 1 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["1\n0\n13\n"]}, {"input": "6 4\n0 -9 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["8\n12\n0\n"]}, {"input": "6 4\n0 -14 4 -1 8 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -3\n2 1 2\n2 3 3\n", "output": ["17\n25\n0\n"]}, {"input": "6 4\n0 -3 2 -1 2 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -3\n2 1 2\n2 1 5\n", "output": ["0\n7\n2\n"]}, {"input": "4 4\n2 -1350 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["1460\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 7 -6\n1 5\n1 4\n5 6\n4 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["10\n14\n24\n"]}, {"input": "6 4\n0 -9 4 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 2 -4\n2 1 2\n2 2 3\n", "output": ["28\n34\n10\n"]}, {"input": "6 3\n0 -17 2 -1 4 -5\n1 5\n3 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["23\n29\n"]}, {"input": "6 4\n0 -9 4 0 0 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 4 2\n2 2 3\n", "output": ["9\n9\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n5 2\n2 3\n2 1 4\n1 1 -3\n2 1 2\n2 5 2\n", "output": ["9\n20\n13\n"]}, {"input": "6 4\n3 -2 2 -1 4 0\n1 5\n5 4\n4 6\n6 2\n6 3\n1 2 4\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["21\n0\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["28\n15\n"]}, {"input": "6 4\n0 -8 0 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["26\n29\n14\n"]}, {"input": "6 3\n10 -21 2 -1 4 -6\n1 5\n5 4\n5 2\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["39\n67\n"]}, {"input": "6 4\n10 -9 2 -1 3 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 3\n", "output": ["37\n23\n"]}, {"input": "6 4\n0 -6 4 0 14 1\n1 6\n5 4\n5 6\n1 2\n6 3\n2 1 4\n1 1 -4\n2 1 2\n2 2 3\n", "output": ["30\n10\n20\n"]}, {"input": "6 3\n0 -17 2 -1 4 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 2 4\n1 2 3\n", "output": ["9\n44\n"]}, {"input": "6 3\n10 -21 2 -1 4 -9\n1 4\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n33\n"]}, {"input": "6 3\n10 -21 2 -1 8 -9\n1 5\n5 4\n5 6\n1 2\n6 3\n2 1 2\n1 1 -3\n2 2 3\n2 3 3\n", "output": ["31\n63\n"]}, {"input": "6 3\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 5\n0 2 3\n", "output": ["9\n7\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n26\n0\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 3 3\n", "output": ["10\n35\n0\n"]}, {"input": "6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -4\n2 1 2\n1 3 3\n", "output": ["31\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["2\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n29\n9\n"]}, {"input": "6 4\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 6\n", "output": ["16\n0\n15\n"]}, {"input": "6 3\n0 -9 4 0 8 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 1\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["0\n0\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["33\n27\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 3 2\n2 3 1\n", "output": ["9\n23\n25\n"]}, {"input": "6 4\n0 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["16\n15\n14\n"]}, {"input": "6 4\n19 -9 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 3 3\n", "output": ["20\n24\n"]}, {"input": "6 4\n0 -9 2 0 14 1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 1 2\n2 2 3\n", "output": ["39\n42\n13\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -4\n2 1 4\n2 5 3\n", "output": ["9\n13\n16\n"]}, {"input": "6 4\n-1 -9 2 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -3\n2 2 2\n2 3 3\n", "output": ["5\n0\n0\n"]}, {"input": "6 4\n10 -25 2 -1 4 -11\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 4 -3\n2 1 2\n2 3 3\n", "output": ["57\n0\n"]}, {"input": "6 4\n0 -9 2 0 8 -4\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["33\n0\n19\n"]}, {"input": "6 4\n0 -9 4 1 -1 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["3\n0\n13\n"]}, {"input": "4 4\n2 -2609 110 3\n4 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2719\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 3 -1 2 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 6\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["9\n26\n15\n"]}, {"input": "6 4\n13 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n1 1 2\n1 3 -3\n2 1 2\n2 2 3\n", "output": ["31\n24\n"]}, {"input": "6 4\n1 -9 4 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -6\n2 1 2\n2 2 3\n", "output": ["10\n35\n25\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n30\n0\n"]}, {"input": "6 4\n10 -3 2 -1 2 -6\n1 4\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 3 -3\n2 1 2\n2 3 6\n", "output": ["0\n31\n9\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["13\n37\n0\n"]}, {"input": "6 4\n1 -1 2 -1 1 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 0\n2 1 2\n2 5 2\n", "output": ["17\n15\n14\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["21\n12\n0\n"]}, {"input": "6 4\n0 -17 2 -1 4 -16\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["42\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n1 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["27\n0\n"]}, {"input": "6 4\n-1 -9 2 -1 0 -9\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -3\n2 1 2\n2 3 5\n", "output": ["21\n30\n20\n"]}, {"input": "6 3\n0 -7 4 -1 10 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n42\n"]}, {"input": "6 4\n4 -9 4 -1 4 -6\n1 2\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -2\n2 1 3\n2 3 3\n", "output": ["13\n36\n0\n"]}, {"input": "6 4\n19 -3 1 -1 0 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n1 1 3\n", "output": ["20\n18\n"]}, {"input": "6 4\n0 -10 3 0 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -4\n2 1 4\n2 1 3\n", "output": ["21\n12\n25\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 1 2\n2 4 4\n", "output": ["13\n27\n0\n"]}, {"input": "6 3\n0 -7 4 -1 10 -3\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["21\n36\n"]}, {"input": "6 4\n0 -16 2 -1 4 -23\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 3\n1 1 -6\n2 1 4\n1 3 3\n", "output": ["56\n15\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n2 2 2\n2 4 4\n", "output": ["13\n0\n0\n"]}, {"input": "6 4\n10 -9 2 -1 3 -1\n1 5\n5 4\n5 6\n6 2\n6 3\n2 3 2\n1 4 -3\n1 2 2\n2 4 4\n", "output": ["13\n0\n"]}, {"input": "4 4\n3 -1000 100 3\n2 1\n3 2\n4 1\n2 1 3\n2 2 2\n1 1 -1000000000\n2 1 4\n", "output": ["2103\n0\n1000000003\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 4\n2 3 2\n", "output": ["9\n12\n23\n"]}, {"input": "6 3\n0 -5 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n1 1 4\n2 2 3\n", "output": ["9\n"]}, {"input": "6 4\n10 -9 2 -1 2 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 2 -5\n2 1 2\n2 3 3\n", "output": ["0\n31\n0\n"]}, {"input": "6 4\n0 -9 4 0 11 0\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 2 3\n", "output": ["22\n0\n13\n"]}, {"input": "6 4\n0 -3 2 -1 2 -12\n1 5\n5 4\n5 6\n6 2\n6 3\n2 2 2\n1 1 -5\n2 1 2\n2 3 3\n", "output": ["0\n36\n0\n"]}, {"input": "6 4\n10 -1 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 3\n2 3 3\n", "output": ["31\n25\n0\n"]}, {"input": "6 4\n0 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 2 2\n2 3 4\n", "output": ["9\n0\n23\n"]}, {"input": "6 4\n0 -9 2 -1 4 -5\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 5\n1 1 -4\n2 1 4\n2 3 3\n", "output": ["4\n13\n0\n"]}, {"input": "4 4\n2 -1000 100 3\n2 1\n3 2\n4 2\n2 2 3\n2 2 2\n1 2 -1000000000\n2 1 4\n", "output": ["1100\n0\n2000000005\n"]}, {"input": "6 4\n0 -4 2 -1 4 -2\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 4\n1 1 -3\n2 1 2\n2 3 3\n", "output": ["9\n19\n0\n"]}], "task_id": "codecontest/8", "prompt": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. They are connected by n - 1 tunnels. This setup guarantees that traveling between any pair of rooms via multiple tunnels is possible. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, which takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c. The variable u denotes the room number, and c represents the new illusion rate value. (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Assume all queries are given in a sequence and must be answered in that order.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "repair_prompt": ["Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions. The map of the labyrinth forms a tree with n rooms numbered from 1 to n. They are connected by n - 1 tunnels. This setup guarantees that traveling between any pair of rooms via multiple tunnels is possible. The i-th room (1 \u2264 i \u2264 n) has a_i illusion rate. To go from the x-th room to the y-th room, there must exist a tunnel between x and y, which takes max(|a_x + a_y|, |a_x - a_y|) energy. |z| denotes the absolute value of z. To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask q queries. There are two types of queries to be done: * 1\\ u\\ c \u2014 The illusion rate of the x-th room is changed to c. The variable u denotes the room number, and c represents the new illusion rate value. (1 \u2264 u \u2264 n, 0 \u2264 |c| \u2264 10^9). * 2\\ u\\ v \u2014 Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room v if they are initially at room u (1 \u2264 u, v \u2264 n). Help them, so you can get a portion of the treasure! Assume all queries are given in a sequence and must be answered in that order.\n\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specified room.\n\n    Args:\n        room: The room number whose illusion rate is to be updated.\n        new_rate: The new illusion rate for the room.\n        illusion_rates: The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_minimum_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to traverse from room u to room v.\n\n    Args:\n        u: The starting room number.\n        v: The destination room number.\n        illusion_rates: The list of current illusion rates for all rooms.\n        tree: The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        The minimum energy required to traverse from room u to room v.\n    \"\"\"\n    # Preprocess the tree to find the LCA and path\n    parent = [-1] * (len(tree))\n    depth = [-1] * (len(tree))\n    visited = [False] * (len(tree))\n    \n    def dfs(node: int, par: int, dep: int):\n        \"\"\"Depth First Search to set parent and depth for each node.\"\"\"\n        visited[node] = True\n        parent[node] = par\n        depth[node] = dep\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node, dep + 1)\n    \n    def lca(x: int, y: int) -> int:\n        \"\"\"Find the Lowest Common Ancestor of nodes x and y.\"\"\"\n        if depth[x] < depth[y]:\n            x, y = y, x\n        # Bring x and y to the same depth\n        while depth[x] > depth[y]:\n            x = parent[x]\n        while x != y:\n            x = parent[x]\n            y = parent[y]\n        return x\n    \n    def path_energy(x: int, y: int) -> int:\n        \"\"\"Calculate the energy required to traverse the path from x to y.\"\"\"\n        energy = 0\n        while x != y:\n            energy += max(abs(illusion_rates[x - 1] + illusion_rates[parent[x] - 1]),\n                          abs(illusion_rates[x - 1] - illusion_rates[parent[x] - 1]))\n            x = parent[x]\n        return energy\n    \n    # Start DFS from node 1 (assuming 1-based index)\n    dfs(1, -1, 0)\n    \n    # Find LCA of u and v\n    ancestor = lca(u, v)\n    \n    # Calculate energy from u to ancestor and v to ancestor\n    energy_u_to_ancestor = path_energy(u, ancestor)\n    energy_v_to_ancestor = path_energy(v, ancestor)\n    \n    # Total energy is the sum of both paths\n    total_energy = energy_u_to_ancestor + energy_v_to_ancestor\n    \n    return total_energy\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n            update_illusion_rate(u, c, illusion_rates)\n        elif query_type == 2:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            result = calculate_minimum_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: list) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\n\n    Args:\n        room (int): The room number whose illusion rate is to be updated.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (list): List of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\n\ndef calculate_min_energy(start_room: int, end_room: int, illusion_rates: list, tunnels: list) -> int:\n    \"\"\"Calculates the minimum energy required to move between two rooms.\n\n    Args:\n        start_room (int): The starting room number.\n        end_room (int): The destination room number.\n        illusion_rates (list): List of current illusion rates for all rooms.\n        tunnels (list): List of tuples representing tunnels between rooms.\n\n    Returns:\n        int: The minimum energy required to move from start_room to end_room.\n    \"\"\"\n    from collections import defaultdict, deque\n\n    # Build adjacency list for the tree structure\n    adjacency_list = defaultdict(list)\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    # Perform BFS to find the path from start_room to end_room\n    def bfs_path(start, end):\n        queue = deque([(start, [start])])\n        visited = set()\n        while queue:\n            current, path = queue.popleft()\n            if current == end:\n                return path\n            visited.add(current)\n            for neighbor in adjacency_list[current]:\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n        return []\n\n    path = bfs_path(start_room, end_room)\n    if not path:\n        return 0\n\n    # Calculate the energy cost along the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        room1 = path[i]\n        room2 = path[i + 1]\n        energy_cost = max(abs(illusion_rates[room1 - 1] + illusion_rates[room2 - 1]),\n                          abs(illusion_rates[room1 - 1] - illusion_rates[room2 - 1]))\n        total_energy += energy_cost\n\n    return total_energy\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Parse input\n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n\n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n\n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n\n    queries = []\n    for _ in range(q):\n        queries.append(data[index:index + 3])\n        index += 3\n\n    # Process queries\n    for query in queries:\n        if query[0] == '1':\n            room = int(query[1])\n            new_rate = int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates)\n        elif query[0] == '2':\n            start_room = int(query[1])\n            end_room = int(query[2])\n            result = calculate_min_energy(start_room, end_room, illusion_rates, tunnels)\n            print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef handle_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    \"\"\"Handles queries to update illusion rates and calculate minimum energy paths.\n\n    Args:\n        n (int): Number of rooms in the maze.\n        q (int): Number of queries.\n        illusion_rates (List[int]): Initial illusion rates of each room.\n        tunnels (List[Tuple[int, int]]): Connections between rooms forming a tree.\n        queries (List[Tuple[int, int, int]]): Queries to process.\n\n    Returns:\n        List[int]: Results for type 2 queries.\n    \"\"\"\n    # Initialize adjacency list for the tree\n    adjacency_list = [[] for _ in range(n + 1)]\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n\n    # Prepare for DFS and LCA\n    parent = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n\n    def dfs(node: int, dep: int):\n        \"\"\"Performs Depth First Search to set parent and depth arrays.\"\"\"\n        visited[node] = True\n        depth[node] = dep\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                dfs(neighbor, dep + 1)\n\n    # Start DFS from node 1 (assuming 1 is the root)\n    dfs(1, 0)\n\n    def lca(u: int, v: int) -> int:\n        \"\"\"Finds the Lowest Common Ancestor of nodes u and v.\"\"\"\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u and v to the same depth\n        while depth[u] > depth[v]:\n            u = parent[u]\n        while u != v:\n            u = parent[u]\n            v = parent[v]\n        return u\n\n    def calculate_energy(u: int, v: int) -> int:\n        \"\"\"Calculates the minimum energy required to travel from u to v.\"\"\"\n        ancestor = lca(u, v)\n        energy = 0\n        # Traverse from u to ancestor\n        while u != ancestor:\n            energy += max(abs(illusion_rates[u - 1] + illusion_rates[parent[u] - 1]),\n                          abs(illusion_rates[u - 1] - illusion_rates[parent[u] - 1]))\n            u = parent[u]\n        # Traverse from v to ancestor\n        while v != ancestor:\n            energy += max(abs(illusion_rates[v - 1] + illusion_rates[parent[v] - 1]),\n                          abs(illusion_rates[v - 1] - illusion_rates[parent[v] - 1]))\n            v = parent[v]\n        return energy\n\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            # Update illusion rate\n            u, c = query[1], query[2]\n            illusion_rates[u - 1] = c\n        elif query[0] == 2:\n            # Calculate minimum energy path\n            u, v = query[1], query[2]\n            results.append(calculate_energy(u, v))\n\n    return results\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print results for type 2 queries\nresults = handle_queries(n, q, illusion_rates, tunnels, queries)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple, Dict\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specified room.\n\n    Args:\n        room (int): The room number whose illusion rate is to be updated.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): List of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\n\n    Args:\n        u (int): The starting room number.\n        v (int): The destination room number.\n        illusion_rates (List[int]): List of current illusion rates for all rooms.\n        tunnels (List[Tuple[int, int]]): List of tunnels connecting the rooms.\n\n    Returns:\n        int: The minimum energy required for the journey.\n    \"\"\"\n    # Build adjacency list for the tree\n    adjacency_list = build_adjacency_list(tunnels, len(illusion_rates))\n    \n    # Find path from u to v using DFS\n    path = find_path_dfs(u, v, adjacency_list)\n    \n    # Calculate energy for the path\n    energy = calculate_energy_for_path(path, illusion_rates)\n    \n    return energy\n\ndef build_adjacency_list(tunnels: List[Tuple[int, int]], n: int) -> Dict[int, List[int]]:\n    \"\"\"Builds an adjacency list representation of the tree.\n\n    Args:\n        tunnels (List[Tuple[int, int]]): List of tunnels connecting the rooms.\n        n (int): Number of rooms.\n\n    Returns:\n        Dict[int, List[int]]: Adjacency list of the tree.\n    \"\"\"\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for s, t in tunnels:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    return adjacency_list\n\ndef find_path_dfs(start: int, end: int, adjacency_list: Dict[int, List[int]]) -> List[int]:\n    \"\"\"Finds a path from start to end using DFS.\n\n    Args:\n        start (int): Starting room number.\n        end (int): Destination room number.\n        adjacency_list (Dict[int, List[int]]): Adjacency list of the tree.\n\n    Returns:\n        List[int]: List of room numbers representing the path from start to end.\n    \"\"\"\n    stack = [(start, [start])]\n    visited = set()\n    \n    while stack:\n        current, path = stack.pop()\n        if current == end:\n            return path\n        visited.add(current)\n        for neighbor in adjacency_list[current]:\n            if neighbor not in visited:\n                stack.append((neighbor, path + [neighbor]))\n    return []\n\ndef calculate_energy_for_path(path: List[int], illusion_rates: List[int]) -> int:\n    \"\"\"Calculates the total energy required for a given path.\n\n    Args:\n        path (List[int]): List of room numbers representing the path.\n        illusion_rates (List[int]): List of current illusion rates for all rooms.\n\n    Returns:\n        int: Total energy required for the path.\n    \"\"\"\n    total_energy = 0\n    for i in range(len(path) - 1):\n        room1 = path[i]\n        room2 = path[i + 1]\n        energy = max(abs(illusion_rates[room1 - 1] + illusion_rates[room2 - 1]),\n                     abs(illusion_rates[room1 - 1] - illusion_rates[room2 - 1]))\n        total_energy += energy\n    return total_energy\n\n# Input interface\nn, q = map(int, input().split())\nillusion_rates = list(map(int, input().split()))\ntunnels = [tuple(map(int, input().split())) for _ in range(n - 1)]\nqueries = [input().split() for _ in range(q)]\n\n# Output interface\nfor query in queries:\n    if query[0] == '1':\n        room, new_rate = int(query[1]), int(query[2])\n        update_illusion_rate(room, new_rate, illusion_rates)\n    elif query[0] == '2':\n        u, v = int(query[1]), int(query[2])\n        result = calculate_min_energy(u, v, illusion_rates, tunnels)\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        self.depth = [0] * (n + 1)\n        self.parent = [0] * (n + 1)\n        self.segment_tree = [0] * (4 * n)\n        self.build_tree(tunnels)\n        self.dfs(1, 0)\n\n    def build_tree(self, tunnels: List[Tuple[int, int]]) -> None:\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n\n    def dfs(self, node: int, par: int) -> None:\n        self.parent[node] = par\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.depth[neighbor] = self.depth[node] + 1\n                self.dfs(neighbor, node)\n\n    def update_illusion_rate(self, room: int, new_rate: int) -> None:\n        self.illusion_rates[room - 1] = new_rate\n        self.update_segment_tree(1, 1, self.n, room, new_rate)\n\n    def update_segment_tree(self, node: int, start: int, end: int, idx: int, value: int) -> None:\n        if start == end:\n            self.segment_tree[node] = value\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update_segment_tree(2 * node, start, mid, idx, value)\n            else:\n                self.update_segment_tree(2 * node + 1, mid + 1, end, idx, value)\n            self.segment_tree[node] = max(self.segment_tree[2 * node], self.segment_tree[2 * node + 1])\n\n    def minimum_energy(self, u: int, v: int) -> int:\n        lca = self.find_lca(u, v)\n        return self.calculate_energy(u, lca) + self.calculate_energy(v, lca)\n\n    def find_lca(self, u: int, v: int) -> int:\n        if self.depth[u] < self.depth[v]:\n            u, v = v, u\n        while self.depth[u] > self.depth[v]:\n            u = self.parent[u]\n        while u != v:\n            u = self.parent[u]\n            v = self.parent[v]\n        return u\n\n    def calculate_energy(self, u: int, v: int) -> int:\n        energy = 0\n        while u != v:\n            energy += max(abs(self.illusion_rates[u - 1] + self.illusion_rates[self.parent[u] - 1]),\n                          abs(self.illusion_rates[u - 1] - self.illusion_rates[self.parent[u] - 1]))\n            u = self.parent[u]\n        return energy\n\ndef process_queries(n: int, q: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]:\n    maze = Maze(n, illusion_rates, tunnels)\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            _, room, new_rate = query\n            maze.update_illusion_rate(room, new_rate)\n        elif query[0] == 2:\n            _, u, v = query\n            results.append(maze.minimum_energy(u, v))\n    return results\n\n# Input and output interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, q = int(data[0]), int(data[1])\n    illusion_rates = list(map(int, data[2:n+2]))\n    tunnels = [tuple(map(int, data[i:i+2])) for i in range(n+2, n+2+(n-1)*2, 2)]\n    queries = [tuple(map(int, data[i:i+3])) for i in range(n+2+(n-1)*2, len(data), 3)]\n    \n    results = process_queries(n, q, illusion_rates, tunnels, queries)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass Maze:\n    def __init__(self, n: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]):\n        self.n = n\n        self.illusion_rates = illusion_rates\n        self.adj_list = [[] for _ in range(n + 1)]\n        for u, v in tunnels:\n            self.adj_list[u].append(v)\n            self.adj_list[v].append(u)\n        self.parent = [-1] * (n + 1)\n        self.depth = [0] * (n + 1)\n        self.dfs(1, -1, 0)\n\n    def dfs(self, node: int, par: int, dep: int):\n        self.parent[node] = par\n        self.depth[node] = dep\n        for neighbor in self.adj_list[node]:\n            if neighbor != par:\n                self.dfs(neighbor, node, dep + 1)\n\n    def update_illusion_rate(self, room_number: int, new_rate: int) -> None:\n        self.illusion_rates[room_number - 1] = new_rate\n\n    def calculate_min_energy_path(self, start_room: int, end_room: int) -> int:\n        path = self.find_path(start_room, end_room)\n        total_energy = 0\n        for i in range(len(path) - 1):\n            u, v = path[i], path[i + 1]\n            energy = max(abs(self.illusion_rates[u - 1] + self.illusion_rates[v - 1]),\n                         abs(self.illusion_rates[u - 1] - self.illusion_rates[v - 1]))\n            total_energy += energy\n        return total_energy\n\n    def find_path(self, start: int, end: int) -> List[int]:\n        path_start = []\n        path_end = []\n        while start != -1:\n            path_start.append(start)\n            start = self.parent[start]\n        while end != -1:\n            path_end.append(end)\n            end = self.parent[end]\n        path_start.reverse()\n        path_end.reverse()\n        i = 0\n        while i < len(path_start) and i < len(path_end) and path_start[i] == path_end[i]:\n            i += 1\n        return path_start[:i] + path_end[i - 1::-1]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n    \n    maze = Maze(n, illusion_rates, tunnels)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        if query_type == 1:\n            room_number = int(data[index + 1])\n            new_rate = int(data[index + 2])\n            maze.update_illusion_rate(room_number, new_rate)\n            index += 3\n        elif query_type == 2:\n            start_room = int(data[index + 1])\n            end_room = int(data[index + 2])\n            result = maze.calculate_min_energy_path(start_room, end_room)\n            results.append(result)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: List[int]) -> None:\n    \"\"\"Update the illusion rate of a specific room in the segment tree.\n\n    Args:\n        room: The room number whose illusion rate is to be updated.\n        new_rate: The new illusion rate for the room.\n        illusion_rates: The list of current illusion rates for all rooms.\n        segment_tree: The segment tree data structure for efficient updates.\n    \"\"\"\n    # Update the illusion rate in the original list\n    illusion_rates[room - 1] = new_rate\n    # Update the segment tree\n    update_segment_tree(segment_tree, 0, len(illusion_rates) - 1, room - 1, new_rate, 0)\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tree: List[List[int]]) -> int:\n    \"\"\"Calculate the minimum energy required to travel from room u to room v.\n\n    Args:\n        u: The starting room number.\n        v: The destination room number.\n        illusion_rates: The list of current illusion rates for all rooms.\n        tree: The adjacency list representing the tree structure of the maze.\n\n    Returns:\n        The minimum energy required to travel from room u to room v.\n    \"\"\"\n    # Perform DFS to find the path from u to v\n    path = []\n    visited = [False] * len(tree)\n    dfs_find_path(u, v, tree, visited, path)\n\n    # Calculate the energy required for the path\n    energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        energy += max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n    \n    return energy\n\ndef dfs_find_path(current: int, target: int, tree: List[List[int]], visited: List[bool], path: List[int]) -> bool:\n    \"\"\"Helper function to perform DFS and find the path from current to target.\n\n    Args:\n        current: The current room number in DFS.\n        target: The target room number to reach.\n        tree: The adjacency list representing the tree structure of the maze.\n        visited: A list to keep track of visited rooms.\n        path: The path from the starting room to the target room.\n\n    Returns:\n        True if the path is found, otherwise False.\n    \"\"\"\n    visited[current] = True\n    path.append(current)\n\n    if current == target:\n        return True\n\n    for neighbor in tree[current]:\n        if not visited[neighbor]:\n            if dfs_find_path(neighbor, target, tree, visited, path):\n                return True\n\n    path.pop()\n    return False\n\ndef build_segment_tree(illusion_rates: List[int]) -> List[int]:\n    \"\"\"Build a segment tree from the given illusion rates.\n\n    Args:\n        illusion_rates: The list of current illusion rates for all rooms.\n\n    Returns:\n        The segment tree built from the illusion rates.\n    \"\"\"\n    n = len(illusion_rates)\n    segment_tree = [0] * (4 * n)\n    build_tree(illusion_rates, segment_tree, 0, n - 1, 0)\n    return segment_tree\n\ndef build_tree(illusion_rates: List[int], segment_tree: List[int], start: int, end: int, node: int) -> None:\n    \"\"\"Helper function to build the segment tree.\n\n    Args:\n        illusion_rates: The list of current illusion rates for all rooms.\n        segment_tree: The segment tree data structure.\n        start: The starting index of the current segment.\n        end: The ending index of the current segment.\n        node: The current node in the segment tree.\n    \"\"\"\n    if start == end:\n        segment_tree[node] = illusion_rates[start]\n    else:\n        mid = (start + end) // 2\n        build_tree(illusion_rates, segment_tree, start, mid, 2 * node + 1)\n        build_tree(illusion_rates, segment_tree, mid + 1, end, 2 * node + 2)\n        segment_tree[node] = segment_tree[2 * node + 1] + segment_tree[2 * node + 2]\n\ndef update_segment_tree(segment_tree: List[int], start: int, end: int, idx: int, value: int, node: int) -> None:\n    \"\"\"Update the segment tree with a new value at a specific index.\n\n    Args:\n        segment_tree: The segment tree data structure.\n        start: The starting index of the current segment.\n        end: The ending index of the current segment.\n        idx: The index to be updated.\n        value: The new value to be set at the index.\n        node: The current node in the segment tree.\n    \"\"\"\n    if start == end:\n        segment_tree[node] = value\n    else:\n        mid = (start + end) // 2\n        if start <= idx <= mid:\n            update_segment_tree(segment_tree, start, mid, idx, value, 2 * node + 1)\n        else:\n            update_segment_tree(segment_tree, mid + 1, end, idx, value, 2 * node + 2)\n        segment_tree[node] = segment_tree[2 * node + 1] + segment_tree[2 * node + 2]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    segment_tree = build_segment_tree(illusion_rates)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n        \n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates, segment_tree)\n        elif query_type == 2:\n            result = calculate_min_energy(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef update_illusion_rate(illusion_rates: List[int], u: int, c: int) -> None:\n    \"\"\"Update the illusion rate of the specified room.\n\n    Args:\n        illusion_rates: A list of integers representing the illusion rates of each room.\n        u: The room number whose illusion rate needs to be updated.\n        c: The new illusion rate value for the room.\n    \"\"\"\n    illusion_rates[u - 1] = c\n\ndef dfs_lca_preprocessing(n: int, edges: List[Tuple[int, int]]) -> Tuple[List[List[int]], List[int], List[int]]:\n    \"\"\"Perform DFS and LCA preprocessing on the tree.\n\n    Args:\n        n: The number of rooms in the maze.\n        edges: A list of tuples representing the connections between rooms.\n\n    Returns:\n        A tuple containing:\n        - A list of lists representing the adjacency list of the tree.\n        - A list representing the depth of each node.\n        - A list representing the parent of each node.\n    \"\"\"\n    from collections import defaultdict, deque\n\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    depth = [-1] * (n + 1)\n    parent = [-1] * (n + 1)\n    depth[1] = 0\n\n    stack = deque([1])\n    while stack:\n        node = stack.pop()\n        for neighbor in adj_list[node]:\n            if depth[neighbor] == -1:\n                depth[neighbor] = depth[node] + 1\n                parent[neighbor] = node\n                stack.append(neighbor)\n\n    return adj_list, depth, parent\n\ndef lca(u: int, v: int, depth: List[int], parent: List[int]) -> int:\n    \"\"\"Find the Lowest Common Ancestor (LCA) of two nodes.\n\n    Args:\n        u: The first node.\n        v: The second node.\n        depth: A list representing the depth of each node.\n        parent: A list representing the parent of each node.\n\n    Returns:\n        The LCA of nodes u and v.\n    \"\"\"\n    if depth[u] < depth[v]:\n        u, v = v, u\n\n    while depth[u] > depth[v]:\n        u = parent[u]\n\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n\n    return u\n\ndef calculate_minimum_energy(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int, int]], illusion_rates: List[int]) -> List[int]:\n    \"\"\"Calculate the minimum energy required for each query.\n\n    Args:\n        n: The number of rooms in the maze.\n        edges: A list of tuples representing the connections between rooms.\n        queries: A list of tuples representing the queries.\n        illusion_rates: A list of integers representing the illusion rates of each room.\n\n    Returns:\n        A list of integers representing the minimum energy required for each type 2 query.\n    \"\"\"\n    adj_list, depth, parent = dfs_lca_preprocessing(n, edges)\n    results = []\n\n    for query in queries:\n        query_type, u, v = query\n        if query_type == 1:\n            update_illusion_rate(illusion_rates, u, v)\n        elif query_type == 2:\n            lca_node = lca(u, v, depth, parent)\n            energy = 0\n            current = u\n            while current != lca_node:\n                next_node = parent[current]\n                energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_node - 1]),\n                              abs(illusion_rates[current - 1] - illusion_rates[next_node - 1]))\n                current = next_node\n\n            current = v\n            while current != lca_node:\n                next_node = parent[current]\n                energy += max(abs(illusion_rates[current - 1] + illusion_rates[next_node - 1]),\n                              abs(illusion_rates[current - 1] - illusion_rates[next_node - 1]))\n                current = next_node\n\n            results.append(energy)\n\n    return results\n\n# Input and Output Interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    edges = []\n    for _ in range(n - 1):\n        s_i = int(data[index])\n        t_i = int(data[index + 1])\n        edges.append((s_i, t_i))\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        queries.append((query_type, u, v))\n        index += 3\n    \n    results = calculate_minimum_energy(n, edges, queries, illusion_rates)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\nclass SegmentTree:\n    \"\"\"A Segment Tree for efficient updates and queries of illusion rates.\"\"\"\n    \n    def __init__(self, data: List[int]):\n        self.n = len(data)\n        self.tree = [0] * (2 * self.n)\n        self.build(data)\n    \n    def build(self, data: List[int]):\n        \"\"\"Builds the segment tree from the initial data.\"\"\"\n        # Initialize leaves\n        for i in range(self.n):\n            self.tree[self.n + i] = data[i]\n        # Build the tree by calculating parents\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]\n    \n    def update(self, pos: int, value: int):\n        \"\"\"Updates the value at position pos to value.\"\"\"\n        pos += self.n\n        self.tree[pos] = value\n        while pos > 1:\n            pos //= 2\n            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        \"\"\"Queries the sum in the range [left, right).\"\"\"\n        result = 0\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result += self.tree[left]\n                left += 1\n            if right & 1:\n                right -= 1\n                result += self.tree[right]\n            left //= 2\n            right //= 2\n        return result\n\ndef update_illusion_rate(room: int, new_rate: int, illusion_rates: List[int], segment_tree: SegmentTree) -> None:\n    \"\"\"Updates the illusion rate of a specific room.\"\"\"\n    segment_tree.update(room - 1, new_rate)\n    illusion_rates[room - 1] = new_rate\n\ndef calculate_min_energy(u: int, v: int, illusion_rates: List[int], tunnels: List[Tuple[int, int]]) -> int:\n    \"\"\"Calculates the minimum energy required to travel from room u to room v.\"\"\"\n    # Build adjacency list for the tree\n    from collections import defaultdict, deque\n    \n    adj_list = defaultdict(list)\n    for s, t in tunnels:\n        adj_list[s].append(t)\n        adj_list[t].append(s)\n    \n    # Perform BFS to find the path from u to v\n    def bfs(start: int, end: int) -> List[int]:\n        queue = deque([start])\n        parent = {start: None}\n        while queue:\n            node = queue.popleft()\n            if node == end:\n                break\n            for neighbor in adj_list[node]:\n                if neighbor not in parent:\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        \n        # Reconstruct path from u to v\n        path = []\n        step = end\n        while step is not None:\n            path.append(step)\n            step = parent[step]\n        path.reverse()\n        return path\n    \n    path = bfs(u, v)\n    \n    # Calculate the energy required for the path\n    total_energy = 0\n    for i in range(len(path) - 1):\n        x, y = path[i], path[i + 1]\n        energy = max(abs(illusion_rates[x - 1] + illusion_rates[y - 1]), abs(illusion_rates[x - 1] - illusion_rates[y - 1]))\n        total_energy += energy\n    \n    return total_energy\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tunnels = []\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        tunnels.append((s, t))\n        index += 2\n    \n    queries = []\n    for _ in range(q):\n        queries.append(data[index:index + 3])\n        index += 3\n    \n    segment_tree = SegmentTree(illusion_rates)\n    \n    results = []\n    for query in queries:\n        if query[0] == '1':\n            room = int(query[1])\n            new_rate = int(query[2])\n            update_illusion_rate(room, new_rate, illusion_rates, segment_tree)\n        elif query[0] == '2':\n            u = int(query[1])\n            v = int(query[2])\n            result = calculate_min_energy(u, v, illusion_rates, tunnels)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef update_illusion_rate(room_number: int, new_rate: int, illusion_rates: List[int]) -> None:\n    \"\"\"Updates the illusion rate of a specific room.\n\n    Args:\n        room_number (int): The room number whose illusion rate is to be updated.\n        new_rate (int): The new illusion rate for the room.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n    \"\"\"\n    illusion_rates[room_number - 1] = new_rate\n\ndef calculate_min_energy_path(start_room: int, end_room: int, illusion_rates: List[int], tree: Dict[int, List[int]]) -> int:\n    \"\"\"Calculates the minimum energy path between two rooms using DFS.\n\n    Args:\n        start_room (int): The starting room number.\n        end_room (int): The ending room number.\n        illusion_rates (List[int]): The list of current illusion rates for all rooms.\n        tree (Dict[int, List[int]]): The adjacency list representation of the tree.\n\n    Returns:\n        int: The minimum sum of energy needed to travel from start_room to end_room.\n    \"\"\"\n    def dfs(current_room: int, target_room: int, visited: set, current_energy: int) -> int:\n        if current_room == target_room:\n            return current_energy\n        \n        visited.add(current_room)\n        min_energy = float('inf')\n        \n        for neighbor in tree[current_room]:\n            if neighbor not in visited:\n                energy_cost = max(abs(illusion_rates[current_room - 1] + illusion_rates[neighbor - 1]),\n                                  abs(illusion_rates[current_room - 1] - illusion_rates[neighbor - 1]))\n                min_energy = min(min_energy, dfs(neighbor, target_room, visited, current_energy + energy_cost))\n        \n        visited.remove(current_room)\n        return min_energy\n\n    return dfs(start_room, end_room, set(), 0)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    \n    illusion_rates = list(map(int, data[index:index + n]))\n    index += n\n    \n    tree = {i: [] for i in range(1, n + 1)}\n    for _ in range(n - 1):\n        s = int(data[index])\n        t = int(data[index + 1])\n        index += 2\n        tree[s].append(t)\n        tree[t].append(s)\n    \n    results = []\n    for _ in range(q):\n        query_type = int(data[index])\n        u = int(data[index + 1])\n        v = int(data[index + 2])\n        index += 3\n        \n        if query_type == 1:\n            update_illusion_rate(u, v, illusion_rates)\n        elif query_type == 2:\n            result = calculate_min_energy_path(u, v, illusion_rates, tree)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe project requires handling a tree structure with rooms and tunnels, where each room has an illusion rate that can be updated. The main challenge is efficiently processing queries to update illusion rates and calculate the minimum energy required to traverse between rooms. The solution must handle up to 100,000 rooms and queries, ensuring quick response times and accurate calculations.\nrequirement pool:\n- Efficiently handle up to 100,000 queries and rooms.\n- Accurately calculate the minimum energy required for room traversal.\n- Allow quick updates to room illusion rates.\n- Ensure the system is responsive and user-friendly.\n- Provide a clear and intuitive interface for users.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure and calculate the minimum energy required for room traversal. The DFS will help in preprocessing the tree to compute the LCA, which will then be used to determine the path between any two rooms. For updating the illusion rates, we will maintain an array that can be updated in constant time. This approach ensures that both update and query operations are efficient, even for the maximum constraints.\n", "requirement analysis:\nThe requirements focus on efficiently managing a tree-structured maze with dynamic updates to room attributes and calculating path costs. The system must handle large input sizes and provide quick responses to queries, ensuring robustness and accuracy.\nrequirement pool:\n- Implement efficient data structures to handle dynamic updates and queries.\n- Optimize pathfinding algorithms to ensure quick response times.\n- Develop a user-friendly interface for input and output operations.\n- Ensure the system can handle edge cases and invalid inputs gracefully.\n- Provide detailed error messages and logs for debugging purposes.\nWe will use a combination of Depth First Search (DFS) for pathfinding in the tree structure and a Segment Tree for efficiently handling updates to the illusion rates. The Segment Tree will allow us to update and query the minimum energy cost efficiently. This approach is chosen due to the tree structure of the maze and the need for dynamic updates and fast query responses.\n", "requirement analysis:\nThe requirements focus on efficiently managing a tree-structured maze with dynamic updates to room properties and calculating the minimum energy path between rooms. The solution must handle large input sizes and provide quick responses to queries, ensuring robustness and accuracy.\nrequirement pool:\n- Implement efficient data structures to handle dynamic updates and queries.\n- Develop algorithms to calculate minimum energy paths in a tree structure.\n- Optimize performance for handling up to 100,000 queries.\n- Ensure the system is robust against invalid inputs.\n- Provide detailed logging for debugging and performance analysis.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure and dynamic updates. The DFS will help in traversing the tree, while LCA will assist in finding the minimum energy path between two rooms. We will use adjacency lists to represent the tree and segment trees to manage dynamic updates efficiently. Libraries like 'collections' for deque and 'bisect' for efficient list operations will be utilized.\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree structure representing a maze with rooms and tunnels. The main challenge is to process updates to the illusion rates and calculate the minimum energy required for traversal between rooms. The solution must handle up to 100,000 rooms and queries, necessitating an efficient algorithm for both updates and path calculations.\nrequirement pool:\n- Efficiently update the illusion rate of a room.\n- Calculate the minimum energy required for traversal between two rooms.\n- Handle large input sizes without performance degradation.\n- Ensure robustness against invalid inputs.\n- Provide a user-friendly interface for input and output.\nWe will use Depth First Search (DFS) to efficiently traverse the tree structure representing the maze. For handling updates to the illusion rates, we will use an array to store the rates and update them directly. For calculating the minimum energy required for traversal between two rooms, we will precompute the paths using DFS and store the results in a dictionary for quick access during queries. This approach ensures efficient handling of both types of queries and scales well with large input sizes.\n", "requirement analysis:\nThe requirements focus on efficiently processing queries related to room illusion rates and calculating the minimum energy required for movement between rooms. The system must handle up to 100,000 queries and room updates, ensuring quick and accurate responses. The tree structure of the maze simplifies pathfinding but requires careful handling of illusion rate updates.\nrequirement pool:\n- Implement efficient query processing for room updates and energy calculations.\n- Ensure accurate calculation of energy requirements using the given formula.\n- Optimize data structures to handle large input sizes efficiently.\n- Provide clear and immediate feedback for each query.\n- Develop a user-friendly interface for input and output handling.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the queries. The DFS will help in precomputing necessary data for quick LCA queries, which will be used to determine the path between any two rooms. We will also use a Segment Tree to handle updates to the illusion rates efficiently. This approach ensures that both update and query operations are handled in logarithmic time, which is crucial given the constraints.\n", "requirement analysis:\nThe project requires handling a tree structure representing a maze with rooms and tunnels. The main challenge is efficiently processing updates to room properties and calculating the minimum energy path between rooms. The solution must handle up to 100,000 rooms and queries, necessitating optimized algorithms for both updates and path calculations.\nrequirement pool:\n- Implement efficient data structures to handle room updates and path queries.\n- Develop algorithms to calculate minimum energy paths in a tree structure.\n- Ensure the system can handle edge cases and invalid inputs gracefully.\n- Optimize performance for large input sizes and high query volumes.\n- Provide clear and concise output for each query.\nWe will use a combination of Depth First Search (DFS) for tree traversal and Segment Tree for efficiently handling updates to the illusion rates. DFS will help in calculating the minimum energy path between rooms, while Segment Tree will allow quick updates to the illusion rates.\n", "requirement analysis:\nThe requirements focus on efficiently managing a tree-structured maze with dynamic updates to room properties and calculating minimum energy paths. The solution must handle large input sizes and provide quick responses to queries, ensuring robustness and accuracy.\nrequirement pool:\n- Implement efficient data structures to handle dynamic updates and queries.\n- Optimize pathfinding algorithms for minimum energy calculations.\n- Ensure the system can handle the maximum constraints of input size and query count.\n- Develop a user-friendly interface for input and output operations.\n- Include detailed logging for debugging and performance monitoring.\nWe will use a combination of Depth First Search (DFS) for pathfinding in the tree structure and a Segment Tree for efficiently handling updates to the illusion rates. The DFS will help in calculating the minimum energy path between two rooms, while the Segment Tree will allow us to update the illusion rates in logarithmic time, ensuring that both types of queries are handled efficiently.\n", "requirement analysis:\nThe project requires efficient handling of tree data structures to manage room connections and update operations. The main challenge is to ensure that energy calculations are performed quickly, even with the maximum constraints of n and q. The solution should be optimized for both time and space complexity to handle up to 100,000 rooms and queries.\nrequirement pool:\n- Implement efficient data structures to manage room connections and updates.\n- Optimize energy calculation algorithms for quick response times.\n- Ensure the system can handle the maximum input constraints without performance issues.\n- Develop a user-friendly interface for input and output operations.\n- Provide detailed documentation for users to understand the system's functionality.\nWe will use a combination of Depth First Search (DFS) and Lowest Common Ancestor (LCA) techniques to efficiently handle the tree structure and answer the queries. For updating the illusion rates, we will use a simple array update. For the path queries, we will precompute the necessary data to quickly calculate the minimum energy required using the properties of the tree and the precomputed LCA information.\n", "requirement analysis:\nThe requirements focus on efficiently handling a tree-structured maze with dynamic updates to room properties and calculating the minimum energy path between rooms. The solution must handle up to 100,000 rooms and queries, necessitating optimized data structures and algorithms. The primary challenge is ensuring fast updates and queries while maintaining accuracy.\nrequirement pool:\n- Implement efficient data structures for room and tunnel management.\n- Develop algorithms to quickly update room illusion rates.\n- Create a method to calculate the minimum energy path between rooms.\n- Optimize the solution for handling up to 100,000 queries.\n- Ensure the system is robust against invalid inputs.\nWe will use a combination of Depth First Search (DFS) for pathfinding and Segment Tree for efficiently updating and querying the illusion rates. The Segment Tree will allow us to handle updates in logarithmic time, and DFS will help in calculating the minimum energy path between rooms.\n", "requirement analysis:\nThe requirements focus on efficiently handling a large number of queries on a tree structure representing a maze. The key challenges include dynamically updating the illusion rates and calculating the minimum energy path between rooms. The solution must be optimized for performance given the constraints on input size.\nrequirement pool:\n- Efficiently process type 2 queries to find the minimum energy path.\n- Implement dynamic updates for illusion rates with minimal performance impact.\n- Ensure the solution can handle the maximum input size within time limits.\n- Provide clear and accurate output for each query.\n- Optimize memory usage for large datasets.\nWe will use Depth First Search (DFS) to preprocess the tree and calculate the minimum energy path efficiently. For dynamic updates, we will use an array to store the illusion rates and update them directly. This approach ensures that both types of queries are handled efficiently, even for large input sizes.\n"], "scores": [], "pass_results": [true, false, true, true, true, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 8, "round": 908, "examples": "\nInput\n\nThe first line contains two integers n and q (2 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of rooms in the maze and the number of queries.\n\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 |a_i| \u2264 10^9) \u2014 inital illusion rate of each room.\n\nThe i-th of the next n-1 lines contains two integers s_i and t_i (1 \u2264 s_i, t_i \u2264 n), meaning there is a tunnel connecting s_i-th room and t_i-th room. The given edges form a tree.\n\nThe next q lines contain the query as described. The given queries are valid.\n\nOutput\n\nFor each type 2 query, output a line containing an integer \u2014 the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.\n\nExample\n\nInput\n\n\n6 4\n10 -9 2 -1 4 -6\n1 5\n5 4\n5 6\n6 2\n6 3\n2 1 2\n1 1 -3\n2 1 2\n2 3 3\n\n\nOutput\n\n\n39\n32\n0\n\nNote\n\n<image>\n\nIn the first query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|10 + 4|, |10 - 4|) = 14 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\nIn total, it takes 39 energy.\n\nIn the second query, the illusion rate of the 1-st room changes from 10 to -3.\n\nIn the third query, their movement from the 1-st to the 2-nd room is as follows.\n\n  * 1 \u2192 5 \u2014 takes max(|-3 + 4|, |-3 - 4|) = 7 energy. \n  * 5 \u2192 6 \u2014 takes max(|4 + (-6)|, |4 - (-6)|) = 10 energy. \n  * 6 \u2192 2 \u2014 takes max(|-6 + (-9)|, |-6 - (-9)|) = 15 energy. \n\n\n\nNow, it takes 32 energy.", "mutate_method": "rephrase_one", "parent_index": 463}
