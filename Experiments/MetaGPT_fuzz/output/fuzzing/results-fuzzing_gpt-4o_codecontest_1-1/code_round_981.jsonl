{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp has an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer).\n\nThe arithmetic mean of a collection of n items is obtained by dividing the sum of the items by the total number of items.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Make sure your solution handles arrays where the elements may include negative numbers. Ensure that your algorithm is efficient even for large values of n.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp has an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer).\n\nThe arithmetic mean of a collection of n items is obtained by dividing the sum of the items by the total number of items.\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). Make sure your solution handles arrays where the elements may include negative numbers. Ensure that your algorithm is efficient even for large values of n.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        valid_pairs = 0\n\n        for num in a:\n            # Calculate the complement that would form a valid pair\n            complement = target_sum - num\n\n            # Check if the complement exists in the map\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n\n            # Update the count map with the current number\n            count_map[num] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for num in a:\n            # Decrease the count of the current element\n            count_map[num] -= 1\n\n            # Calculate the required pair element\n            required_pair = target_sum - num\n\n            # Check if the required pair exists in the map\n            if required_pair in count_map and count_map[required_pair] > 0:\n                valid_pairs += count_map[required_pair]\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for array in test_cases:\n        n = len(array)\n        total_sum = sum(array)\n        target_sum = total_sum * (n - 2) / n\n\n        if target_sum != int(target_sum):\n            results.append(0)\n            continue\n\n        target_sum = int(target_sum)\n        freq_map = defaultdict(int)\n        valid_pairs = 0\n\n        for num in array:\n            complement = target_sum - num\n            if complement in freq_map:\n                valid_pairs += freq_map[complement]\n            freq_map[num] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        array = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append(array)\n\n    # Call the function and print the results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that if the elements\n    on these positions are deleted, the mean of the remaining elements is equal to the mean\n    of the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        mean = total_sum / n\n        \n        # To find pairs (i, j) such that a[i] + a[j] = 2 * mean\n        target_sum = 2 * mean\n        \n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        valid_pairs = 0\n        \n        for number in case:\n            # Calculate the complement that would form the target_sum with the current number\n            complement = target_sum - number\n            \n            # If complement is an integer and exists in the map, add its count to valid pairs\n            if complement.is_integer():\n                valid_pairs += count_map[int(complement)]\n            \n            # Increment the count of the current number in the map\n            count_map[number] += 1\n        \n        results.append(valid_pairs)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append(array)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that if the elements\n    on these positions are deleted, the mean of the remaining elements is equal to the mean\n    of the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = (n - 2) * mean\n        \n        # Dictionary to store frequency of each element\n        freq = defaultdict(int)\n        for num in a:\n            freq[num] += 1\n        \n        count = 0\n        \n        for num in a:\n            # Calculate the required pair value\n            required = target_sum - (total_sum - num)\n            \n            # Check if the required value exists in the array\n            if required in freq:\n                count += freq[required]\n                \n                # If the required value is the same as the current number, we need to decrement\n                # the count by one to avoid counting the pair (num, num) itself\n                if required == num:\n                    count -= 1\n        \n        # Each pair is counted twice, so divide by 2\n        results.append(count // 2)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n\n        # The target sum for the pair to be removed\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find pairs\n        for num in a:\n            # Decrease the count of the current number\n            count_map[num] -= 1\n\n            # Calculate the required pair number\n            required_pair = target_sum - num\n\n            # Check if the required pair exists in the map\n            if required_pair in count_map:\n                valid_pairs += count_map[required_pair]\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n\n        if target_sum != int(target_sum):\n            results.append(0)\n            continue\n\n        target_sum = int(target_sum)\n        freq = defaultdict(int)\n        valid_pairs = 0\n\n        for num in a:\n            complement = target_sum - num\n            if complement in freq:\n                valid_pairs += freq[complement]\n            freq[num] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the remaining elements unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n        \n        # Use a hashmap to count occurrences of each element\n        freq = defaultdict(int)\n        for num in a:\n            freq[num] += 1\n        \n        count_pairs = 0\n        \n        for num in a:\n            # Calculate the required partner value to maintain the mean\n            partner_value = target_sum - num\n            \n            # Check if the partner value exists in the hashmap\n            if partner_value in freq:\n                count_pairs += freq[partner_value]\n                \n                # If the partner value is the same as the current number, we need to decrement\n                # the count by one to avoid counting the pair (num, num) twice\n                if partner_value == num:\n                    count_pairs -= 1\n        \n        # Each pair is counted twice (once for each element), so divide by 2\n        results.append(count_pairs // 2)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that\n    removing these elements keeps the mean of the array unchanged.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n\n        if target_sum != int(target_sum):\n            # If target_sum is not an integer, no valid pairs can exist\n            results.append(0)\n            continue\n\n        target_sum = int(target_sum)\n        freq = defaultdict(int)\n        valid_pairs = 0\n\n        for num in a:\n            # Calculate the required complement to form a valid pair\n            complement = target_sum - num\n            if complement in freq:\n                valid_pairs += freq[complement]\n            freq[num] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that if the elements\n    on these positions are deleted, the mean of the remaining elements is equal to the mean\n    of the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        mean = total_sum / n\n        target_sum = 2 * mean\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over the array to find valid pairs\n        for num in a:\n            # Decrease the count of the current number\n            count_map[num] -= 1\n\n            # Calculate the required pair number\n            required_pair = target_sum - num\n\n            # Check if the required pair exists in the map\n            if required_pair in count_map and count_map[required_pair] > 0:\n                valid_pairs += count_map[required_pair]\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires calculating pairs of positions in an array where removing these elements keeps the mean unchanged. The solution must efficiently handle large arrays and include negative numbers. The algorithm should be optimized for performance and accuracy across all test cases.\nrequirement pool:\n- Efficiently handle large arrays up to 2 \u22c5 10^5 elements\n- Correctly process arrays with negative numbers\n- Ensure accurate results for all test cases\n- Optimize algorithm for performance\n- Simplify implementation for maintainability\nWe will use a hashmap to efficiently count the occurrences of each element in the array. The key insight is that for the mean to remain unchanged after removing two elements, the sum of the removed elements must equal twice the mean of the original array. This allows us to find pairs of elements whose sum equals twice the mean using a hashmap for quick lookup, ensuring the solution is efficient even for large arrays.\n", "requirement analysis:\nThe task requires calculating the number of pairs of indices that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must efficiently handle large arrays and account for potential negative numbers. The algorithm should be optimized to handle up to 200,000 elements across all test cases.\nrequirement pool:\n- Develop an efficient algorithm to handle large datasets\n- Ensure the algorithm correctly handles negative numbers\n- Optimize the solution for speed and accuracy\n- Test the algorithm against a variety of test cases\n- Document the solution for maintainability\nWe will use a hashmap to efficiently count the occurrences of each element in the array. The key insight is that for the mean to remain unchanged after removing two elements, the sum of the removed elements must equal twice the mean of the original array. This allows us to find pairs of elements whose sum equals twice the mean. The algorithm will iterate over the array, and for each element, it will check if there exists another element that can form a valid pair. This approach ensures that the solution is efficient even for large arrays.\n", "requirement analysis:\nThe task requires calculating the number of pairs of positions [i, j] such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle large arrays and include negative numbers. The output must be formatted correctly for multiple test cases.\nrequirement pool:\n- Efficiently handle large arrays up to 2 \u22c5 10^5 elements.\n- Correctly handle arrays with negative numbers.\n- Ensure the output format is correct for multiple test cases.\n- Optimize the algorithm for speed and accuracy.\n- Provide detailed error messages for incorrect inputs.\nWe will use a mathematical approach to solve the problem efficiently. The key observation is that removing two elements should not change the mean of the array. This implies that the sum of the remaining elements should be equal to the original sum minus the sum of the two removed elements. We can use a hashmap to store the frequency of each element and efficiently find pairs that satisfy the condition. This approach will handle large arrays and negative numbers effectively.\n", "requirement analysis:\nThe task requires calculating the number of pairs of positions that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must efficiently handle large arrays and consider negative numbers. The algorithm should be optimized for performance given the constraints on input size.\nrequirement pool:\n- Efficiently calculate the number of valid pairs for large arrays\n- Ensure the algorithm handles negative numbers correctly\n- Optimize the solution for performance and memory usage\n- Provide clear and accurate output for each test case\n- Implement additional test cases for edge scenarios\nWe will use a hashmap to efficiently count the occurrences of each element in the array. This will allow us to determine the number of valid pairs that can be removed while maintaining the mean. The approach will involve calculating the total sum and mean of the array, then iterating through the array to find pairs that satisfy the condition. This method ensures that the solution is efficient even for large datasets.\n", "requirement analysis:\nThe task requires calculating the number of pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must be efficient due to constraints on the size of the input. Handling of negative numbers and large values is crucial.\nrequirement pool:\n- Efficiently calculate valid pairs of indices for large arrays\n- Ensure the algorithm handles negative numbers correctly\n- Optimize for performance to handle up to 10^4 test cases\n- Provide clear and accurate output for each test case\n- Implement a user-friendly interface for input and output\nWe will use a mathematical approach to solve the problem efficiently. The key observation is that removing two elements should not change the mean of the array. This implies that the sum of the remaining elements should be equal to the sum of the original array minus the sum of the two removed elements. We can use a hashmap to store the frequency of each element and efficiently find pairs that satisfy the condition.\n", "requirement analysis:\nThe task requires developing an efficient algorithm to find pairs of elements in an array that can be removed while maintaining the original arithmetic mean. The solution must handle large arrays and include negative numbers, ensuring accuracy across multiple test cases.\nrequirement pool:\n- Develop an efficient algorithm to handle large datasets.\n- Ensure the algorithm correctly handles negative numbers.\n- Optimize the solution for computational efficiency.\n- Validate the solution against all provided test cases.\n- Document the algorithm for ease of understanding and maintenance.\nWe will use a hashmap to efficiently count the occurrences of each element in the array. The key insight is that for the mean to remain unchanged after removing two elements, the sum of the removed elements must equal twice the mean of the original array. This allows us to find pairs of elements whose sum equals a specific target value derived from the mean. This approach ensures that we handle large datasets efficiently and correctly manage arrays with negative numbers.\n", "requirement analysis:\nThe task requires calculating the number of pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must be efficient, handling up to 200,000 elements across all test cases, and should work with both positive and negative numbers.\nrequirement pool:\n- Efficiently calculate the number of valid pairs for large datasets.\n- Ensure the solution handles negative numbers correctly.\n- Optimize the algorithm for speed and accuracy.\n- Provide clear and concise output for each test case.\n- Implement additional test cases to ensure robustness.\nWe will use a mathematical approach to efficiently calculate the number of valid pairs. The key observation is that the sum of the array must remain unchanged when two elements are removed. We can use a hashmap to store the frequency of each element and then iterate through the array to find pairs that satisfy the condition. This approach ensures that the solution is efficient even for large datasets.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of indices such that removing these elements keeps the mean unchanged. The solution must efficiently handle large arrays and consider edge cases like negative numbers.\nrequirement pool:\n- Efficiently calculate valid pairs for large datasets\n- Handle arrays with negative numbers correctly\n- Optimize for time complexity\n- Ensure the solution is easy to understand and maintain\n- Provide detailed error messages for invalid inputs\nWe will use a mathematical approach to efficiently calculate the number of valid pairs. The key observation is that the sum of the array must remain unchanged when two elements are removed. We can use a hashmap to store the frequency of each element and calculate the number of pairs that satisfy the condition. This approach ensures that the solution is efficient even for large datasets.\n", "requirement analysis:\nThe task requires calculating the number of pairs of indices such that removing these elements keeps the mean of the array unchanged. The solution must efficiently handle large arrays and consider edge cases, including arrays with negative numbers. The algorithm should be optimized to run within the constraints provided, ensuring it can handle the maximum input size effectively.\nrequirement pool:\n- Efficiently calculate valid pairs for large arrays\n- Handle arrays with negative numbers\n- Optimize for quick execution\n- Ensure accuracy across all test cases\n- Simplify implementation for maintainability\nWe will use a mathematical approach to solve the problem efficiently. The key observation is that removing two elements should not change the mean of the array. This can be achieved by ensuring the sum of the remaining elements is equal to the sum of the original array minus the sum of the two removed elements. We will use a hashmap to store the frequency of each element and calculate the number of valid pairs using this frequency data. This approach ensures the solution is efficient even for large arrays.\n", "requirement analysis:\nThe requirement is to efficiently compute the number of pairs of elements that can be removed from an array such that the mean of the remaining elements remains unchanged. The solution must handle large arrays and negative numbers, ensuring accuracy across all test cases.\nrequirement pool:\n- Efficient computation for large arrays\n- Accurate handling of negative numbers\n- Ensure solution passes all test cases\n- Optimize for edge cases\n- Simplify implementation for readability\nWe will use a hashmap to efficiently count the occurrences of each element in the array. The key insight is that for the mean to remain unchanged after removing two elements, the sum of the removed elements must equal twice the mean of the original array. This allows us to find pairs of elements whose sum equals twice the mean. The algorithm will iterate over the array, and for each element, it will check if there exists another element that can form a valid pair with it. This approach ensures that the solution is efficient even for large arrays.\n"], "scores": [], "pass_results": [false, true, false, false, true, false, true, true, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 981, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 568}
