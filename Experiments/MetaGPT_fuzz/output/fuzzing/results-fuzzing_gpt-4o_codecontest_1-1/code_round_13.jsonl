{"name": "1582_C. Grandma Capa Knits a Scarf", "description": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "tags": ["brute force", "data structures", "greedy", "strings", "two pointers"], "difficulty": 9, "id": 1582, "sample_io": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}], "test_list": [{"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["3\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhhyhhyyky\n", "output": ["-1\n-1\n1\n3\n3\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyzxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabcaacba\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacaa\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkyyyhkhhhy\n", "output": ["-1\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nxkhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxzxzyx\n4\nbaba\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrpparlar\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxxzxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyyxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nyyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcbacaa\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n0\n3\n-1\n"]}, {"input": "5\n8\nabbaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["3\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabca\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyzyhhhhky\n", "output": ["2\n3\n1\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxzy\n4\nabab\n8\nrprarlap\n10\nkhyyhhhyky\n", "output": ["2\n1\n1\n3\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxzzxyy\n4\nbaba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n2\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacbb\n6\nxxzwxz\n4\nbaba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["3\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n1\n1\n-1\n4\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyx\n4\nacbb\n8\nsakparpr\n10\nkyyyhhhhky\n", "output": ["2\n1\n-1\n-1\n4\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["-1\n2\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\naabb\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n2\n-1\n4\n"]}, {"input": "5\n8\nabcaacba\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["0\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbcaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n-1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyx\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbabca\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzzyx\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n0\n0\n-1\n-1\n"]}, {"input": "5\n8\naacaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["-1\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["3\n1\n1\n3\n2\n"]}, {"input": "5\n8\naccabcaa\n6\nxyzxyy\n4\nabbc\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["3\n3\n-1\n-1\n4\n"]}, {"input": "5\n8\nabdaacab\n6\nyyzxxy\n4\nacba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["-1\n-1\n1\n-1\n4\n"]}, {"input": "5\n8\nbbcaacbb\n6\nzyxzyx\n4\nabba\n8\nroqarlap\n10\nykhxhhyyhk\n", "output": ["0\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nabbb\n8\nrpqapkas\n10\nkyhyhyhhky\n", "output": ["2\n1\n1\n-1\n3\n"]}, {"input": "5\n8\naacaacab\n6\nyyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhiyyhk\n", "output": ["-1\n2\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzxx\n4\nabbb\n8\nqprarlap\n10\nkhhyyhyhky\n", "output": ["2\n3\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nyyzwyy\n4\nbabb\n8\nrpqapkas\n10\njyyyhhhhky\n", "output": ["2\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nzzzxyx\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyxzyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhhyky\n", "output": ["3\n-1\n0\n-1\n4\n"]}, {"input": "5\n8\ncccbaaab\n6\nzxyzyx\n4\nbbab\n8\npalrarpr\n10\nkgyyhhyhky\n", "output": ["3\n1\n1\n3\n-1\n"]}, {"input": "5\n8\nabcabcba\n6\nxyzxzy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["1\n1\n0\n-1\n2\n"]}, {"input": "5\n8\nbabaadba\n6\nxyyxxy\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n3\n-1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nyzywyz\n4\nacda\n8\napqrrlap\n10\nykhxhhyyhk\n", "output": ["-1\n1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbabaadba\n6\nyxxxyx\n4\ncbba\n8\noalraqpr\n10\nkyyyhhihjy\n", "output": ["-1\n1\n-1\n-1\n-1\n"]}, {"input": "5\n8\ncbabacbb\n6\nyyzyxx\n4\naabb\n8\nrpqarlap\n10\nkyyyhhhhkx\n", "output": ["3\n-1\n2\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhghhyyyk\n", "output": ["2\n3\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n0\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpqarlap\n10\nykhyyhyhhk\n", "output": ["-1\n-1\n2\n-1\n3\n"]}, {"input": "5\n8\nabcaacab\n6\nyyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaslap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqpr\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxzzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpaqrlap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nbaba\n8\nrrparlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nacba\n8\nrqqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\nrprarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxxzwyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nabba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzyx\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyhgyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\nbbaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrprarlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nykhyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nacba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrplarqap\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nqpsarlap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\ncaba\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\nrpsarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlbp\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\nabba\n8\npalraqps\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabaa\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxyz\n4\naabb\n8\nrpparlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naaba\n8\nspaqrlbp\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxghyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabab\n8\nrprarlaq\n10\njhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcabcaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["-1\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nabac\n8\nrpraqlaq\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\naaba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqpr\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcbbcaa\n6\nxyzxyy\n4\nabba\n8\nrpqarkap\n10\nkhyyhhyhky\n", "output": ["-1\n3\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqaskap\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\nabba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\naeba\n8\nrpqarlap\n10\nylhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacbc\n6\nxxzwyz\n4\nadba\n8\nrpqarlap\n10\nyyhxhhykgk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nqprarlap\n10\nkhyyhhxhky\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\nbbab\n8\npalrarpr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyxxzyx\n4\nbbba\n8\nrpqarlao\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqor\n10\nkhyyhhyhky\n", "output": ["3\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrpqapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nwyzxxz\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\ncbcbaaab\n6\nzxxzyx\n4\naaba\n8\npalraspr\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\naccabbaa\n6\nxyzxyy\n4\nabbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nabbaacab\n6\nzxxzyw\n4\naaba\n8\nspqarlap\n10\nkhyyghyhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacbacba\n6\nxyzxyz\n4\nabba\n8\npalraqos\n10\nkhyyhhzhky\n", "output": ["3\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\naccabbaa\n6\nxzxxyy\n4\nacbb\n8\nrprapkas\n10\nkyyyhhhhky\n", "output": ["2\n-1\n-1\n-1\n4\n"]}, {"input": "5\n8\ncbcaaaab\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyy\n4\nabba\n8\nrpqlraap\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\nrqqaralp\n10\nykhhhhyyyk\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxyz\n4\nbaaa\n8\nrprarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n1\n3\n2\n"]}, {"input": "5\n8\nbbcaacaa\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nkhyzhhyhky\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nyyxzyx\n4\nabba\n8\npalraqor\n10\nkyyyhhhhky\n", "output": ["2\n3\n0\n-1\n4\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzwyz\n4\nabab\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabab\n8\nrprarmap\n10\nkhyyihyhky\n", "output": ["2\n-1\n1\n3\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nyyxzyx\n4\nacba\n8\nrpqarlap\n10\nykhhhhyyyk\n", "output": ["2\n3\n1\n-1\n4\n"]}, {"input": "5\n8\nbacaabba\n6\nxyzwyz\n4\nabbb\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nzyxzzx\n4\nabba\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyz\n4\nabba\n8\nrpqarlap\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\ncbcbaaab\n6\nxyzxxz\n4\nabba\n8\npalrarpr\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n3\n2\n"]}, {"input": "5\n8\nabbaacab\n6\nzywzxx\n4\nabba\n8\nspaqrlap\n10\nykhyhhyyhk\n", "output": ["-1\n-1\n0\n-1\n2\n"]}, {"input": "5\n8\nbacaabba\n6\nxyywyz\n4\nacba\n8\nspaqrlap\n10\nykhyhhyyhl\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\naaab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["2\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacbb\n6\nzyxzyx\n4\nabba\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzwyz\n4\naabb\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["-1\n-1\n2\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxyz\n4\nabca\n8\nrpqarlap\n10\nykhxhhyyhk\n", "output": ["2\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabbaacab\n6\nxyzxxz\n4\nabba\n8\nspqarlap\n10\nyhkyigyyhk\n", "output": ["-1\n-1\n0\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxyzxyz\n4\nadba\n8\nrpqarlap\n10\nkhyyhhxhky\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nabcaacbb\n6\nxxzwyz\n4\nadba\n8\nrpqaalrp\n10\nykhxhhyyhk\n", "output": ["-1\n-1\n1\n-1\n-1\n"]}, {"input": "5\n8\nbacaacba\n6\nxyzxyy\n4\nabba\n8\nrpqaplar\n10\nykhyhhyyhk\n", "output": ["2\n3\n0\n-1\n2\n"]}, {"input": "5\n8\nabcaacba\n6\nzyxzyx\n4\nabab\n8\nrpqarlap\n10\nkhyyhhyhky\n", "output": ["0\n-1\n1\n-1\n2\n"]}, {"input": "5\n8\nabcaacab\n6\nxyzxxz\n4\nabba\n8\npalraqpr\n10\nykhyhhyyhk\n", "output": ["2\n-1\n0\n-1\n2\n"]}], "task_id": "codecontest/30", "prompt": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter. Then she will erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "repair_prompt": ["Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\n\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter. Then she will erase some (at her choice, possibly none or all) occurrences of that letter in string s.\n\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\n\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum erasures required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\n\n        Args:\n            s (str): The string to check.\n\n        Returns:\n            bool: True if the string is a palindrome, False otherwise.\n        \"\"\"\n        return s == s[::-1]\n\n    def min_erasures_for_letter(s: str, letter: str) -> int:\n        \"\"\"Calculate the minimum number of erasures required to make the string a palindrome by removing occurrences of a specific letter.\n\n        Args:\n            s (str): The string to process.\n            letter (str): The letter to remove.\n\n        Returns:\n            int: Minimum number of erasures required, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        erasures = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == letter:\n                left += 1\n                erasures += 1\n            elif s[right] == letter:\n                right -= 1\n                erasures += 1\n            else:\n                return -1\n\n        return erasures\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        min_erasures = float('inf')\n        for letter in set(s):\n            erasures = min_erasures_for_letter(s, letter)\n            if erasures != -1:\n                min_erasures = min(min_erasures, erasures)\n\n        results.append(min_erasures if min_erasures != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_erasures_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum erasures required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Calculate the minimum removals to make a string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_erasures_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_letter(s: str, letter: str) -> int:\n        \"\"\"Calculate the minimum removals required to make the string a palindrome by removing occurrences of a specific letter.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == letter:\n                left += 1\n                removals += 1\n            elif s[right] == letter:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this letter\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_letters = set(s)\n        min_removals = float('inf')\n\n        for letter in unique_letters:\n            removals = min_removals_for_letter(s, letter)\n            min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_removals_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make a string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum removals for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append((n, s))\n\n    # Call the function and print results\n    results = min_removals_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum erasures for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Calculate the minimum removals to make a string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append(s)\n\n# Output interface\nresults = min_erasures_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum erasures for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_erasures_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum erasures needed to make the string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        erasures = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                erasures += 1\n            elif s[right] == char:\n                right -= 1\n                erasures += 1\n            else:\n                return float('inf')  # Impossible to form a palindrome by removing this character\n\n        return erasures\n\n    results = []\n    for s in test_cases:\n        unique_chars = set(s)\n        min_erasures = float('inf')\n\n        for char in unique_chars:\n            erasures = min_erasures_for_char(s, char)\n            min_erasures = min(min_erasures, erasures)\n\n        if min_erasures == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_erasures)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_erasures_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make a string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing the length of the string and the string itself.\n\n    Returns:\n        List[int]: List of minimum erasures required for each test case, or -1 if impossible.\n    \"\"\"\n    def can_form_palindrome_by_removing(s: str, char_to_remove: str) -> int:\n        \"\"\"Check if a palindrome can be formed by removing occurrences of a specific character.\n\n        Args:\n            s (str): The string to check.\n            char_to_remove (str): The character to remove.\n\n        Returns:\n            int: Minimum number of removals required, or -1 if impossible.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return -1\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        min_removals = float('inf')\n        unique_chars = set(s)\n\n        for char in unique_chars:\n            removals = can_form_palindrome_by_removing(s, char)\n            if removals != -1:\n                min_removals = min(min_removals, removals)\n\n        results.append(min_removals if min_removals != float('inf') else -1)\n\n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    test_cases.append((n, s))\n\n# Output interface\nresults = min_erasures_to_palindrome(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures required to make each string a palindrome.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[str]): A list of strings, each representing a test case.\n\n    Returns:\n        List[int]: A list of integers where each integer is the minimum number of erasures\n                   required to make the corresponding string a palindrome, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char_to_remove: str) -> int:\n        \"\"\"Calculate the minimum removals to make a string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char_to_remove:\n                left += 1\n                removals += 1\n            elif s[right] == char_to_remove:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n    for s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_erasures_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_removals_to_palindrome(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum number of removals to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing an integer n and a string s.\n\n    Returns:\n        List[int]: List of minimum removals required for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_for_char(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make the string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n\n        return removals\n\n    results = []\n    for n, s in test_cases:\n        if is_palindrome(s):\n            results.append(0)\n            continue\n\n        unique_chars = set(s)\n        min_removals = float('inf')\n\n        for char in unique_chars:\n            removals = min_removals_for_char(s, char)\n            min_removals = min(min_removals, removals)\n\n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append((n, s))\n\n    results = min_removals_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_erasures_to_palindrome(t: int, test_cases: List[str]) -> List[int]:\n    \"\"\"Calculate the minimum number of erasures needed to make each string a palindrome.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[str]): List of strings for each test case.\n\n    Returns:\n        List[int]: List of minimum erasures for each test case, or -1 if impossible.\n    \"\"\"\n    def is_palindrome(s: str) -> bool:\n        \"\"\"Check if a string is a palindrome.\"\"\"\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s: str, char: str) -> int:\n        \"\"\"Calculate the minimum removals needed to make a string a palindrome by removing a specific character.\"\"\"\n        left, right = 0, len(s) - 1\n        removals = 0\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            elif s[left] == char:\n                left += 1\n                removals += 1\n            elif s[right] == char:\n                right -= 1\n                removals += 1\n            else:\n                return float('inf')  # Impossible to make palindrome by removing this character\n        return removals\n\n    results = []\n    for s in test_cases:\n        unique_chars = set(s)\n        min_removals = float('inf')\n        for char in unique_chars:\n            removals = min_removals_to_palindrome(s, char)\n            min_removals = min(min_removals, removals)\n        \n        if min_removals == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_removals)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        s = input().strip()\n        test_cases.append(s)\n\n    # Output interface\n    results = min_erasures_to_palindrome(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on transforming a given string into a palindrome by selectively erasing occurrences of a chosen letter. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring minimal erasures and providing clear output for each test case.\nrequirement pool:\n- Implement efficient palindrome transformation logic\n- Ensure solution handles large input sizes\n- Optimize for minimal erasures\n- Provide clear output format\n- Test against diverse cases for robustness\nWe will implement a function that checks if a string can be transformed into a palindrome by erasing occurrences of a chosen letter. The function will iterate over each possible letter and attempt to form a palindrome by removing occurrences of that letter. We will use a two-pointer technique to efficiently check for palindromes and calculate the minimum number of erasures required. The solution will handle multiple test cases and large input sizes efficiently.\n", "requirement analysis:\nThe main requirement is to transform a given string into a palindrome by erasing occurrences of a chosen letter, minimizing the number of erasures. The solution must handle multiple test cases efficiently and provide clear output, indicating either the minimum number of erasures or the impossibility of transformation.\nrequirement pool:\n- Implement efficient palindrome transformation logic\n- Ensure clear and correct output format\n- Optimize for large input sizes\n- Provide detailed error messages for impossible transformations\n- Enhance user interface for input handling\nWe will implement a function that checks if a string can be transformed into a palindrome by erasing occurrences of a single chosen letter. The function will iterate over each character in the string, attempt to form a palindrome by removing occurrences of that character, and calculate the minimum number of removals required. If no palindrome can be formed, it will return -1. The solution will efficiently handle multiple test cases and large input sizes by leveraging two-pointer technique for palindrome checking.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to convert a given string into a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle multiple test cases and large input sizes, ensuring accurate results.\nrequirement pool:\n- Implement the main algorithm to find the minimum erasures\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for better performance\n- Provide clear output format as specified\n- Document the solution for maintainability\nWe will implement a function that iterates over each possible letter in the string and attempts to make the string a palindrome by removing occurrences of that letter. The function will use a two-pointer technique to check if the string can be a palindrome after removals, and will keep track of the minimum number of removals required. If no letter can make the string a palindrome, it will return -1. We will use Python's built-in capabilities for string manipulation and list operations to ensure efficiency.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a string to make it a palindrome by only removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with string lengths up to 100,000, ensuring the sum of all string lengths does not exceed 200,000.\nrequirement pool:\n- Efficiently handle large input sizes\n- Provide clear and concise output format\n- Consider edge cases where no palindrome can be formed\n- Optimize for minimal character removal\n- Ensure solution is easy to understand and implement\nWe will implement a function that checks if a string can be transformed into a palindrome by removing occurrences of a single chosen character. The function will iterate over each character in the string, attempt to form a palindrome by removing occurrences of that character, and calculate the minimum number of removals required. If no palindrome can be formed, it will return -1. We will use efficient string manipulation techniques to handle large inputs, ensuring the solution is optimal for the given constraints.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to convert a given string into a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring that the sum of all string lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Implement the main algorithm to find the minimum erasures for palindrome conversion.\n- Optimize the solution for handling large input sizes efficiently.\n- Ensure the solution provides clear output for each test case.\n- Test the solution against edge cases to ensure robustness.\n- Improve user experience with concise and informative output.\nWe will implement a function that iterates over each character in the string and attempts to make the string a palindrome by removing occurrences of that character. The function will check if the remaining string can be rearranged into a palindrome and calculate the minimum number of removals required. We will use a two-pointer technique to efficiently check for palindromes and count necessary removals. The solution will be optimized to handle large inputs by ensuring that each test case runs in linear time relative to the string length.\n", "requirement analysis:\nThe requirement is to transform a given string into a palindrome by erasing occurrences of a single chosen letter, minimizing the number of erasures. The solution must efficiently handle up to 100 test cases with string lengths up to 10^5, ensuring the sum of lengths does not exceed 2 \u22c5 10^5.\nrequirement pool:\n- Implement efficient palindrome transformation logic\n- Ensure correct output format for multiple test cases\n- Optimize for minimal character erasure\n- Handle edge cases such as already palindromic strings\n- Provide detailed error handling for impossible cases\nWe will implement a function that checks if a string can be transformed into a palindrome by erasing occurrences of a single chosen letter. The function will iterate over each character in the string, attempting to form a palindrome by removing occurrences of that character. We will use a two-pointer technique to check for palindromes and count the necessary erasures. The solution will handle multiple test cases efficiently, ensuring the sum of string lengths does not exceed 2 \u22c5 10^5.\n", "requirement analysis:\nThe solution must efficiently determine the minimum number of erasures needed to make a string a palindrome, or determine if it's impossible. It should handle up to 100 test cases with a total string length of up to 200,000 characters. The output must be clear and follow the specified format.\nrequirement pool:\n- Efficiently process up to 100 test cases\n- Determine minimum erasures or impossibility\n- Handle edge cases such as already palindromic strings\n- Ensure output format is consistent and clear\n- Optimize for large input sizes\nWe will implement a function that checks if a string can be transformed into a palindrome by erasing occurrences of a single chosen letter. The function will iterate over each possible letter and attempt to form a palindrome by removing occurrences of that letter. We will use a two-pointer technique to efficiently check for palindromic structure after potential removals. The solution will handle multiple test cases and ensure efficient processing for large inputs using Python's built-in capabilities.\n", "requirement analysis:\nThe requirements focus on transforming a given string into a palindrome by erasing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with strings of length up to 10^5, ensuring the sum of lengths does not exceed 2 \u22c5 10^5. The output must clearly indicate the minimum number of erasures or if transformation is impossible.\nrequirement pool:\n- Efficiently handle large input sizes\n- Provide clear output format\n- Optimize for edge cases\n- Ensure solution is responsive\n- Maintain simplicity in implementation\nWe will implement a function that checks if a string can be transformed into a palindrome by erasing occurrences of a single chosen letter. The function will iterate over each character in the string, attempt to form a palindrome by removing occurrences of that character, and calculate the minimum number of removals required. If no palindrome can be formed, it will return -1. The solution will efficiently handle large inputs by using a two-pointer technique to check for palindromes.\n", "requirement analysis:\nThe requirement is to determine the minimum number of characters to erase from a string to make it a palindrome by only removing occurrences of a single chosen character. The solution must efficiently handle up to 100 test cases with string lengths up to 100,000, ensuring the sum of all string lengths does not exceed 200,000.\nrequirement pool:\n- Implement the main algorithm to determine the minimum number of erasures needed.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm for minimal computational complexity.\n- Provide clear documentation and comments within the code.\n- Develop test cases to validate the solution against various scenarios.\nWe will implement a function that iterates over each test case, attempting to make the string a palindrome by removing occurrences of a single chosen character. The function will check each character in the string as a potential candidate for removal and calculate the minimum number of removals required to achieve a palindrome. If no character can be chosen to make the string a palindrome, the function will return -1 for that test case. The approach will efficiently handle large inputs by using a two-pointer technique to check for palindromes.\n", "requirement analysis:\nThe requirement is to determine the minimum number of erasures needed to convert a given string into a palindrome by removing occurrences of a single chosen letter. The solution must efficiently handle up to 100 test cases with string lengths up to 100,000, ensuring the sum of all string lengths does not exceed 200,000.\nrequirement pool:\n- Implement the main algorithm to find the minimum erasures for palindrome conversion.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases where palindrome conversion is impossible.\n- Provide clear output format as specified in the requirements.\n- Test the solution against multiple test cases to ensure accuracy.\nWe will implement a function that iterates over each character in the string and attempts to make the string a palindrome by removing occurrences of that character. For each character, we will use a two-pointer technique to check if the string can be made a palindrome by removing occurrences of that character. If it is possible, we will count the number of removals needed and keep track of the minimum number of removals across all characters. If no character can make the string a palindrome, we will return -1. This approach ensures that we efficiently handle large input sizes by minimizing unnecessary computations.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 13, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 100) \u2014 the number of test cases. The next 2 \u22c5 t lines contain the description of test cases. The description of each test case consists of two lines.\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the string.\n\nThe second line of each test case contains the string s consisting of n lowercase English letters.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and -1, if it is impossible.\n\nExample\n\nInput\n\n\n5\n8\nabcaacab\n6\nxyzxyz\n4\nabba\n8\nrprarlap\n10\nkhyyhhyhky\n\n\nOutput\n\n\n2\n-1\n0\n3\n2\n\nNote\n\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\n\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\n\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.", "mutate_method": "expand_one2two", "parent_index": 13}
