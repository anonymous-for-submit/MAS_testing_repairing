{"name": "1613_E. Crazy Robot", "description": "There is a grid, consisting of n rows and m columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.\n\nA crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "tags": ["dfs and similar", "graphs"], "difficulty": 11, "id": 1613, "sample_io": [{"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n"]}], "test_list": [{"input": "1\n3 31\n############################..#\n.............................L.\n############################..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n3 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n######################++#\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n3 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n############################..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n############################..#\n", "output": ["#++############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n#..######################\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n++##L\n+#...\n++...\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n#..######################\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n#++######################\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L++++++++++++++++++++...\n######################..#\n"]}, {"input": "1\n3 25\n##..#####################\n.......................L.\n#..######################\n", "output": ["##..#####################\n....+++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 31\n#############################..\n...........L...................\n############################..#\n", "output": ["#############################..\n+++++++++++L++++++++++++++++...\n############################..#\n"]}, {"input": "1\n3 25\n######################..#\n.L.......................\n#..######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n#++######################\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#..###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#..############################\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n#++############################\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n############################..#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n############################++#\n"]}, {"input": "1\n3 25\n#..######################\n.......................L.\n#..######################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n#..######################\n"]}, {"input": "1\n3 25\n#####################..##\n.L.......................\n######################..#\n", "output": ["#####################..##\n+L+++++++++++++++++++....\n######################..#\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n#..######$####\"#$########\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n3 31\n..#############################\n.L.............................\n############################..#\n", "output": ["++#############################\n+L++++++++++++++++++++++++++...\n############################..#\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n##########\"######\"##########./#\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n############################..#\n", "output": ["#############################..\n+++++++++++++++++++L++++++++...\n############################..#\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n#.##.##########################\n", "output": ["#++############################\n+L++...........................\n#+##.##########################\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"#################..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"########..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.......................L.\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n.......................L+\n"]}, {"input": "1\n3 31\n#..############################\n.L.............................\n################.############.#\n", "output": ["#++############################\n+L++++++++++++++...............\n################.############.#\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n..#..\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n..#..\n.....\nL\n.#++L++++\n"]}, {"input": "1\n3 25\n#..######################\n.L.......................\n#..######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n#++######################\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#..############################\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 25\n##.#####.################\n.L.......................\n#..######$####\"#$########\n", "output": ["##.#####.################\n+L.......................\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n#.##.##########################\n", "output": ["#..############################\n.....++++++++++++++++++++++++L+\n#.##.##########################\n"]}, {"input": "1\n2 25\n######################..#\n......................L..\n#..###$##################\n", "output": ["######################++#\n++++++++++++++++++++++L++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n.#...\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#++++\n++##L\n+#...\n++...\nL\n++++L++#.\n"]}, {"input": "1\n2 25\n#####################..##\n.......................L.\n#..######################\n", "output": ["#####################..##\n.......................L+\n"]}, {"input": "1\n2 25\n########.#############.##\n.L.......................\n#..###$###########$######\n", "output": ["########.#############.##\n+L++++++.................\n"]}, {"input": "1\n2 25\n###########.##########.##\n.L.......................\n####\"#################..#\n", "output": ["###########.##########.##\n+L+++++++++..............\n"]}, {"input": "1\n3 31\n#..############################\n.............................L.\n################.############.#\n", "output": ["#..############################\n.................++++++++++++L+\n################.############+#\n"]}, {"input": "1\n2 25\n##########.############.#\n......................L..\n#..###$##################\n", "output": ["##########.############.#\n...........+++++++++++L..\n"]}, {"input": "1\n2 31\n#..############################\n...............L...............\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++L+++++++++++++++\n"]}, {"input": "4\n3 3\n...\n.L.\n...\n4 5\n#....\nL.##.\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n", "output": ["...\n.L.\n...\n#....\nL.##.\n...#.\n.....\nL\n++++L++#.\n"]}, {"input": "1\n2 31\n#############################..\n.............................L.\n############################..#\n", "output": ["#############################++\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "4\n3 3\n...\n..L\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n.#..L....\n", "output": ["..+\n..L\n..+\n#++++\n..##L\n...#+\n...++\nL\n.#++L++++\n"]}, {"input": "1\n2 25\n#..######################\n....................L....\n#..######################\n", "output": ["#..######################\n...+++++++++++++++++L++++\n"]}, {"input": "1\n2 25\n##..#####################\n.L.......................\n#..######################\n", "output": ["##..#####################\n+L.......................\n"]}, {"input": "1\n2 31\n..#############################\n.............................L.\n############################..#\n", "output": ["..#############################\n..+++++++++++++++++++++++++++L+\n"]}, {"input": "1\n3 25\n##..#####################\n.L.......................\n######################..#\n", "output": ["##..#####################\n+L.......................\n######################..#\n"]}, {"input": "1\n3 31\n#############################..\n...................L...........\n#..############################\n", "output": ["#############################..\n...++++++++++++++++L+++++++++..\n#..############################\n"]}, {"input": "1\n2 25\n######.###############.##\n.......................L.\n#..###$##################\n", "output": ["######.###############.##\n.......................L+\n"]}, {"input": "1\n3 31\n############################..#\n.............................L.\n#..############################\n", "output": ["############################++#\n...++++++++++++++++++++++++++L+\n#..############################\n"]}, {"input": "1\n2 31\n#..############################\n.L.............................\n#################\"##########-.#\n", "output": ["#++############################\n+L+++++++++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..######################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"##########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n######################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$##################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..###$###########$######\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$###########$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"##############$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"####\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##########\"###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###########\"#$####$###\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$##$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#.#############.#########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$##################\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..######$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############\"######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########$##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#######\"######$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n##################$###..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########..#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##################$###..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n##########\"######\"##########./#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#$########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##############\"#######..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$#####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..##$##$###########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###############!######\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$$#..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$#####$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n####\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n$#######$#\"#####$#####..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###################$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./######################\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#############\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"##########\"##########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#################\"##########-.#\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$########$##$######\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n##$#\"###########$##$##..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n##########\"######\"##########..#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#################..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..####$############\"\"###\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n######!###############..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###$##################\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#################..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"########..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-##########\"#################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n######$##$########$###..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"#########$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#################\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"####\"##$######$##..\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"#########$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#\"#########\"###\"###$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#########\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n######\"######\"##$#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..#######$#####\"###\"###\"\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n######\"######\"##$#####..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########\"##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"###########$#####..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$######\"####$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#######\"#########\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.#############.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###$########%##$######\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$##$##..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#..##########\"######\"##########\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#####$$\"##\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$#####$#\"##\"#######$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n##############\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n##.#############.########\n.L.......................\n#/.###$###########$######\n", "output": ["##.#############.########\n+L.......................\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$#######\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..###################$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#./######################\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####$########\"########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n###$####$#\"###########..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 31\n############################..#\n.L.............................\n#################\"##########-.#\n", "output": ["############################..#\n+L++++++++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$##\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$############\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"..##$#########\"####\"####\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.##########.###########\n.L.......................\n####\"############\"####..#\n", "output": ["##.##########.###########\n+L.......................\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n##.#####.################\n.......................L.\n#############\"##%#####..#\n", "output": ["##.#####.################\n.........++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"###\"#####$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"##\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######\"#######\"#######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#./$#####$#\"##\"#$#####$##\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"###\"#$#######$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..$###\"###\"##\"#$####\"$##\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n###\"\"#################..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$#\"####$######..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n####\"#########\"####$##..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n##################$##\"..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"#######\"######$#$..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n####\"#################..$\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#####$$####\"#$########\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n.#################$####.#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n################.#####.##\n.L.......................\n########$#\"####$######..#\n", "output": ["################.#####.##\n+L++++++++++++++.........\n"]}, {"input": "1\n2 31\n#..############################\n.............................L.\n#/.##########\"######\"##########\n", "output": ["#..############################\n...++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n\"###\"#################..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..###$######$###########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"######\"##########..#\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#############\"$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 31\n############################..#\n.............................L.\n#.-######\"#####################\n", "output": ["############################++#\n+++++++++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..#################\"###\"\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n\"#############$#######..#\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n#..#######$#########\"###\"\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n######################..#\n.......................L.\n#..###########!##########\n", "output": ["######################++#\n+++++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#.############$.#########\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n######$##%########$###..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n####\"###########$#$###..$\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n#..$\"#\"##$####\"#$########\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n#..####$###$########\"\"###\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.......................L.\n\"#$#\"#########$#######..#\n", "output": ["#..######################\n...++++++++++++++++++++L+\n"]}, {"input": "1\n2 25\n#..######################\n.L.......................\n$..#######\"#########\"####\n", "output": ["#++######################\n+L+++++++++++++++++++++++\n"]}, {"input": "1\n2 25\n######################..#\n.L.......................\n########$###\"\"$$#####$..#\n", "output": ["######################..#\n+L++++++++++++++++++++...\n"]}], "task_id": "codecontest/117", "prompt": "There exists a grid, made up of n rows and m columns. Each cell in the grid is either unoccupied or blocked, and one of the unoccupied cells contains a laboratory, and all cells outside the grid's limits are also blocked.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", where each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, because the robot is crazy, it will do anything except obey the command. Upon being given a command, it will select a direction that is not the one specified in the command and where the cell in that direction is not blocked, then proceed to a neighbouring cell in that direction if it exists; otherwise, it will remain stationary.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell, that is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "repair_prompt": ["There exists a grid, made up of n rows and m columns. Each cell in the grid is either unoccupied or blocked, and one of the unoccupied cells contains a laboratory, and all cells outside the grid's limits are also blocked.\n\nA crazy robot has escaped from this lab and is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\", where each command means moving to a neighbouring cell in the corresponding direction.\n\nHowever, because the robot is crazy, it will do anything except obey the command. Upon being given a command, it will select a direction that is not the one specified in the command and where the cell in that direction is not blocked, then proceed to a neighbouring cell in that direction if it exists; otherwise, it will remain stationary.\n\nWe want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell, that is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing\n            the number of rows, number of columns, and the grid itself.\n\n    Returns:\n        List[List[str]]: List of modified grids for each test case.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Performs BFS to determine reachable cells from the lab.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[str]): The grid representation.\n\n        Returns:\n            List[str]: The modified grid with reachable cells marked.\n        \"\"\"\n        # Directions for moving in the grid: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # Find the lab position\n        lab_pos = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_pos = (i, j)\n                    break\n            if lab_pos:\n                break\n        \n        # Initialize BFS\n        queue = deque([lab_pos])\n        visited = set([lab_pos])\n        grid = [list(row) for row in grid]  # Convert grid to a mutable list of lists\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.':\n                    # Check if this cell can be forced to reach the lab\n                    free_directions = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_directions += 1\n                    \n                    if free_directions <= 1:\n                        grid[nx][ny] = '+'\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        return [''.join(row) for row in grid]\n\n    results = []\n    for n, m, grid in test_cases:\n        results.append(bfs(n, m, grid))\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Find free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Perform BFS to find reachable cells from the lab.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[str]): Grid data.\n\n        Returns:\n            List[str]: Modified grid with reachable cells marked.\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        queue = deque()\n        visited = set()\n        lab_position = None\n\n        # Find the lab position and initialize BFS\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    queue.append(lab_position)\n                    visited.add(lab_position)\n                    break\n            if lab_position:\n                break\n\n        # Perform BFS from the lab\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.':\n                    # Check if the cell can be forced to reach the lab\n                    free_neighbors = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_neighbors += 1\n                    if free_neighbors <= 1:\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n\n        # Mark reachable cells\n        modified_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if (i, j) in visited and grid[i][j] == '.':\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            modified_grid.append(''.join(row))\n\n        return modified_grid\n\n    result = []\n    for n, m, grid in test_cases:\n        result.append(bfs(n, m, grid))\n\n    return result\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, grid))\n\n# Output interface\nresult = find_reachable_cells(t, test_cases)\nfor grid in result:\n    for row in grid:\n        print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Determine which free cells can force the robot to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of grids for each test case.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n        grid = [list(row) for row in grid]\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to find all reachable cells\n        def bfs(start: Tuple[int, int]):\n            queue = deque([start])\n            visited = set()\n            visited.add(start)\n\n            while queue:\n                x, y = queue.popleft()\n\n                # Check all four possible directions\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n\n                    if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                        if grid[nx][ny] == '.':\n                            # Check if the cell can be forced to reach the lab\n                            free_directions = 0\n                            for ddx, ddy in directions:\n                                nnx, nny = nx + ddx, ny + ddy\n                                if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] != '#':\n                                    free_directions += 1\n\n                            if free_directions <= 1:\n                                grid[nx][ny] = '+'\n                                queue.append((nx, ny))\n                                visited.add((nx, ny))\n\n        # Start BFS from the lab position\n        if lab_position:\n            bfs(lab_position)\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Find free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of grids for each test case.\n\n    Returns:\n        List[List[str]]: Modified grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        reachable = [[False] * m for _ in range(n)]\n        reachable[lab_position[0]][lab_position[1]] = True\n\n        # Directions for BFS: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and not reachable[nx][ny]:\n                    # Check if the cell is reachable\n                    free_neighbors = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_neighbors += 1\n\n                    # If the cell has less than 2 free neighbors, mark it as reachable\n                    if free_neighbors < 2:\n                        reachable[nx][ny] = True\n                        queue.append((nx, ny))\n\n        # Modify the grid based on reachable cells\n        modified_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if grid[i][j] == '.' and reachable[i][j]:\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            modified_grid.append(''.join(row))\n\n        results.append(modified_grid)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds all free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - grid: A list of strings representing the grid.\n\n    Returns:\n        A list of grids with reachable free cells marked with '+'.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a mutable list of lists\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to mark reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Check if the cell can be forced to reach the lab\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing the grid dimensions and the grid itself.\n\n    Returns:\n        List[List[str]]: List of modified grids with reachable cells marked.\n    \"\"\"\n    def bfs(n: int, m: int, grid: List[str]) -> List[str]:\n        \"\"\"Performs BFS to find all reachable cells from the lab.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[str]): The grid itself.\n\n        Returns:\n            List[str]: The modified grid with reachable cells marked.\n        \"\"\"\n        # Convert grid to a mutable list of lists\n        grid = [list(row) for row in grid]\n        \n        # Directions for moving in the grid: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Initialize BFS queue\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            # Check all four possible directions\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                # Check if the new position is within bounds and is a free cell\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.':\n                    # Count the number of free adjacent cells\n                    free_adjacent_count = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_adjacent_count += 1\n                    \n                    # If there is only one free adjacent cell, mark it as reachable\n                    if free_adjacent_count <= 1:\n                        grid[nx][ny] = '+'\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        return [''.join(row) for row in grid]\n\n    # Process each test case\n    results = []\n    for n, m, grid in test_cases:\n        modified_grid = bfs(n, m, grid)\n        results.append(modified_grid)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Find free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: List of modified grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for easier manipulation\n        grid = [list(row) for row in grid]\n        \n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # BFS to find reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            # Check all four possible directions\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Count free neighbors\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        \n                        # If the cell has only one free neighbor, mark it as reachable\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    \n                    visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Call the function and print the result\n    results = find_reachable_cells(t, test_cases)\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and the grid.\n\n    Returns:\n        List[List[str]]: List of grids with free cells marked as '+' if the robot can be forced to reach the lab.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for mutability\n        grid = [list(row) for row in grid]\n        \n        # Find the lab position\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        # BFS to find all reachable cells from the lab\n        queue = deque([lab_position])\n        visited = set([lab_position])\n\n        while queue:\n            x, y = queue.popleft()\n\n            # Check all four possible directions\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Count the number of free adjacent cells\n                        free_adjacent_count = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_adjacent_count += 1\n\n                        # If there is only one free adjacent cell, mark it as reachable\n                        if free_adjacent_count <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n\n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n\n    # Output interface\n    result = find_reachable_cells(t, test_cases)\n    for grid in result:\n        for row in grid:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[List[str]]:\n    \"\"\"Finds the free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[str]]]): List of test cases, each containing grid dimensions and grid data.\n\n    Returns:\n        List[List[str]]: List of processed grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for n, m, grid in test_cases:\n        # Convert grid to a list of lists for easier manipulation\n        grid = [list(row) for row in grid]\n        \n        # Find the position of the lab\n        lab_position = None\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n        \n        # Directions for BFS: right, down, left, up\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        # BFS to find all reachable cells\n        queue = deque([lab_position])\n        visited = set([lab_position])\n        \n        while queue:\n            x, y = queue.popleft()\n            \n            # Check all four possible directions\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    if grid[nx][ny] == '.':\n                        # Count free neighbors\n                        free_neighbors = 0\n                        for ddx, ddy in directions:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                                free_neighbors += 1\n                        \n                        # If the cell has only one free neighbor, mark it as reachable\n                        if free_neighbors <= 1:\n                            grid[nx][ny] = '+'\n                            queue.append((nx, ny))\n                    \n                    visited.add((nx, ny))\n        \n        # Convert grid back to list of strings\n        results.append([''.join(row) for row in grid])\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, grid))\n    \n    # Output interface\n    results = find_reachable_cells(t, test_cases)\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef find_reachable_cells(t: int, test_cases: List[List[str]]) -> List[List[str]]:\n    \"\"\"Find free cells from which the robot can be forced to reach the lab.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[str]]): List of grids for each test case.\n\n    Returns:\n        List[List[str]]: List of grids with reachable cells marked.\n    \"\"\"\n    results = []\n\n    for grid in test_cases:\n        n = len(grid)\n        m = len(grid[0])\n        lab_position = None\n\n        # Find the lab position\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'L':\n                    lab_position = (i, j)\n                    break\n            if lab_position:\n                break\n\n        # Initialize BFS\n        queue = deque([lab_position])\n        reachable = [[False] * m for _ in range(n)]\n        reachable[lab_position[0]][lab_position[1]] = True\n\n        # Directions for BFS: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n        while queue:\n            x, y = queue.popleft()\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and not reachable[nx][ny]:\n                    # Check if the cell is reachable\n                    free_neighbors = 0\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n                        if 0 <= nnx < n and 0 <= nny < m and grid[nnx][nny] == '.':\n                            free_neighbors += 1\n\n                    # If the cell has only one free neighbor, it can be forced to reach the lab\n                    if free_neighbors <= 1:\n                        reachable[nx][ny] = True\n                        queue.append((nx, ny))\n\n        # Prepare the result grid\n        result_grid = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                if grid[i][j] == '.' and reachable[i][j]:\n                    row.append('+')\n                else:\n                    row.append(grid[i][j])\n            result_grid.append(''.join(row))\n\n        results.append(result_grid)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append(grid)\n\n    # Call the function\n    results = find_reachable_cells(t, test_cases)\n\n    # Output interface\n    for result in results:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring correct output format.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles the maximum input constraints.\n- Optimize the algorithm for computational efficiency.\n- Provide clear and correct output for each test case.\n- Test the solution against edge cases and large grids.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring we find all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the output will be formatted as specified.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is consistent and easy to interpret.\nrequirement pool:\n- Implement efficient pathfinding algorithm for large grids\n- Ensure output format matches requirements\n- Handle edge cases like single cell grids\n- Optimize for multiple test cases\n- Provide detailed error handling and logging\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other free cells, ensuring that we can identify all cells from which the robot can be forced to reach the lab. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case independently.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can force a robot to reach a lab cell, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring correct output format.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm for better performance.\n- Provide clear and concise output formatting.\n- Include comprehensive test cases for validation.\nWe will use a breadth-first search (BFS) approach starting from the lab cell to determine which free cells can force the robot to reach the lab. The BFS will propagate through free cells, marking them as reachable if they can be forced to reach the lab. This approach ensures that we efficiently explore all possible paths from the lab to other free cells, leveraging the grid's constraints and the robot's behavior.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring that the output format is strictly followed. The challenge lies in simulating the robot's movement and ensuring all possible paths to the lab are considered.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles the maximum input size within constraints.\n- Optimize the algorithm to reduce time complexity.\n- Provide clear documentation and comments in the code.\n- Include additional test cases for edge scenarios.\nWe will use a Breadth-First Search (BFS) algorithm starting from the lab cell to determine which free cells can lead the robot to the lab. The BFS will propagate through all free cells, marking those that can reach the lab. This approach is efficient for grid-based pathfinding and ensures that all possible paths are considered. The BFS will be implemented using a queue to explore each cell's neighbors, and we will mark cells that can reach the lab with a '+'.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is consistent with the requirements.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Ensure the solution handles edge cases like single cell grids\n- Optimize the algorithm for performance\n- Validate the output format for each test case\n- Document the solution for maintainability\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it explores all possible paths from the lab to free cells, ensuring that we can identify all reachable cells efficiently. We will start the BFS from the lab and mark all reachable free cells with a '+'.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can lead a robot to a lab cell, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is strictly followed.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs.\n- Optimize the algorithm for performance.\n- Provide clear documentation and comments in the code.\n- Include additional test cases for validation.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring we find all reachable cells. We will start the BFS from the lab cell and mark all reachable free cells with a '+'. This approach handles large grids effectively due to its linear complexity relative to the number of cells.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and ensure correct output formatting.\nrequirement pool:\n- Implement efficient grid traversal to identify reachable cells.\n- Ensure output format strictly follows the requirements.\n- Optimize algorithm for performance given constraints.\n- Handle edge cases such as single cell grids.\n- Provide detailed documentation for the solution.\nWe will use a Breadth-First Search (BFS) algorithm to determine which free cells can lead the robot to the lab. The BFS will start from the lab and explore all reachable free cells, marking them as reachable. This approach ensures that we efficiently handle large grids by only exploring necessary paths. The BFS will be implemented using a queue to manage the exploration of cells, and we will use a set to track visited cells to avoid redundant processing.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can force a robot to reach a lab cell, given the robot's unpredictable movement. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is correct for each scenario.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs efficiently.\n- Optimize the algorithm for better performance.\n- Provide detailed comments and documentation for clarity.\n- Create additional test cases for thorough testing.\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can force the robot to reach the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring we can mark reachable cells correctly. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the output will be formatted as specified.\n", "requirement analysis:\nThe problem requires determining which free cells can lead the robot to the lab regardless of its erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is consistent with the requirements.\nrequirement pool:\n- Implement the main algorithm to determine reachable cells\n- Ensure the solution handles edge cases and large inputs\n- Optimize the algorithm for performance\n- Validate the output format against the requirements\n- Document the solution for maintainability\nWe will use a breadth-first search (BFS) algorithm to determine which free cells can lead the robot to the lab. BFS is suitable for this problem as it efficiently explores all possible paths from the lab to other cells, ensuring that we can identify all reachable cells. We will utilize a queue to manage the exploration of cells and a set to track visited cells. The grid will be processed for each test case, and the output will be formatted according to the requirements.\n", "requirement analysis:\nThe problem requires determining which free cells in a grid can force a robot to reach a lab cell, given the robot's erratic behavior. The solution must efficiently handle large grids and multiple test cases, ensuring the output format is correct and clear.\nrequirement pool:\n- Implement an efficient algorithm to determine reachable cells.\n- Ensure the solution handles edge cases and large inputs.\n- Optimize the algorithm for computational efficiency.\n- Provide a clear and correct output format.\n- Test the solution against a variety of test cases.\nWe will use a breadth-first search (BFS) approach starting from the lab cell to determine which free cells can force the robot to reach the lab. This approach is efficient for grid-based problems and will help us explore all possible paths the robot can take. We will mark cells that can reach the lab with a '+'. The BFS will ensure that we only explore valid paths and handle large grids efficiently.\n"], "scores": [], "pass_results": [false, true, false, true, false, false, false, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 289, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of testcases.\n\nThe first line of each testcase contains two integers n and m (1 \u2264 n, m \u2264 10^6; n \u22c5 m \u2264 10^6) \u2014 the number of rows and the number of columns in the grid.\n\nThe i-th of the next n lines provides a description of the i-th row of the grid. It consists of m elements of one of three types: \n\n  * '.' \u2014 the cell is free; \n  * '#' \u2014 the cell is blocked; \n  * 'L' \u2014 the cell contains a lab. \n\n\n\nThe grid contains exactly one lab. The sum of n \u22c5 m over all testcases doesn't exceed 10^6.\n\nOutput\n\nFor each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.\n\nExample\n\nInput\n\n\n4\n3 3\n...\n.L.\n...\n4 5\n#....\n..##L\n...#.\n.....\n1 1\nL\n1 9\n....L..#.\n\n\nOutput\n\n\n...\n.L.\n...\n#++++\n..##L\n...#+\n...++\nL\n++++L++#.\n\nNote\n\nIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.\n\nIn the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.", "mutate_method": "condense_two2one", "parent_index": 208}
