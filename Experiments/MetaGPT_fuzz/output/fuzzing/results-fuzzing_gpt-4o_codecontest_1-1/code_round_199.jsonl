{"name": "1598_C. Delete Two Elements", "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n).\n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k.\n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "tags": ["data structures", "dp", "implementation", "math", "two pointers"], "difficulty": 9, "id": 1598, "sample_io": [{"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}], "test_list": [{"input": "1\n3\n228 1337 228\n", "output": ["0\n"]}, {"input": "1\n3\n228 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n2\n3\n"]}, {"input": "4\n4\n8 9 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n34 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["6\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 7\n", "output": ["6\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 1\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["0\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 9\n", "output": ["6\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 10\n5\n1 2 7 0 5\n7\n2 2 3 7 1 4 9\n", "output": ["0\n0\n1\n1\n"]}, {"input": "4\n4\n8 8 0 8\n3\n222 20 6\n5\n1 2 7 0 5\n7\n0 2 3 7 1 4 9\n", "output": ["0\n0\n1\n0\n"]}, {"input": "4\n4\n8 2 2 8\n3\n50 20 10\n5\n1 4 7 0 5\n7\n1 2 3 4 5 6 7\n", "output": ["4\n0\n0\n3\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 28 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n1\n0\n0\n"]}, {"input": "4\n4\n8 8 5 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["0\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n4 2 3 7 1 4 7\n", "output": ["6\n0\n1\n3\n"]}, {"input": "4\n4\n5 8 11 8\n3\n9 24 10\n5\n1 4 2 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["2\n0\n2\n0\n"]}, {"input": "4\n4\n5 8 5 8\n3\n9 34 10\n5\n1 4 4 3 5\n7\n0 2 3 3 5 8 20\n", "output": ["4\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1337 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 4 4 0 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 7 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 18 14\n3\n44 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 8 0 3 5\n7\n-1 2 3 12 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 127\n", "output": ["0\n"]}, {"input": "1\n3\n40 1144 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 7 3 9\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 0 2 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n", "output": ["0\n0\n2\n3\n"]}, {"input": "4\n4\n8 8 8 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 14\n3\n50 25 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 -1 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n342 1512 3\n", "output": ["0\n"]}, {"input": "4\n4\n8 2 2 11\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 0 4 5 6 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n50 25 9\n5\n1 4 7 3 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "1\n1\n228 2063 0\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n1 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 7 3 5\n7\n0 2 -1 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 5\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 2\n", "output": ["0\n"]}, {"input": "4\n4\n8 9 24 8\n3\n89 20 10\n5\n1 8 7 5 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 3 6 3 5\n7\n0 2 3 8 6 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 14 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 8\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 5\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n228 1337 103\n", "output": ["0\n"]}, {"input": "1\n3\n40 270 228\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 10\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["6\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 44\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 37 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 10\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 3\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 25 1\n5\n0 4 6 3 5\n7\n0 2 3 8 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 10\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n228 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 13 5\n3\n50 25 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 13 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 5\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 3 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 2 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n382 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 8\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 4 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 74\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n89 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 2 7 3 5\n7\n0 2 3 4 5 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n50 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 14\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 4 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 10\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 10\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 25 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n298 4021 1\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n93 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 5 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 5\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1337 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 15\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 11\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 8\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "1\n1\n148 1337 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 5 6 5\n", "output": ["0\n0\n0\n3\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 10\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n1 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 0 4 0\n", "output": ["6\n0\n0\n9\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 6 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 5\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 3\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n10 8 13 5\n3\n50 29 6\n5\n0 4 7 2 5\n7\n0 2 0 4 0 4 7\n", "output": ["2\n0\n0\n0\n"]}, {"input": "4\n4\n8 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n141 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 8 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 3 8 8\n3\n50 40 1\n5\n0 4 0 10 5\n7\n-1 2 4 8 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 7 8\n3\n50 40 1\n5\n0 4 0 0 0\n7\n-1 1 3 0 9 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 103\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 4 20\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 14 16\n3\n2 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 11 8\n3\n50 25 7\n5\n1 4 3 3 5\n7\n-1 2 3 8 0 1 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n1\n148 141 93\n", "output": ["0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 20 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 5 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n83 18 1\n5\n1 0 7 3 5\n7\n0 2 3 4 5 4 10\n", "output": ["6\n0\n0\n2\n"]}, {"input": "4\n4\n8 8 13 8\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 4 28\n3\n50 53 10\n5\n1 4 7 3 5\n7\n-1 2 3 4 0 0 5\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n116 20 10\n5\n1 2 7 5 5\n7\n2 2 3 7 1 4 7\n", "output": ["6\n0\n1\n0\n"]}, {"input": "4\n4\n8 8 8 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 3 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n1 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 17 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 8 8\n3\n233 25 1\n5\n0 4 0 6 7\n7\n0 2 3 8 9 4 7\n", "output": ["6\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 9 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 1055 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 5 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 11 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 16\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 8\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n12 8 8 8\n3\n130 20 10\n5\n0 4 7 3 5\n7\n1 2 0 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 13 0\n3\n38 46 4\n5\n1 4 12 3 5\n7\n-1 2 3 4 0 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 6 8\n3\n50 25 3\n5\n1 4 12 3 5\n7\n0 2 4 4 1 4 0\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 9 8\n3\n50 25 19\n5\n0 4 8 6 5\n7\n0 2 7 4 1 4 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 9 15 8\n3\n89 20 18\n5\n0 4 7 5 7\n7\n1 2 3 2 5 6 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n8 8 12 14\n3\n44 2 5\n5\n0 4 7 5 8\n7\n-1 2 3 4 1 0 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n6 1 24 14\n3\n50 45 10\n5\n0 4 7 2 5\n7\n0 2 0 4 0 8 7\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 12 8\n3\n50 25 2\n5\n0 4 0 3 10\n7\n-1 2 3 11 7 3 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "1\n3\n232 461 22\n", "output": ["0\n"]}, {"input": "4\n4\n8 8 8 9\n3\n50 20 7\n5\n1 4 12 3 5\n7\n1 2 3 4 1 5 7\n", "output": ["0\n0\n0\n0\n"]}, {"input": "4\n4\n5 8 8 8\n3\n9 25 10\n5\n1 4 4 3 5\n7\n0 2 3 4 5 8 20\n", "output": ["0\n0\n0\n1\n"]}, {"input": "4\n4\n8 8 14 28\n3\n4 25 10\n5\n1 4 7 3 5\n7\n0 2 3 6 0 8 7\n", "output": ["0\n0\n2\n0\n"]}, {"input": "4\n4\n8 15 2 12\n3\n50 37 10\n5\n1 4 3 3 5\n7\n1 4 3 4 7 6 5\n", "output": ["0\n0\n0\n0\n"]}], "task_id": "codecontest/60", "prompt": "Monocarp possesses an array a made up of n integers, and k denotes the mathematical average of these numbers (consider that k might not be an integer), with Monocarp wanting to remove exactly two elements from a so that the mathematical average of the remaining (n - 2) elements stays equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematical average of (n - 2) remaining elements equals k (which corresponds to the mathematical average of n elements of the original array a), ensuring your solution handles arrays that may include negative numbers.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "repair_prompt": ["Monocarp possesses an array a made up of n integers, and k denotes the mathematical average of these numbers (consider that k might not be an integer), with Monocarp wanting to remove exactly two elements from a so that the mathematical average of the remaining (n - 2) elements stays equal to k. Your task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematical average of (n - 2) remaining elements equals k (which corresponds to the mathematical average of n elements of the original array a), ensuring your solution handles arrays that may include negative numbers.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Count the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the average of the remaining elements the same.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an integer n\n                                      followed by n integers representing the array.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = case[0]\n        a = case[1:]\n\n        total_sum = sum(a)\n        k = total_sum / n\n\n        # We need to find pairs (i, j) such that:\n        # a[i] + a[j] = 2 * k\n        target_sum = 2 * k\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        valid_pairs = 0\n\n        for number in a:\n            # Calculate the complement that would form the target_sum with the current number\n            complement = target_sum - number\n\n            # If the complement is in the map, it means we can form a valid pair\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n\n            # Add the current number to the map\n            count_map[number] += 1\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append([n] + a)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Count pairs of positions [i, j] such that removing elements at these positions\n    maintains the average of the remaining elements.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an integer n\n                                      followed by n integers representing the array.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        array = case[1:]\n        \n        total_sum = sum(array)\n        target_sum = total_sum * (n - 2) / n\n        \n        count_map = defaultdict(int)\n        pair_count = 0\n        \n        for num in array:\n            complement = target_sum - num\n            pair_count += count_map[complement]\n            count_map[num] += 1\n        \n        results.append(pair_count)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        test_cases.append([n] + array)\n    \n    results = count_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing these elements\n    keeps the average of the remaining elements the same as the original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        average = total_sum / n\n        target_sum = 2 * average\n        \n        count_map = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n            count_map[num] += 1\n        \n        results.append(valid_pairs)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing these elements\n    keeps the average of the remaining elements equal to the original average.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        k = total_sum / n\n        target_sum = 2 * k\n        \n        count_map = defaultdict(int)\n        valid_pairs = 0\n        \n        for num in a:\n            complement = target_sum - num\n            if complement in count_map:\n                valid_pairs += count_map[complement]\n            count_map[num] += 1\n        \n        results.append(valid_pairs)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that removing these elements\n    keeps the average of the remaining elements equal to the original average.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n    \n    for array in test_cases:\n        n = len(array)\n        total_sum = sum(array)\n        target_sum = total_sum * (n - 2) / n\n        \n        # Dictionary to store frequency of elements\n        freq = defaultdict(int)\n        for num in array:\n            freq[num] += 1\n        \n        count_pairs = 0\n        \n        for num in array:\n            # Calculate the required second number to form a valid pair\n            required_num = target_sum - num\n            \n            # Decrease frequency of current number to avoid counting itself\n            freq[num] -= 1\n            \n            # Check if the required number exists in the remaining array\n            if required_num in freq:\n                count_pairs += freq[required_num]\n            \n            # Restore frequency for next iteration\n            freq[num] += 1\n        \n        # Since each pair is counted twice (once for each element), divide by 2\n        results.append(count_pairs // 2)\n    \n    return results\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    test_cases.append(array)\n\n# Output interface\nresults = count_valid_pairs(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Dict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Counts the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the average of the remaining elements the same.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        target_sum = 2 * total_sum / n\n\n        # Use a hashmap to count occurrences of each element\n        count_map: Dict[int, int] = {}\n        for num in a:\n            if num in count_map:\n                count_map[num] += 1\n            else:\n                count_map[num] = 1\n\n        valid_pairs = 0\n\n        # Iterate over the array to find valid pairs\n        for num in a:\n            complement = target_sum - num\n\n            # Decrease the count of the current number\n            count_map[num] -= 1\n\n            # Check if the complement exists in the map\n            if complement in count_map and count_map[complement] > 0:\n                valid_pairs += count_map[complement]\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of pairs of positions [i, j] such that removing these elements keeps the average of the remaining elements equal to the original average.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of valid pairs for each test case.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        target_sum = total_sum * (n - 2) / n\n\n        # Dictionary to store frequency of each element\n        freq = defaultdict(int)\n        for num in a:\n            freq[num] += 1\n\n        count = 0\n        for i in range(n):\n            # Calculate the needed value to pair with a[i] to achieve the target sum\n            needed = total_sum - target_sum - a[i]\n            if needed in freq:\n                count += freq[needed]\n                # If the needed value is the same as a[i], we should decrement the count by one\n                # because we are considering the same element twice\n                if needed == a[i]:\n                    count -= 1\n\n        # Each pair is counted twice, so divide by 2\n        results.append(count // 2)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Call the function and print results\n    results = count_pairs(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Counts the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the average of the remaining elements the same as the\n    original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for case in test_cases:\n        n = len(case)\n        total_sum = sum(case)\n        target_sum = total_sum * (n - 2) / n\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in case:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        for num in case:\n            # Calculate the required pair value\n            required_pair_value = target_sum - num\n\n            # Check if the required pair value exists in the map\n            if required_pair_value in count_map:\n                valid_pairs += count_map[required_pair_value]\n\n            # If the required pair value is the same as the current number,\n            # we need to decrement the count to avoid counting the pair (num, num)\n            if required_pair_value == num:\n                valid_pairs -= 1\n\n        # Each pair is counted twice, so divide by 2\n        results.append(valid_pairs // 2)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        array = list(map(int, input().strip().split()))\n        test_cases.append(array)\n\n    # Call the function and print results\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the number of valid pairs of positions [i, j] such that if the elements\n    on these positions are deleted, the mathematical average of the remaining elements\n    equals the original average of the array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        k = total_sum / n\n        target_sum = 2 * k\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        # Iterate over each element to find valid pairs\n        for num in a:\n            # Decrease the count of the current number as it is being considered\n            count_map[num] -= 1\n\n            # Calculate the required pair number\n            required_pair = target_sum - num\n\n            # Check if the required pair exists in the map\n            if required_pair in count_map:\n                valid_pairs += count_map[required_pair]\n\n        # Append the result for the current test case\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef count_valid_pairs(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Counts the number of valid pairs of positions [i, j] such that removing\n    these elements keeps the average of the remaining elements the same as the\n    original array.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results for each test case, representing the number of valid pairs.\n    \"\"\"\n    results = []\n\n    for a in test_cases:\n        n = len(a)\n        total_sum = sum(a)\n        k = total_sum / n\n        target_sum = (n - 2) * k\n\n        # Use a hashmap to count occurrences of each element\n        count_map = defaultdict(int)\n        for num in a:\n            count_map[num] += 1\n\n        valid_pairs = 0\n\n        for num in a:\n            # Calculate the required pair value\n            required_pair_value = target_sum - (total_sum - num)\n            count_map[num] -= 1  # Decrement count of current element\n\n            # Check if the required pair value exists in the map\n            if required_pair_value in count_map:\n                valid_pairs += count_map[required_pair_value]\n\n        results.append(valid_pairs)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output interface\n    results = count_valid_pairs(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to find pairs of elements in an array such that removing them keeps the average of the remaining elements the same as the original average. The solution must efficiently handle large arrays and multiple test cases, ensuring accuracy even with negative numbers.\nrequirement pool:\n- Efficiently calculate valid pairs of elements\n- Ensure solution handles negative numbers\n- Optimize for large input sizes\n- Provide clear output format\n- Maintain low memory usage\nWe will use a hashmap to efficiently count pairs of elements that can be removed to maintain the average. The approach involves calculating the total sum of the array and using the properties of averages to determine valid pairs. This method ensures handling of negative numbers and optimizes performance for large input sizes.\n", "requirement analysis:\nThe task requires calculating pairs of positions in an array such that removing these elements keeps the average of the remaining elements unchanged. The solution must efficiently handle large arrays and multiple test cases, ensuring accuracy even with negative numbers.\nrequirement pool:\n- Accurate calculation of pairs\n- Efficient handling of large inputs\n- Support for negative numbers\n- Clear and correct output format\n- Robust error handling\nWe will use a hashmap to efficiently count pairs of elements that can be removed to maintain the average. The key insight is that the sum of the remaining elements must be equal to the sum of the original array minus the sum of the two removed elements. This approach will handle large inputs efficiently and support negative numbers.\n", "requirement analysis:\nThe task requires calculating the number of valid pairs of positions in an array such that removing these elements keeps the average of the remaining elements unchanged. The solution must efficiently handle large arrays and multiple test cases, ensuring accuracy even with negative numbers.\nrequirement pool:\n- Accurate calculation of valid pairs\n- Efficient handling of large input sizes\n- Support for negative numbers in arrays\n- Clear output format\n- User-friendly input handling\nWe will use a hashmap to efficiently count the occurrences of each element in the array. The key insight is that for the average to remain the same after removing two elements, the sum of the two removed elements must equal twice the average of the entire array. This allows us to find pairs of elements that satisfy this condition in O(n) time per test case, ensuring the solution is efficient even for large input sizes.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of indices such that removing these elements keeps the average of the remaining elements the same as the original array. The solution must efficiently handle large arrays and consider edge cases, including arrays with negative numbers.\nrequirement pool:\n- Efficiently calculate valid pairs for large datasets\n- Handle arrays with negative numbers correctly\n- Optimize for edge cases\n- Ensure solution is tested against multiple test cases\n- Provide clear documentation and comments in the code\nWe will use a hashmap to efficiently count pairs of elements that can be removed to maintain the average. The approach involves calculating the total sum of the array and using the properties of averages to determine valid pairs. This method ensures we handle large datasets and arrays with negative numbers efficiently.\n", "requirement analysis:\nThe task requires calculating the number of pairs of positions [i, j] such that removing these elements keeps the average of the remaining elements equal to the original average. The solution must efficiently handle large arrays and multiple test cases, ensuring performance and accuracy even with negative numbers.\nrequirement pool:\n- Efficiently calculate valid pairs for large arrays\n- Ensure solution handles negative numbers correctly\n- Optimize performance for maximum constraints\n- Provide clear output format\n- Support multiple test cases input\nWe will calculate the total sum of the array and use it to determine the required sum of the remaining elements after removing two elements. By iterating through the array and using a hashmap to track the frequency of elements, we can efficiently find pairs of elements that satisfy the condition. This approach ensures that we handle large arrays and negative numbers effectively.\n", "requirement analysis:\nThe problem requires calculating the number of pairs of elements that can be removed from an array such that the average of the remaining elements remains unchanged. The solution must efficiently handle up to 10,000 test cases with arrays containing up to 200,000 elements in total. The solution should also account for arrays with negative numbers and ensure the output format is strictly followed.\nrequirement pool:\n- Efficiently handle large input sizes and multiple test cases\n- Correctly calculate the number of valid pairs of elements to remove\n- Support arrays with negative numbers\n- Ensure output format is strictly followed\n- Optimize for performance and clarity\nWe will use a hashmap to efficiently count the occurrences of each element in the array. The key observation is that for the average to remain the same after removing two elements, the sum of the removed elements must equal twice the average of the original array. This allows us to find pairs of elements whose sum equals twice the average. We will iterate over the array, and for each element, calculate the required complement that would form a valid pair. We will use the hashmap to check if this complement exists and count the valid pairs.\n", "requirement analysis:\nThe task requires calculating pairs of positions in an array such that removing these elements maintains the average of the remaining elements. The solution must efficiently handle large arrays and multiple test cases, ensuring accuracy even with negative numbers.\nrequirement pool:\n- Accurate calculation of pairs maintaining average\n- Efficient handling of large datasets\n- Clear and concise output format\n- Robust handling of edge cases including negative numbers\n- User-friendly input method for multiple test cases\nWe will implement a function that calculates the number of pairs of positions [i, j] such that removing these elements keeps the average of the remaining elements equal to the original average. The approach involves calculating the total sum of the array and using a hashmap to efficiently find pairs that satisfy the condition. This ensures the solution is optimized for large datasets and handles negative numbers correctly.\n", "requirement analysis:\nThe requirement is to find pairs of elements in an array such that removing them keeps the average of the remaining elements the same as the original average. The solution must efficiently handle large arrays and multiple test cases, ensuring accurate results even with negative numbers.\nrequirement pool:\n- Implement efficient algorithm to find valid pairs\n- Ensure solution handles large input sizes within constraints\n- Optimize for performance and memory usage\n- Provide clear output format\n- Include edge case handling for negative numbers\nWe will use a hashmap to efficiently count pairs of elements that can be removed to maintain the average. The key insight is that the sum of the remaining elements should be equal to the sum of the original array minus the sum of the two removed elements. This approach will handle large arrays and negative numbers efficiently.\n", "requirement analysis:\nThe task requires calculating the number of pairs of elements that can be removed from an array such that the average of the remaining elements remains unchanged. The solution must efficiently handle large arrays and consider edge cases, including arrays with negative numbers.\nrequirement pool:\n- Efficiently compute the number of valid pairs for large datasets\n- Handle arrays with negative numbers correctly\n- Ensure the solution is easy to understand and maintain\n- Optimize for both time and space complexity\n- Provide detailed error messages for invalid inputs\nWe will use a hashmap to efficiently count the occurrences of each element in the array. The key insight is that for the average to remain the same after removing two elements, the sum of the two removed elements must equal twice the average of the entire array. This allows us to find pairs of elements that satisfy this condition in O(n) time per test case, which is efficient enough given the constraints.\n", "requirement analysis:\nThe task requires calculating pairs of indices in an array such that removing these indices keeps the average of the remaining elements the same as the original array. The solution must efficiently handle large arrays and negative numbers, ensuring accuracy and performance.\nrequirement pool:\n- Accurate calculation of pairs\n- Efficient handling of large inputs\n- Support for negative numbers\n- User-friendly input/output format\n- Detailed error handling\nWe will use a hashmap to efficiently count pairs of elements that can be removed to maintain the average. The approach involves calculating the total sum of the array and using the properties of averages to determine valid pairs. This method ensures we handle large inputs and negative numbers effectively.\n"], "scores": [], "pass_results": [false, true, false, true, true, true, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 199, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains one integer n (3 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of elements in the array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 \u2264 a_i \u2264 10^{9}), where a_i is the i-th element of the array.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\n\nExample\n\nInput\n\n\n4\n4\n8 8 8 8\n3\n50 20 10\n5\n1 4 7 3 5\n7\n1 2 3 4 5 6 7\n\n\nOutput\n\n\n6\n0\n2\n3\n\nNote\n\nIn the first example, any pair of elements can be removed since all of them are equal.\n\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\n\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.", "mutate_method": "rephrase_one", "parent_index": 146}
