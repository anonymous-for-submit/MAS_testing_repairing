{"name": "1575_M. Managing Telephone Poles", "description": "Mr. Chanek's city can be represented as a plane. He wants to build a housing complex in the city.\n\nThere are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1). There is a telephone pole at (x, y) if a_{x, y} = 1.\n\nFor each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y). Formally, the square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2.\n\nTo optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m. Help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "tags": ["data structures", "geometry"], "difficulty": 20, "id": 1575, "sample_io": [{"input": "2 2\n101\n000\n000\n", "output": ["18\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["36\n"]}], "test_list": [{"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["182\n"]}, {"input": "0 0\n1\n", "output": ["0\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["181\n"]}, {"input": "2 2\n101\n010\n000\n", "output": ["8\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n00100\n00110\n", "output": ["33\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00001\n10100\n00110\n", "output": ["25\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["187\n"]}, {"input": "5 4\n10010\n00000\n00000\n00001\n10100\n00110\n", "output": ["38\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["188\n"]}, {"input": "5 4\n10010\n00000\n00000\n01001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n10010\n00100\n00000\n01001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01001\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n10101\n00100\n01001\n10110\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n00111\n", "output": ["16\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n10110\n01111\n", "output": ["15\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["17\n"]}, {"input": "0 4\n10010\n00000\n01000\n00001\n00100\n00010\n", "output": ["3\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["152\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["149\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["163\n"]}, {"input": "5 4\n10010\n00001\n00000\n00001\n10100\n00110\n", "output": ["36\n"]}, {"input": "5 9\n0000110000\n0001001000\n0001000000\n0001011000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["193\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10110\n00110\n", "output": ["32\n"]}, {"input": "5 4\n00010\n00101\n00000\n01001\n10100\n01110\n", "output": ["30\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00010\n", "output": ["35\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00111\n", "output": ["29\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11110\n00111\n", "output": ["22\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["148\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["146\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["164\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10100\n00010\n", "output": ["40\n"]}, {"input": "5 4\n01100\n11101\n00100\n01001\n00110\n00111\n", "output": ["20\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["158\n"]}, {"input": "9 9\n0000110010\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["109\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["147\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["173\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01110\n", "output": ["27\n"]}, {"input": "4 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n10101\n00010\n", "output": ["39\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["157\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["106\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["171\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["107\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["129\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["101\n"]}, {"input": "4 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["14\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["103\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["128\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n00100\n01111\n", "output": ["9\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001000011\n0011111110\n", "output": ["133\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["90\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["89\n"]}, {"input": "1 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["7\n"]}, {"input": "9 9\n0000110011\n0001011000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["88\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["84\n"]}, {"input": "4 4\n10010\n10100\n01011\n00010\n00101\n10111\n", "output": ["19\n"]}, {"input": "3 4\n01100\n11101\n00100\n01101\n10110\n01110\n", "output": ["10\n"]}, {"input": "9 9\n0000110011\n0001011010\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["85\n"]}, {"input": "1 4\n01100\n11101\n00100\n00101\n11110\n01110\n", "output": ["4\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["184\n"]}, {"input": "2 2\n101\n000\n010\n", "output": ["6\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["177\n"]}, {"input": "2 2\n101\n000\n110\n", "output": ["5\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10100\n00110\n", "output": ["67\n"]}, {"input": "5 4\n00000\n00100\n00000\n01001\n10100\n00010\n", "output": ["43\n"]}, {"input": "0 4\n10110\n00000\n01000\n00001\n00100\n00010\n", "output": ["2\n"]}, {"input": "9 9\n0000110010\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111101110\n", "output": ["153\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n1001111000\n0001000000\n0001001000\n0110100110\n1000000001\n1001001011\n0111111110\n", "output": ["145\n"]}, {"input": "5 4\n00010\n00100\n00000\n00001\n10110\n00110\n", "output": ["37\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["180\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000000\n1001001001\n0111111110\n", "output": ["159\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00010\n", "output": ["52\n"]}, {"input": "9 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["137\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001110000\n0101000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["175\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001000\n0001111000\n1001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["99\n"]}, {"input": "5 4\n01000\n00111\n10100\n01101\n11111\n00111\n", "output": ["13\n"]}, {"input": "9 9\n0100100001\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["113\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110100110\n1000000011\n1001001011\n0110111110\n", "output": ["124\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000001\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["98\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["97\n"]}, {"input": "2 9\n0000110000\n0001000100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["78\n"]}, {"input": "9 9\n0000110011\n0001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["87\n"]}, {"input": "9 9\n0001110000\n0001001000\n0001001000\n1001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["144\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0001111000\n0001000000\n0001001000\n0110000010\n1000000001\n1001001011\n0011111110\n", "output": ["190\n"]}, {"input": "5 4\n10000\n00000\n00000\n00001\n10101\n00110\n", "output": ["66\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001000010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["162\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1001001011\n0111111110\n", "output": ["136\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1101111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["115\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["139\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["121\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00011\n", "output": ["51\n"]}, {"input": "4 9\n0000100000\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["111\n"]}, {"input": "5 4\n11010\n00000\n00000\n00001\n10100\n00111\n", "output": ["34\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001001\n0011111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["86\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001011\n0110111110\n", "output": ["126\n"]}, {"input": "9 9\n1100010000\n1001001000\n0001001100\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["96\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001001000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["79\n"]}, {"input": "9 9\n0000110000\n0001011000\n0001000000\n0001011000\n0001010010\n0001001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["161\n"]}, {"input": "9 9\n0000110000\n0001001000\n1001001000\n0000111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["143\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["135\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["116\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001000000\n0101111000\n1001000100\n0011001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["138\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n0001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["123\n"]}, {"input": "5 4\n00000\n00101\n00000\n00001\n00101\n00111\n", "output": ["48\n"]}, {"input": "4 9\n0000100000\n0101001001\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0111111110\n", "output": ["73\n"]}, {"input": "3 4\n10010\n11101\n01000\n00011\n00100\n00110\n", "output": ["12\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001100\n0001111000\n1001001001\n0001001000\n0110000110\n0000010001\n1001001011\n0111111110\n", "output": ["76\n"]}, {"input": "2 4\n00010\n10100\n01001\n00011\n00100\n10111\n", "output": ["11\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["127\n"]}, {"input": "2 9\n0000110000\n0001001100\n0011000000\n0001110010\n1101000000\n0001001000\n0110000110\n1000000001\n1001000001\n0011111110\n", "output": ["57\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001000\n0110000110\n0000010001\n1001000011\n0111111111\n", "output": ["77\n"]}, {"input": "9 9\n0000110011\n1001111000\n1001000000\n0011111100\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0111111111\n", "output": ["80\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["142\n"]}, {"input": "5 4\n10001\n00000\n00000\n00001\n10101\n10110\n", "output": ["42\n"]}, {"input": "0 4\n11110\n01000\n01000\n00001\n00110\n00010\n", "output": ["1\n"]}, {"input": "9 9\n0000010010\n0001001001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["131\n"]}, {"input": "9 9\n0000110000\n0001001000\n0001001010\n1100111000\n0001000000\n0001000000\n0110000110\n1000000001\n1001001011\n0111111100\n", "output": ["117\n"]}, {"input": "9 9\n0000110000\n0011001100\n0001000000\n1001110000\n1000000000\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["118\n"]}, {"input": "9 9\n0000110000\n0001001100\n0001000000\n0001110100\n0101000100\n0001001000\n0110000110\n1000000001\n1001001011\n0011111110\n", "output": ["125\n"]}, {"input": "9 9\n0000110011\n0101001000\n1001001001\n0001111000\n0001001000\n0001001000\n0110000110\n0000010001\n1001001011\n0110111110\n", "output": ["82\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["110\n"]}, {"input": "2 9\n0000010000\n0001001100\n0001000000\n0001110000\n1101000000\n0001101000\n0110001110\n1000000000\n1001001001\n0011111110\n", "output": ["75\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001111000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["140\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001001000\n0001001000\n0110000110\n1000010001\n1101001011\n0111111110\n", "output": ["132\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000000011\n1001001001\n0110111110\n", "output": ["105\n"]}, {"input": "9 9\n1100010000\n1001001000\n0101001100\n1101111000\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111010\n", "output": ["102\n"]}, {"input": "9 9\n0100110000\n0001001000\n0001101000\n0001011000\n0001000000\n0101001000\n0110001110\n1000000001\n1001001001\n0111111110\n", "output": ["141\n"]}, {"input": "7 9\n0000110000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001000\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["189\n"]}, {"input": "2 9\n0000110000\n0000001100\n0011000000\n1001110010\n1101000000\n0001001000\n0110000110\n1000000011\n1001000001\n0011111110\n", "output": ["60\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n0010010001\n1001000011\n0111111111\n", "output": ["72\n"]}, {"input": "9 9\n0000110000\n0001011001\n0101000000\n0001011000\n0101010010\n0101001000\n0110000110\n1000000001\n1001001011\n0111111110\n", "output": ["83\n"]}, {"input": "5 4\n10000\n00001\n00000\n00001\n01110\n00111\n", "output": ["41\n"]}, {"input": "9 9\n0000010010\n0001000001\n0001001100\n0001111000\n0001011000\n0001001000\n0110000110\n1000010001\n1101101011\n0111111110\n", "output": ["130\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0001111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["155\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001100\n1101111101\n0001000000\n0001001000\n0100100110\n1000100011\n1001001001\n0110101110\n", "output": ["104\n"]}, {"input": "9 9\n0000110011\n0001001000\n1001001010\n0011111100\n1001001000\n0001001100\n0110000111\n1010010001\n1001000011\n0111111111\n", "output": ["71\n"]}, {"input": "7 9\n0000100000\n0001000000\n0001000000\n0001111000\n1001000000\n0001001001\n0110000111\n0000000001\n1001001011\n0111111110\n", "output": ["195\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001000100\n0011111010\n0001001000\n0001001000\n0011000110\n1100000000\n1001000001\n1111111110\n", "output": ["134\n"]}, {"input": "5 4\n00010\n00100\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n00000\n00101\n00000\n01001\n10100\n00110\n", "output": ["33\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00110\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n10100\n00111\n", "output": ["24\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0110000110\n1000000001\n1001001001\n0111111110\n", "output": ["183\n"]}, {"input": "5 4\n10010\n00000\n01000\n00011\n00100\n00110\n", "output": ["31\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00110\n", "output": ["24\n"]}, {"input": "5 4\n11010\n00100\n00000\n01001\n10100\n00110\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00101\n00100\n01000\n10110\n00111\n", "output": ["23\n"]}, {"input": "5 4\n01000\n10101\n00100\n01101\n10110\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01100\n10101\n00100\n01001\n00110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10110\n01111\n", "output": ["17\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00110\n01111\n", "output": ["16\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001000\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001001\n0111111110\n", "output": ["181\n"]}, {"input": "5 4\n10010\n00100\n01000\n00011\n00100\n00110\n", "output": ["29\n"]}, {"input": "5 4\n11010\n00000\n01000\n00001\n10100\n00111\n", "output": ["23\n"]}, {"input": "5 4\n10011\n00001\n00000\n00001\n10100\n00110\n", "output": ["35\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n00010\n00101\n00000\n01011\n10100\n01110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00000\n00001\n10100\n00110\n", "output": ["30\n"]}, {"input": "5 4\n01000\n00101\n00000\n01001\n11111\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01000\n00101\n00100\n01010\n10110\n00111\n", "output": ["21\n"]}, {"input": "5 4\n01100\n10101\n00100\n01000\n10111\n01111\n", "output": ["15\n"]}, {"input": "4 4\n01100\n10101\n00100\n01001\n00100\n01111\n", "output": ["17\n"]}, {"input": "5 4\n10010\n10100\n01000\n00011\n00100\n00110\n", "output": ["28\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00110\n", "output": ["27\n"]}, {"input": "5 4\n01000\n00101\n10000\n01001\n11111\n00111\n", "output": ["18\n"]}, {"input": "5 4\n01000\n00101\n00100\n01011\n10110\n00111\n", "output": ["20\n"]}, {"input": "4 4\n01100\n10101\n00100\n01101\n00100\n01111\n", "output": ["16\n"]}, {"input": "5 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["26\n"]}, {"input": "9 9\n0000010000\n0001001000\n0001001000\n1101111000\n0001000000\n0001001000\n0110000110\n1000000001\n1001001011\n0110111110\n", "output": ["148\n"]}, {"input": "5 4\n11010\n00100\n00000\n00001\n10100\n01111\n", "output": ["26\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00010\n", "output": ["36\n"]}, {"input": "5 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["31\n"]}, {"input": "5 4\n01000\n00101\n10000\n01101\n11111\n00111\n", "output": ["17\n"]}, {"input": "5 4\n01000\n00101\n00100\n00011\n10110\n00111\n", "output": ["24\n"]}, {"input": "4 4\n01100\n11101\n00100\n01101\n00100\n01111\n", "output": ["15\n"]}, {"input": "9 9\n0000100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["158\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00110\n", "output": ["20\n"]}, {"input": "5 4\n11010\n00100\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00101\n00100\n00001\n10101\n00011\n", "output": ["35\n"]}, {"input": "3 4\n01000\n00101\n00100\n00001\n10100\n00100\n", "output": ["25\n"]}, {"input": "5 4\n01000\n00101\n10100\n01101\n11111\n00111\n", "output": ["15\n"]}, {"input": "9 9\n0100100000\n0001001000\n0001001100\n0001111000\n0001001000\n0001001000\n0111000110\n1000000001\n1001001011\n0011111110\n", "output": ["129\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n00111\n", "output": ["20\n"]}, {"input": "2 9\n0000110000\n0001001000\n0001000000\n0001110000\n1101000000\n0001001000\n0110000110\n1000000001\n1001001001\n0011111110\n", "output": ["101\n"]}, {"input": "5 4\n11010\n00110\n00000\n00011\n10100\n01111\n", "output": ["22\n"]}, {"input": "5 4\n00000\n00101\n00100\n10001\n10101\n00011\n", "output": ["30\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n00100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n11111\n00111\n", "output": ["23\n"]}, {"input": "4 4\n10010\n10100\n01001\n00011\n00100\n10111\n", "output": ["20\n"]}, {"input": "9 9\n0100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["109\n"]}, {"input": "5 4\n11000\n00110\n00000\n00011\n10100\n01111\n", "output": ["24\n"]}, {"input": "5 4\n00000\n00111\n00100\n10001\n10101\n00011\n", "output": ["28\n"]}, {"input": "3 4\n01001\n00101\n00100\n00001\n10100\n10100\n", "output": ["23\n"]}, {"input": "5 4\n01000\n00100\n10100\n01101\n01111\n00111\n", "output": ["25\n"]}, {"input": "3 4\n01100\n11111\n00100\n01101\n10100\n01111\n", "output": ["9\n"]}, {"input": "4 4\n10010\n10100\n01001\n00010\n00100\n10111\n", "output": ["22\n"]}, {"input": "9 9\n1100010000\n0001001000\n0001001000\n1101111100\n0001000000\n0001001000\n0110000110\n1000000011\n1001001011\n0110111110\n", "output": ["107\n"]}, {"input": "2 9\n0000110000\n0001001100\n0001000000\n0001110000\n1101000000\n0001001000\n0110001110\n1000000001\n1001001001\n0011111110\n", "output": ["74\n"]}], "task_id": "codecontest/12", "prompt": "Mr. Chanek's city can be represented as a plane, where he wants to build a housing complex. There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1), with a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), and this square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m, so help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "repair_prompt": ["Mr. Chanek's city can be represented as a plane, where he wants to build a housing complex. There are some telephone poles on the plane, which is represented by a grid a of size (n + 1) \u00d7 (m + 1), with a telephone pole at (x, y) if a_{x, y} = 1. For each point (x, y), define S(x, y) as the square of the Euclidean distance between the nearest pole and (x, y), and this square of the Euclidean distance between two points (x_1, y_1) and (x_2, y_2) is (x_2 - x_1)^2 + (y_2 - y_1)^2. To optimize the building plan, the project supervisor asks you the sum of all S(x, y) for each 0 \u2264 x \u2264 n and 0 \u2264 y \u2264 m, so help him by finding the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): A grid representing the positions of telephone poles.\n\n    Returns:\n        int: The sum of squared distances from each point to the nearest telephone pole.\n    \"\"\"\n    # Initialize a distance grid with a large number\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with all telephone pole positions and set their distance to 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate the minimum distance to a telephone pole for each point\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                if distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                    distance_grid[nx][ny] = distance_grid[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distance_grid[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Call the function and output the result\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): A grid representing the positions of telephone poles.\n\n    Returns:\n        int: The sum of squared distances for each point in the grid.\n    \"\"\"\n    # Initialize a distance grid with infinity values\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0  # Distance to itself is zero\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate minimum distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # Calculate the new distance\n                new_distance = distance_grid[x][y] + 1\n                \n                if new_distance < distance_grid[nx][ny]:\n                    distance_grid[nx][ny] = new_distance\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distance_grid[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Call the function and output the result\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared Euclidean distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): A 2D list representing the grid with telephone poles.\n\n    Returns:\n        int: The sum of squared Euclidean distances.\n    \"\"\"\n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Initialize a distance matrix with infinity\n    distance = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS\n    queue = deque()\n    \n    # Initialize the queue with all telephone poles and set their distance to 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance[x][y] = 0\n    \n    # Perform BFS to calculate the minimum distance to the nearest pole for each grid point\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # Calculate the new distance\n                new_distance = distance[x][y] + 1\n                if new_distance < distance[nx][ny]:\n                    distance[nx][ny] = new_distance\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distance[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Function call\nresult = calculate_sum_of_squared_distances(n, m, grid)\n\n# Output interface\nprint(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\nimport collections\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: np.ndarray) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (np.ndarray): A 2D numpy array representing the grid with telephone poles.\n\n    Returns:\n        int: The sum of squared distances for each point in the grid.\n    \"\"\"\n    # Directions for moving in the grid: right, left, down, up\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Initialize a distance array with a large number\n    distances = np.full((n + 1, m + 1), np.inf)\n    \n    # Queue for BFS\n    queue = collections.deque()\n    \n    # Initialize the queue with all telephone pole positions\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x, y] == 1:\n                queue.append((x, y))\n                distances[x, y] = 0  # Distance to itself is zero\n    \n    # Perform BFS to calculate the shortest distance to a telephone pole\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                if distances[nx, ny] > distances[x, y] + 1:\n                    distances[nx, ny] = distances[x, y] + 1\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distances[x, y] ** 2\n    \n    return int(sum_of_squared_distances)\n\n# Input interface\nn, m = map(int, input().split())\ngrid = np.array([list(map(int, input().strip())) for _ in range(n + 1)])\n\n# Output interface\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nimport numpy as np\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: np.ndarray) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (np.ndarray): A 2D numpy array representing the grid with telephone poles.\n\n    Returns:\n        int: The sum of squared distances for each grid point to the nearest telephone pole.\n    \"\"\"\n    # Initialize a distance array with a large number\n    distances = np.full((n + 1, m + 1), np.inf)\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with all telephone pole positions and set their distances to 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x, y] == 1:\n                queue.append((x, y))\n                distances[x, y] = 0\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate the shortest distance to a telephone pole for each grid point\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # Calculate the new distance\n                new_distance = distances[x, y] + 1\n                if new_distance < distances[nx, ny]:\n                    distances[nx, ny] = new_distance\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distances[x, y] ** 2\n    \n    return int(sum_of_squared_distances)\n\n# Input interface\nn, m = map(int, input().split())\ngrid = np.array([list(map(int, input().strip())) for _ in range(n + 1)])\n\n# Function call\nresult = calculate_sum_of_squared_distances(n, m, grid)\n\n# Output interface\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): A grid representing the positions of telephone poles.\n\n    Returns:\n        int: The sum of squared distances from each grid point to the nearest telephone pole.\n    \"\"\"\n    # Initialize a distance matrix with infinity\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distances[x][y] = 0  # Distance to itself is zero\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate the shortest distance to a pole for each grid point\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                # Calculate the distance from the current pole\n                new_distance = distances[x][y] + 1\n                \n                if new_distance < distances[nx][ny]:\n                    distances[nx][ny] = new_distance\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distances[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Output interface\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): A grid representing the positions of telephone poles.\n\n    Returns:\n        int: The sum of squared distances for each point in the grid.\n    \"\"\"\n    # Initialize the distance grid with infinity\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize the queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0  # Distance to itself is zero\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate the minimum distance to a telephone pole for each point\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                if distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                    distance_grid[nx][ny] = distance_grid[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distance_grid[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Output interface\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): A grid representing the positions of telephone poles.\n\n    Returns:\n        int: The sum of squared distances for each point in the grid.\n    \"\"\"\n    # Initialize a distance matrix with infinity\n    distances = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distances[x][y] = 0  # Distance to itself is zero\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate the minimum distance to a telephone pole for each point\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                if distances[nx][ny] > distances[x][y] + 1:\n                    distances[nx][ny] = distances[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distances[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\nn, m = map(int, input().split())\ngrid = [list(map(int, input().strip())) for _ in range(n + 1)]\n\n# Output interface\nresult = calculate_sum_of_squared_distances(n, m, grid)\nprint(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each grid point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid minus one.\n        m (int): Number of columns in the grid minus one.\n        grid (List[List[int]]): A grid representing the positions of telephone poles.\n\n    Returns:\n        int: The sum of squared distances for each point in the grid.\n    \"\"\"\n    # Initialize a distance grid with infinity\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Initialize a queue for BFS\n    queue = deque()\n    \n    # Populate the queue with initial positions of telephone poles\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0  # Distance to itself is zero\n    \n    # Directions for moving in the grid (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Perform BFS to calculate minimum distances\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                if distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                    distance_grid[nx][ny] = distance_grid[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distance_grid[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n + 1)]\n    \n    # Output interface\n    result = calculate_sum_of_squared_distances(n, m, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom collections import deque\n\ndef calculate_sum_of_squared_distances(n: int, m: int, grid: List[List[int]]) -> int:\n    \"\"\"Calculate the sum of squared distances from each point to the nearest telephone pole.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        grid (List[List[int]]): Grid representing the positions of telephone poles.\n\n    Returns:\n        int: Sum of squared distances for each point in the grid.\n    \"\"\"\n    # Directions for moving in the grid: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Initialize distance grid with infinity\n    distance_grid = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    \n    # Queue for BFS\n    queue = deque()\n    \n    # Initialize the queue with all telephone pole positions\n    for x in range(n + 1):\n        for y in range(m + 1):\n            if grid[x][y] == 1:\n                queue.append((x, y))\n                distance_grid[x][y] = 0\n    \n    # Perform BFS to calculate the minimum distance to a telephone pole for each point\n    while queue:\n        x, y = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx <= n and 0 <= ny <= m:\n                if distance_grid[nx][ny] > distance_grid[x][y] + 1:\n                    distance_grid[nx][ny] = distance_grid[x][y] + 1\n                    queue.append((nx, ny))\n    \n    # Calculate the sum of squared distances\n    sum_of_squared_distances = 0\n    for x in range(n + 1):\n        for y in range(m + 1):\n            sum_of_squared_distances += distance_grid[x][y] ** 2\n    \n    return sum_of_squared_distances\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().strip())) for _ in range(n + 1)]\n    \n    # Call the function and output the result\n    result = calculate_sum_of_squared_distances(n, m, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to compute the sum of squared Euclidean distances from each point in a grid to the nearest telephone pole. The grid size can be large, so the solution must be efficient in both time and space. The presence of at least one telephone pole ensures that every point has a nearest pole.\nrequirement pool:\n- Efficient calculation of distances for large grids\n- Scalable solution that performs well under maximum constraints\n- Clear and accurate output for all test cases\n- Handle edge cases and large inputs efficiently\n- Simple implementation for ease of understanding\nWe will use a Breadth-First Search (BFS) approach to efficiently calculate the nearest telephone pole for each point in the grid. This approach is suitable for large grids as it ensures that each point is processed in a manner that minimizes redundant calculations. We will utilize the collections.deque from Python's standard library to manage the BFS queue efficiently.\n", "requirement analysis:\nThe requirement is to calculate the sum of squared Euclidean distances from each point in a grid to the nearest telephone pole. The grid can be large, so the solution must be efficient in terms of time and space complexity. The algorithm should accurately handle edge cases and ensure that the output format is strictly followed.\nrequirement pool:\n- Implement the main algorithm to calculate the sum of squared distances.\n- Ensure the solution handles large grid sizes efficiently.\n- Optimize the algorithm for real-time performance.\n- Validate the output against multiple test cases.\n- Provide clear documentation and comments in the code.\nWe will use a breadth-first search (BFS) approach to efficiently calculate the nearest telephone pole for each point in the grid. This approach is suitable for large grids as it minimizes redundant calculations and ensures that each point is processed in optimal time. We will utilize the collections.deque for efficient queue operations during BFS.\n", "requirement analysis:\nThe task requires calculating the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The grid can be large, so efficiency is crucial. The solution must handle edge cases and ensure accurate distance calculations.\nrequirement pool:\n- Implement efficient distance calculation algorithm\n- Ensure accurate representation of grid and pole positions\n- Optimize performance for large grid sizes\n- Handle edge cases like minimum grid size\n- Provide clear and reliable output\nWe will implement a function to calculate the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The approach will involve iterating over each grid point and calculating the distance to all poles, selecting the minimum distance for each point. To optimize performance, we will use a breadth-first search (BFS) approach starting from all poles simultaneously, which efficiently computes the minimum distance to the nearest pole for each grid point. This approach is efficient for large grids and ensures accurate distance calculations.\n", "requirement analysis:\nThe requirement is to calculate the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The grid can be large, so the solution must be efficient in terms of time and space complexity. The output must be an integer representing the total sum.\nrequirement pool:\n- Implement efficient distance calculation algorithm\n- Ensure accuracy for all grid sizes\n- Optimize for real-time performance\n- Handle edge cases with minimal poles\n- Provide detailed documentation\nWe will use a breadth-first search (BFS) algorithm to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable for large grids as it minimizes redundant calculations and ensures accurate results. We will utilize the NumPy library for efficient array manipulation and calculations.\n", "requirement analysis:\nThe task requires calculating the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The solution must efficiently handle grids up to 2000x2000 in size, ensuring performance and accuracy. The input format is crucial, and the output must be a single integer representing the total sum.\nrequirement pool:\n- Efficient calculation of squared distances for large grids\n- Accurate handling of edge cases and maximum constraints\n- User-friendly output format\n- Scalability for future grid size increases\n- Integration with other city planning tools\nWe will use a breadth-first search (BFS) algorithm to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable for large grids as it minimizes redundant calculations and ensures optimal performance. We will utilize the NumPy library for efficient array manipulations and calculations.\n", "requirement analysis:\nThe task requires calculating the sum of squared Euclidean distances from each point on a grid to the nearest telephone pole. The grid can be large, so the solution must be efficient. The input format is straightforward, and the output must be a single integer. The challenge lies in efficiently finding the nearest pole for each grid point.\nrequirement pool:\n- Efficiently compute the nearest pole for each grid point.\n- Calculate the sum of squared distances accurately.\n- Optimize the algorithm for large grid sizes.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed documentation and examples.\nWe will use a Breadth-First Search (BFS) algorithm to efficiently compute the nearest pole for each grid point. This approach is suitable for large grids as it explores all possible paths in a systematic manner, ensuring that the shortest path to a pole is found. We will utilize the collections.deque for efficient queue operations in BFS.\n", "requirement analysis:\nThe requirement is to calculate the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The grid can be large, so the solution must be efficient in terms of time and space complexity. The algorithm should accurately handle edge cases and ensure performance does not degrade with larger grid sizes.\nrequirement pool:\n- Implement efficient distance calculation algorithm\n- Ensure accuracy for all grid sizes\n- Optimize for real-time performance\n- Handle edge cases gracefully\n- Provide clear documentation\nWe will use a breadth-first search (BFS) algorithm to efficiently calculate the nearest telephone pole for each grid point. This approach is suitable for large grids as it minimizes redundant calculations and ensures optimal performance. We will utilize the collections.deque for efficient queue operations in BFS.\n", "requirement analysis:\nThe requirement is to calculate the sum of squared Euclidean distances from each point on a grid to the nearest telephone pole. The grid can be large, so the solution must be efficient. The input format is straightforward, and the output is a single integer. The challenge lies in efficiently finding the nearest pole for each point.\nrequirement pool:\n- Efficient calculation of squared distances for each grid point\n- Handle maximum grid size constraints effectively\n- Provide clear documentation and examples for users\n- Optimize the algorithm for speed and accuracy\n- Include visualization tools for better understanding\nWe will use a Breadth-First Search (BFS) algorithm to efficiently calculate the nearest telephone pole for each point in the grid. This approach is suitable for large grids as it can explore all possible paths from each pole simultaneously, ensuring optimal performance. We will utilize the collections.deque for efficient queue operations in BFS.\n", "requirement analysis:\nThe task requires calculating the sum of squared Euclidean distances from each grid point to the nearest telephone pole. The solution must efficiently handle grids up to 2000x2000, ensuring performance and accuracy. The presence of at least one pole guarantees that every point has a nearest pole.\nrequirement pool:\n- Implement the main algorithm to calculate the sum of squared distances.\n- Optimize the algorithm for large grid sizes.\n- Ensure the solution handles edge cases, such as minimal grid sizes.\n- Provide clear documentation and examples for users.\n- Consider additional features like visualizing the grid and distances.\nWe will use a brute-force approach to calculate the sum of squared distances from each grid point to the nearest telephone pole. Given the constraints, we will optimize the search for the nearest pole using a breadth-first search (BFS) approach starting from each pole, which efficiently calculates distances in a grid. This approach ensures that we handle large grid sizes up to 2000x2000 efficiently.\n", "requirement analysis:\nThe task requires calculating the sum of squared Euclidean distances from each point in a grid to the nearest telephone pole. The grid can be large, so the solution must be efficient in both time and space. The presence of at least one telephone pole ensures that every point has a nearest pole.\nrequirement pool:\n- Implement an efficient algorithm to calculate the sum of squared distances.\n- Ensure the solution handles the maximum grid size efficiently.\n- Optimize the algorithm for both time and space complexity.\n- Validate the solution with multiple test cases.\n- Document the code for maintainability and clarity.\nWe will use a Breadth-First Search (BFS) approach to efficiently find the nearest telephone pole for each point in the grid. This method is suitable for large grids and ensures that we can calculate the sum of squared distances in a reasonable time frame. We will utilize the collections.deque for efficient queue operations during BFS.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 4, "examples": "\nInput\n\nThe first line contains two integers n and m (0 \u2264 n, m < 2000) \u2014 the size of the grid.\n\nThen (n + 1) lines follow, each containing (m + 1) integers a_{i, j} (0 \u2264 a_{i, j} \u2264 1) \u2014 the grid denoting the positions of telephone poles in the plane. There is at least one telephone pole in the given grid.\n\nOutput\n\nOutput an integer denoting the value of \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}}.\n\nExamples\n\nInput\n\n\n2 2\n101\n000\n000\n\n\nOutput\n\n\n18\n\n\nInput\n\n\n5 4\n10010\n00000\n01000\n00001\n00100\n00010\n\n\nOutput\n\n\n36\n\nNote\n\n<image>\n\nIn the first example, the nearest telephone pole for the points (0,0), (1,0), (2,0), (0,1), (1,1), and (2,1) is at (0, 0). While the nearest telephone pole for the points (0, 2), (1,2), and (2,2) is at (0, 2). Thus, \u2211_{x=0}^{n} {\u2211_{y=0}^{m} {S(x, y)}} = (0 + 1 + 4) + (1 + 2 + 5) + (0 + 1 + 4) = 18.", "mutate_method": "condense_two2one", "parent_index": 4}
