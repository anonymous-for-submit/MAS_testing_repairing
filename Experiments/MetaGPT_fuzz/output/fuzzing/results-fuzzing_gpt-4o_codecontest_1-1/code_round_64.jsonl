{"name": "1615_B. And It's Non-Zero", "description": "You are given an array consisting of all integers from [l, r] inclusive. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. What's the minimum number of elements you can delete to make the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array non-zero?\n\nA bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "tags": ["bitmasks", "greedy", "math"], "difficulty": 8, "id": 1615, "sample_io": [{"input": "5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n", "output": ["1\n3\n0\n2\n31072\n"]}], "test_list": [{"input": "5\n1 2\n2 8\n4 5\n2 5\n100000 200000\n", "output": ["1\n3\n0\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n100000 200000\n", "output": ["1\n3\n0\n0\n31072\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 5\n100000 200000\n", "output": ["1\n4\n0\n2\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100000 200000\n", "output": ["0\n3\n0\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n110000 200000\n", "output": ["1\n3\n0\n0\n21072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100100 200000\n", "output": ["0\n3\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 10\n110000 200000\n", "output": ["1\n3\n0\n3\n21072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n1 5\n100001 200000\n", "output": ["1\n3\n0\n2\n31071\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n100000 104325\n", "output": ["1\n3\n0\n0\n0\n"]}, {"input": "5\n2 2\n2 8\n1 5\n2 5\n100000 200000\n", "output": ["0\n3\n2\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 12\n110000 200000\n", "output": ["1\n3\n0\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n100100 200000\n", "output": ["0\n3\n1\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n4 9\n1 5\n100000 200000\n", "output": ["1\n3\n2\n2\n31072\n"]}, {"input": "5\n2 2\n2 12\n1 5\n2 5\n100000 200000\n", "output": ["0\n5\n2\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n110000 200000\n", "output": ["2\n3\n0\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 7\n100100 200000\n", "output": ["1\n3\n0\n2\n30972\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n101100 200000\n", "output": ["0\n3\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n100000 200000\n", "output": ["1\n3\n1\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 7\n100100 200000\n", "output": ["1\n2\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101000 200000\n", "output": ["1\n3\n1\n2\n30072\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n101000 200000\n", "output": ["1\n2\n1\n2\n30072\n"]}, {"input": "5\n2 4\n1 8\n4 5\n2 7\n100100 200000\n", "output": ["1\n4\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n101100 200000\n", "output": ["1\n2\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n4 5\n3 5\n100000 200000\n", "output": ["1\n3\n0\n1\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n4 5\n100000 200000\n", "output": ["0\n3\n0\n0\n31072\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 1\n100000 200000\n", "output": ["1\n4\n0\n0\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n4 5\n110000 200000\n", "output": ["0\n3\n0\n0\n21072\n"]}, {"input": "5\n2 2\n2 16\n4 5\n2 5\n100100 200000\n", "output": ["0\n7\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 7\n4 5\n4 10\n110000 200000\n", "output": ["1\n2\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 7\n4 6\n2 5\n100100 200000\n", "output": ["0\n2\n0\n2\n30972\n"]}, {"input": "5\n2 2\n2 8\n1 5\n4 5\n100000 200000\n", "output": ["0\n3\n2\n0\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 6\n4 5\n110001 200000\n", "output": ["1\n3\n0\n0\n21071\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 7\n100110 200000\n", "output": ["0\n3\n0\n2\n30962\n"]}, {"input": "5\n1 2\n2 8\n4 5\n7 12\n110000 200000\n", "output": ["1\n3\n0\n1\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 4\n100100 200000\n", "output": ["0\n3\n1\n1\n30972\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 5\n100000 200000\n", "output": ["1\n3\n3\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n010000 200000\n", "output": ["2\n3\n0\n0\n91697\n"]}, {"input": "5\n1 2\n2 4\n4 5\n4 13\n110000 200000\n", "output": ["1\n1\n0\n4\n21072\n"]}, {"input": "5\n2 2\n1 8\n3 6\n2 5\n101100 200000\n", "output": ["0\n4\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n100000 200000\n", "output": ["1\n3\n1\n5\n31072\n"]}, {"input": "5\n1 4\n1 7\n4 5\n2 7\n100100 200000\n", "output": ["2\n3\n0\n2\n30972\n"]}, {"input": "5\n1 4\n1 8\n4 5\n2 7\n100100 200000\n", "output": ["2\n4\n0\n2\n30972\n"]}, {"input": "5\n2 4\n2 5\n4 5\n2 7\n100100 123776\n", "output": ["1\n2\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 10\n110000 200000\n", "output": ["1\n2\n0\n2\n21072\n"]}, {"input": "5\n2 2\n2 8\n1 6\n4 5\n100000 200000\n", "output": ["0\n3\n3\n0\n31072\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 7\n100110 200000\n", "output": ["0\n4\n0\n2\n30962\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 4\n100101 200000\n", "output": ["0\n3\n1\n1\n30971\n"]}, {"input": "5\n2 2\n1 1\n3 6\n2 5\n101100 200000\n", "output": ["0\n0\n1\n2\n29972\n"]}, {"input": "5\n1 2\n1 8\n7 9\n1 10\n100000 200000\n", "output": ["1\n4\n1\n5\n31072\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101010 188450\n", "output": ["1\n3\n1\n2\n30062\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 20\n110000 200000\n", "output": ["1\n2\n0\n7\n21072\n"]}, {"input": "5\n2 2\n2 8\n1 2\n4 5\n100000 200000\n", "output": ["0\n3\n1\n0\n31072\n"]}, {"input": "5\n2 2\n2 5\n3 6\n2 4\n100101 200000\n", "output": ["0\n2\n1\n1\n30971\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101011 188450\n", "output": ["1\n3\n1\n2\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 5\n101000 200000\n", "output": ["1\n1\n1\n2\n30072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 5\n101011 188450\n", "output": ["1\n3\n3\n2\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 5\n101001 200000\n", "output": ["1\n1\n1\n2\n30071\n"]}, {"input": "5\n1 1\n1 8\n7 10\n1 10\n100000 186611\n", "output": ["0\n4\n1\n5\n31072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 2\n101011 188450\n", "output": ["1\n3\n3\n1\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 7\n101001 200000\n", "output": ["1\n1\n1\n3\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n101001 200000\n", "output": ["2\n1\n1\n3\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n111001 200000\n", "output": ["2\n1\n1\n3\n20071\n"]}, {"input": "5\n1 4\n1 6\n7 9\n1 7\n111001 200000\n", "output": ["2\n3\n1\n3\n20071\n"]}, {"input": "5\n1 4\n2 6\n7 9\n1 7\n111001 200000\n", "output": ["2\n2\n1\n3\n20071\n"]}, {"input": "5\n2 4\n3 6\n7 9\n1 7\n111001 200000\n", "output": ["1\n1\n1\n3\n20071\n"]}, {"input": "5\n2 8\n3 6\n7 9\n1 7\n111001 200000\n", "output": ["3\n1\n1\n3\n20071\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 4\n100001 200000\n", "output": ["1\n3\n0\n0\n31071\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100000 101573\n", "output": ["0\n3\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 4\n4 5\n4 5\n110000 200000\n", "output": ["1\n1\n0\n0\n21072\n"]}, {"input": "5\n1 2\n1 8\n4 5\n4 10\n110000 200000\n", "output": ["1\n4\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n100100 200000\n", "output": ["0\n6\n0\n2\n30972\n"]}, {"input": "5\n1 2\n4 8\n4 5\n1 5\n100000 200000\n", "output": ["1\n1\n0\n2\n31072\n"]}, {"input": "5\n2 2\n2 8\n1 5\n2 5\n100000 161404\n", "output": ["0\n3\n2\n2\n30333\n"]}, {"input": "5\n1 2\n2 8\n3 6\n4 5\n110000 200000\n", "output": ["1\n3\n1\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 10\n100100 200000\n", "output": ["1\n3\n0\n4\n30972\n"]}, {"input": "5\n1 1\n2 8\n4 5\n4 12\n110000 200000\n", "output": ["0\n3\n0\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n100101 200000\n", "output": ["0\n3\n1\n2\n30971\n"]}, {"input": "5\n1 1\n2 8\n7 9\n1 5\n100000 200000\n", "output": ["0\n3\n1\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 11\n4 5\n110000 200000\n", "output": ["2\n3\n4\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 7\n100101 200000\n", "output": ["1\n3\n0\n2\n30971\n"]}, {"input": "5\n1 2\n2 8\n2 5\n4 13\n110000 200000\n", "output": ["1\n3\n2\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 11\n2 5\n101100 200000\n", "output": ["0\n3\n4\n2\n29972\n"]}, {"input": "5\n1 2\n2 13\n7 9\n1 5\n100000 200000\n", "output": ["1\n6\n1\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 7\n000100 200000\n", "output": ["1\n2\n0\n2\n99933\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101000 135172\n", "output": ["1\n3\n1\n2\n4101\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n100000 200000\n", "output": ["1\n2\n1\n2\n31072\n"]}, {"input": "5\n1 4\n2 7\n7 9\n1 5\n101100 200000\n", "output": ["2\n2\n1\n2\n29972\n"]}, {"input": "5\n2 2\n2 10\n4 5\n4 5\n100000 200000\n", "output": ["0\n4\n0\n0\n31072\n"]}, {"input": "5\n2 4\n2 16\n4 5\n2 5\n100100 200000\n", "output": ["1\n7\n0\n2\n30972\n"]}, {"input": "5\n1 3\n2 2\n4 6\n2 5\n100000 200000\n", "output": ["1\n0\n0\n2\n31072\n"]}, {"input": "5\n2 2\n1 8\n1 5\n4 5\n100000 200000\n", "output": ["0\n4\n2\n0\n31072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n4 4\n100100 200000\n", "output": ["0\n3\n1\n0\n30972\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 8\n100000 200000\n", "output": ["1\n3\n3\n4\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n010001 200000\n", "output": ["2\n3\n0\n0\n91696\n"]}, {"input": "5\n2 2\n1 15\n3 6\n2 5\n101100 200000\n", "output": ["0\n7\n1\n2\n29972\n"]}, {"input": "5\n1 4\n1 8\n4 5\n4 7\n100100 200000\n", "output": ["2\n4\n0\n0\n30972\n"]}, {"input": "5\n4 4\n2 5\n4 5\n2 7\n100100 123776\n", "output": ["0\n2\n0\n2\n0\n"]}, {"input": "5\n1 2\n3 7\n4 5\n6 10\n110000 200000\n", "output": ["1\n1\n0\n2\n21072\n"]}, {"input": "5\n2 2\n2 7\n4 6\n2 11\n100100 200000\n", "output": ["0\n2\n0\n4\n30972\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 3\n100110 200000\n", "output": ["0\n4\n0\n0\n30962\n"]}, {"input": "5\n2 2\n2 10\n3 6\n2 4\n100101 200000\n", "output": ["0\n4\n1\n1\n30971\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 20\n100000 200000\n", "output": ["1\n2\n0\n7\n31072\n"]}, {"input": "5\n2 2\n2 5\n3 6\n2 4\n100101 108244\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 3\n1 1\n3 6\n2 5\n111100 200000\n", "output": ["0\n0\n1\n2\n19972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n101011 188450\n", "output": ["1\n3\n1\n5\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 14\n101001 200000\n", "output": ["1\n1\n1\n7\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n110001 200000\n", "output": ["2\n1\n1\n3\n21071\n"]}, {"input": "5\n1 4\n3 6\n7 9\n1 13\n111001 200000\n", "output": ["2\n1\n1\n6\n20071\n"]}, {"input": "5\n1 2\n2 13\n4 5\n1 2\n100000 200000\n", "output": ["1\n6\n0\n1\n31072\n"]}, {"input": "5\n2 2\n2 8\n3 5\n2 5\n100000 101573\n", "output": ["0\n3\n1\n2\n0\n"]}, {"input": "5\n1 2\n1 13\n4 5\n4 10\n110000 200000\n", "output": ["1\n6\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n100100 138386\n", "output": ["0\n6\n0\n2\n7315\n"]}, {"input": "5\n1 2\n2 8\n3 8\n4 5\n110000 200000\n", "output": ["1\n3\n2\n0\n21072\n"]}, {"input": "5\n2 2\n2 2\n3 6\n2 5\n100101 200000\n", "output": ["0\n0\n1\n2\n30971\n"]}, {"input": "5\n1 4\n2 5\n4 11\n4 5\n110000 200000\n", "output": ["2\n2\n4\n0\n21072\n"]}, {"input": "5\n1 4\n2 8\n4 5\n2 7\n100101 200000\n", "output": ["2\n3\n0\n2\n30971\n"]}, {"input": "5\n2 2\n1 8\n3 11\n2 5\n101100 200000\n", "output": ["0\n4\n4\n2\n29972\n"]}, {"input": "5\n2 4\n2 7\n4 5\n1 7\n000100 200000\n", "output": ["1\n2\n0\n3\n99933\n"]}, {"input": "5\n1 2\n2 4\n7 9\n1 5\n101000 135172\n", "output": ["1\n1\n1\n2\n4101\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n100001 200000\n", "output": ["1\n2\n1\n2\n31071\n"]}, {"input": "5\n2 2\n2 8\n2 4\n4 5\n110000 200000\n", "output": ["0\n3\n1\n0\n21072\n"]}, {"input": "5\n2 4\n1 16\n4 5\n2 5\n100100 200000\n", "output": ["1\n8\n0\n2\n30972\n"]}, {"input": "5\n2 2\n1 8\n1 5\n4 5\n100000 150693\n", "output": ["0\n4\n2\n0\n19622\n"]}, {"input": "5\n1 2\n2 8\n3 5\n4 5\n110001 200000\n", "output": ["1\n3\n1\n0\n21071\n"]}, {"input": "5\n1 3\n2 8\n4 5\n2 12\n110000 200000\n", "output": ["1\n3\n0\n5\n21072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 8\n100010 200000\n", "output": ["1\n3\n3\n4\n31062\n"]}, {"input": "5\n1 1\n2 4\n4 5\n4 15\n110000 200000\n", "output": ["0\n1\n0\n4\n21072\n"]}, {"input": "5\n1 4\n1 8\n4 5\n3 7\n100100 200000\n", "output": ["2\n4\n0\n1\n30972\n"]}, {"input": "5\n2 2\n3 7\n4 5\n6 10\n110000 200000\n", "output": ["0\n1\n0\n2\n21072\n"]}, {"input": "5\n2 3\n2 8\n1 6\n4 5\n100100 200000\n", "output": ["0\n3\n3\n0\n30972\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 3\n101110 200000\n", "output": ["0\n4\n0\n0\n29962\n"]}, {"input": "5\n1 2\n4 8\n7 9\n2 5\n101011 188450\n", "output": ["1\n1\n1\n2\n30061\n"]}, {"input": "5\n1 2\n4 7\n4 5\n6 20\n100000 200000\n", "output": ["1\n0\n0\n7\n31072\n"]}, {"input": "5\n2 3\n1 2\n3 6\n2 5\n111100 200000\n", "output": ["0\n1\n1\n2\n19972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n101010 188450\n", "output": ["1\n3\n1\n5\n30062\n"]}, {"input": "5\n1 4\n1 3\n7 15\n1 5\n101000 200000\n", "output": ["2\n1\n1\n2\n30072\n"]}, {"input": "5\n1 1\n1 8\n7 8\n1 10\n100010 186611\n", "output": ["0\n4\n1\n5\n31062\n"]}, {"input": "5\n1 2\n1 4\n7 9\n1 14\n101001 200000\n", "output": ["1\n2\n1\n7\n30071\n"]}, {"input": "5\n1 4\n1 3\n9 9\n1 7\n110001 200000\n", "output": ["2\n1\n0\n3\n21071\n"]}, {"input": "5\n1 4\n1 8\n7 9\n1 7\n111001 200000\n", "output": ["2\n4\n1\n3\n20071\n"]}, {"input": "5\n1 4\n3 6\n7 9\n1 9\n111001 200000\n", "output": ["2\n1\n1\n4\n20071\n"]}, {"input": "5\n2 3\n1 8\n4 5\n2 5\n100100 185068\n", "output": ["0\n4\n0\n2\n30972\n"]}, {"input": "5\n1 2\n1 13\n4 5\n1 10\n110000 200000\n", "output": ["1\n6\n0\n5\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n000100 138386\n", "output": ["0\n6\n0\n2\n69139\n"]}, {"input": "5\n1 2\n2 14\n3 8\n4 5\n110000 200000\n", "output": ["1\n6\n2\n0\n21072\n"]}, {"input": "5\n1 2\n2 5\n4 11\n4 5\n110000 200000\n", "output": ["1\n2\n4\n0\n21072\n"]}, {"input": "5\n1 4\n2 5\n4 5\n2 7\n100101 200000\n", "output": ["2\n2\n0\n2\n30971\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 8\n100001 200000\n", "output": ["1\n2\n1\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 4\n4 5\n110000 200000\n", "output": ["0\n0\n1\n0\n21072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 14\n100010 200000\n", "output": ["1\n3\n3\n7\n31062\n"]}, {"input": "5\n1 1\n2 5\n4 5\n4 15\n110000 200000\n", "output": ["0\n2\n0\n4\n21072\n"]}, {"input": "5\n2 2\n3 9\n4 5\n6 10\n110000 200000\n", "output": ["0\n3\n0\n2\n21072\n"]}, {"input": "5\n1 2\n4 8\n7 9\n3 5\n101011 188450\n", "output": ["1\n1\n1\n1\n30061\n"]}, {"input": "5\n1 4\n4 7\n4 5\n6 20\n100000 200000\n", "output": ["2\n0\n0\n7\n31072\n"]}, {"input": "5\n2 3\n1 2\n1 6\n2 5\n111100 200000\n", "output": ["0\n1\n3\n2\n19972\n"]}, {"input": "5\n1 1\n1 8\n7 8\n2 10\n100010 186611\n", "output": ["0\n4\n1\n4\n31062\n"]}, {"input": "5\n1 2\n1 4\n7 9\n1 14\n100001 200000\n", "output": ["1\n2\n1\n7\n31071\n"]}, {"input": "5\n1 4\n1 3\n9 9\n2 7\n110001 200000\n", "output": ["2\n1\n0\n2\n21071\n"]}, {"input": "5\n1 4\n1 8\n7 9\n1 2\n111001 200000\n", "output": ["2\n4\n1\n1\n20071\n"]}, {"input": "5\n1 2\n3 14\n3 8\n4 5\n110000 200000\n", "output": ["1\n5\n2\n0\n21072\n"]}, {"input": "5\n1 4\n2 5\n4 5\n2 8\n100101 200000\n", "output": ["2\n2\n0\n3\n30971\n"]}, {"input": "5\n1 2\n2 12\n7 9\n1 8\n100001 200000\n", "output": ["1\n5\n1\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 4\n4 5\n110100 200000\n", "output": ["0\n0\n1\n0\n20972\n"]}, {"input": "5\n1 1\n4 5\n4 5\n4 15\n110000 200000\n", "output": ["0\n0\n0\n4\n21072\n"]}, {"input": "5\n1 4\n1 16\n4 7\n3 7\n100100 200000\n", "output": ["2\n8\n0\n1\n30972\n"]}, {"input": "5\n1 2\n3 9\n4 5\n6 10\n110000 200000\n", "output": ["1\n3\n0\n2\n21072\n"]}, {"input": "5\n2 3\n1 2\n1 6\n2 5\n101100 200000\n", "output": ["0\n1\n3\n2\n29972\n"]}, {"input": "5\n1 4\n1 3\n9 9\n2 7\n111001 200000\n", "output": ["2\n1\n0\n2\n20071\n"]}, {"input": "5\n1 4\n1 5\n7 9\n1 2\n111001 200000\n", "output": ["2\n2\n1\n1\n20071\n"]}, {"input": "5\n2 2\n2 5\n3 5\n2 5\n101000 129464\n", "output": ["0\n2\n1\n2\n0\n"]}, {"input": "5\n1 2\n2 12\n4 9\n1 8\n100001 200000\n", "output": ["1\n5\n2\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 8\n4 5\n110100 200000\n", "output": ["0\n0\n3\n0\n20972\n"]}, {"input": "5\n1 2\n4 8\n3 5\n4 7\n110001 200000\n", "output": ["1\n1\n1\n0\n21071\n"]}, {"input": "5\n2 3\n2 8\n3 5\n4 12\n110000 200000\n", "output": ["0\n3\n1\n4\n21072\n"]}, {"input": "5\n1 1\n4 5\n4 5\n4 15\n110010 200000\n", "output": ["0\n0\n0\n4\n21062\n"]}, {"input": "5\n1 1\n1 8\n7 14\n2 16\n100010 186611\n", "output": ["0\n4\n1\n7\n31062\n"]}, {"input": "5\n1 6\n1 5\n7 9\n1 2\n111001 200000\n", "output": ["3\n2\n1\n1\n20071\n"]}, {"input": "5\n2 2\n2 5\n3 9\n2 5\n101000 129464\n", "output": ["0\n2\n3\n2\n0\n"]}, {"input": "5\n1 1\n2 12\n4 9\n1 8\n100001 200000\n", "output": ["0\n5\n2\n4\n31071\n"]}, {"input": "5\n1 2\n4 8\n3 5\n1 7\n110001 200000\n", "output": ["1\n1\n1\n3\n21071\n"]}, {"input": "5\n2 3\n2 8\n3 5\n4 12\n010000 200000\n", "output": ["0\n3\n1\n4\n91697\n"]}, {"input": "5\n2 3\n1 3\n1 6\n2 8\n101100 200000\n", "output": ["0\n1\n3\n3\n29972\n"]}, {"input": "5\n1 1\n1 8\n6 14\n2 16\n100010 186611\n", "output": ["0\n4\n2\n7\n31062\n"]}, {"input": "5\n1 6\n1 10\n7 9\n1 2\n111001 200000\n", "output": ["3\n5\n1\n1\n20071\n"]}, {"input": "5\n1 1\n2 12\n4 13\n1 8\n100001 200000\n", "output": ["0\n5\n4\n4\n31071\n"]}, {"input": "5\n1 2\n4 4\n3 5\n1 7\n110001 200000\n", "output": ["1\n0\n1\n3\n21071\n"]}, {"input": "5\n2 3\n1 5\n1 6\n2 8\n101100 200000\n", "output": ["0\n2\n3\n3\n29972\n"]}, {"input": "5\n1 6\n1 10\n9 9\n1 2\n111001 200000\n", "output": ["3\n5\n0\n1\n20071\n"]}, {"input": "5\n1 1\n2 12\n4 13\n1 8\n100000 200000\n", "output": ["0\n5\n4\n4\n31072\n"]}, {"input": "5\n1 2\n4 4\n3 8\n1 7\n110001 200000\n", "output": ["1\n0\n2\n3\n21071\n"]}, {"input": "5\n1 2\n4 4\n3 8\n2 7\n110001 200000\n", "output": ["1\n0\n2\n2\n21071\n"]}, {"input": "5\n2 3\n2 5\n1 6\n2 8\n101101 200000\n", "output": ["0\n2\n3\n3\n29971\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 5\n100000 121445\n", "output": ["1\n4\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n110010 200000\n", "output": ["1\n3\n0\n0\n21062\n"]}, {"input": "5\n1 2\n2 10\n4 5\n4 12\n110000 200000\n", "output": ["1\n4\n0\n4\n21072\n"]}, {"input": "5\n2 2\n4 8\n3 6\n2 5\n100100 200000\n", "output": ["0\n1\n1\n2\n30972\n"]}, {"input": "5\n2 2\n2 7\n1 5\n2 5\n100000 200000\n", "output": ["0\n2\n2\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 13\n100100 200000\n", "output": ["1\n2\n0\n6\n30972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 1\n101000 200000\n", "output": ["1\n3\n1\n0\n30072\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n111100 200000\n", "output": ["1\n2\n1\n2\n19972\n"]}], "task_id": "codecontest/120", "prompt": "You are provided an array that includes all integers from [l, r]. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. What's the minimum number of elements you can delete to make the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array non-zero?\n\nA bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits. It is important to consider the properties of binary numbers and their bitwise operations to solve this problem efficiently.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "repair_prompt": ["You are provided an array that includes all integers from [l, r]. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. What's the minimum number of elements you can delete to make the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array non-zero?\n\nA bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits. It is important to consider the properties of binary numbers and their bitwise operations to solve this problem efficiently.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_for_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Find the highest bit position set in the range\n        highest_bit = 0\n        for i in range(l, r + 1):\n            highest_bit |= i\n        \n        # Count numbers that do not have the highest bit set\n        deletions = 0\n        for i in range(l, r + 1):\n            if (i & highest_bit) != highest_bit:\n                deletions += 1\n        \n        results.append(deletions)\n    \n    return results\n\ndef main():\n    # Input interface\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Call the function and get results\n    results = min_deletions_for_non_zero_and(t, test_cases)\n    \n    # Output results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_for_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Calculate the number of deletions required\n        # The key observation is that the bitwise AND of a range becomes zero when there is a power of two within the range.\n        # We need to find the largest power of two less than or equal to r.\n        deletions = 0\n        while l <= r:\n            # Find the largest power of two less than or equal to r\n            largest_power_of_two = 1\n            while largest_power_of_two <= r:\n                largest_power_of_two <<= 1\n            largest_power_of_two >>= 1\n            \n            # If the largest power of two is within the range [l, r], we need to delete elements\n            if largest_power_of_two >= l:\n                deletions = r - largest_power_of_two + 1\n                break\n            else:\n                # If no power of two is within the range, no deletions are needed\n                deletions = 0\n                break\n        \n        results.append(deletions)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = min_deletions_for_non_zero_and(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    for l, r in test_cases:\n        # Calculate the number of elements in the range [l, r]\n        num_elements = r - l + 1\n        \n        # Initialize the minimum deletions to the number of elements\n        min_deletions = num_elements\n        \n        # Iterate over possible starting points of the range\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Iterate over the range and calculate the bitwise AND\n            for num in range(start, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions required\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of results for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the number of elements in the range [l, r]\n        num_elements = r - l + 1\n        \n        # Initialize the minimum deletions to the number of elements\n        min_deletions = num_elements\n        \n        # Iterate over possible starting points of the range\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Iterate over the range starting from 'start'\n            for num in range(start, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    # If AND becomes zero, break and count deletions\n                    deletions = num - start + 1\n                    break\n            \n            # Update the minimum deletions required\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Calculate the minimum number of deletions required\n        # The key observation is that the bitwise AND of a range [l, r] is non-zero\n        # if there exists a number in the range that has all bits set in positions\n        # where the AND result is non-zero.\n        \n        # Initialize the bitwise AND result with the first number in the range\n        current_and = l\n        for num in range(l + 1, r + 1):\n            current_and &= num\n            if current_and == 0:\n                break\n        \n        # If the AND result is non-zero, no deletions are needed\n        if current_and != 0:\n            results.append(0)\n        else:\n            # Calculate the minimum deletions required\n            # We need to find the smallest number of deletions to make the AND non-zero\n            min_deletions = float('inf')\n            for num in range(l, r + 1):\n                temp_and = num\n                deletions = 0\n                for other_num in range(l, r + 1):\n                    if other_num != num:\n                        temp_and &= other_num\n                        if temp_and == 0:\n                            deletions += 1\n                min_deletions = min(min_deletions, deletions)\n            results.append(min_deletions)\n    \n    return results\n\ndef main():\n    n = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Call the function and print results\n    results = min_deletions_to_non_zero_and(n, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to achieve a non-zero bitwise AND for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to the maximum possible value\n        min_deletions = r - l + 1\n        \n        # Iterate over all possible bit positions (0 to 17, since 2^17 > 200000)\n        for bit in range(18):\n            # Calculate the mask for the current bit position\n            mask = 1 << bit\n            \n            # Count numbers in the range [l, r] that have the current bit set\n            count_with_bit_set = 0\n            for num in range(l, r + 1):\n                if num & mask:\n                    count_with_bit_set += 1\n            \n            # Calculate deletions needed to make the AND non-zero for this bit position\n            deletions = (r - l + 1) - count_with_bit_set\n            \n            # Update the minimum deletions\n            min_deletions = min(min_deletions, deletions)\n        \n        # Append the result for the current test case\n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Initialize the result for this test case\n        min_deletions = float('inf')\n        \n        # Iterate over all possible starting points of the range\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the AND for the range [start, r]\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # If the AND is non-zero, update the minimum deletions\n            if current_and != 0:\n                min_deletions = min(min_deletions, deletions)\n        \n        # If no valid AND was found, it means we need to delete all but one element\n        if min_deletions == float('inf'):\n            min_deletions = r - l\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(t, cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        num_elements = r - l + 1\n        max_non_zero_length = 0\n        \n        # Iterate over possible starting points for the subarray\n        for start in range(l, r + 1):\n            current_and = start\n            current_length = 1\n            \n            # Iterate over the range and calculate the bitwise AND\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and != 0:\n                    current_length += 1\n                else:\n                    break\n            \n            # Update the maximum length of subarray with non-zero AND\n            max_non_zero_length = max(max_non_zero_length, current_length)\n        \n        # Calculate the minimum deletions required\n        min_deletions = num_elements - max_non_zero_length\n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nn = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output interface\nresults = min_deletions_to_non_zero_and(n, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_for_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the number of elements in the range [l, r]\n        num_elements = r - l + 1\n        \n        # Initialize the minimum deletions to the number of elements\n        min_deletions = num_elements\n        \n        # Iterate over possible starting points of the range\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the AND for the current range starting at 'start'\n            for num in range(start, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    # If AND is non-zero, calculate deletions needed\n                    deletions += (r - num)\n                    break\n            \n            # Update the minimum deletions\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Output interface\n    results = min_deletions_for_non_zero_and(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the number of elements in the range\n        num_elements = r - l + 1\n        \n        # Find the highest bit position where l and r differ\n        highest_diff_bit = 0\n        for bit in range(31, -1, -1):\n            if (l >> bit) != (r >> bit):\n                highest_diff_bit = bit\n                break\n        \n        # Calculate the minimum deletions required\n        min_deletions = max(0, num_elements - (1 << highest_diff_bit))\n        \n        results.append(min_deletions)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. This involves understanding the properties of bitwise operations and efficiently handling large input sizes. The solution must be optimized to handle up to 10,000 test cases with ranges up to 200,000.\nrequirement pool:\n- Develop an algorithm to calculate the minimum deletions for non-zero bitwise AND\n- Ensure the solution is optimized for large input sizes\n- Provide detailed comments and documentation for the code\n- Implement error handling for edge cases\n- Create a user-friendly interface for input and output\nWe will use a mathematical approach to determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The key observation is that the bitwise AND of a range of numbers is non-zero if there exists a number in the range that has all bits set in positions where the AND operation results in non-zero. We will iterate over the range and calculate the bitwise AND, keeping track of the minimum number of deletions required.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. This involves understanding the properties of bitwise operations and efficiently handling large input sizes.\nrequirement pool:\n- Develop an algorithm to calculate the minimum deletions for non-zero bitwise AND.\n- Ensure the solution is optimized for large input sizes up to 10^4 test cases.\n- Provide detailed comments and documentation for the algorithm.\n- Implement comprehensive test cases to validate the solution.\n- Explore alternative algorithms for potential performance improvements.\nWe will iterate over each test case and for each range [l, r], calculate the bitwise AND of all numbers. The key observation is that the bitwise AND of a range becomes zero when there is a power of two within the range. We will use this property to determine the minimum deletions required. The solution will be efficient enough to handle the maximum constraints by leveraging bitwise operations and properties of binary numbers.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. This involves understanding the properties of bitwise operations and efficiently handling large input sizes.\nrequirement pool:\n- Implement the main algorithm to solve the problem efficiently.\n- Optimize the solution for performance to handle up to 10,000 test cases.\n- Ensure the solution is easy to understand and maintain.\n- Handle edge cases effectively, such as when l equals r.\n- Provide comprehensive test cases to verify the solution.\nWe will use a mathematical approach to determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The key observation is that the bitwise AND of a range of numbers is non-zero if there exists a number in the range that has all bits set in positions where the AND result is expected to be non-zero. We will iterate over the range and calculate the bitwise AND, keeping track of the minimum deletions required.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of arrays. The solution must be able to process up to 10,000 test cases with array sizes up to 200,000, ensuring the bitwise AND is non-zero with minimal deletions.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Ensure the solution handles large input sizes effectively\n- Provide clear and accurate output for each test case\n- Optimize the solution for speed and performance\n- Document the solution process for better understanding\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range [l, r] and checking the bitwise AND of subsets to find the optimal solution. We will leverage Python's built-in bitwise operators and optimize the solution to handle large input sizes effectively.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. This involves understanding the properties of bitwise operations and efficiently handling large input sizes.\nrequirement pool:\n- Implement the main algorithm to solve the problem using bitwise operations.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is tested against a variety of test cases.\n- Provide clear documentation and comments in the code.\n- Consider edge cases and potential optimizations.\nWe will use bitwise operations to determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The key observation is that the bitwise AND of a range [l, r] is non-zero if there exists a number in the range that has all bits set in positions where the AND result is non-zero. We will iterate over the range and calculate the AND, keeping track of the number of deletions required to achieve a non-zero result.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations and efficient handling of large input sizes. The solution must be able to determine the minimum number of deletions required to achieve a non-zero bitwise AND for each test case.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Ensure the solution can handle up to 10^4 test cases\n- Optimize the solution for large ranges up to 2 \u22c5 10^5\n- Provide clear output formatting for each test case\n- Include comments and documentation for code clarity\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to achieve a non-zero bitwise AND for each test case. The key insight is to find the smallest number of elements that can be removed such that the remaining elements have a non-zero bitwise AND. This can be achieved by analyzing the binary representation of numbers in the range and finding common bits that can be preserved.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. This involves understanding the properties of bitwise operations and efficiently handling large input sizes.\nrequirement pool:\n- Implement the main algorithm to solve the problem using bitwise operations.\n- Ensure the solution is optimized for large input sizes.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution.\n- Explore alternative algorithms for potential optimization.\nWe will use bitwise operations to determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The key observation is that the bitwise AND of a range [l, r] is non-zero if there exists a number in the range that has all bits set in positions where the AND result is non-zero. We will iterate over the range and calculate the AND, keeping track of the number of deletions needed to achieve a non-zero result.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. This involves understanding the properties of bitwise operations and efficiently handling large input sizes.\nrequirement pool:\n- Develop an algorithm to calculate the minimum deletions for non-zero bitwise AND\n- Ensure the solution is optimized for large input sizes\n- Provide detailed comments and documentation for the code\n- Implement test cases to validate the solution\n- Explore alternative algorithms for potential optimization\nWe will use a mathematical approach to determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The key observation is that the bitwise AND of a range of numbers is non-zero if there exists a number in the range that has all bits set in positions where the AND operation results in non-zero. We will iterate over the range and calculate the bitwise AND, keeping track of the minimum number of deletions required.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. The solution must efficiently handle up to 10,000 test cases with ranges up to 200,000, necessitating an optimized approach to bitwise operations.\nrequirement pool:\n- Develop an algorithm to calculate the minimum deletions for non-zero bitwise AND\n- Ensure the solution is optimized for large input sizes\n- Provide detailed comments and documentation for the solution\n- Implement test cases to validate the solution\n- Explore alternative algorithms for potential optimization\nWe will use a bitwise approach to determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The key observation is that the bitwise AND of a range [l, r] is non-zero if there exists a number in the range that has all bits set in positions where the AND result is non-zero. We will iterate over the range and calculate the AND, keeping track of the number of deletions required to achieve a non-zero result.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. The solution must efficiently handle up to 10,000 test cases with ranges up to 200,000, necessitating an optimized approach to avoid timeouts.\nrequirement pool:\n- Implement an efficient algorithm to compute the minimum deletions\n- Ensure the solution is optimized for large input sizes\n- Provide detailed comments and documentation for the code\n- Include test cases to validate the solution\n- Optimize the code for readability and maintainability\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves analyzing the binary representation of numbers in the range and identifying the minimum subset that can achieve a non-zero AND result. We will leverage Python's built-in bitwise operations and optimize the solution to handle large input sizes effectively.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 64, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "mutate_method": "rephrase_one", "parent_index": 81}
