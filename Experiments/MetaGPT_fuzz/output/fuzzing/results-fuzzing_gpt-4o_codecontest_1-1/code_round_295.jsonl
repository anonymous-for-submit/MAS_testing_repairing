{"name": "1575_A. Another Sorting Problem", "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "tags": ["data structures", "sortings", "strings"], "difficulty": 7, "id": 1575, "sample_io": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": ["5 2 1 3 4 \n"]}], "test_list": [{"input": "5 2\nAA\nAB\nBB\nBA\nZA\n", "output": ["2 1 3 4 5\n"]}, {"input": "5 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "5 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["5 2 1 3 4\n"]}, {"input": "3 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "4 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "3 2\nAA\nBA\nCB\nAB\nAZ\n", "output": ["1 2 3\n"]}, {"input": "4 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1 4 3\n"]}, {"input": "4 2\nBA\nBC\nEA\nAB\nZ@\n", "output": ["4 2 1 3\n"]}, {"input": "3 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 3 1\n"]}, {"input": "3 2\nAA\nBA\nBC\nAB\nAZ\n", "output": ["1 3 2\n"]}, {"input": "5 2\nAA\nBA\nCC\nBB\nAZ\n", "output": ["5 1 4 2 3\n"]}, {"input": "2 2\nAA\nAB\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nCB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nBA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "5 2\nAA\nAB\nBB\nBA\nZB\n", "output": ["2 1 3 4 5\n"]}, {"input": "2 2\nAA\nAD\nCB\nAB\nAZ\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nBA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAB\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAA\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\nZ?\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nDA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nCA\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAZ\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[A\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nCA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nAA\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "3 2\nBA\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBB\nAC\nCA\nBA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nBA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAB\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBC\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAC\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\nBA\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nDB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAD\nBC\nA@\n?Z\n", "output": ["2 1\n"]}, {"input": "4 2\nBA\nAC\nEA\nAB\nZ@\n", "output": ["2 4 1 3\n"]}, {"input": "1 2\nCB\nAC\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBA\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nAC\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nCB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBC\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "1 2\nCB\nCA\nCA\nAB\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nBC\nBB\nBB\nZ?\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nBB\nCA\nCA\n@Y\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nCA\nAC\nAD\n[C\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nDA\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nDA\nBB\nA?\n?Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nBB\nCA\nDA\n@Y\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nCA\nBB\nAA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nCA\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nBB\nAC\nD@\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nBB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nBA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nAB\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nAB\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nA[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA?\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nBA\nB[\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nAD\nCA\nA>\n?Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nDA\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nB[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nAC\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nCA\nC[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAD\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\nC[\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAE\nAB\nBA\n[C\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAB\nCB\nAC\nAZ\n", "output": ["2 1\n"]}, {"input": "3 2\nAA\nAC\nCB\nAB\nAZ\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nBC\nDB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nCB\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nBC\nBC\nAC\nZA\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCB\nAB\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nAC\nCC\nBA\nZA\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nCA\nBC\nBA\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nCC\nAA\nZA\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAD\nCB\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCB\n@A\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nCA\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAC\nCA\nAB\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nAC\nAC\nAB\n@Y\n", "output": ["2 1\n"]}, {"input": "2 2\nAA\nBC\nBD\nAB\nYA\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAC\nBC\nAB\n[A\n", "output": ["2 1 3\n"]}, {"input": "2 2\nAA\nAC\nAC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 1\nAA\nAC\nBC\nAA\nAZ\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nDA\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "2 2\nBA\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 1\nAB\nCA\nCA\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBA\nAC\nCA\nAB\n@Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nBC\nBA\nAB\n@Z\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCA\nAC\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "5 2\nAA\nAB\nCC\nBB\nAZ\n", "output": ["5 2 1 4 3\n"]}, {"input": "2 2\nBA\nCB\nBB\nAB\nAZ\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nAB\nBC\nBA\nAY\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nAC\nCB\nAA\n[@\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCA\nAD\nAB\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nAB\nCB\nCB\nAB\n@Y\n", "output": ["1 2\n"]}, {"input": "3 2\nAA\nAB\nCC\nBA\nAY\n", "output": ["2 1 3\n"]}, {"input": "1 2\nBA\nBC\nBB\nBB\nZA\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nAC\nAC\n[A\n", "output": ["1 2\n"]}, {"input": "2 2\nAA\nAB\nBC\nBA\nAZ\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAB\nBB\nBA\nA[\n", "output": ["1\n"]}, {"input": "1 2\nAA\nAC\nBC\nAB\n@[\n", "output": ["1\n"]}, {"input": "1 2\nBA\nBC\nCA\nAA\nZ@\n", "output": ["1\n"]}, {"input": "2 2\nAA\nCA\nBC\nAA\n?Z\n", "output": ["1 2\n"]}, {"input": "3 2\nAB\nAC\nEA\nAA\nZ@\n", "output": ["2 1 3\n"]}, {"input": "2 2\nBA\nAC\nAC\nAA\nZ@\n", "output": ["2 1\n"]}, {"input": "1 2\nBB\nCA\nCA\nBA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAB\nBA\nAC\nBA\nZ@\n", "output": ["1 2\n"]}, {"input": "2 2\nBB\nCB\nCA\nAC\n@Y\n", "output": ["1 2\n"]}, {"input": "1 2\nBA\nCB\nBB\nBA\nZA\n", "output": ["1\n"]}, {"input": "2 2\nBA\nAC\nAC\nAC\n[B\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\nAZ\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAB\nBC\nB@\nA[\n", "output": ["2 1\n"]}, {"input": "1 2\nAA\nAC\nCB\nAA\n@Z\n", "output": ["1\n"]}, {"input": "2 2\nAA\nAC\nCA\nBB\n?Z\n", "output": ["2 1\n"]}, {"input": "2 2\nAB\nCB\nBB\nAB\nZA\n", "output": ["1 2\n"]}, {"input": "1 2\nAA\nCA\nAC\nAC\n[B\n", "output": ["1\n"]}, {"input": "3 2\nAA\nAB\nCB\nBA\nA[\n", "output": ["2 1 3\n"]}, {"input": "1 1\nAA\nAC\nCB\nAB\nZ@\n", "output": ["1\n"]}, {"input": "1 2\nBA\nAC\nCC\nAB\n@Z\n", "output": ["1\n"]}], "task_id": "codecontest/0", "prompt": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. The title of each book is given with a specific length m. It means that every title has a fixed number of characters. This ensures that all titles will be compared based on strings of the same length, making the comparison consistent. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "repair_prompt": ["Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string s_i numbered from 1 to n, each with length m. The title of each book is given with a specific length m. It means that every title has a fixed number of characters. This ensures that all titles will be compared based on strings of the same length, making the comparison consistent. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd-indexed characters (0-based index) are sorted ascending\n            if i % 2 == 0:\n                key.append((0, char))\n            # Even-indexed characters (0-based index) are sorted descending\n            else:\n                key.append((1, -ord(char)))\n        return key\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd indices (0-based) are sorted ascending\n            if i % 2 == 0:\n                key.append((0, char))\n            # Even indices (0-based) are sorted descending\n            else:\n                key.append((1, -ord(char)))\n        return key\n\n    # Create a list of tuples (index, book) to maintain original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom functools import cmp_to_key\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts the books based on the custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: List of indices representing the sorted order of books.\n    \"\"\"\n    \n    def custom_comparator(a: str, b: str) -> int:\n        \"\"\"Compares two strings based on the asc-desc-ending order.\n\n        Args:\n            a (str): First string to compare.\n            b (str): Second string to compare.\n\n        Returns:\n            int: Negative if a < b, zero if a == b, positive if a > b.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if (i + 1) % 2 == 1:  # Odd index (1-based)\n                    if a[i] < b[i]:\n                        return -1\n                    else:\n                        return 1\n                else:  # Even index (1-based)\n                    if a[i] > b[i]:\n                        return -1\n                    else:\n                        return 1\n        return 0\n\n    # Create a list of indices\n    indices = list(range(1, n + 1))\n    \n    # Sort the indices based on the custom comparator applied to the book titles\n    indices.sort(key=cmp_to_key(lambda i, j: custom_comparator(books[i - 1], books[j - 1])))\n    \n    return indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport functools\n\ndef custom_sort(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts the book titles based on custom asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the titles sorted in the custom order.\n    \"\"\"\n    \n    def custom_comparator(a: str, b: str) -> int:\n        \"\"\"Custom comparator for sorting titles.\n\n        Args:\n            a (str): First title to compare.\n            b (str): Second title to compare.\n\n        Returns:\n            int: Negative if a < b, zero if a == b, positive if a > b.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if (i + 1) % 2 == 1:  # Odd index (1-based)\n                    return -1 if a[i] < b[i] else 1\n                else:  # Even index (1-based)\n                    return 1 if a[i] < b[i] else -1\n        return 0\n\n    # Create a list of indices\n    indices = list(range(1, n + 1))\n    \n    # Sort indices based on the custom comparator applied to titles\n    indices.sort(key=functools.cmp_to_key(lambda i, j: custom_comparator(titles[i - 1], titles[j - 1])))\n    \n    return indices\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\nresult = custom_sort(n, m, titles)\n\n# Output interface\nprint(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the books sorted in asc-desc-ending order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd-indexed characters (0-based index) are sorted ascending\n            if i % 2 == 0:\n                key.append((char, 1))\n            # Even-indexed characters (0-based index) are sorted descending\n            else:\n                key.append((char, -1))\n        return key\n\n    # Create a list of tuples (index, book) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Call the function and print the result\n    sorted_indices = sort_books(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom functools import cmp_to_key\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts the books based on the custom asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): The list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in the custom order.\n    \"\"\"\n    \n    def custom_comparator(a: str, b: str) -> int:\n        \"\"\"Compares two strings based on the custom asc-desc-ending order.\n\n        Args:\n            a (str): The first string to compare.\n            b (str): The second string to compare.\n\n        Returns:\n            int: Negative if a < b, zero if a == b, positive if a > b.\n        \"\"\"\n        for i in range(m):\n            if a[i] != b[i]:\n                if (i + 1) % 2 == 1:  # Odd position (1-based index)\n                    if a[i] < b[i]:\n                        return -1\n                    else:\n                        return 1\n                else:  # Even position (1-based index)\n                    if a[i] > b[i]:\n                        return -1\n                    else:\n                        return 1\n        return 0\n\n    # Sort the books using the custom comparator\n    sorted_books = sorted(range(n), key=cmp_to_key(lambda i, j: custom_comparator(books[i], books[j])))\n\n    # Convert 0-based indices to 1-based indices\n    sorted_indices = [index + 1 for index in sorted_books]\n\n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of the book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order\n                key.append(ord(char))\n        return key\n\n    # Create a list of tuples (index, book title)\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the indexed books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\nbooks = [input().strip() for _ in range(n)]\n\n# Call the function and print the result\nsorted_indices = sort_books_asc_desc(n, m, books)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nfrom functools import cmp_to_key\n\ndef sort_books(n: int, m: int, titles: List[str]) -> List[int]:\n    \"\"\"Sorts book titles in asc-desc-ending order.\n\n    Args:\n        n (int): Number of book titles.\n        m (int): Length of each book title.\n        titles (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Indices of the sorted book titles.\n    \"\"\"\n    \n    def custom_comparator(title_a: str, title_b: str) -> int:\n        \"\"\"Compares two titles based on asc-desc-ending order.\n\n        Args:\n            title_a (str): First book title.\n            title_b (str): Second book title.\n\n        Returns:\n            int: Negative if title_a < title_b, zero if title_a == title_b, positive if title_a > title_b.\n        \"\"\"\n        for i in range(m):\n            if title_a[i] != title_b[i]:\n                if (i + 1) % 2 == 1:  # Odd index (1-based)\n                    return -1 if title_a[i] < title_b[i] else 1\n                else:  # Even index (1-based)\n                    return 1 if title_a[i] < title_b[i] else -1\n        return 0\n\n    # Create a list of tuples (index, title) to keep track of original indices\n    indexed_titles = list(enumerate(titles, start=1))\n    \n    # Sort using the custom comparator\n    indexed_titles.sort(key=cmp_to_key(lambda x, y: custom_comparator(x[1], y[1])))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_titles]\n    \n    return sorted_indices\n\n# Input interface\nn, m = map(int, input().split())\ntitles = [input().strip() for _ in range(n)]\n\n# Output interface\nsorted_indices = sort_books(n, m, titles)\nprint(' '.join(map(str, sorted_indices)))\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books_asc_desc(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on asc-desc-ending order.\n\n    Args:\n        n (int): Number of books.\n        m (int): Length of each book title.\n        books (List[str]): List of book titles.\n\n    Returns:\n        List[int]: Sorted indices of the book titles.\n    \"\"\"\n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            if i % 2 == 0:\n                # Even index: descending order\n                key.append(-ord(char))\n            else:\n                # Odd index: ascending order\n                key.append(ord(char))\n        return key\n\n    # Generate a list of tuples (index, book title)\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the indexed books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n\n    # Extract and return the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Call the function and print the result\n    sorted_indices = sort_books_asc_desc(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef sort_books(n: int, m: int, books: List[str]) -> List[int]:\n    \"\"\"Sorts book titles based on a custom asc-desc-ending order.\n\n    Args:\n        n (int): The number of books.\n        m (int): The length of each book title.\n        books (List[str]): A list of book titles.\n\n    Returns:\n        List[int]: The indices of the books sorted in the custom order.\n    \"\"\"\n    \n    def custom_sort_key(title: str) -> List:\n        \"\"\"Generates a custom sort key for a book title.\n\n        Args:\n            title (str): The book title.\n\n        Returns:\n            List: A list representing the custom sort key.\n        \"\"\"\n        key = []\n        for i, char in enumerate(title):\n            # Odd-indexed characters (0-based) are sorted ascending\n            if i % 2 == 0:\n                key.append((char, 'asc'))\n            # Even-indexed characters (0-based) are sorted descending\n            else:\n                key.append((char, 'desc'))\n        return key\n\n    # Create a list of tuples (index, book) to keep track of original indices\n    indexed_books = list(enumerate(books, start=1))\n    \n    # Sort the books using the custom sort key\n    indexed_books.sort(key=lambda x: custom_sort_key(x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [index for index, _ in indexed_books]\n    \n    return sorted_indices\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Output interface\n    sorted_indices = sort_books(n, m, books)\n    print(' '.join(map(str, sorted_indices)))\n"], "plans": ["requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd positions in ascending order and characters at even positions in descending order. The input consists of a number of book titles, each of a fixed length, and the output should be the indices of these titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise documentation for the sorting logic.\n- Include test cases to validate the sorting algorithm.\n- Optimize the code for readability and maintainability.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will handle up to 10^6 characters efficiently.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of a number of book titles, each of a fixed length, and the output should be the indices of these titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear documentation and comments in the code.\n- Include test cases to validate the sorting logic.\n- Optimize the code for readability and maintainability.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of n book titles, each of length m, and the output should be the indices of the titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise documentation for the sorting logic.\n- Include test cases to validate the sorting algorithm.\n- Optimize the code for readability and maintainability.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities. The key challenge is to define a custom comparator that handles the asc-desc-ending order efficiently. We will use the functools library to create a comparator function that compares strings based on the specified odd-even character rules.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of a number of book titles, each of a fixed length, and the output should be the indices of these titles in the new sorted order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Include comprehensive test cases to validate the sorting logic.\n- Document the code to explain the sorting logic and approach.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities. The key challenge is to define a custom comparator that sorts odd-indexed characters in ascending order and even-indexed characters in descending order. We will use the functools library to create a custom comparator function.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd positions in ascending order and characters at even positions in descending order. The input consists of a number of book titles, each of a fixed length, and the output should be the indices of these titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Include comprehensive test cases to validate the sorting logic.\n- Consider edge cases such as minimum input size and identical characters.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will handle up to 10^6 characters efficiently.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd positions in ascending order and characters at even positions in descending order. The input consists of a number of book titles, each with a fixed length, and the output should be the indices of these titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise documentation for the sorting logic.\n- Include test cases to validate the sorting algorithm.\n- Optimize the code for readability and maintainability.\nWe will implement a custom sorting algorithm using Python's built-in sorting capabilities. The key challenge is to define a custom comparator that adheres to the asc-desc-ending order. We will use the functools library to create a comparator function that compares characters at odd positions in ascending order and characters at even positions in descending order.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of n book titles, each of length m, and the output should be the indices of the titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise documentation for the sorting logic.\n- Include test cases to validate the sorting algorithm.\n- Optimize the code for readability and maintainability.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently.\n", "requirement analysis:\nThe task involves sorting a list of book titles based on a custom lexicographical order. The order is determined by comparing characters at odd positions in ascending order and characters at even positions in descending order. The input size constraint ensures that the solution must be efficient, likely requiring a custom comparator for sorting.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear documentation and comments in the code.\n- Include test cases to validate the sorting logic.\n- Optimize for readability and maintainability of the code.\nWe will implement a custom sorting algorithm using a comparator function that compares book titles based on the specified asc-desc-ending order. The Python built-in `sorted()` function will be used with this custom comparator to efficiently sort the list of book titles. Given the constraints, the solution will be optimized for performance to handle large input sizes.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order where odd-indexed characters are sorted in ascending order and even-indexed characters are sorted in descending order. The input consists of a number of book titles, each of a fixed length, and the output should be the indices of these titles in the new sorted order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear and concise documentation for the sorting logic.\n- Optimize the code for readability and maintainability.\n- Include test cases to validate the sorting algorithm.\nWe will implement a custom sorting function that sorts book titles based on the specified asc-desc-ending order. The function will compare characters at odd indices in ascending order and characters at even indices in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will handle up to 10^6 characters efficiently.\n", "requirement analysis:\nThe requirement is to sort a list of book titles based on a custom sorting order. The sorting order is determined by comparing characters at odd positions in ascending order and characters at even positions in descending order. The input consists of a number of book titles, each of a fixed length, and the output should be the indices of these titles sorted according to the specified order.\nrequirement pool:\n- Implement the custom sorting algorithm for book titles.\n- Ensure the solution handles the maximum input size efficiently.\n- Provide clear documentation and examples for the sorting function.\n- Optimize the code for readability and maintainability.\n- Consider edge cases such as minimum input size.\nWe will implement a custom sorting algorithm that sorts book titles based on the specified asc-desc-ending order. The algorithm will compare characters at odd positions in ascending order and characters at even positions in descending order. We will use Python's built-in sorting capabilities with a custom key function to achieve this efficiently. Given the constraints, the solution will handle up to 10^6 characters efficiently.\n"], "scores": [], "pass_results": [true, false, true, false, true, true, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 295, "examples": "\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u22c5 m \u2264 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n", "mutate_method": "expand_one2two", "parent_index": 51}
