{"name": "1622_B. Berland Music", "description": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\n\n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "tags": ["data structures", "greedy", "math", "sortings"], "difficulty": 8, "id": 1622, "sample_io": [{"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}], "test_list": [{"input": "1\n7\n1 2 3 4 5 6 7\n0101010\n", "output": ["1 5 2 6 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n10101010101010101010101010101010101010101010101010\n", "output": ["26 1 27 2 28 3 29 4 30 5 31 6 32 7 33 8 34 9 35 10 36 11 37 12 38 13 39 14 40 15 41 16 42 17 43 18 44 19 45 20 46 21 47 22 48 23 49 24 50 25\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 4 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n3 1 2\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["2 1\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101010\n", "output": ["4 5 1 6 2 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 1 2\n1 6 5 8 2 7 4 3\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101000\n", "output": ["5 6 1 7 2 3 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n3 1 2\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n1 2 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 2 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 1 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 7 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["2 1\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01100100\n", "output": ["2 1\n3 2 1\n1 7 6 5 2 8 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n1 2 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 5 2 6 3 4 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 1 6 2 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 1 2 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n1 2 3\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 4 2 5 6 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 7 4 5 6\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111011\n", "output": ["2 1\n1 6 2 7 3 4 5\n3 4 2 8 5 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 2 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 5 6 7 2 3 4\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 6 7 1 2 3\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110100\n", "output": ["2 1\n3 2 1\n5 6 4 8 1 7 3 2\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n2 3 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1001000\n", "output": ["6 1 2 7 3 4 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00100001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 7 6 4 3 5 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n2 3 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 3 2 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n3 2 1\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n1 5 6 7 2 3 4\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010010\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 6 1 8 3 2 7 4\n"]}, {"input": "3\n2\n2 1\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 4 5 6 1 7 2\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 7 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 4 3 8 2 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111101\n", "output": ["2 1\n3 2 1\n1 4 3 8 6 5 2 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n2 3 4 5 6 1 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0110000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 7 2 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n2 1 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 6 4 7 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 3 1\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110110\n", "output": ["2 1\n3 2 1\n1 5 4 8 2 6 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n10010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 2 1 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 2 1\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 2 1\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 2 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 5 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1100010\n", "output": ["5 6 1 2 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110111\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 4 8 3 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n4 5 6 7 1 2 3\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 4 2 5 3 6 7\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 4 1 5 6 7 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110110\n", "output": ["2 1\n3 2 1\n4 5 3 8 1 6 7 2\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["1 2\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n3 4 5 6 7 1 2\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01100001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 7 6 5 3 2 4 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 7 2 3 4 5 6\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11011011\n", "output": ["2 1\n1 5 2 6 3 4 7\n3 4 1 8 5 2 7 6\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}], "task_id": "codecontest/155", "prompt": "Berland Music is a music streaming service built specifically to support Berland local artist, and its developers are currently working on a song recommendation module. So imagine Monocarp got recommended n songs, numbered from 1 to n, and the i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once; in other words, p is a permutation. After listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it. Now the service has to re-evaluate the song ratings in such a way that: * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). Among all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x. Print the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "repair_prompt": ["Berland Music is a music streaming service built specifically to support Berland local artist, and its developers are currently working on a song recommendation module. So imagine Monocarp got recommended n songs, numbered from 1 to n, and the i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once; in other words, p is a permutation. After listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it. Now the service has to re-evaluate the song ratings in such a way that: * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). Among all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x. Print the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0."], "completions": ["from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef adjust_song_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjust song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Create the new permutation q\n        q = [0] * n\n        liked_index = 0\n        disliked_index = 0\n\n        # Assign ratings ensuring liked songs have higher ratings than disliked ones\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                q[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = adjust_song_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append((p[i], i))\n            else:\n                disliked.append((p[i], i))\n\n        # Sort liked and disliked songs by their predicted ratings\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for _, index in disliked:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for _, index in liked:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user likes and dislikes.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): String of likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate liked and disliked songs\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        liked_index = 0\n        disliked_index = 0\n\n        # Fill the permutation q\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                q[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and print results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    test_cases = []\n\n    # Read each test case\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n    \n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n        \n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n        \n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n        \n        # Assign new ratings\n        q = [0] * n\n        liked_index = n - len(liked)\n        disliked_index = 0\n        \n        for i in range(n):\n            if s[i] == '1':\n                q[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                q[i] = disliked[disliked_index]\n                disliked_index += 1\n        \n        results.append(q)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n    \n    results = re_evaluate_ratings(t, test_cases)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef adjust_song_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjust song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Create the new permutation q\n        q = [0] * n\n        liked_index = 0\n        disliked_index = 0\n\n        # Assign ratings ensuring liked songs have higher ratings than disliked ones\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = disliked_index + len(disliked) + 1\n                liked_index += 1\n            else:\n                q[i] = disliked_index + 1\n                disliked_index += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\nt = int(input())\n\n# Read each test case\ntest_cases = []\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    s = input().strip()\n    test_cases.append((n, p, s))\n\n# Call the function\nresults = adjust_song_ratings(t, test_cases)\n\n# Output interface\nfor result in results:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef reevaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Permutation of predicted ratings.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append((p[i], i))\n            else:\n                disliked.append((p[i], i))\n\n        # Sort liked and disliked songs by their original ratings\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings ensuring liked songs have higher ratings than disliked ones\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for _, index in disliked:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for _, index in liked:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = reevaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef adjust_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjust song ratings based on user feedback while maintaining permutation integrity.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings as a permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: Adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked songs\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        liked_index = n - len(liked)\n        disliked_index = 0\n\n        for i in range(n):\n            if s[i] == '1':\n                q[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                q[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = adjust_ratings(t, test_cases)\n\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef adjust_song_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjust song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings as a permutation.\n            - s (str): Feedback string where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: Adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort liked and disliked songs by their predicted ratings\n        liked_songs = sorted((p[i], i) for i in liked_indices)\n        disliked_songs = sorted((p[i], i) for i in disliked_indices)\n\n        # Assign new ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for _, index in disliked_songs:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for _, index in liked_songs:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\n# Input interface\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        p = list(map(int, data[index:index + n]))\n        index += n\n        s = data[index]\n        index += 1\n        test_cases.append((n, p, s))\n    \n    # Output interface\n    results = adjust_song_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's likes and dislikes.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Permutation of predicted ratings.\n            - s (str): String representing likes ('1') and dislikes ('0').\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked categories\n        for i in range(n):\n            if s[i] == '1':\n                liked.append((p[i], i))\n            else:\n                disliked.append((p[i], i))\n\n        # Sort liked and disliked songs by their predicted ratings\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        q = [0] * n\n        current_rating = 1\n\n        # Assign lowest ratings to disliked songs\n        for _, index in disliked:\n            q[index] = current_rating\n            current_rating += 1\n\n        # Assign highest ratings to liked songs\n        for _, index in liked:\n            q[index] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and get results\n    results = re_evaluate_ratings(t, test_cases)\n\n    # Output results\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef adjust_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjusts the ratings of songs based on Monocarp's feedback.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: The number of songs.\n            - p: A list of integers representing the permutation of predicted ratings.\n            - s: A string representing Monocarp's feedback (0 for dislike, 1 for like).\n\n    Returns:\n        A list of lists, where each list contains the adjusted ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate the indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the indices based on the original ratings\n        liked_indices.sort(key=lambda i: p[i])\n        disliked_indices.sort(key=lambda i: p[i])\n\n        # Create a new permutation q\n        q = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for i in disliked_indices:\n            q[i] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for i in liked_indices:\n            q[i] = current_rating\n            current_rating += 1\n\n        results.append(q)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    results = adjust_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement focuses on developing a song recommendation module that adjusts song ratings based on user feedback. The system must ensure liked songs have higher ratings than disliked ones while minimizing the difference between predicted and adjusted ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation algorithm to adjust ratings based on user feedback.\n- Ensure the algorithm efficiently handles up to 10,000 test cases with a total of 200,000 songs.\n- Develop a user interface for liking and disliking songs.\n- Integrate local artist support by prioritizing their songs in recommendations.\n- Optimize the system for fast response times and minimal latency.\nWe will implement a function to adjust song ratings based on user feedback using a permutation approach. The function will ensure liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences between predicted and adjusted ratings. We will use Python's built-in sorting capabilities to efficiently handle the permutation and rating adjustment process.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution must handle multiple test cases efficiently and adhere to the input-output format.\nrequirement pool:\n- Implement the song recommendation algorithm to re-evaluate ratings based on user feedback.\n- Ensure the solution handles up to 10,000 test cases efficiently.\n- Maintain permutation integrity in the re-evaluated ratings.\n- Optimize the algorithm to minimize the sum of absolute differences between predicted and re-evaluated ratings.\n- Provide clear documentation and examples for input-output format compliance.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust the ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this, ensuring the solution is optimal for large inputs.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. The solution should handle multiple test cases efficiently.\nrequirement pool:\n- Implement the song recommendation algorithm\n- Ensure the algorithm handles large input sizes efficiently\n- Develop a user interface for liking/disliking songs\n- Integrate local artist support into the recommendation system\n- Optimize the algorithm for speed and accuracy\nWe will implement a function that processes multiple test cases efficiently. The function will separate liked and disliked songs, sort them, and then assign new ratings to minimize the absolute difference from the predicted ratings. This approach ensures that liked songs have higher ratings than disliked ones while maintaining the permutation property. We will use Python's built-in sorting and list manipulation capabilities to achieve this.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences between predicted and re-evaluated ratings. The solution should handle multiple test cases efficiently.\nrequirement pool:\n- Implement the song recommendation algorithm\n- Ensure liked songs have higher ratings than disliked ones\n- Optimize for minimum sum of absolute differences\n- Support multiple test cases efficiently\n- Provide user interface for feedback collection\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and reassign ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this, ensuring the solution is optimal for large inputs.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that adjusts song ratings based on user feedback. The system must ensure liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. The solution should handle multiple test cases efficiently.\nrequirement pool:\n- Implement song recommendation algorithm\n- Ensure liked songs have higher ratings than disliked ones\n- Optimize for minimum sum of absolute differences\n- Support multiple test cases efficiently\n- Enhance user interface for feedback collection\nWe will implement a function to adjust song ratings based on user feedback using a permutation approach. The function will ensure liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences from predicted ratings. We will use efficient sorting and permutation techniques to handle multiple test cases efficiently.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that re-evaluates song ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution must handle multiple test cases efficiently and adhere to the input-output format.\nrequirement pool:\n- Implement song recommendation algorithm\n- Ensure liked songs have higher ratings than disliked ones\n- Optimize for minimum sum of absolute differences\n- Support multiple test cases efficiently\n- Enhance user interface for feedback\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust the ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this, ensuring the permutation constraint is maintained while minimizing the sum of absolute differences.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that adjusts ratings based on user feedback. The challenge is to maintain permutation integrity while ensuring liked songs have higher ratings than disliked ones, minimizing the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement the song recommendation algorithm ensuring permutation integrity.\n- Develop a user interface for liking/disliking songs.\n- Optimize the algorithm for large datasets.\n- Ensure cross-device compatibility and responsiveness.\n- Enhance UI aesthetics to improve user engagement.\nWe will implement a function to adjust song ratings based on user feedback while maintaining permutation integrity. The approach involves sorting the songs into liked and disliked categories, assigning the highest ratings to liked songs and the lowest to disliked ones. We will use Python's built-in sorting capabilities to efficiently handle the permutation and rating adjustments.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that adjusts song ratings based on user feedback. The module must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. The solution should handle multiple test cases efficiently.\nrequirement pool:\n- Develop the song recommendation algorithm\n- Ensure permutation constraints are met\n- Optimize for minimum absolute difference\n- Handle large input sizes efficiently\n- Integrate with existing music streaming platform\nWe will implement a function to adjust song ratings based on user feedback using permutation constraints. The function will ensure liked songs have higher ratings than disliked ones while minimizing the absolute difference from predicted ratings. We will use efficient sorting and list manipulation techniques to handle large input sizes.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the absolute difference between predicted and re-evaluated ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Implement the song recommendation module to handle up to 10,000 test cases efficiently.\n- Ensure the re-evaluated ratings form a valid permutation with minimal absolute difference.\n- Optimize the algorithm for performance given the constraint on the sum of n over all test cases.\n- Provide clear and correct output format for each test case.\n- Consider edge cases where all songs are liked or disliked.\nWe will implement a function that processes multiple test cases efficiently. For each test case, we will separate the songs into liked and disliked categories based on the input string. We will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring that the permutation constraint is satisfied. The solution will be optimized to handle the maximum constraints using sorting and efficient data manipulation techniques.\n", "requirement analysis:\nThe requirement focuses on developing a song recommendation module that adjusts ratings based on user feedback. The key challenge is to ensure that liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. The solution must handle multiple test cases efficiently and adhere to the input-output format.\nrequirement pool:\n- Implement the song recommendation algorithm to adjust ratings based on user feedback.\n- Ensure the solution handles multiple test cases efficiently.\n- Develop a user interface that allows easy liking and disliking of songs.\n- Optimize the algorithm for large datasets.\n- Integrate the recommendation module with the existing music streaming service.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust the ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this, ensuring the solution is optimal for large datasets.\n"], "scores": [], "pass_results": [true, false, true, false, true, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 49, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "mutate_method": "condense_two2one", "parent_index": 49}
