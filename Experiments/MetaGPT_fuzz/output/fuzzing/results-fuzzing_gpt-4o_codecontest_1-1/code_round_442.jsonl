{"name": "1615_B. And It's Non-Zero", "description": "You are given an array consisting of all integers from [l, r] inclusive. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. What's the minimum number of elements you can delete to make the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array non-zero?\n\nA bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "tags": ["bitmasks", "greedy", "math"], "difficulty": 8, "id": 1615, "sample_io": [{"input": "5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n", "output": ["1\n3\n0\n2\n31072\n"]}], "test_list": [{"input": "5\n1 2\n2 8\n4 5\n2 5\n100000 200000\n", "output": ["1\n3\n0\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n100000 200000\n", "output": ["1\n3\n0\n0\n31072\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 5\n100000 200000\n", "output": ["1\n4\n0\n2\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100000 200000\n", "output": ["0\n3\n0\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n110000 200000\n", "output": ["1\n3\n0\n0\n21072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100100 200000\n", "output": ["0\n3\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 10\n110000 200000\n", "output": ["1\n3\n0\n3\n21072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n1 5\n100001 200000\n", "output": ["1\n3\n0\n2\n31071\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n100000 104325\n", "output": ["1\n3\n0\n0\n0\n"]}, {"input": "5\n2 2\n2 8\n1 5\n2 5\n100000 200000\n", "output": ["0\n3\n2\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 12\n110000 200000\n", "output": ["1\n3\n0\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n100100 200000\n", "output": ["0\n3\n1\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n4 9\n1 5\n100000 200000\n", "output": ["1\n3\n2\n2\n31072\n"]}, {"input": "5\n2 2\n2 12\n1 5\n2 5\n100000 200000\n", "output": ["0\n5\n2\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n110000 200000\n", "output": ["2\n3\n0\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 7\n100100 200000\n", "output": ["1\n3\n0\n2\n30972\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n101100 200000\n", "output": ["0\n3\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n100000 200000\n", "output": ["1\n3\n1\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 7\n100100 200000\n", "output": ["1\n2\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101000 200000\n", "output": ["1\n3\n1\n2\n30072\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n101000 200000\n", "output": ["1\n2\n1\n2\n30072\n"]}, {"input": "5\n2 4\n1 8\n4 5\n2 7\n100100 200000\n", "output": ["1\n4\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n101100 200000\n", "output": ["1\n2\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n4 5\n3 5\n100000 200000\n", "output": ["1\n3\n0\n1\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n4 5\n100000 200000\n", "output": ["0\n3\n0\n0\n31072\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 1\n100000 200000\n", "output": ["1\n4\n0\n0\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n4 5\n110000 200000\n", "output": ["0\n3\n0\n0\n21072\n"]}, {"input": "5\n2 2\n2 16\n4 5\n2 5\n100100 200000\n", "output": ["0\n7\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 7\n4 5\n4 10\n110000 200000\n", "output": ["1\n2\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 7\n4 6\n2 5\n100100 200000\n", "output": ["0\n2\n0\n2\n30972\n"]}, {"input": "5\n2 2\n2 8\n1 5\n4 5\n100000 200000\n", "output": ["0\n3\n2\n0\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 6\n4 5\n110001 200000\n", "output": ["1\n3\n0\n0\n21071\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 7\n100110 200000\n", "output": ["0\n3\n0\n2\n30962\n"]}, {"input": "5\n1 2\n2 8\n4 5\n7 12\n110000 200000\n", "output": ["1\n3\n0\n1\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 4\n100100 200000\n", "output": ["0\n3\n1\n1\n30972\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 5\n100000 200000\n", "output": ["1\n3\n3\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n010000 200000\n", "output": ["2\n3\n0\n0\n91697\n"]}, {"input": "5\n1 2\n2 4\n4 5\n4 13\n110000 200000\n", "output": ["1\n1\n0\n4\n21072\n"]}, {"input": "5\n2 2\n1 8\n3 6\n2 5\n101100 200000\n", "output": ["0\n4\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n100000 200000\n", "output": ["1\n3\n1\n5\n31072\n"]}, {"input": "5\n1 4\n1 7\n4 5\n2 7\n100100 200000\n", "output": ["2\n3\n0\n2\n30972\n"]}, {"input": "5\n1 4\n1 8\n4 5\n2 7\n100100 200000\n", "output": ["2\n4\n0\n2\n30972\n"]}, {"input": "5\n2 4\n2 5\n4 5\n2 7\n100100 123776\n", "output": ["1\n2\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 10\n110000 200000\n", "output": ["1\n2\n0\n2\n21072\n"]}, {"input": "5\n2 2\n2 8\n1 6\n4 5\n100000 200000\n", "output": ["0\n3\n3\n0\n31072\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 7\n100110 200000\n", "output": ["0\n4\n0\n2\n30962\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 4\n100101 200000\n", "output": ["0\n3\n1\n1\n30971\n"]}, {"input": "5\n2 2\n1 1\n3 6\n2 5\n101100 200000\n", "output": ["0\n0\n1\n2\n29972\n"]}, {"input": "5\n1 2\n1 8\n7 9\n1 10\n100000 200000\n", "output": ["1\n4\n1\n5\n31072\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101010 188450\n", "output": ["1\n3\n1\n2\n30062\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 20\n110000 200000\n", "output": ["1\n2\n0\n7\n21072\n"]}, {"input": "5\n2 2\n2 8\n1 2\n4 5\n100000 200000\n", "output": ["0\n3\n1\n0\n31072\n"]}, {"input": "5\n2 2\n2 5\n3 6\n2 4\n100101 200000\n", "output": ["0\n2\n1\n1\n30971\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101011 188450\n", "output": ["1\n3\n1\n2\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 5\n101000 200000\n", "output": ["1\n1\n1\n2\n30072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 5\n101011 188450\n", "output": ["1\n3\n3\n2\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 5\n101001 200000\n", "output": ["1\n1\n1\n2\n30071\n"]}, {"input": "5\n1 1\n1 8\n7 10\n1 10\n100000 186611\n", "output": ["0\n4\n1\n5\n31072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 2\n101011 188450\n", "output": ["1\n3\n3\n1\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 7\n101001 200000\n", "output": ["1\n1\n1\n3\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n101001 200000\n", "output": ["2\n1\n1\n3\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n111001 200000\n", "output": ["2\n1\n1\n3\n20071\n"]}, {"input": "5\n1 4\n1 6\n7 9\n1 7\n111001 200000\n", "output": ["2\n3\n1\n3\n20071\n"]}, {"input": "5\n1 4\n2 6\n7 9\n1 7\n111001 200000\n", "output": ["2\n2\n1\n3\n20071\n"]}, {"input": "5\n2 4\n3 6\n7 9\n1 7\n111001 200000\n", "output": ["1\n1\n1\n3\n20071\n"]}, {"input": "5\n2 8\n3 6\n7 9\n1 7\n111001 200000\n", "output": ["3\n1\n1\n3\n20071\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 4\n100001 200000\n", "output": ["1\n3\n0\n0\n31071\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100000 101573\n", "output": ["0\n3\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 4\n4 5\n4 5\n110000 200000\n", "output": ["1\n1\n0\n0\n21072\n"]}, {"input": "5\n1 2\n1 8\n4 5\n4 10\n110000 200000\n", "output": ["1\n4\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n100100 200000\n", "output": ["0\n6\n0\n2\n30972\n"]}, {"input": "5\n1 2\n4 8\n4 5\n1 5\n100000 200000\n", "output": ["1\n1\n0\n2\n31072\n"]}, {"input": "5\n2 2\n2 8\n1 5\n2 5\n100000 161404\n", "output": ["0\n3\n2\n2\n30333\n"]}, {"input": "5\n1 2\n2 8\n3 6\n4 5\n110000 200000\n", "output": ["1\n3\n1\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 10\n100100 200000\n", "output": ["1\n3\n0\n4\n30972\n"]}, {"input": "5\n1 1\n2 8\n4 5\n4 12\n110000 200000\n", "output": ["0\n3\n0\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n100101 200000\n", "output": ["0\n3\n1\n2\n30971\n"]}, {"input": "5\n1 1\n2 8\n7 9\n1 5\n100000 200000\n", "output": ["0\n3\n1\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 11\n4 5\n110000 200000\n", "output": ["2\n3\n4\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 7\n100101 200000\n", "output": ["1\n3\n0\n2\n30971\n"]}, {"input": "5\n1 2\n2 8\n2 5\n4 13\n110000 200000\n", "output": ["1\n3\n2\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 11\n2 5\n101100 200000\n", "output": ["0\n3\n4\n2\n29972\n"]}, {"input": "5\n1 2\n2 13\n7 9\n1 5\n100000 200000\n", "output": ["1\n6\n1\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 7\n000100 200000\n", "output": ["1\n2\n0\n2\n99933\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101000 135172\n", "output": ["1\n3\n1\n2\n4101\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n100000 200000\n", "output": ["1\n2\n1\n2\n31072\n"]}, {"input": "5\n1 4\n2 7\n7 9\n1 5\n101100 200000\n", "output": ["2\n2\n1\n2\n29972\n"]}, {"input": "5\n2 2\n2 10\n4 5\n4 5\n100000 200000\n", "output": ["0\n4\n0\n0\n31072\n"]}, {"input": "5\n2 4\n2 16\n4 5\n2 5\n100100 200000\n", "output": ["1\n7\n0\n2\n30972\n"]}, {"input": "5\n1 3\n2 2\n4 6\n2 5\n100000 200000\n", "output": ["1\n0\n0\n2\n31072\n"]}, {"input": "5\n2 2\n1 8\n1 5\n4 5\n100000 200000\n", "output": ["0\n4\n2\n0\n31072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n4 4\n100100 200000\n", "output": ["0\n3\n1\n0\n30972\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 8\n100000 200000\n", "output": ["1\n3\n3\n4\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n010001 200000\n", "output": ["2\n3\n0\n0\n91696\n"]}, {"input": "5\n2 2\n1 15\n3 6\n2 5\n101100 200000\n", "output": ["0\n7\n1\n2\n29972\n"]}, {"input": "5\n1 4\n1 8\n4 5\n4 7\n100100 200000\n", "output": ["2\n4\n0\n0\n30972\n"]}, {"input": "5\n4 4\n2 5\n4 5\n2 7\n100100 123776\n", "output": ["0\n2\n0\n2\n0\n"]}, {"input": "5\n1 2\n3 7\n4 5\n6 10\n110000 200000\n", "output": ["1\n1\n0\n2\n21072\n"]}, {"input": "5\n2 2\n2 7\n4 6\n2 11\n100100 200000\n", "output": ["0\n2\n0\n4\n30972\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 3\n100110 200000\n", "output": ["0\n4\n0\n0\n30962\n"]}, {"input": "5\n2 2\n2 10\n3 6\n2 4\n100101 200000\n", "output": ["0\n4\n1\n1\n30971\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 20\n100000 200000\n", "output": ["1\n2\n0\n7\n31072\n"]}, {"input": "5\n2 2\n2 5\n3 6\n2 4\n100101 108244\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 3\n1 1\n3 6\n2 5\n111100 200000\n", "output": ["0\n0\n1\n2\n19972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n101011 188450\n", "output": ["1\n3\n1\n5\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 14\n101001 200000\n", "output": ["1\n1\n1\n7\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n110001 200000\n", "output": ["2\n1\n1\n3\n21071\n"]}, {"input": "5\n1 4\n3 6\n7 9\n1 13\n111001 200000\n", "output": ["2\n1\n1\n6\n20071\n"]}, {"input": "5\n1 2\n2 13\n4 5\n1 2\n100000 200000\n", "output": ["1\n6\n0\n1\n31072\n"]}, {"input": "5\n2 2\n2 8\n3 5\n2 5\n100000 101573\n", "output": ["0\n3\n1\n2\n0\n"]}, {"input": "5\n1 2\n1 13\n4 5\n4 10\n110000 200000\n", "output": ["1\n6\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n100100 138386\n", "output": ["0\n6\n0\n2\n7315\n"]}, {"input": "5\n1 2\n2 8\n3 8\n4 5\n110000 200000\n", "output": ["1\n3\n2\n0\n21072\n"]}, {"input": "5\n2 2\n2 2\n3 6\n2 5\n100101 200000\n", "output": ["0\n0\n1\n2\n30971\n"]}, {"input": "5\n1 4\n2 5\n4 11\n4 5\n110000 200000\n", "output": ["2\n2\n4\n0\n21072\n"]}, {"input": "5\n1 4\n2 8\n4 5\n2 7\n100101 200000\n", "output": ["2\n3\n0\n2\n30971\n"]}, {"input": "5\n2 2\n1 8\n3 11\n2 5\n101100 200000\n", "output": ["0\n4\n4\n2\n29972\n"]}, {"input": "5\n2 4\n2 7\n4 5\n1 7\n000100 200000\n", "output": ["1\n2\n0\n3\n99933\n"]}, {"input": "5\n1 2\n2 4\n7 9\n1 5\n101000 135172\n", "output": ["1\n1\n1\n2\n4101\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n100001 200000\n", "output": ["1\n2\n1\n2\n31071\n"]}, {"input": "5\n2 2\n2 8\n2 4\n4 5\n110000 200000\n", "output": ["0\n3\n1\n0\n21072\n"]}, {"input": "5\n2 4\n1 16\n4 5\n2 5\n100100 200000\n", "output": ["1\n8\n0\n2\n30972\n"]}, {"input": "5\n2 2\n1 8\n1 5\n4 5\n100000 150693\n", "output": ["0\n4\n2\n0\n19622\n"]}, {"input": "5\n1 2\n2 8\n3 5\n4 5\n110001 200000\n", "output": ["1\n3\n1\n0\n21071\n"]}, {"input": "5\n1 3\n2 8\n4 5\n2 12\n110000 200000\n", "output": ["1\n3\n0\n5\n21072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 8\n100010 200000\n", "output": ["1\n3\n3\n4\n31062\n"]}, {"input": "5\n1 1\n2 4\n4 5\n4 15\n110000 200000\n", "output": ["0\n1\n0\n4\n21072\n"]}, {"input": "5\n1 4\n1 8\n4 5\n3 7\n100100 200000\n", "output": ["2\n4\n0\n1\n30972\n"]}, {"input": "5\n2 2\n3 7\n4 5\n6 10\n110000 200000\n", "output": ["0\n1\n0\n2\n21072\n"]}, {"input": "5\n2 3\n2 8\n1 6\n4 5\n100100 200000\n", "output": ["0\n3\n3\n0\n30972\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 3\n101110 200000\n", "output": ["0\n4\n0\n0\n29962\n"]}, {"input": "5\n1 2\n4 8\n7 9\n2 5\n101011 188450\n", "output": ["1\n1\n1\n2\n30061\n"]}, {"input": "5\n1 2\n4 7\n4 5\n6 20\n100000 200000\n", "output": ["1\n0\n0\n7\n31072\n"]}, {"input": "5\n2 3\n1 2\n3 6\n2 5\n111100 200000\n", "output": ["0\n1\n1\n2\n19972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n101010 188450\n", "output": ["1\n3\n1\n5\n30062\n"]}, {"input": "5\n1 4\n1 3\n7 15\n1 5\n101000 200000\n", "output": ["2\n1\n1\n2\n30072\n"]}, {"input": "5\n1 1\n1 8\n7 8\n1 10\n100010 186611\n", "output": ["0\n4\n1\n5\n31062\n"]}, {"input": "5\n1 2\n1 4\n7 9\n1 14\n101001 200000\n", "output": ["1\n2\n1\n7\n30071\n"]}, {"input": "5\n1 4\n1 3\n9 9\n1 7\n110001 200000\n", "output": ["2\n1\n0\n3\n21071\n"]}, {"input": "5\n1 4\n1 8\n7 9\n1 7\n111001 200000\n", "output": ["2\n4\n1\n3\n20071\n"]}, {"input": "5\n1 4\n3 6\n7 9\n1 9\n111001 200000\n", "output": ["2\n1\n1\n4\n20071\n"]}, {"input": "5\n2 3\n1 8\n4 5\n2 5\n100100 185068\n", "output": ["0\n4\n0\n2\n30972\n"]}, {"input": "5\n1 2\n1 13\n4 5\n1 10\n110000 200000\n", "output": ["1\n6\n0\n5\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n000100 138386\n", "output": ["0\n6\n0\n2\n69139\n"]}, {"input": "5\n1 2\n2 14\n3 8\n4 5\n110000 200000\n", "output": ["1\n6\n2\n0\n21072\n"]}, {"input": "5\n1 2\n2 5\n4 11\n4 5\n110000 200000\n", "output": ["1\n2\n4\n0\n21072\n"]}, {"input": "5\n1 4\n2 5\n4 5\n2 7\n100101 200000\n", "output": ["2\n2\n0\n2\n30971\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 8\n100001 200000\n", "output": ["1\n2\n1\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 4\n4 5\n110000 200000\n", "output": ["0\n0\n1\n0\n21072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 14\n100010 200000\n", "output": ["1\n3\n3\n7\n31062\n"]}, {"input": "5\n1 1\n2 5\n4 5\n4 15\n110000 200000\n", "output": ["0\n2\n0\n4\n21072\n"]}, {"input": "5\n2 2\n3 9\n4 5\n6 10\n110000 200000\n", "output": ["0\n3\n0\n2\n21072\n"]}, {"input": "5\n1 2\n4 8\n7 9\n3 5\n101011 188450\n", "output": ["1\n1\n1\n1\n30061\n"]}, {"input": "5\n1 4\n4 7\n4 5\n6 20\n100000 200000\n", "output": ["2\n0\n0\n7\n31072\n"]}, {"input": "5\n2 3\n1 2\n1 6\n2 5\n111100 200000\n", "output": ["0\n1\n3\n2\n19972\n"]}, {"input": "5\n1 1\n1 8\n7 8\n2 10\n100010 186611\n", "output": ["0\n4\n1\n4\n31062\n"]}, {"input": "5\n1 2\n1 4\n7 9\n1 14\n100001 200000\n", "output": ["1\n2\n1\n7\n31071\n"]}, {"input": "5\n1 4\n1 3\n9 9\n2 7\n110001 200000\n", "output": ["2\n1\n0\n2\n21071\n"]}, {"input": "5\n1 4\n1 8\n7 9\n1 2\n111001 200000\n", "output": ["2\n4\n1\n1\n20071\n"]}, {"input": "5\n1 2\n3 14\n3 8\n4 5\n110000 200000\n", "output": ["1\n5\n2\n0\n21072\n"]}, {"input": "5\n1 4\n2 5\n4 5\n2 8\n100101 200000\n", "output": ["2\n2\n0\n3\n30971\n"]}, {"input": "5\n1 2\n2 12\n7 9\n1 8\n100001 200000\n", "output": ["1\n5\n1\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 4\n4 5\n110100 200000\n", "output": ["0\n0\n1\n0\n20972\n"]}, {"input": "5\n1 1\n4 5\n4 5\n4 15\n110000 200000\n", "output": ["0\n0\n0\n4\n21072\n"]}, {"input": "5\n1 4\n1 16\n4 7\n3 7\n100100 200000\n", "output": ["2\n8\n0\n1\n30972\n"]}, {"input": "5\n1 2\n3 9\n4 5\n6 10\n110000 200000\n", "output": ["1\n3\n0\n2\n21072\n"]}, {"input": "5\n2 3\n1 2\n1 6\n2 5\n101100 200000\n", "output": ["0\n1\n3\n2\n29972\n"]}, {"input": "5\n1 4\n1 3\n9 9\n2 7\n111001 200000\n", "output": ["2\n1\n0\n2\n20071\n"]}, {"input": "5\n1 4\n1 5\n7 9\n1 2\n111001 200000\n", "output": ["2\n2\n1\n1\n20071\n"]}, {"input": "5\n2 2\n2 5\n3 5\n2 5\n101000 129464\n", "output": ["0\n2\n1\n2\n0\n"]}, {"input": "5\n1 2\n2 12\n4 9\n1 8\n100001 200000\n", "output": ["1\n5\n2\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 8\n4 5\n110100 200000\n", "output": ["0\n0\n3\n0\n20972\n"]}, {"input": "5\n1 2\n4 8\n3 5\n4 7\n110001 200000\n", "output": ["1\n1\n1\n0\n21071\n"]}, {"input": "5\n2 3\n2 8\n3 5\n4 12\n110000 200000\n", "output": ["0\n3\n1\n4\n21072\n"]}, {"input": "5\n1 1\n4 5\n4 5\n4 15\n110010 200000\n", "output": ["0\n0\n0\n4\n21062\n"]}, {"input": "5\n1 1\n1 8\n7 14\n2 16\n100010 186611\n", "output": ["0\n4\n1\n7\n31062\n"]}, {"input": "5\n1 6\n1 5\n7 9\n1 2\n111001 200000\n", "output": ["3\n2\n1\n1\n20071\n"]}, {"input": "5\n2 2\n2 5\n3 9\n2 5\n101000 129464\n", "output": ["0\n2\n3\n2\n0\n"]}, {"input": "5\n1 1\n2 12\n4 9\n1 8\n100001 200000\n", "output": ["0\n5\n2\n4\n31071\n"]}, {"input": "5\n1 2\n4 8\n3 5\n1 7\n110001 200000\n", "output": ["1\n1\n1\n3\n21071\n"]}, {"input": "5\n2 3\n2 8\n3 5\n4 12\n010000 200000\n", "output": ["0\n3\n1\n4\n91697\n"]}, {"input": "5\n2 3\n1 3\n1 6\n2 8\n101100 200000\n", "output": ["0\n1\n3\n3\n29972\n"]}, {"input": "5\n1 1\n1 8\n6 14\n2 16\n100010 186611\n", "output": ["0\n4\n2\n7\n31062\n"]}, {"input": "5\n1 6\n1 10\n7 9\n1 2\n111001 200000\n", "output": ["3\n5\n1\n1\n20071\n"]}, {"input": "5\n1 1\n2 12\n4 13\n1 8\n100001 200000\n", "output": ["0\n5\n4\n4\n31071\n"]}, {"input": "5\n1 2\n4 4\n3 5\n1 7\n110001 200000\n", "output": ["1\n0\n1\n3\n21071\n"]}, {"input": "5\n2 3\n1 5\n1 6\n2 8\n101100 200000\n", "output": ["0\n2\n3\n3\n29972\n"]}, {"input": "5\n1 6\n1 10\n9 9\n1 2\n111001 200000\n", "output": ["3\n5\n0\n1\n20071\n"]}, {"input": "5\n1 1\n2 12\n4 13\n1 8\n100000 200000\n", "output": ["0\n5\n4\n4\n31072\n"]}, {"input": "5\n1 2\n4 4\n3 8\n1 7\n110001 200000\n", "output": ["1\n0\n2\n3\n21071\n"]}, {"input": "5\n1 2\n4 4\n3 8\n2 7\n110001 200000\n", "output": ["1\n0\n2\n2\n21071\n"]}, {"input": "5\n2 3\n2 5\n1 6\n2 8\n101101 200000\n", "output": ["0\n2\n3\n3\n29971\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 5\n100000 121445\n", "output": ["1\n4\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n110010 200000\n", "output": ["1\n3\n0\n0\n21062\n"]}, {"input": "5\n1 2\n2 10\n4 5\n4 12\n110000 200000\n", "output": ["1\n4\n0\n4\n21072\n"]}, {"input": "5\n2 2\n4 8\n3 6\n2 5\n100100 200000\n", "output": ["0\n1\n1\n2\n30972\n"]}, {"input": "5\n2 2\n2 7\n1 5\n2 5\n100000 200000\n", "output": ["0\n2\n2\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 13\n100100 200000\n", "output": ["1\n2\n0\n6\n30972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 1\n101000 200000\n", "output": ["1\n3\n1\n0\n30072\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n111100 200000\n", "output": ["1\n2\n1\n2\n19972\n"]}], "task_id": "codecontest/120", "prompt": "You are provided an array that includes all integers from [l, r]. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. Solving the problem efficiently requires understanding the properties of binary numbers and their bitwise operations to determine the minimum number of elements you can delete to make the bitwise AND of the array non-zero.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "repair_prompt": ["You are provided an array that includes all integers from [l, r]. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. Solving the problem efficiently requires understanding the properties of binary numbers and their bitwise operations to determine the minimum number of elements you can delete to make the bitwise AND of the array non-zero.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_for_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to a large number\n        min_deletions = float('inf')\n        \n        # Iterate over each possible starting point in the range [l, r]\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the AND for the range [start, r]\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions needed\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_for_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples, each containing two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to a large number\n        min_deletions = r - l + 1\n        \n        # Iterate over possible starting points for the bitwise AND\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the bitwise AND for the range [start, r]\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions if a better solution is found\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to a large number\n        min_deletions = float('inf')\n        \n        # Iterate over each possible starting point in the range [l, r]\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the AND for the range [start, r]\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # If the AND is non-zero, update the minimum deletions\n            if current_and != 0:\n                min_deletions = min(min_deletions, deletions)\n        \n        # If no valid AND was found, it means we need to delete all but one element\n        if min_deletions == float('inf'):\n            min_deletions = r - l\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_for_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to the size of the array\n        min_deletions = r - l + 1\n        \n        # Iterate over possible starting points for the subset\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Check the AND operation for the current subset\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions if a better subset is found\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Compute results\n    results = min_deletions_for_non_zero_and(t, test_cases)\n    \n    # Output results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    for l, r in test_cases:\n        # Calculate the number of elements in the range [l, r]\n        num_elements = r - l + 1\n        \n        # Initialize the minimum deletions to the number of elements\n        min_deletions = num_elements\n        \n        # Iterate over possible bit positions\n        for bit_position in range(20):  # 20 is enough because r <= 2 * 10^5\n            # Calculate the mask for the current bit position\n            mask = 1 << bit_position\n            \n            # Count how many numbers in the range [l, r] have this bit set\n            count_set_bits = 0\n            for number in range(l, r + 1):\n                if number & mask:\n                    count_set_bits += 1\n            \n            # Calculate deletions needed to make this bit position non-zero\n            deletions_needed = num_elements - count_set_bits\n            \n            # Update the minimum deletions\n            min_deletions = min(min_deletions, deletions_needed)\n        \n        results.append(min_deletions)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Process the test cases\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    \n    # Output results for each test case\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_for_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the bitwise AND of the entire range [l, r]\n        current_and = l\n        for num in range(l + 1, r + 1):\n            current_and &= num\n        \n        # If the AND is non-zero, no deletions are needed\n        if current_and != 0:\n            results.append(0)\n            continue\n        \n        # If the AND is zero, find the minimum deletions\n        min_deletions = float('inf')\n        \n        # Iterate over all possible starting points of the array\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the AND for the current subarray\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions if a better solution is found\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_for_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_for_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the number of bits in the range [l, r]\n        max_bits = r.bit_length()\n        \n        # Initialize the minimum deletions to a large number\n        min_deletions = float('inf')\n        \n        # Iterate over each bit position\n        for bit in range(max_bits):\n            # Calculate the mask for the current bit\n            mask = 1 << bit\n            \n            # Count numbers in the range [l, r] that have the current bit set\n            count_with_bit_set = 0\n            for num in range(l, r + 1):\n                if num & mask:\n                    count_with_bit_set += 1\n            \n            # Calculate deletions needed to make the AND non-zero for this bit\n            deletions = (r - l + 1) - count_with_bit_set\n            \n            # Update the minimum deletions if a better solution is found\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    results = min_deletions_for_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_for_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Initialize the minimum deletions to a large number\n        min_deletions = r - l + 1\n        \n        # Iterate over all possible numbers in the range [l, r]\n        for i in range(l, r + 1):\n            # Calculate the bitwise AND of the range [l, r] with the current number\n            current_and = i\n            deletions = 0\n            \n            # Check each number in the range [l, r]\n            for j in range(l, r + 1):\n                if (current_and & j) == 0:\n                    deletions += 1\n            \n            # Update the minimum deletions if a better solution is found\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    results = min_deletions_for_non_zero_and(t, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the number of elements in the range\n        num_elements = r - l + 1\n        \n        # Initialize the minimum deletions to the maximum possible value\n        min_deletions = num_elements\n        \n        # Iterate over all possible starting points for the bitwise AND\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the bitwise AND for the current starting point\n            for num in range(l, r + 1):\n                if num != start:\n                    current_and &= num\n                    deletions += 1\n                    if current_and != 0:\n                        break\n            \n            # Update the minimum deletions if a better solution is found\n            if current_and != 0:\n                min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n\n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to the maximum possible value\n        min_deletions = r - l + 1\n        \n        # Iterate over possible starting points for the bitwise AND\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the bitwise AND for the range [start, r]\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions if a better solution is found\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. This involves understanding bitwise operations and efficiently handling large input sizes. The solution must be optimized to handle up to 10,000 test cases with ranges up to 200,000.\nrequirement pool:\n- Develop an algorithm to calculate the minimum deletions for non-zero AND.\n- Optimize the solution to handle maximum constraints efficiently.\n- Ensure the solution is tested against a variety of test cases.\n- Provide clear documentation and explanation of the solution.\n- Explore alternative approaches to improve efficiency.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and calculating the AND operation while keeping track of the number of deletions needed. We will utilize Python's built-in capabilities for handling large integers and bitwise operations.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. This involves understanding bitwise operations and efficiently handling large input sizes. The solution must be optimized to handle up to 10,000 test cases with ranges up to 200,000.\nrequirement pool:\n- Develop an algorithm to calculate the minimum deletions for non-zero bitwise AND.\n- Ensure the solution is optimized for large input sizes.\n- Provide detailed comments and documentation for the code.\n- Implement comprehensive test cases to validate the solution.\n- Explore alternative algorithms for potential optimization.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and calculating the bitwise AND, while keeping track of the number of deletions needed to achieve a non-zero result.\n", "requirement analysis:\nThe problem requires an understanding of bitwise operations to determine the minimum number of deletions needed to make the bitwise AND of a range of numbers non-zero. The solution must efficiently handle up to 10,000 test cases with ranges up to 200,000.\nrequirement pool:\n- Develop an algorithm to solve the problem efficiently\n- Ensure the solution is optimized for large input sizes\n- Provide detailed comments and documentation for the code\n- Create test cases to validate the solution\n- Optimize the code for readability and maintainability\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and calculating the bitwise AND, while keeping track of the number of deletions needed. We will leverage Python's built-in capabilities for handling large integers and bitwise operations.\n", "requirement analysis:\nThe problem requires an understanding of bitwise operations and efficient handling of large input ranges. The goal is to minimize deletions to achieve a non-zero bitwise AND, which involves analyzing the binary representation of numbers in the range.\nrequirement pool:\n- Develop an algorithm to determine the minimum deletions for a non-zero bitwise AND.\n- Ensure the solution is optimized for large input sizes up to 200,000.\n- Provide detailed comments and documentation for the code.\n- Implement comprehensive test cases to validate the solution.\n- Explore alternative algorithms for potential performance improvements.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and analyzing the binary representation of numbers to find the optimal subset with a non-zero AND.\n", "requirement analysis:\nThe problem requires an understanding of bitwise operations and efficient handling of large input sizes. The goal is to minimize deletions to achieve a non-zero bitwise AND for the array. The solution must be optimized for performance given the constraints.\nrequirement pool:\n- Develop an algorithm to determine the minimum deletions for a non-zero bitwise AND\n- Ensure the solution is efficient for the maximum input constraints\n- Provide clear documentation and comments within the code\n- Test the solution against a variety of edge cases\n- Optimize the solution for readability and maintainability\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and calculating the bitwise AND, while keeping track of the number of deletions needed. We will utilize Python's built-in capabilities for handling large integers and bitwise operations.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations to determine the minimum number of deletions needed to achieve a non-zero bitwise AND for the array. The solution must efficiently handle up to 10,000 test cases with array sizes up to 200,000.\nrequirement pool:\n- Efficiently compute the minimum deletions for non-zero bitwise AND.\n- Handle large input sizes up to 200,000 efficiently.\n- Ensure the solution is optimized for time complexity.\n- Provide clear output format matching the example.\n- Include detailed comments for understanding bitwise operations.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range [l, r] and calculating the bitwise AND for subsets of the array, while keeping track of the minimum deletions needed. We will utilize Python's built-in bitwise operators and optimize the solution to handle large input sizes efficiently.\n", "requirement analysis:\nThe problem requires an understanding of bitwise operations and efficient handling of large input sizes. The solution must determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The challenge lies in optimizing the solution to handle up to 10,000 test cases with large ranges efficiently.\nrequirement pool:\n- Develop an algorithm to determine the minimum deletions for non-zero bitwise AND.\n- Ensure the solution is optimized for large input sizes and multiple test cases.\n- Provide clear documentation and examples for understanding the solution.\n- Implement comprehensive test cases to validate the solution.\n- Explore alternative approaches to further optimize the solution.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and calculating the bitwise AND, while keeping track of the number of deletions needed. We will utilize Python's built-in capabilities for handling large integers and efficient list operations.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of an array non-zero. This involves understanding bitwise operations and efficiently handling large input sizes. The solution must be optimized to handle up to 10,000 test cases with array sizes up to 200,000.\nrequirement pool:\n- Develop an algorithm to compute the minimum deletions for non-zero AND.\n- Optimize the solution to handle maximum constraints efficiently.\n- Ensure the solution is tested against a variety of test cases.\n- Provide clear documentation and comments within the code.\n- Consider edge cases and potential optimizations.\nWe will use bitwise operations to determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The key observation is that the bitwise AND of a range [l, r] is non-zero if there exists a number in the range that has all bits set in positions where the AND result is non-zero. We will iterate over the range and calculate the number of deletions needed by checking the bitwise AND of the current number with the result of the AND operation of the entire range.\n", "requirement analysis:\nThe problem requires an efficient algorithm to determine the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. The solution must handle up to 10,000 test cases with ranges up to 200,000, necessitating a focus on performance and optimization.\nrequirement pool:\n- Develop an algorithm to solve the problem efficiently.\n- Ensure the solution can handle the maximum input constraints.\n- Optimize the solution for performance and speed.\n- Provide clear documentation and examples for understanding.\n- Implement additional test cases for thorough testing.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and calculating the bitwise AND, while keeping track of the number of deletions needed to achieve a non-zero result. Libraries such as itertools can be used to handle combinations efficiently.\n", "requirement analysis:\nThe problem requires an understanding of bitwise operations and efficient handling of large input ranges. The goal is to minimize deletions to achieve a non-zero bitwise AND, which involves strategic selection of elements based on their binary properties.\nrequirement pool:\n- Implement the main algorithm to solve the problem efficiently.\n- Optimize the solution to handle the maximum constraints.\n- Ensure the solution is tested against a variety of test cases.\n- Provide detailed documentation of the solution approach.\n- Explore alternative algorithms for potential improvements.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and calculating the bitwise AND, while keeping track of the number of deletions needed to achieve a non-zero result.\n"], "scores": [], "pass_results": [false, false, false, false, false, true, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 442, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "mutate_method": "condense_two2one", "parent_index": 265}
