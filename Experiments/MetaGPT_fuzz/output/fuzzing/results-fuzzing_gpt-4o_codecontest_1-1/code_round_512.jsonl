{"name": "1615_B. And It's Non-Zero", "description": "You are given an array consisting of all integers from [l, r] inclusive. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. What's the minimum number of elements you can delete to make the [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) of the array non-zero?\n\nA bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "tags": ["bitmasks", "greedy", "math"], "difficulty": 8, "id": 1615, "sample_io": [{"input": "5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n", "output": ["1\n3\n0\n2\n31072\n"]}], "test_list": [{"input": "5\n1 2\n2 8\n4 5\n2 5\n100000 200000\n", "output": ["1\n3\n0\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n100000 200000\n", "output": ["1\n3\n0\n0\n31072\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 5\n100000 200000\n", "output": ["1\n4\n0\n2\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100000 200000\n", "output": ["0\n3\n0\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n110000 200000\n", "output": ["1\n3\n0\n0\n21072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100100 200000\n", "output": ["0\n3\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 10\n110000 200000\n", "output": ["1\n3\n0\n3\n21072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n1 5\n100001 200000\n", "output": ["1\n3\n0\n2\n31071\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n100000 104325\n", "output": ["1\n3\n0\n0\n0\n"]}, {"input": "5\n2 2\n2 8\n1 5\n2 5\n100000 200000\n", "output": ["0\n3\n2\n2\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 12\n110000 200000\n", "output": ["1\n3\n0\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n100100 200000\n", "output": ["0\n3\n1\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n4 9\n1 5\n100000 200000\n", "output": ["1\n3\n2\n2\n31072\n"]}, {"input": "5\n2 2\n2 12\n1 5\n2 5\n100000 200000\n", "output": ["0\n5\n2\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n110000 200000\n", "output": ["2\n3\n0\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 7\n100100 200000\n", "output": ["1\n3\n0\n2\n30972\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n101100 200000\n", "output": ["0\n3\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n100000 200000\n", "output": ["1\n3\n1\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 7\n100100 200000\n", "output": ["1\n2\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101000 200000\n", "output": ["1\n3\n1\n2\n30072\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n101000 200000\n", "output": ["1\n2\n1\n2\n30072\n"]}, {"input": "5\n2 4\n1 8\n4 5\n2 7\n100100 200000\n", "output": ["1\n4\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n101100 200000\n", "output": ["1\n2\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n4 5\n3 5\n100000 200000\n", "output": ["1\n3\n0\n1\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n4 5\n100000 200000\n", "output": ["0\n3\n0\n0\n31072\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 1\n100000 200000\n", "output": ["1\n4\n0\n0\n31072\n"]}, {"input": "5\n2 2\n2 8\n4 5\n4 5\n110000 200000\n", "output": ["0\n3\n0\n0\n21072\n"]}, {"input": "5\n2 2\n2 16\n4 5\n2 5\n100100 200000\n", "output": ["0\n7\n0\n2\n30972\n"]}, {"input": "5\n1 2\n2 7\n4 5\n4 10\n110000 200000\n", "output": ["1\n2\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 7\n4 6\n2 5\n100100 200000\n", "output": ["0\n2\n0\n2\n30972\n"]}, {"input": "5\n2 2\n2 8\n1 5\n4 5\n100000 200000\n", "output": ["0\n3\n2\n0\n31072\n"]}, {"input": "5\n1 2\n2 8\n4 6\n4 5\n110001 200000\n", "output": ["1\n3\n0\n0\n21071\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 7\n100110 200000\n", "output": ["0\n3\n0\n2\n30962\n"]}, {"input": "5\n1 2\n2 8\n4 5\n7 12\n110000 200000\n", "output": ["1\n3\n0\n1\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 4\n100100 200000\n", "output": ["0\n3\n1\n1\n30972\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 5\n100000 200000\n", "output": ["1\n3\n3\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n010000 200000\n", "output": ["2\n3\n0\n0\n91697\n"]}, {"input": "5\n1 2\n2 4\n4 5\n4 13\n110000 200000\n", "output": ["1\n1\n0\n4\n21072\n"]}, {"input": "5\n2 2\n1 8\n3 6\n2 5\n101100 200000\n", "output": ["0\n4\n1\n2\n29972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n100000 200000\n", "output": ["1\n3\n1\n5\n31072\n"]}, {"input": "5\n1 4\n1 7\n4 5\n2 7\n100100 200000\n", "output": ["2\n3\n0\n2\n30972\n"]}, {"input": "5\n1 4\n1 8\n4 5\n2 7\n100100 200000\n", "output": ["2\n4\n0\n2\n30972\n"]}, {"input": "5\n2 4\n2 5\n4 5\n2 7\n100100 123776\n", "output": ["1\n2\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 10\n110000 200000\n", "output": ["1\n2\n0\n2\n21072\n"]}, {"input": "5\n2 2\n2 8\n1 6\n4 5\n100000 200000\n", "output": ["0\n3\n3\n0\n31072\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 7\n100110 200000\n", "output": ["0\n4\n0\n2\n30962\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 4\n100101 200000\n", "output": ["0\n3\n1\n1\n30971\n"]}, {"input": "5\n2 2\n1 1\n3 6\n2 5\n101100 200000\n", "output": ["0\n0\n1\n2\n29972\n"]}, {"input": "5\n1 2\n1 8\n7 9\n1 10\n100000 200000\n", "output": ["1\n4\n1\n5\n31072\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101010 188450\n", "output": ["1\n3\n1\n2\n30062\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 20\n110000 200000\n", "output": ["1\n2\n0\n7\n21072\n"]}, {"input": "5\n2 2\n2 8\n1 2\n4 5\n100000 200000\n", "output": ["0\n3\n1\n0\n31072\n"]}, {"input": "5\n2 2\n2 5\n3 6\n2 4\n100101 200000\n", "output": ["0\n2\n1\n1\n30971\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101011 188450\n", "output": ["1\n3\n1\n2\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 5\n101000 200000\n", "output": ["1\n1\n1\n2\n30072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 5\n101011 188450\n", "output": ["1\n3\n3\n2\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 5\n101001 200000\n", "output": ["1\n1\n1\n2\n30071\n"]}, {"input": "5\n1 1\n1 8\n7 10\n1 10\n100000 186611\n", "output": ["0\n4\n1\n5\n31072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 2\n101011 188450\n", "output": ["1\n3\n3\n1\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 7\n101001 200000\n", "output": ["1\n1\n1\n3\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n101001 200000\n", "output": ["2\n1\n1\n3\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n111001 200000\n", "output": ["2\n1\n1\n3\n20071\n"]}, {"input": "5\n1 4\n1 6\n7 9\n1 7\n111001 200000\n", "output": ["2\n3\n1\n3\n20071\n"]}, {"input": "5\n1 4\n2 6\n7 9\n1 7\n111001 200000\n", "output": ["2\n2\n1\n3\n20071\n"]}, {"input": "5\n2 4\n3 6\n7 9\n1 7\n111001 200000\n", "output": ["1\n1\n1\n3\n20071\n"]}, {"input": "5\n2 8\n3 6\n7 9\n1 7\n111001 200000\n", "output": ["3\n1\n1\n3\n20071\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 4\n100001 200000\n", "output": ["1\n3\n0\n0\n31071\n"]}, {"input": "5\n2 2\n2 8\n4 5\n2 5\n100000 101573\n", "output": ["0\n3\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 4\n4 5\n4 5\n110000 200000\n", "output": ["1\n1\n0\n0\n21072\n"]}, {"input": "5\n1 2\n1 8\n4 5\n4 10\n110000 200000\n", "output": ["1\n4\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n100100 200000\n", "output": ["0\n6\n0\n2\n30972\n"]}, {"input": "5\n1 2\n4 8\n4 5\n1 5\n100000 200000\n", "output": ["1\n1\n0\n2\n31072\n"]}, {"input": "5\n2 2\n2 8\n1 5\n2 5\n100000 161404\n", "output": ["0\n3\n2\n2\n30333\n"]}, {"input": "5\n1 2\n2 8\n3 6\n4 5\n110000 200000\n", "output": ["1\n3\n1\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 10\n100100 200000\n", "output": ["1\n3\n0\n4\n30972\n"]}, {"input": "5\n1 1\n2 8\n4 5\n4 12\n110000 200000\n", "output": ["0\n3\n0\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n2 5\n100101 200000\n", "output": ["0\n3\n1\n2\n30971\n"]}, {"input": "5\n1 1\n2 8\n7 9\n1 5\n100000 200000\n", "output": ["0\n3\n1\n2\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 11\n4 5\n110000 200000\n", "output": ["2\n3\n4\n0\n21072\n"]}, {"input": "5\n2 4\n2 8\n4 5\n2 7\n100101 200000\n", "output": ["1\n3\n0\n2\n30971\n"]}, {"input": "5\n1 2\n2 8\n2 5\n4 13\n110000 200000\n", "output": ["1\n3\n2\n4\n21072\n"]}, {"input": "5\n2 2\n2 8\n3 11\n2 5\n101100 200000\n", "output": ["0\n3\n4\n2\n29972\n"]}, {"input": "5\n1 2\n2 13\n7 9\n1 5\n100000 200000\n", "output": ["1\n6\n1\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 7\n000100 200000\n", "output": ["1\n2\n0\n2\n99933\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 5\n101000 135172\n", "output": ["1\n3\n1\n2\n4101\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n100000 200000\n", "output": ["1\n2\n1\n2\n31072\n"]}, {"input": "5\n1 4\n2 7\n7 9\n1 5\n101100 200000\n", "output": ["2\n2\n1\n2\n29972\n"]}, {"input": "5\n2 2\n2 10\n4 5\n4 5\n100000 200000\n", "output": ["0\n4\n0\n0\n31072\n"]}, {"input": "5\n2 4\n2 16\n4 5\n2 5\n100100 200000\n", "output": ["1\n7\n0\n2\n30972\n"]}, {"input": "5\n1 3\n2 2\n4 6\n2 5\n100000 200000\n", "output": ["1\n0\n0\n2\n31072\n"]}, {"input": "5\n2 2\n1 8\n1 5\n4 5\n100000 200000\n", "output": ["0\n4\n2\n0\n31072\n"]}, {"input": "5\n2 2\n2 8\n3 6\n4 4\n100100 200000\n", "output": ["0\n3\n1\n0\n30972\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 8\n100000 200000\n", "output": ["1\n3\n3\n4\n31072\n"]}, {"input": "5\n1 4\n2 8\n4 6\n4 5\n010001 200000\n", "output": ["2\n3\n0\n0\n91696\n"]}, {"input": "5\n2 2\n1 15\n3 6\n2 5\n101100 200000\n", "output": ["0\n7\n1\n2\n29972\n"]}, {"input": "5\n1 4\n1 8\n4 5\n4 7\n100100 200000\n", "output": ["2\n4\n0\n0\n30972\n"]}, {"input": "5\n4 4\n2 5\n4 5\n2 7\n100100 123776\n", "output": ["0\n2\n0\n2\n0\n"]}, {"input": "5\n1 2\n3 7\n4 5\n6 10\n110000 200000\n", "output": ["1\n1\n0\n2\n21072\n"]}, {"input": "5\n2 2\n2 7\n4 6\n2 11\n100100 200000\n", "output": ["0\n2\n0\n4\n30972\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 3\n100110 200000\n", "output": ["0\n4\n0\n0\n30962\n"]}, {"input": "5\n2 2\n2 10\n3 6\n2 4\n100101 200000\n", "output": ["0\n4\n1\n1\n30971\n"]}, {"input": "5\n1 2\n2 7\n4 5\n6 20\n100000 200000\n", "output": ["1\n2\n0\n7\n31072\n"]}, {"input": "5\n2 2\n2 5\n3 6\n2 4\n100101 108244\n", "output": ["0\n2\n1\n1\n0\n"]}, {"input": "5\n2 3\n1 1\n3 6\n2 5\n111100 200000\n", "output": ["0\n0\n1\n2\n19972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n101011 188450\n", "output": ["1\n3\n1\n5\n30061\n"]}, {"input": "5\n1 2\n1 3\n7 9\n1 14\n101001 200000\n", "output": ["1\n1\n1\n7\n30071\n"]}, {"input": "5\n1 4\n1 3\n7 9\n1 7\n110001 200000\n", "output": ["2\n1\n1\n3\n21071\n"]}, {"input": "5\n1 4\n3 6\n7 9\n1 13\n111001 200000\n", "output": ["2\n1\n1\n6\n20071\n"]}, {"input": "5\n1 2\n2 13\n4 5\n1 2\n100000 200000\n", "output": ["1\n6\n0\n1\n31072\n"]}, {"input": "5\n2 2\n2 8\n3 5\n2 5\n100000 101573\n", "output": ["0\n3\n1\n2\n0\n"]}, {"input": "5\n1 2\n1 13\n4 5\n4 10\n110000 200000\n", "output": ["1\n6\n0\n3\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n100100 138386\n", "output": ["0\n6\n0\n2\n7315\n"]}, {"input": "5\n1 2\n2 8\n3 8\n4 5\n110000 200000\n", "output": ["1\n3\n2\n0\n21072\n"]}, {"input": "5\n2 2\n2 2\n3 6\n2 5\n100101 200000\n", "output": ["0\n0\n1\n2\n30971\n"]}, {"input": "5\n1 4\n2 5\n4 11\n4 5\n110000 200000\n", "output": ["2\n2\n4\n0\n21072\n"]}, {"input": "5\n1 4\n2 8\n4 5\n2 7\n100101 200000\n", "output": ["2\n3\n0\n2\n30971\n"]}, {"input": "5\n2 2\n1 8\n3 11\n2 5\n101100 200000\n", "output": ["0\n4\n4\n2\n29972\n"]}, {"input": "5\n2 4\n2 7\n4 5\n1 7\n000100 200000\n", "output": ["1\n2\n0\n3\n99933\n"]}, {"input": "5\n1 2\n2 4\n7 9\n1 5\n101000 135172\n", "output": ["1\n1\n1\n2\n4101\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n100001 200000\n", "output": ["1\n2\n1\n2\n31071\n"]}, {"input": "5\n2 2\n2 8\n2 4\n4 5\n110000 200000\n", "output": ["0\n3\n1\n0\n21072\n"]}, {"input": "5\n2 4\n1 16\n4 5\n2 5\n100100 200000\n", "output": ["1\n8\n0\n2\n30972\n"]}, {"input": "5\n2 2\n1 8\n1 5\n4 5\n100000 150693\n", "output": ["0\n4\n2\n0\n19622\n"]}, {"input": "5\n1 2\n2 8\n3 5\n4 5\n110001 200000\n", "output": ["1\n3\n1\n0\n21071\n"]}, {"input": "5\n1 3\n2 8\n4 5\n2 12\n110000 200000\n", "output": ["1\n3\n0\n5\n21072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 8\n100010 200000\n", "output": ["1\n3\n3\n4\n31062\n"]}, {"input": "5\n1 1\n2 4\n4 5\n4 15\n110000 200000\n", "output": ["0\n1\n0\n4\n21072\n"]}, {"input": "5\n1 4\n1 8\n4 5\n3 7\n100100 200000\n", "output": ["2\n4\n0\n1\n30972\n"]}, {"input": "5\n2 2\n3 7\n4 5\n6 10\n110000 200000\n", "output": ["0\n1\n0\n2\n21072\n"]}, {"input": "5\n2 3\n2 8\n1 6\n4 5\n100100 200000\n", "output": ["0\n3\n3\n0\n30972\n"]}, {"input": "5\n2 2\n2 9\n4 5\n2 3\n101110 200000\n", "output": ["0\n4\n0\n0\n29962\n"]}, {"input": "5\n1 2\n4 8\n7 9\n2 5\n101011 188450\n", "output": ["1\n1\n1\n2\n30061\n"]}, {"input": "5\n1 2\n4 7\n4 5\n6 20\n100000 200000\n", "output": ["1\n0\n0\n7\n31072\n"]}, {"input": "5\n2 3\n1 2\n3 6\n2 5\n111100 200000\n", "output": ["0\n1\n1\n2\n19972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 10\n101010 188450\n", "output": ["1\n3\n1\n5\n30062\n"]}, {"input": "5\n1 4\n1 3\n7 15\n1 5\n101000 200000\n", "output": ["2\n1\n1\n2\n30072\n"]}, {"input": "5\n1 1\n1 8\n7 8\n1 10\n100010 186611\n", "output": ["0\n4\n1\n5\n31062\n"]}, {"input": "5\n1 2\n1 4\n7 9\n1 14\n101001 200000\n", "output": ["1\n2\n1\n7\n30071\n"]}, {"input": "5\n1 4\n1 3\n9 9\n1 7\n110001 200000\n", "output": ["2\n1\n0\n3\n21071\n"]}, {"input": "5\n1 4\n1 8\n7 9\n1 7\n111001 200000\n", "output": ["2\n4\n1\n3\n20071\n"]}, {"input": "5\n1 4\n3 6\n7 9\n1 9\n111001 200000\n", "output": ["2\n1\n1\n4\n20071\n"]}, {"input": "5\n2 3\n1 8\n4 5\n2 5\n100100 185068\n", "output": ["0\n4\n0\n2\n30972\n"]}, {"input": "5\n1 2\n1 13\n4 5\n1 10\n110000 200000\n", "output": ["1\n6\n0\n5\n21072\n"]}, {"input": "5\n2 2\n2 14\n4 6\n2 5\n000100 138386\n", "output": ["0\n6\n0\n2\n69139\n"]}, {"input": "5\n1 2\n2 14\n3 8\n4 5\n110000 200000\n", "output": ["1\n6\n2\n0\n21072\n"]}, {"input": "5\n1 2\n2 5\n4 11\n4 5\n110000 200000\n", "output": ["1\n2\n4\n0\n21072\n"]}, {"input": "5\n1 4\n2 5\n4 5\n2 7\n100101 200000\n", "output": ["2\n2\n0\n2\n30971\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 8\n100001 200000\n", "output": ["1\n2\n1\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 4\n4 5\n110000 200000\n", "output": ["0\n0\n1\n0\n21072\n"]}, {"input": "5\n1 2\n2 8\n3 9\n1 14\n100010 200000\n", "output": ["1\n3\n3\n7\n31062\n"]}, {"input": "5\n1 1\n2 5\n4 5\n4 15\n110000 200000\n", "output": ["0\n2\n0\n4\n21072\n"]}, {"input": "5\n2 2\n3 9\n4 5\n6 10\n110000 200000\n", "output": ["0\n3\n0\n2\n21072\n"]}, {"input": "5\n1 2\n4 8\n7 9\n3 5\n101011 188450\n", "output": ["1\n1\n1\n1\n30061\n"]}, {"input": "5\n1 4\n4 7\n4 5\n6 20\n100000 200000\n", "output": ["2\n0\n0\n7\n31072\n"]}, {"input": "5\n2 3\n1 2\n1 6\n2 5\n111100 200000\n", "output": ["0\n1\n3\n2\n19972\n"]}, {"input": "5\n1 1\n1 8\n7 8\n2 10\n100010 186611\n", "output": ["0\n4\n1\n4\n31062\n"]}, {"input": "5\n1 2\n1 4\n7 9\n1 14\n100001 200000\n", "output": ["1\n2\n1\n7\n31071\n"]}, {"input": "5\n1 4\n1 3\n9 9\n2 7\n110001 200000\n", "output": ["2\n1\n0\n2\n21071\n"]}, {"input": "5\n1 4\n1 8\n7 9\n1 2\n111001 200000\n", "output": ["2\n4\n1\n1\n20071\n"]}, {"input": "5\n1 2\n3 14\n3 8\n4 5\n110000 200000\n", "output": ["1\n5\n2\n0\n21072\n"]}, {"input": "5\n1 4\n2 5\n4 5\n2 8\n100101 200000\n", "output": ["2\n2\n0\n3\n30971\n"]}, {"input": "5\n1 2\n2 12\n7 9\n1 8\n100001 200000\n", "output": ["1\n5\n1\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 4\n4 5\n110100 200000\n", "output": ["0\n0\n1\n0\n20972\n"]}, {"input": "5\n1 1\n4 5\n4 5\n4 15\n110000 200000\n", "output": ["0\n0\n0\n4\n21072\n"]}, {"input": "5\n1 4\n1 16\n4 7\n3 7\n100100 200000\n", "output": ["2\n8\n0\n1\n30972\n"]}, {"input": "5\n1 2\n3 9\n4 5\n6 10\n110000 200000\n", "output": ["1\n3\n0\n2\n21072\n"]}, {"input": "5\n2 3\n1 2\n1 6\n2 5\n101100 200000\n", "output": ["0\n1\n3\n2\n29972\n"]}, {"input": "5\n1 4\n1 3\n9 9\n2 7\n111001 200000\n", "output": ["2\n1\n0\n2\n20071\n"]}, {"input": "5\n1 4\n1 5\n7 9\n1 2\n111001 200000\n", "output": ["2\n2\n1\n1\n20071\n"]}, {"input": "5\n2 2\n2 5\n3 5\n2 5\n101000 129464\n", "output": ["0\n2\n1\n2\n0\n"]}, {"input": "5\n1 2\n2 12\n4 9\n1 8\n100001 200000\n", "output": ["1\n5\n2\n4\n31071\n"]}, {"input": "5\n2 2\n2 3\n2 8\n4 5\n110100 200000\n", "output": ["0\n0\n3\n0\n20972\n"]}, {"input": "5\n1 2\n4 8\n3 5\n4 7\n110001 200000\n", "output": ["1\n1\n1\n0\n21071\n"]}, {"input": "5\n2 3\n2 8\n3 5\n4 12\n110000 200000\n", "output": ["0\n3\n1\n4\n21072\n"]}, {"input": "5\n1 1\n4 5\n4 5\n4 15\n110010 200000\n", "output": ["0\n0\n0\n4\n21062\n"]}, {"input": "5\n1 1\n1 8\n7 14\n2 16\n100010 186611\n", "output": ["0\n4\n1\n7\n31062\n"]}, {"input": "5\n1 6\n1 5\n7 9\n1 2\n111001 200000\n", "output": ["3\n2\n1\n1\n20071\n"]}, {"input": "5\n2 2\n2 5\n3 9\n2 5\n101000 129464\n", "output": ["0\n2\n3\n2\n0\n"]}, {"input": "5\n1 1\n2 12\n4 9\n1 8\n100001 200000\n", "output": ["0\n5\n2\n4\n31071\n"]}, {"input": "5\n1 2\n4 8\n3 5\n1 7\n110001 200000\n", "output": ["1\n1\n1\n3\n21071\n"]}, {"input": "5\n2 3\n2 8\n3 5\n4 12\n010000 200000\n", "output": ["0\n3\n1\n4\n91697\n"]}, {"input": "5\n2 3\n1 3\n1 6\n2 8\n101100 200000\n", "output": ["0\n1\n3\n3\n29972\n"]}, {"input": "5\n1 1\n1 8\n6 14\n2 16\n100010 186611\n", "output": ["0\n4\n2\n7\n31062\n"]}, {"input": "5\n1 6\n1 10\n7 9\n1 2\n111001 200000\n", "output": ["3\n5\n1\n1\n20071\n"]}, {"input": "5\n1 1\n2 12\n4 13\n1 8\n100001 200000\n", "output": ["0\n5\n4\n4\n31071\n"]}, {"input": "5\n1 2\n4 4\n3 5\n1 7\n110001 200000\n", "output": ["1\n0\n1\n3\n21071\n"]}, {"input": "5\n2 3\n1 5\n1 6\n2 8\n101100 200000\n", "output": ["0\n2\n3\n3\n29972\n"]}, {"input": "5\n1 6\n1 10\n9 9\n1 2\n111001 200000\n", "output": ["3\n5\n0\n1\n20071\n"]}, {"input": "5\n1 1\n2 12\n4 13\n1 8\n100000 200000\n", "output": ["0\n5\n4\n4\n31072\n"]}, {"input": "5\n1 2\n4 4\n3 8\n1 7\n110001 200000\n", "output": ["1\n0\n2\n3\n21071\n"]}, {"input": "5\n1 2\n4 4\n3 8\n2 7\n110001 200000\n", "output": ["1\n0\n2\n2\n21071\n"]}, {"input": "5\n2 3\n2 5\n1 6\n2 8\n101101 200000\n", "output": ["0\n2\n3\n3\n29971\n"]}, {"input": "5\n1 2\n2 10\n4 5\n1 5\n100000 121445\n", "output": ["1\n4\n0\n2\n0\n"]}, {"input": "5\n1 2\n2 8\n4 5\n4 5\n110010 200000\n", "output": ["1\n3\n0\n0\n21062\n"]}, {"input": "5\n1 2\n2 10\n4 5\n4 12\n110000 200000\n", "output": ["1\n4\n0\n4\n21072\n"]}, {"input": "5\n2 2\n4 8\n3 6\n2 5\n100100 200000\n", "output": ["0\n1\n1\n2\n30972\n"]}, {"input": "5\n2 2\n2 7\n1 5\n2 5\n100000 200000\n", "output": ["0\n2\n2\n2\n31072\n"]}, {"input": "5\n2 4\n2 7\n4 5\n2 13\n100100 200000\n", "output": ["1\n2\n0\n6\n30972\n"]}, {"input": "5\n1 2\n2 8\n7 9\n1 1\n101000 200000\n", "output": ["1\n3\n1\n0\n30072\n"]}, {"input": "5\n1 2\n2 7\n7 9\n1 5\n111100 200000\n", "output": ["1\n2\n1\n2\n19972\n"]}], "task_id": "codecontest/120", "prompt": "You are provided an array that includes all integers from [l, r]. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. Solving the problem efficiently requires understanding the properties of binary numbers and their bitwise operations, which is essential to determine the minimum number of elements you can delete to make the bitwise AND of the array non-zero.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "repair_prompt": ["You are provided an array that includes all integers from [l, r]. For example, if l = 2 and r = 5, the array would be [2, 3, 4, 5]. Solving the problem efficiently requires understanding the properties of binary numbers and their bitwise operations, which is essential to determine the minimum number of elements you can delete to make the bitwise AND of the array non-zero.\n\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\n-------\nImportant Note: You must follow the input output format.  The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of results for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the number of elements in the range\n        num_elements = r - l + 1\n        \n        # Initialize the minimum deletions to the maximum possible value\n        min_deletions = num_elements\n        \n        # Iterate over possible starting points of the array\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the AND for the current subset\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions required\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to a large number\n        min_deletions = float('inf')\n        \n        # Iterate over all possible starting points of the array\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the bitwise AND for the current subset\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions if a better solution is found\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions needed to achieve a non-zero bitwise AND for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples, each containing two integers l and r.\n\n    Returns:\n        List[int]: List of results, each representing the minimum number of deletions for the corresponding test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the number of bits in r\n        num_bits = r.bit_length()\n        \n        # Initialize the minimum deletions to the size of the range\n        min_deletions = r - l + 1\n        \n        # Iterate over all possible bit positions\n        for bit in range(num_bits):\n            # Calculate the mask for the current bit position\n            mask = (1 << (bit + 1)) - 1\n            \n            # Calculate the prefix that results in a non-zero AND\n            prefix = r & mask\n            \n            # Calculate the number of deletions needed\n            if prefix >= l:\n                deletions = r - prefix\n                min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Process the test cases\n    results = min_deletions_to_non_zero_and(t, test_cases)\n    \n    # Output results\n    for result in results:\n        print(result)\n\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to a large number\n        min_deletions = r - l + 1\n        \n        # Iterate over possible bit positions\n        for bit_position in range(20):  # Since r <= 2 * 10^5, we consider up to 20 bits\n            # Calculate the mask for the current bit position\n            mask = 1 << bit_position\n            \n            # Count numbers in the range [l, r] that have the current bit set\n            count_with_bit_set = 0\n            for number in range(l, r + 1):\n                if number & mask:\n                    count_with_bit_set += 1\n            \n            # Calculate deletions needed to make the AND non-zero for this bit position\n            deletions_needed = (r - l + 1) - count_with_bit_set\n            \n            # Update the minimum deletions\n            min_deletions = min(min_deletions, deletions_needed)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Calculate the number of elements in the range [l, r]\n        num_elements = r - l + 1\n        \n        # Initialize the minimum deletions to the maximum possible value\n        min_deletions = num_elements\n        \n        # Iterate over all possible starting points of the array\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the AND for the current subset\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions needed\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to the size of the array\n        min_deletions = r - l + 1\n        \n        # Iterate over possible bit positions\n        for bit_position in range(20):  # 20 bits are enough for numbers up to 2 * 10^5\n            # Calculate the mask for the current bit position\n            mask = 1 << bit_position\n            \n            # Count numbers in the range [l, r] that have the current bit set\n            count_with_bit_set = 0\n            for number in range(l, r + 1):\n                if number & mask:\n                    count_with_bit_set += 1\n            \n            # Calculate deletions needed to make the AND non-zero for this bit position\n            deletions_for_bit = (r - l + 1) - count_with_bit_set\n            \n            # Update the minimum deletions\n            min_deletions = min(min_deletions, deletions_for_bit)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    for l, r in test_cases:\n        max_length = 0\n        current_length = 0\n        current_and = 0\n        \n        for num in range(l, r + 1):\n            if current_and == 0:\n                current_and = num\n                current_length = 1\n            else:\n                current_and &= num\n                if current_and != 0:\n                    current_length += 1\n                else:\n                    current_and = num\n                    current_length = 1\n            \n            max_length = max(max_length, current_length)\n        \n        min_deletions = (r - l + 1) - max_length\n        results.append(min_deletions)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to the maximum possible deletions\n        min_deletions = r - l + 1\n        \n        # Iterate over each possible starting point in the range [l, r]\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the AND for the current subarray starting at 'start'\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions needed\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    n = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(n, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, test_cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in test_cases:\n        # Initialize the minimum deletions to the maximum possible value\n        min_deletions = r - l + 1\n        \n        # Iterate over possible starting points of the subarray\n        for start in range(l, r + 1):\n            current_and = start\n            deletions = 0\n            \n            # Calculate the bitwise AND for the subarray starting at 'start'\n            for num in range(start + 1, r + 1):\n                current_and &= num\n                if current_and == 0:\n                    deletions += 1\n                else:\n                    break\n            \n            # Update the minimum deletions required\n            min_deletions = min(min_deletions, deletions)\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    \n    # Output interface\n    results = min_deletions_to_non_zero_and(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef min_deletions_to_non_zero_and(t: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of deletions required to make the bitwise AND of the array non-zero.\n\n    Args:\n        t (int): Number of test cases.\n        cases (List[Tuple[int, int]]): List of tuples, each containing two integers l and r.\n\n    Returns:\n        List[int]: List of integers representing the minimum deletions for each test case.\n    \"\"\"\n    results = []\n    \n    for l, r in cases:\n        # Initialize the minimum deletions to the maximum possible value\n        min_deletions = r - l + 1\n        \n        # Iterate over possible powers of two\n        power_of_two = 1\n        while power_of_two <= r:\n            # Calculate the number of elements in the range [l, r] that are divisible by the current power of two\n            divisible_count = (r // power_of_two) - ((l - 1) // power_of_two)\n            \n            # Calculate the number of deletions required to remove all elements divisible by the current power of two\n            deletions = (r - l + 1) - divisible_count\n            \n            # Update the minimum deletions if the current deletions are less\n            min_deletions = min(min_deletions, deletions)\n            \n            # Move to the next power of two\n            power_of_two *= 2\n        \n        results.append(min_deletions)\n    \n    return results\n\n# Input interface\nt = int(input())\ncases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Output interface\nresults = min_deletions_to_non_zero_and(t, cases)\nfor result in results:\n    print(result)\n"], "plans": ["requirement analysis:\nThe problem requires understanding of bitwise operations to efficiently determine the minimum number of elements to delete for a non-zero bitwise AND. The solution must handle up to 10,000 test cases with array sizes up to 200,000, ensuring both efficiency and correctness.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem.\n- Ensure the solution handles large input sizes up to 200,000.\n- Verify the solution against multiple test cases for correctness.\n- Optimize the solution for performance.\n- Provide clear documentation of the solution approach.\nWe will use bitwise operations to efficiently determine the minimum number of elements to delete from the array to make the bitwise AND non-zero. The approach involves iterating over the range [l, r] and calculating the bitwise AND for subsets of the array, while keeping track of the minimum deletions required. We will leverage Python's built-in bitwise operators and optimize the solution to handle large input sizes.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of an array non-zero. This involves understanding bitwise operations and efficiently handling large input sizes. The solution must be optimized to handle up to 10,000 test cases with array sizes up to 200,000.\nrequirement pool:\n- Develop an algorithm to calculate the minimum deletions for non-zero bitwise AND.\n- Optimize the solution to handle maximum constraints efficiently.\n- Ensure the solution is tested against a variety of test cases.\n- Provide clear documentation and comments within the code.\n- Implement additional features for user interaction and feedback.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range [l, r] and calculating the bitwise AND for subsets of the array, while keeping track of the minimum deletions needed. Given the constraints, we will optimize the solution to handle up to 10,000 test cases with array sizes up to 200,000 using efficient bitwise manipulation techniques.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations to efficiently determine the minimum number of deletions needed to achieve a non-zero bitwise AND for the array. The solution must handle up to 10,000 test cases and arrays with elements ranging from 1 to 200,000, necessitating an optimized approach.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem.\n- Ensure the solution handles large input sizes within time constraints.\n- Provide clear documentation for understanding the solution approach.\n- Optimize the code for readability and maintainability.\n- Include test cases to validate the solution's correctness.\nWe will use bitwise operations to efficiently determine the minimum number of deletions needed to achieve a non-zero bitwise AND for the array. The approach involves iterating over the range and calculating the bitwise AND, while keeping track of the number of deletions required. We will utilize Python's built-in capabilities for bitwise operations and optimize the solution to handle large input sizes within time constraints.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations to determine the minimum number of deletions needed to achieve a non-zero bitwise AND for the array. The solution must efficiently handle up to 10,000 test cases with array sizes up to 200,000.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem.\n- Ensure the solution handles large input sizes effectively.\n- Provide clear and correct output for all test cases.\n- Optimize the solution for performance.\n- Document the solution approach for future reference.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range [l, r] and calculating the bitwise AND for subsets of the array, while keeping track of the minimum deletions needed. We will leverage Python's built-in bitwise operations to achieve this.\n", "requirement analysis:\nThe problem requires an understanding of bitwise operations to determine the minimum number of deletions needed to make the bitwise AND of an array non-zero. The solution must efficiently handle up to 10,000 test cases with array ranges up to 200,000.\nrequirement pool:\n- Develop an algorithm to determine the minimum deletions for a non-zero bitwise AND.\n- Ensure the solution is optimized for large input sizes.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution.\n- Optimize the code for readability and maintainability.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range [l, r] and calculating the bitwise AND for subsets of the array, while keeping track of the minimum deletions needed. We will leverage Python's built-in bitwise operators and optimize the solution to handle up to 10,000 test cases efficiently.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations to efficiently determine the minimum number of elements to delete from an array to make the bitwise AND non-zero. The solution must handle up to 10,000 test cases with array sizes up to 200,000, ensuring both efficiency and correctness.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem\n- Ensure the solution handles large input sizes up to 200,000\n- Optimize the algorithm for speed and performance\n- Provide clear and correct output for each test case\n- Document the solution approach and edge cases\nWe will use bitwise operations to efficiently determine the minimum number of elements to delete from the array to make the bitwise AND non-zero. The approach involves iterating over the range [l, r] and calculating the bitwise AND for subsets of the array, leveraging properties of binary numbers to minimize deletions. We will use Python's built-in bitwise operators and optimize the solution to handle large input sizes.\n", "requirement analysis:\nThe problem requires determining the minimum number of deletions needed to make the bitwise AND of an array non-zero. This involves understanding bitwise operations and efficiently handling large input sizes. The solution must be optimized to handle up to 10,000 test cases with array sizes up to 200,000.\nrequirement pool:\n- Develop an algorithm to calculate the minimum deletions for non-zero bitwise AND.\n- Optimize the solution to handle maximum constraints efficiently.\n- Ensure the solution is tested against a variety of test cases.\n- Provide clear documentation and comments within the code.\n- Implement additional features for user interaction and feedback.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range [l, r] and calculating the bitwise AND for subsets of the array, while keeping track of the minimum deletions needed. We will leverage Python's built-in capabilities for handling large integers and bitwise operations.\n", "requirement analysis:\nThe problem requires an efficient algorithm to determine the minimum number of deletions needed to make the bitwise AND of a range of integers non-zero. The solution must handle up to 10,000 test cases and large ranges efficiently. Understanding bitwise operations and their properties is crucial for optimizing the solution.\nrequirement pool:\n- Develop an algorithm to solve the problem efficiently.\n- Ensure the solution handles the maximum constraints effectively.\n- Optimize the solution for large values of l and r.\n- Provide clear and concise output for each test case.\n- Document the solution and its approach clearly.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The approach involves iterating over the range and calculating the bitwise AND, while keeping track of the number of deletions needed. We will use Python's built-in capabilities for bitwise operations and leverage efficient iteration techniques to handle large ranges and multiple test cases.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations to efficiently determine the minimum number of elements to delete for a non-zero bitwise AND. The solution must handle up to 10,000 test cases with ranges up to 200,000, ensuring scalability and efficiency.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem.\n- Ensure the solution handles large input sizes up to 10,000 test cases.\n- Verify the output format is correct for all test cases.\n- Optimize the solution for performance and scalability.\n- Provide clear documentation for the solution approach.\nWe will use bitwise operations to efficiently determine the minimum number of elements to delete from the array to make the bitwise AND non-zero. The approach involves iterating over the range [l, r] and calculating the bitwise AND for subsets of the array, while keeping track of the minimum deletions required. This can be optimized by understanding the properties of binary numbers and leveraging bitwise operations to reduce unnecessary calculations.\n", "requirement analysis:\nThe problem requires understanding of bitwise operations to efficiently determine the minimum number of elements to delete from an array to make the bitwise AND non-zero. The solution must handle up to 10,000 test cases with array sizes up to 200,000, ensuring scalability and efficiency.\nrequirement pool:\n- Implement efficient bitwise operations to solve the problem.\n- Ensure the solution handles large input sizes up to 200,000.\n- Provide clear and correct output for each test case.\n- Optimize the solution for performance and scalability.\n- Document the solution approach and edge cases.\nWe will use bitwise operations to efficiently determine the minimum number of deletions required to make the bitwise AND of the array non-zero. The key observation is that the bitwise AND of a range [l, r] is zero if there exists a power of two within the range. We will iterate over each test case, calculate the number of elements that need to be removed to achieve a non-zero AND, and output the result.\n"], "scores": [], "pass_results": [false, false, false, false, true, false, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 512, "examples": "\nInput\n\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t cases follow.\n\nThe first line of each test case contains two integers l and r (1 \u2264 l \u2264 r \u2264 2 \u22c5 10^5) \u2014 the description of the array.\n\nOutput\n\nFor each test case, output a single integer \u2014 the answer to the problem.\n\nExample\n\nInput\n\n\n5\n1 2\n2 8\n4 5\n1 5\n100000 200000\n\n\nOutput\n\n\n1\n3\n0\n2\n31072\n\nNote\n\nIn the first test case, the array is [1, 2]. Currently, the bitwise AND is 0, as 1\\ \\& \\ 2 = 0. However, after deleting 1 (or 2), the array becomes [2] (or [1]), and the bitwise AND becomes 2 (or 1). This can be proven to be the optimal, so the answer is 1.\n\nIn the second test case, the array is [2, 3, 4, 5, 6, 7, 8]. Currently, the bitwise AND is 0. However, after deleting 4, 5, and 8, the array becomes [2, 3, 6, 7], and the bitwise AND becomes 2. This can be proven to be the optimal, so the answer is 3. Note that there may be other ways to delete 3 elements.", "mutate_method": "condense_two2one", "parent_index": 302}
