{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir has a rectangular piece of paper with a checkered grid that is n \u00d7 m in size. At the start, each square on the grid is white.\n\nLet's represent the cell with coordinates i downwards and j sideways by (i, j), where the top left cell will be called (1, 1) and the bottom right cell will be called (n, m).\n\nCasimir sketches ticks of varying sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn in this manner:\n\n  1. First, the central cell (i, j) is colored black.\n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also colored black. \n  3. Therefore, all the cells at positions (i - h, j \u00b1 h) for every h from 0 to d are colored. Specifically, a tick is made up of 2d + 1 black cells.\n\nA cell that is already painted will stay black if painted again. Below is an illustration of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou receive a description of a checkered field of size n \u00d7 m. Casimir claims that this field was created by marking some (maybe 0) ticks on it, and the ticks could vary in sizes, but each tick must have a size of at least k (that is, d \u2265 k for every tick).\n\nEvaluate whether this field can indeed result from drawing some (possibly none) ticks of sizes d \u2265 k or not. Consider edge cases where the field dimensions or the values of k result in limited or no space for ticks.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir has a rectangular piece of paper with a checkered grid that is n \u00d7 m in size. At the start, each square on the grid is white.\n\nLet's represent the cell with coordinates i downwards and j sideways by (i, j), where the top left cell will be called (1, 1) and the bottom right cell will be called (n, m).\n\nCasimir sketches ticks of varying sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn in this manner:\n\n  1. First, the central cell (i, j) is colored black.\n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also colored black. \n  3. Therefore, all the cells at positions (i - h, j \u00b1 h) for every h from 0 to d are colored. Specifically, a tick is made up of 2d + 1 black cells.\n\nA cell that is already painted will stay black if painted again. Below is an illustration of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou receive a description of a checkered field of size n \u00d7 m. Casimir claims that this field was created by marking some (maybe 0) ticks on it, and the ticks could vary in sizes, but each tick must have a size of at least k (that is, d \u2265 k for every tick).\n\nEvaluate whether this field can indeed result from drawing some (possibly none) ticks of sizes d \u2265 k or not. Consider edge cases where the field dimensions or the values of k result in limited or no space for ticks.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(n: int, m: int, k: int, grid: List[str]) -> str:\n    \"\"\"Check if all '*' in the grid can be part of a valid tick of size at least k.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        k (int): Minimum size of the tick.\n        grid (List[str]): The grid represented as a list of strings.\n\n    Returns:\n        str: 'YES' if all '*' can be part of a valid tick, otherwise 'NO'.\n    \"\"\"\n    # Helper function to check if a tick can be formed at a given position and size\n    def is_valid_tick(x: int, y: int, size: int) -> bool:\n        for i in range(size):\n            if x - i < 0 or y - i < 0 or y + i >= m:\n                return False\n            if grid[x - i][y - i] != '*' or grid[x - i][y + i] != '*':\n                return False\n        return True\n\n    # Create a 2D list to mark positions that are part of a valid tick\n    marked = [[False] * m for _ in range(n)]\n\n    # Iterate over the grid to find all possible ticks\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                # Check for the largest possible tick size at this position\n                size = 0\n                while is_valid_tick(i, j, size + 1):\n                    size += 1\n                # Mark all positions of the valid tick\n                for s in range(size):\n                    marked[i - s][j - s] = True\n                    marked[i - s][j + s] = True\n\n    # Verify if all '*' are part of a valid tick\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*' and not marked[i][j]:\n                return 'NO'\n    return 'YES'\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        result = can_form_ticks(n, m, k, grid)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a given grid can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark the cells that can be part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a valid tick\n        for i in range(k, n - k):\n            for j in range(k, m - k):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells of the tick\n                        marked[i][j] = True\n                        for d in range(1, k + 1):\n                            marked[i - d][j - d] = True\n                            marked[i - d][j + d] = True\n\n        # Check if all '*' in the grid are part of a tick\n        all_ticks_covered = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    all_ticks_covered = False\n                    break\n            if not all_ticks_covered:\n                break\n\n        if all_ticks_covered:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if all '*' cells in each grid can be covered by valid ticks.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark covered cells\n        covered = [[False] * m for _ in range(n)]\n\n        # Function to check if a tick of size `size` can be formed at (i, j)\n        def can_form_tick(i: int, j: int, size: int) -> bool:\n            for d in range(size):\n                if i - d < 0 or j - d < 0 or j + d >= m:\n                    return False\n                if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                    return False\n            return True\n\n        # Attempt to form ticks starting from the bottom of the grid\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                # Determine the maximum size of the tick that can be formed at (i, j)\n                size = 0\n                while can_form_tick(i, j, size + 1):\n                    size += 1\n\n                # If the tick size is at least k, mark the cells as covered\n                if size >= k:\n                    for d in range(size):\n                        covered[i - d][j - d] = True\n                        covered[i - d][j + d] = True\n\n        # Check if all '*' cells are covered\n        all_covered = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not covered[i][j]:\n                    all_covered = False\n                    break\n            if not all_covered:\n                break\n\n        results.append('YES' if all_covered else 'NO')\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each grid in the test cases can form valid ticks of at least size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): A list of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: A list of \"YES\" or \"NO\" for each test case indicating if the grid can form valid ticks.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a valid tick\n        for i in range(k, n - k):\n            for j in range(k, m - k):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells of the tick\n                        for d in range(k + 1):\n                            marked[i - d][j - d] = True\n                            marked[i - d][j + d] = True\n\n        # Verify if all '*' in the grid are part of a valid tick\n        all_ticks_covered = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    all_ticks_covered = False\n                    break\n            if not all_ticks_covered:\n                break\n\n        if all_ticks_covered:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determines if a tick of at least size k can be formed in each test case grid.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    def is_valid_tick_center(x: int, y: int, k: int, grid: List[str], n: int, m: int) -> bool:\n        \"\"\"Checks if a tick of size k can be centered at (x, y).\n\n        Args:\n            x (int): Row index of the center.\n            y (int): Column index of the center.\n            k (int): Minimum size of the tick.\n            grid (List[str]): The grid.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n\n        Returns:\n            bool: True if a tick can be formed, False otherwise.\n        \"\"\"\n        # Check if the tick can be formed with arms of length k\n        for arm_length in range(1, k + 1):\n            if (x - arm_length < 0 or y - arm_length < 0 or y + arm_length >= m or\n                grid[x - arm_length][y - arm_length] != '*' or\n                grid[x - arm_length][y + arm_length] != '*'):\n                return False\n        return True\n\n    results = []\n    for n, m, k, grid in test_cases:\n        can_form = False\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and is_valid_tick_center(i, j, k, grid, n, m):\n                    can_form = True\n                    break\n            if can_form:\n                break\n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n    \n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a given grid can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): Grid representation with '*' and '.'.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to track tick formation\n        tick_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and\n                           i + size < n and j + size < m and\n                           grid[i - size][j] == '*' and grid[i + size][j] == '*' and\n                           grid[i][j - size] == '*' and grid[i][j + size] == '*'):\n                        size += 1\n\n                    # If a tick of at least size k can be formed, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            tick_grid[i - s][j] = True\n                            tick_grid[i + s][j] = True\n                            tick_grid[i][j - s] = True\n                            tick_grid[i][j + s] = True\n\n        # Check if all '*' in the grid are part of a tick\n        can_form = all(\n            grid[i][j] == '.' or tick_grid[i][j]\n            for i in range(n)\n            for j in range(m)\n        )\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each grid can form valid ticks of size at least k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that can be part of a valid tick\n        valid_tick = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a valid tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                                grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells as valid\n                    if size > k:\n                        for s in range(size):\n                            valid_tick[i - s][j - s] = True\n                            valid_tick[i - s][j + s] = True\n\n        # Verify if all '*' in the grid are part of a valid tick\n        is_valid = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not valid_tick[i][j]:\n                    is_valid = False\n                    break\n            if not is_valid:\n                break\n\n        results.append(\"YES\" if is_valid else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if a valid tick of size at least k can be formed in each test case grid.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that can be part of a valid tick\n        can_be_tick = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a valid tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if i - d < 0 or j - d < 0 or j + d >= m:\n                            valid_tick = False\n                            break\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells of the tick\n                        for d in range(k + 1):\n                            can_be_tick[i - d][j - d] = True\n                            can_be_tick[i - d][j + d] = True\n\n        # Verify if all '*' in the grid can be part of a valid tick\n        all_ticks_covered = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not can_be_tick[i][j]:\n                    all_ticks_covered = False\n                    break\n            if not all_ticks_covered:\n                break\n\n        if all_ticks_covered:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each grid can form ticks of at least size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that can be part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                                grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If a tick of at least size k is possible, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the grid are part of a tick\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if all '*' in the grid can be part of ticks of size at least k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    def is_valid_tick(n: int, m: int, k: int, grid: List[List[str]], x: int, y: int) -> bool:\n        \"\"\"Check if a tick of size at least k can be formed with its center at (x, y).\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the tick.\n            grid (List[List[str]]): The grid itself.\n            x (int): Row index of the center of the tick.\n            y (int): Column index of the center of the tick.\n\n        Returns:\n            bool: True if a valid tick can be formed, False otherwise.\n        \"\"\"\n        length = 0\n        while True:\n            if x - length < 0 or y - length < 0 or y + length >= m:\n                break\n            if grid[x - length][y - length] != '*' or grid[x - length][y + length] != '*':\n                break\n            length += 1\n        return length > k\n\n    def mark_tick(n: int, m: int, grid: List[List[str]], x: int, y: int, length: int):\n        \"\"\"Mark the cells that are part of a valid tick.\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            grid (List[List[str]]): The grid itself.\n            x (int): Row index of the center of the tick.\n            y (int): Column index of the center of the tick.\n            length (int): Length of the tick.\n        \"\"\"\n        for i in range(length):\n            grid[x - i][y - i] = '.'\n            grid[x - i][y + i] = '.'\n\n    results = []\n    for n, m, k, grid in test_cases:\n        grid = [list(row) for row in grid]\n        valid = True\n\n        for x in range(n - 1, -1, -1):\n            for y in range(m):\n                if grid[x][y] == '*':\n                    if is_valid_tick(n, m, k, grid, x, y):\n                        length = 0\n                        while x - length >= 0 and y - length >= 0 and y + length < m and \\\n                              grid[x - length][y - length] == '*' and grid[x - length][y + length] == '*':\n                            length += 1\n                        mark_tick(n, m, grid, x, y, length)\n                    else:\n                        valid = False\n                        break\n            if not valid:\n                break\n\n        if valid:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each grid for possible tick formations and handle multiple test cases. Edge cases include small grid sizes and high k values relative to n and m.\nrequirement pool:\n- Implement the main algorithm to check for valid tick formations.\n- Optimize the solution for performance with large input sizes.\n- Ensure the solution handles edge cases correctly.\n- Provide clear and consistent output formatting.\n- Maintain code readability and simplicity.\nWe will iterate over each test case and for each grid, we will check if all '*' can be part of a valid tick of size at least k. We will use a helper function to verify if a tick can be formed at a given position and size. The solution will efficiently handle the constraints by iterating over the grid and checking possible tick formations.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each grid cell and validate potential tick formations, considering constraints on grid size and tick size.\nrequirement pool:\n- Implement the main logic to check for valid tick formations.\n- Optimize the solution for performance with multiple test cases.\n- Ensure the solution handles edge cases, such as small grids or large k values.\n- Maintain code readability and simplicity for future maintenance.\n- Provide detailed comments and documentation for the code.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. We will use a nested loop to verify the tick formation by checking the required diagonal cells. The solution will handle edge cases by ensuring that the tick does not extend beyond the grid boundaries.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each grid for possible tick formations and ensure that all black cells can be accounted for by valid ticks.\nrequirement pool:\n- Implement the main logic to check for valid tick formations.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution handles edge cases, such as small grids or large k values.\n- Provide clear and consistent output for each test case.\n- Maintain code readability and simplicity for future maintenance.\nWe will iterate over each test case and for each grid, we will attempt to identify all possible tick formations that satisfy the minimum size requirement. We will use a nested loop to traverse the grid and check for potential tick centers. For each potential center, we will verify if a tick of size k or greater can be formed by checking the diagonals. If all '*' cells can be covered by valid ticks, we will return 'YES', otherwise 'NO'.\n", "requirement analysis:\nThe requirement is to determine if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases, each with a grid size of up to 10x19. The challenge lies in accurately identifying valid tick patterns and ensuring that all black cells can be accounted for by these patterns.\nrequirement pool:\n- Implement the main logic to evaluate tick patterns on the grid.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution provides clear and concise output for each test case.\n- Handle edge cases and invalid inputs gracefully.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function to evaluate if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. We will use a nested loop to verify the tick pattern for each potential center. The solution will be optimized to handle up to 100 test cases efficiently by leveraging the constraints on grid size and tick size.\n", "requirement analysis:\nThe requirements focus on evaluating whether a given field can be obtained by drawing ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide accurate results for each. Edge cases, such as limited space for ticks, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test cases\n- Handle edge cases effectively\n- Ensure clear output format\n- Improve performance for large inputs\nWe will implement a function to evaluate whether a given field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use a simple nested loop to traverse the grid and a helper function to verify if a tick can be formed at a given position. The solution will be optimized for multiple test cases by processing each test case independently and efficiently.\n", "requirement analysis:\nThe requirement is to determine if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently handle multiple test cases and provide a YES or NO output for each. The constraints on grid size and tick size must be considered to ensure accurate detection.\nrequirement pool:\n- Implement tick detection algorithm for grids.\n- Optimize solution for performance with multiple test cases.\n- Handle edge cases where grid size or tick size limits tick placement.\n- Ensure output format is consistent and clear.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. If a tick can be formed, it will mark the cells as part of a tick. The solution will handle multiple test cases efficiently by processing each grid independently and outputting YES or NO based on the possibility of forming the grid with the given constraints.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each grid cell to see if it can be the center of a valid tick, considering the constraints of grid size and tick size. Edge cases include small grids and large k values where ticks may not fit.\nrequirement pool:\n- Implement the main logic to check for valid tick formations.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the output format is consistent and clear.\n- Handle edge cases such as small grids and large k values.\n- Maintain code readability and simplicity for future maintenance.\nWe will implement a function that iterates over each cell in the grid to determine if it can be the center of a valid tick of size at least k. The function will check the diagonals from each potential center to ensure they can form a valid tick. If any '*' cannot be part of a valid tick, the function will return 'NO' for that test case. We will use simple loops and condition checks to achieve this, ensuring the solution is efficient and handles edge cases like small grids and large k values.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each cell to see if it can be the center of a valid tick and ensure all '*' cells are covered by such ticks. Edge cases include small grids and large k values.\nrequirement pool:\n- Implement the main logic to check for valid tick formations.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution handles edge cases like small grids and large k values.\n- Maintain code readability and simplicity for future maintenance.\n- Provide detailed comments and documentation for the code.\nWe will iterate over each cell in the grid and check if it can be the center of a valid tick of size at least k. For each potential center, we will verify if the required cells in the diagonals are black ('*'). If a cell cannot be part of a valid tick, we will mark it as not possible. The solution will efficiently handle the constraints by ensuring each cell is checked only once.\n", "requirement analysis:\nThe problem requires evaluating whether a given grid can be formed by drawing ticks of a minimum size. The constraints are small, allowing for a direct simulation approach. Edge cases include small grids and minimum tick sizes that limit possible tick placements.\nrequirement pool:\n- Implement the main logic to evaluate tick placement.\n- Ensure the solution handles all edge cases.\n- Optimize the solution for efficiency.\n- Provide clear and consistent output.\n- Maintain code readability and simplicity.\nWe will implement a function to evaluate whether a given grid can be formed by drawing ticks of a minimum size. The approach will involve iterating over each cell in the grid and checking if it can be the center of a tick of size at least k. We will use simple loops and condition checks to simulate the tick drawing process. Given the constraints, this direct simulation approach will be efficient enough.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, considering the constraints on grid size and tick size. Edge cases include small grids and large k values where ticks may not fit.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution handles edge cases, such as small grids or large k values.\n- Provide clear and consistent output for each test case.\n- Maintain code readability and simplicity for future maintenance.\nWe will iterate over each test case and for each grid, we will attempt to identify if all '*' can be part of ticks of size at least k. We will use a helper function to check if a tick can be formed at a given position and mark the cells that are part of a valid tick. If any '*' cannot be part of a valid tick, we will return 'NO' for that test case.\n"], "scores": [], "pass_results": [false, false, false, false, true, true, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 2, "round": 254, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "condense_two2one", "parent_index": 99}
