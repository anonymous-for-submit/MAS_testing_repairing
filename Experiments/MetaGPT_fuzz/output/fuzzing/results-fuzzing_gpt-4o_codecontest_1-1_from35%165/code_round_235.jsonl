{"name": "1623_A. Robot Cleaner", "description": "A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of n rows and m columns. The rows of the floor are numbered from 1 to n from top to bottom, and columns of the floor are numbered from 1 to m from left to right. The cell on the intersection of the r-th row and the c-th column is denoted as (r,c). The initial position of the robot is (r_b, c_b).\n\nIn one second, the robot moves by dr rows and dc columns, that is, after one second, the robot moves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc = 1. If there is a vertical wall (the left or the right walls) in the movement direction, dc is reflected before the movement, so the new value of dc is -dc. And if there is a horizontal wall (the upper or lower walls), dr is reflected before the movement, so the new value of dr is -dr.\n\nEach second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at (r_d, c_d). The job of the robot is to clean that dirty cell.\n\n<image> Illustration for the first example. The blue arc is the robot. The red star is the target dirty cell. Each second the robot cleans a row and a column, denoted by yellow stripes.\n\nGiven the floor size n and m, the robot's initial position (r_b, c_b) and the dirty cell's position (r_d, c_d), find the time for the robot to do its job.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n", "tags": ["brute force", "implementation", "math"], "difficulty": 7, "id": 1623, "sample_io": [{"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}], "test_list": [{"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n15\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n9\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n9\n1\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 2\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n8\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n9\n9\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n9\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n8 8 5 8 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n1\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["3\n9\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n7\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n26\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n3\n0\n"]}, {"input": "5\n10 10 2 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 2\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["0\n10\n8\n3\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n9\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 5 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n10\n9\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 1 8\n2 1 1 1 2 1\n", "output": ["3\n9\n9\n6\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 3 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n6\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n7\n15\n3\n0\n"]}, {"input": "5\n10 10 6 2 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["6\n10\n9\n3\n1\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 1 1\n11 8 9 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["3\n10\n9\n3\n0\n"]}, {"input": "5\n25 10 5 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 3 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n2\n1\n"]}, {"input": "5\n14 10 5 1 4 8\n10 10 9 5 4 1\n17 11 5 6 2 1\n6 9 2 2 5 4\n2 2 1 1 2 1\n", "output": ["7\n7\n15\n2\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 8 7 6 2 1\n6 9 3 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 3 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 2 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n0\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 6 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 4 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n7\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n26\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 1 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n4\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 15 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n11\n1\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 3 8\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n1\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 2 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n11\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 2 8\n2 2 2 1 2 1\n", "output": ["7\n10\n9\n0\n0\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 9 2 1\n17 17 5 8 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n25\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n6 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n5\n1\n1\n"]}, {"input": "5\n25 10 2 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["0\n9\n15\n3\n1\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 13 7 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n19\n3\n0\n"]}, {"input": "5\n14 10 1 1 4 8\n10 10 9 5 4 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["3\n7\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 8 7 6 2 1\n6 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n1\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 2 6 2 1\n6 9 3 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n0\n2\n0\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n6\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 1 6 2 1\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n1\n3\n0\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["2\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n13\n15\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n29\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n9\n27\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 3 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n1\n0\n"]}, {"input": "5\n7 10 2 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["0\n9\n9\n4\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 5 6 2 1\n6 9 2 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n15\n3\n1\n"]}, {"input": "5\n8 10 5 1 2 8\n10 10 9 9 2 1\n17 16 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n25\n3\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 9 7 1 1\n6 9 2 2 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n8\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 7 5 4 1\n17 11 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n15\n1\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 9 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["7\n9\n0\n3\n1\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 10 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["2\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n13 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n14\n15\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n29\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 10 5 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n27\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 19 9 9 1 1\n25 8 5 1 1 1\n6 9 2 2 5 3\n2 1 1 1 2 1\n", "output": ["1\n10\n0\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n5 8 5 6 1 1\n6 9 2 2 3 8\n2 1 1 1 2 1\n", "output": ["1\n9\n4\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 6 2 1\n6 9 2 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n3\n1\n"]}, {"input": "5\n14 16 6 1 2 8\n15 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 3 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n26\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n6 8 5 6 2 2\n6 9 4 2 5 8\n2 2 1 1 1 2\n", "output": ["7\n10\n5\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n6\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n25 13 7 6 2 2\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n18\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n9\n1\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 1\n10 10 9 9 2 1\n17 9 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["0\n9\n0\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 4 1\n17 17 5 5 2 1\n6 15 2 2 5 8\n3 2 1 2 2 1\n", "output": ["7\n7\n27\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 1 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 6 2 1\n6 9 2 2 6 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n4\n1\n"]}, {"input": "5\n18 8 6 2 2 8\n10 10 6 9 1 1\n25 8 5 6 2 2\n6 9 2 2 5 8\n2 1 0 1 2 1\n", "output": ["6\n10\n8\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n3\n0\n"]}, {"input": "5\n18 10 1 3 2 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n7\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n25 8 5 6 1 1\n6 9 2 2 3 9\n2 1 1 1 0 1\n", "output": ["7\n9\n9\n1\n0\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n26\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n5 8 1 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n0\n1\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 2 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n1\n1\n3\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["0\n10\n9\n7\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 4 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n0\n1\n0\n"]}, {"input": "5\n18 10 2 3 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["5\n10\n9\n7\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 4 1 1 8\n2 2 1 2 2 2\n", "output": ["7\n9\n0\n7\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 9 2 1\n5 12 1 6 1 1\n6 8 4 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n10\n0\n5\n0\n"]}, {"input": "5\n7 10 1 2 1 8\n20 10 9 9 2 1\n5 12 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["0\n10\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n3\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 1\n5 21 1 12 1 1\n6 9 4 1 2 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 32 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n29\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 2 1\n17 11 5 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n14\n3\n1\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 9 3 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["4\n8\n9\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n8 8 5 8 2 1\n6 9 4 2 1 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n6\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 5 5 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n10\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 2\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n0\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n3\n1\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 5 9 2 1\n14 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n10\n9\n1\n0\n"]}, {"input": "5\n18 10 1 1 0 8\n10 10 9 9 1 1\n25 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n9\n4\n0\n"]}, {"input": "5\n14 10 6 1 2 5\n10 10 9 9 2 1\n17 17 5 3 3 1\n6 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["4\n9\n26\n3\n0\n"]}, {"input": "5\n23 10 6 2 2 8\n17 10 9 9 1 1\n25 8 5 4 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n11\n3\n0\n"]}, {"input": "5\n7 10 1 1 2 0\n10 10 9 9 2 1\n11 13 5 6 2 1\n6 9 2 2 5 8\n3 1 1 1 2 1\n", "output": ["1\n9\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n9 10 9 9 1 1\n25 8 7 6 2 1\n12 9 3 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n8\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 3 2 2 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n6\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 8 4 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n24\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 5 2 1\n6 9 2 2 2 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n0\n1\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 4 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n1\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 3 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n8\n26\n3\n1\n"]}, {"input": "5\n18 10 1 1 2 8\n11 19 9 9 1 1\n25 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n12\n9\n3\n0\n"]}, {"input": "5\n14 16 6 1 2 15\n10 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["14\n9\n26\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 1 12 2 1\n6 9 2 2 3 8\n2 2 1 2 2 2\n", "output": ["7\n9\n1\n1\n0\n"]}, {"input": "5\n7 10 1 1 2 0\n10 10 9 1 2 1\n11 8 5 6 2 1\n6 9 2 3 5 8\n3 1 1 1 2 1\n", "output": ["1\n0\n9\n3\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 0 2 8\n2 2 1 1 2 1\n", "output": ["6\n9\n9\n0\n0\n"]}, {"input": "5\n14 10 2 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["0\n9\n27\n6\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 6 8\n3 2 1 2 2 2\n", "output": ["7\n9\n0\n4\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 2 8\n2 2 1 2 2 2\n", "output": ["7\n13\n15\n0\n0\n"]}, {"input": "5\n18 17 11 1 2 7\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["6\n9\n27\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 10 9 5 1 2\n25 8 5 6 2 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n9\n0\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 2 6 2 1\n6 9 2 2 5 0\n2 2 1 1 2 1\n", "output": ["7\n7\n0\n3\n0\n"]}, {"input": "5\n23 10 6 2 3 8\n10 10 9 9 1 1\n25 8 5 5 2 1\n6 9 2 2 5 8\n2 1 1 1 0 1\n", "output": ["6\n10\n10\n3\n0\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 10 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["2\n9\n9\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 6 1 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n30\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 13 5 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n13\n27\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 2\n6 8 5 6 2 2\n6 9 4 2 5 8\n2 2 1 1 1 2\n", "output": ["7\n9\n5\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 3 1\n5 8 5 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n8\n4\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n6\n14\n3\n1\n"]}, {"input": "5\n25 10 3 1 2 8\n10 10 9 9 2 2\n17 11 1 6 2 1\n6 9 2 2 5 6\n2 2 1 2 2 1\n", "output": ["7\n9\n1\n3\n1\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 10 2 2\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n22\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 4 2 5 6\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n1\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 4 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n3\n1\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 7\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["6\n9\n0\n3\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n10 10 9 9 2 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["0\n9\n9\n7\n0\n"]}, {"input": "5\n18 36 11 1 2 11\n10 10 5 9 2 2\n17 17 3 6 2 2\n6 9 2 2 5 8\n5 2 1 2 2 2\n", "output": ["10\n9\n26\n3\n0\n"]}, {"input": "5\n7 13 1 1 1 8\n14 10 9 4 1 1\n11 8 9 7 1 1\n6 26 2 2 5 8\n2 1 2 1 2 1\n", "output": ["0\n15\n8\n3\n0\n"]}, {"input": "5\n18 10 2 6 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["2\n10\n9\n7\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 10 2 1\n5 12 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 3\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n1\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 2\n5 21 1 12 1 1\n6 9 4 2 2 5\n3 1 1 1 2 1\n", "output": ["0\n17\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 1 1\n17 11 5 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n10\n14\n3\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 5 5 1 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n10\n0\n0\n"]}, {"input": "5\n18 10 6 1 2 2\n10 10 9 9 1 1\n7 8 5 6 2 1\n6 9 2 2 5 8\n2 2 0 1 2 1\n", "output": ["1\n10\n7\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 6\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 2\n2 2 1 2 2 2\n", "output": ["5\n9\n21\n0\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 1 9 1 1\n25 8 3 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n0\n9\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 3\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n0\n3\n0\n"]}, {"input": "5\n18 10 0 1 0 8\n10 10 9 9 1 1\n25 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["0\n10\n9\n4\n0\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 2 2 1\n17 12 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 1 2\n", "output": ["7\n9\n17\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 1 1\n11 8 9 6 1 1\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["3\n10\n9\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 5\n10 10 9 9 2 1\n17 17 5 3 3 1\n6 9 1 2 5 8\n2 2 0 2 2 2\n", "output": ["4\n9\n26\n4\n0\n"]}, {"input": "5\n23 10 6 2 2 8\n17 10 9 9 1 1\n25 8 5 4 2 1\n6 9 2 2 5 4\n2 1 1 1 2 1\n", "output": ["6\n10\n11\n2\n0\n"]}, {"input": "5\n23 10 11 2 2 8\n17 10 2 9 1 1\n25 8 5 1 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 8 4 2 1\n6 9 2 2 5 8\n2 2 1 2 1 1\n", "output": ["7\n9\n24\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 3 5 2 1\n6 9 2 2 2 8\n2 2 1 2 2 1\n", "output": ["7\n9\n28\n0\n1\n"]}, {"input": "5\n14 10 6 1 2 6\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 4 2 5 8\n2 2 1 2 2 2\n", "output": ["5\n9\n27\n1\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 3 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n8\n27\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 2\n17 17 3 6 2 1\n6 9 2 1 5 2\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n1\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 6 5 6 1 2\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n4\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 6 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 1\n", "output": ["4\n9\n9\n3\n1\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 9 4 1\n17 17 3 6 2 1\n6 9 2 2 4 8\n3 2 1 2 2 2\n", "output": ["7\n7\n27\n2\n0\n"]}, {"input": "5\n7 10 1 1 2 8\n19 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 0 1 2 1\n", "output": ["1\n10\n9\n4\n0\n"]}, {"input": "5\n10 10 6 1 2 6\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 1 8\n2 2 2 1 2 1\n", "output": ["5\n10\n9\n6\n0\n"]}, {"input": "5\n14 10 3 1 4 8\n10 9 9 9 4 1\n17 19 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["1\n7\n27\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n12 10 9 9 1 1\n25 13 7 6 2 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n19\n0\n0\n"]}, {"input": "5\n25 10 3 1 2 8\n10 15 9 9 2 1\n17 11 5 6 2 1\n6 9 3 2 4 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n1\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 14 8 6 2 2\n10 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n20\n3\n0\n"]}, {"input": "5\n14 10 2 1 2 3\n10 10 9 9 1 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["0\n10\n27\n6\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 4 8\n3 2 1 2 2 2\n", "output": ["7\n9\n0\n2\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 10 2 1\n17 11 5 6 2 1\n6 9 2 2 2 8\n2 2 1 2 2 2\n", "output": ["7\n9\n15\n0\n0\n"]}, {"input": "5\n14 17 11 1 4 10\n10 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["9\n9\n29\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 19 9 9 1 1\n25 10 5 6 1 1\n6 9 2 2 5 5\n2 1 1 1 2 1\n", "output": ["1\n10\n13\n3\n0\n"]}, {"input": "5\n8 10 5 1 2 7\n10 10 9 9 2 1\n17 16 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 1 1\n", "output": ["6\n9\n25\n3\n0\n"]}, {"input": "5\n7 10 1 3 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 1 6\n2 1 0 1 2 1\n", "output": ["3\n9\n9\n4\n0\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n25 13 7 11 2 1\n6 9 2 2 5 8\n2 1 1 1 1 1\n", "output": ["1\n10\n14\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 8 2 1\n6 9 3 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n2\n1\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n19 13 7 6 2 2\n6 9 2 2 4 8\n2 1 1 1 2 1\n", "output": ["1\n10\n18\n2\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n19 10 9 9 1 1\n9 8 7 6 2 1\n6 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["0\n10\n9\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 3 1\n5 8 3 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n8\n6\n1\n0\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 10 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n23\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 3 2 5 6\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n2\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 4 1\n17 21 2 3 3 1\n5 9 2 2 3 8\n2 2 0 2 2 2\n", "output": ["7\n3\n1\n1\n0\n"]}, {"input": "5\n18 10 2 3 1 8\n10 10 9 9 2 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["5\n9\n9\n7\n0\n"]}, {"input": "5\n18 36 11 1 2 11\n10 10 5 9 2 2\n17 17 3 6 3 2\n6 9 2 2 5 8\n5 2 1 2 2 2\n", "output": ["10\n9\n0\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 9 2 2\n5 12 1 6 2 1\n6 8 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n1\n1\n0\n"]}, {"input": "5\n15 10 1 2 1 8\n19 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 3 2 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n2\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 3\n5 21 1 12 1 1\n6 9 4 2 2 5\n3 1 1 1 2 1\n", "output": ["0\n16\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 1 1\n17 11 5 6 2 2\n6 9 2 2 6 8\n2 2 1 2 2 1\n", "output": ["7\n10\n14\n4\n1\n"]}, {"input": "5\n10 10 6 1 1 8\n9 10 9 9 1 1\n7 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n8\n7\n3\n1\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}], "task_id": "codecontest/160", "prompt": "A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of n rows and m columns. The rows of the floor are numbered from 1 to n from top to bottom, and columns of the floor are numbered from 1 to m from left to right, and the cell on the intersection of the r-th row and the c-th column is denoted as (r,c). The initial position of the robot is (r_b, c_b).\n\nIn one second, the robot moves by dr rows and dc columns, that is, after one second, the robot moves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc = 1. If there is a vertical wall (the left or the right walls) in the movement direction, dc is reflected before the movement, so the new value of dc is -dc. And if there is a horizontal wall (the upper or lower walls), dr is reflected before the movement, so the new value of dr is -dr.\n\nEach second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at (r_d, c_d). The job of the robot is to clean that dirty cell.\n\n<image> Illustration for the first example. The blue arc is the robot. The red star is the target dirty cell. Each second the robot cleans a row and a column, denoted by yellow stripes.\n\nGiven the floor size n and m, the robot's initial position (r_b, c_b) and the dirty cell's position (r_d, c_d), find the time for the robot to do its job. Make sure to consider edge cases where the robot might start on or immediately adjacent to the dirty cell. The description should also account for scenarios where the robot reaches the boundaries and changes its direction due to reflection.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n", "repair_prompt": ["A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of n rows and m columns. The rows of the floor are numbered from 1 to n from top to bottom, and columns of the floor are numbered from 1 to m from left to right, and the cell on the intersection of the r-th row and the c-th column is denoted as (r,c). The initial position of the robot is (r_b, c_b).\n\nIn one second, the robot moves by dr rows and dc columns, that is, after one second, the robot moves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc = 1. If there is a vertical wall (the left or the right walls) in the movement direction, dc is reflected before the movement, so the new value of dc is -dc. And if there is a horizontal wall (the upper or lower walls), dr is reflected before the movement, so the new value of dr is -dr.\n\nEach second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at (r_d, c_d). The job of the robot is to clean that dirty cell.\n\n<image> Illustration for the first example. The blue arc is the robot. The red star is the target dirty cell. Each second the robot cleans a row and a column, denoted by yellow stripes.\n\nGiven the floor size n and m, the robot's initial position (r_b, c_b) and the dirty cell's position (r_d, c_d), find the time for the robot to do its job. Make sure to consider edge cases where the robot might start on or immediately adjacent to the dirty cell. The description should also account for scenarios where the robot reaches the boundaries and changes its direction due to reflection.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n"], "completions": ["from typing import List\n## main.py\n\ndef calculate_cleaning_time(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time taken for the robot to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken to clean the dirty cell.\n    \"\"\"\n    # If the robot starts on the dirty cell, it cleans immediately\n    if r_b == r_d and c_b == c_d:\n        return 0\n\n    # Calculate the time to reach the dirty cell\n    # The robot moves diagonally, so it will take the maximum of the row or column distance\n    row_distance = abs(r_d - r_b)\n    col_distance = abs(c_d - c_b)\n\n    # The time taken is the maximum of the row and column distance\n    return max(row_distance, col_distance)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = calculate_cleaning_time(n, m, r_b, c_b, r_d, c_d)\n        print(f\"Time to clean the dirty cell: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the minimum time for the robot to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Minimum time in seconds to clean the dirty cell.\n    \"\"\"\n    # Initial direction of the robot\n    dr, dc = 1, 1  # dr: row direction, dc: column direction\n\n    # Initialize time\n    time = 0\n\n    # Simulate the robot's movement\n    while r_b != r_d or c_b != c_d:\n        # Move the robot\n        if r_b == n and dr == 1:\n            dr = -1\n        elif r_b == 1 and dr == -1:\n            dr = 1\n\n        if c_b == m and dc == 1:\n            dc = -1\n        elif c_b == 1 and dc == -1:\n            dc = 1\n\n        r_b += dr\n        c_b += dc\n\n        # Increment time\n        time += 1\n\n    return time\n\n# Input interface\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n, m, r_b, c_b, r_d, c_d = map(int, data[i].split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n    for res in results:\n        print(res)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the minimum time for the robot to clean the dirty cell.\n\n    The robot moves diagonally and reflects off the walls. The function calculates\n    the time it takes for the robot to reach the dirty cell by checking if the robot's\n    current row or column matches the dirty cell's row or column.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Minimum time required for the robot to clean the dirty cell.\n    \"\"\"\n    # Calculate the time to reach the dirty cell in both row and column directions\n    time_row = abs(r_d - r_b)\n    time_col = abs(c_d - c_b)\n\n    # The robot moves diagonally, so the time to reach the dirty cell is the maximum\n    # of the time required to align either the row or the column\n    return max(time_row, time_col)\n\ndef main():\n    \"\"\"Main function to read input, process each test case, and output results.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n, m, r_b, c_b, r_d, c_d = map(int, data[i].split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the minimum time for the robot to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Minimum time required for the robot to reach the dirty cell.\n    \"\"\"\n    # If the robot starts on the dirty cell, no time is needed\n    if r_b == r_d and c_b == c_d:\n        return 0\n    \n    # Calculate the time based on the robot's initial position and the dirty cell's position\n    # considering the room's boundaries\n    time_row = abs(r_d - r_b)\n    time_col = abs(c_d - c_b)\n    \n    return time_row + time_col\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    data = sys.stdin.read().strip().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, data[index:index+6])\n        index += 6\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == '__main__':\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time taken for the robot to reach the dirty cell.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken for the robot to reach the dirty cell.\n    \"\"\"\n    # Initialize direction of movement\n    direction_row = 1  # 1 for down, -1 for up\n    direction_col = 1  # 1 for right, -1 for left\n\n    time = 0\n\n    while r_b != r_d or c_b != c_d:\n        # Move the robot\n        if r_b == n and direction_row == 1:\n            direction_row = -1\n        elif r_b == 1 and direction_row == -1:\n            direction_row = 1\n\n        if c_b == m and direction_col == 1:\n            direction_col = -1\n        elif c_b == 1 and direction_col == -1:\n            direction_col = 1\n\n        r_b += direction_row\n        c_b += direction_col\n        time += 1\n\n    return time\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Simulate the robot's movement in a bounded rectangular room to determine\n    the time it takes to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: The time it takes for the robot to clean the dirty cell.\n    \"\"\"\n    # Initialize direction of movement\n    dr, dc = 1, 1  # dr: row direction, dc: column direction\n    time = 0\n\n    while True:\n        # Check if the robot is on the dirty cell\n        if r_b == r_d or c_b == c_d:\n            return time\n\n        # Move the robot\n        r_b += dr\n        c_b += dc\n        time += 1\n\n        # Reflect off the walls if necessary\n        if r_b == 1 or r_b == n:\n            dr *= -1\n        if c_b == 1 or c_b == m:\n            dc *= -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time it takes for the robot to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time in seconds to clean the dirty cell.\n    \"\"\"\n    # Initial direction of the robot\n    dr, dc = 1, 1  # dr: row direction, dc: column direction\n\n    time = 0\n    while r_b != r_d and c_b != c_d:\n        # Move the robot\n        if r_b + dr > n or r_b + dr < 1:\n            dr *= -1  # Reflect off the horizontal wall\n        if c_b + dc > m or c_b + dc < 1:\n            dc *= -1  # Reflect off the vertical wall\n\n        r_b += dr\n        c_b += dc\n        time += 1\n\n    # If the robot is on the same row or column as the dirty cell\n    if r_b == r_d:\n        time += abs(c_d - c_b)\n    elif c_b == c_d:\n        time += abs(r_d - r_b)\n\n    return time\n\ndef main():\n    \"\"\"Main function to read input and output the result.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n, m, r_b, c_b, r_d, c_d = map(int, data[i].split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the minimum time for the robot to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        r_b (int): Starting row of the robot.\n        c_b (int): Starting column of the robot.\n        r_d (int): Row of the dirty cell.\n        c_d (int): Column of the dirty cell.\n\n    Returns:\n        int: Minimum time to clean the dirty cell.\n    \"\"\"\n    # If the robot starts on the same row or column as the dirty cell\n    if r_b == r_d or c_b == c_d:\n        return 0\n\n    # Calculate the time to reach the same row or column as the dirty cell\n    time_to_row = abs(r_d - r_b)\n    time_to_col = abs(c_d - c_b)\n\n    # The robot can move diagonally, so the minimum time is the maximum of the two\n    return max(time_to_row, time_to_col)\n\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n, m, r_b, c_b, r_d, c_d = map(int, data[i].split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time taken for the robot to clean a specific dirty cell.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken for the robot to clean the dirty cell.\n    \"\"\"\n    # Calculate the time taken to reach the dirty cell\n    # The robot moves diagonally, so it will take the maximum of the row and column differences\n    row_diff = abs(r_d - r_b)\n    col_diff = abs(c_d - c_b)\n    \n    # The robot cleans the entire row and column it occupies each second\n    # Therefore, the time taken is the maximum of the row and column differences\n    time_taken = max(row_diff, col_diff)\n    \n    return time_taken\n\ndef main():\n    \"\"\"Main function to handle multiple test cases.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        print(f\"Time to clean the dirty cell: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\ndef time_to_clean(t: int, test_cases: List[Tuple[int, int, int, int, int, int]]) -> List[int]:\n    \"\"\"Calculate the time taken for the robot to clean the dirty cell.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, int, int, int]]): Each test case contains:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            r_b (int): Initial row position of the robot.\n            c_b (int): Initial column position of the robot.\n            r_d (int): Row position of the dirty cell.\n            c_d (int): Column position of the dirty cell.\n\n    Returns:\n        List[int]: List of time taken for each test case to clean the dirty cell.\n    \"\"\"\n    results = []\n    for n, m, r_b, c_b, r_d, c_d in test_cases:\n        # If the robot is already at the dirty cell, no time is needed\n        if r_b == r_d and c_b == c_d:\n            results.append(0)\n            continue\n        \n        # Calculate time to reach the dirty cell\n        time = 0\n        row_direction = 1  # 1 for down, -1 for up\n        col_direction = 1  # 1 for right, -1 for left\n        \n        while True:\n            # Check if the robot is in the same row or column as the dirty cell\n            if r_b == r_d or c_b == c_d:\n                time += abs(r_b - r_d) + abs(c_b - c_d)\n                results.append(time)\n                break\n            \n            # Move the robot\n            if r_b == n - 1:\n                row_direction = -1\n            elif r_b == 0:\n                row_direction = 1\n            \n            if c_b == m - 1:\n                col_direction = -1\n            elif c_b == 0:\n                col_direction = 1\n            \n            r_b += row_direction\n            c_b += col_direction\n            time += 1\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input_data[index:index+6])\n        test_cases.append((n, m, r_b, c_b, r_d, c_d))\n        index += 6\n    \n    results = time_to_clean(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe robot must efficiently clean the dirty cell by moving in a predictable pattern, reflecting off walls when necessary. The solution should handle up to 10,000 test cases efficiently, ensuring that the robot's path is calculated correctly even when starting near or on the dirty cell.\nrequirement pool:\n- Implement the robot's movement and cleaning logic.\n- Handle boundary reflections accurately.\n- Optimize the solution for large input sizes.\n- Ensure the solution is robust against edge cases.\n- Provide detailed documentation and examples.\nWe will implement a function that simulates the robot's movement and cleaning process. The function will handle boundary reflections and calculate the time taken for the robot to clean the dirty cell. We will use simple arithmetic operations to determine the robot's path and reflections, ensuring efficiency for up to 10,000 test cases.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot must clean a specific dirty cell by moving in a pattern that reflects off walls. The solution must efficiently handle up to 10,000 test cases, considering edge cases where the robot starts on or near the dirty cell. The algorithm should be optimized for performance given the constraints on room size and number of test cases.\nrequirement pool:\n- Implement the robot movement and cleaning logic.\n- Optimize the solution for handling up to 10,000 test cases.\n- Ensure the robot correctly reflects off walls.\n- Handle edge cases where the robot starts on or near the dirty cell.\n- Provide detailed output for debugging and analysis.\nWe will simulate the robot's movement in the room, reflecting its direction when it hits a wall. The robot cleans the entire row and column it is in at each second. The key is to calculate the minimum time it takes for the robot to reach the dirty cell, considering its initial direction and the room's boundaries. We will use a simple simulation approach to track the robot's position and direction, updating them each second until the robot cleans the dirty cell. This approach is efficient given the constraints, as the room size is limited to 100x100 and the number of test cases is up to 10,000.\n", "requirement analysis:\nThe robot must efficiently clean the dirty cell by navigating the room and handling reflections at boundaries. The solution should be optimized for performance given the constraints of multiple test cases and room sizes.\nrequirement pool:\n- Implement robot movement logic with boundary reflection\n- Optimize cleaning algorithm for multiple test cases\n- Handle edge cases where robot starts on or adjacent to the dirty cell\n- Ensure solution scalability for large input sizes\n- Provide clear output format as specified\nWe will implement a function that simulates the robot's movement across the room, taking into account the reflections at the boundaries. The robot will move diagonally and reflect off walls, and we will calculate the time it takes for the robot to clean the dirty cell by checking if the robot's current row or column matches the dirty cell's row or column. The approach will be efficient enough to handle up to 10,000 test cases by directly calculating the minimum time required based on the robot's initial position and the dirty cell's position.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot must clean a specific dirty cell by moving in a pattern that reflects off walls. The solution must efficiently handle up to 10,000 test cases, each with room dimensions up to 100x100. The robot's movement and cleaning logic must be implemented to ensure it eventually cleans the target cell, considering all possible initial positions and directions.\nrequirement pool:\n- Implement the robot's movement and cleaning logic.\n- Optimize the solution for handling up to 10,000 test cases.\n- Ensure the robot correctly reflects off walls.\n- Handle edge cases where the robot starts on or near the dirty cell.\n- Provide clear and efficient input/output handling.\nWe will implement a simulation of the robot's movement in a bounded rectangular room using simple arithmetic operations to reflect the robot's direction when it encounters walls. The solution will efficiently handle multiple test cases by iterating through each test case and calculating the time taken for the robot to clean the dirty cell. The approach will focus on minimizing computational complexity by directly calculating the time based on the robot's initial position and the dirty cell's position, considering the room's boundaries.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot must clean a specific dirty cell by moving in a pattern that reflects off walls. The solution must efficiently handle up to 10,000 test cases, ensuring that the robot's movement and cleaning logic are correctly implemented. Edge cases, such as starting on the dirty cell or near walls, must be considered.\nrequirement pool:\n- Implement the robot's movement and cleaning logic.\n- Optimize the solution for handling up to 10,000 test cases.\n- Ensure accurate reflection logic when the robot hits walls.\n- Handle edge cases where the robot starts on or near the dirty cell.\n- Provide clear and efficient input/output handling.\nWe will simulate the robot's movement in the room using a simple loop to track its position and direction. The robot will start at its initial position and move according to the given rules, reflecting off walls when necessary. We will calculate the time taken for the robot to reach the dirty cell by checking if the robot's current row or column matches the dirty cell's row or column at each step. This approach ensures that we handle up to 10,000 test cases efficiently by simulating each test case independently.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot must clean a specific dirty cell by moving in a pattern that reflects off walls. The solution must efficiently handle up to 10,000 test cases, each with room dimensions up to 100x100. The robot's movement and cleaning logic must be implemented to ensure it eventually cleans the target cell, considering reflections at boundaries.\nrequirement pool:\n- Implement robot movement and cleaning logic\n- Handle boundary reflections correctly\n- Optimize performance for large number of test cases\n- Ensure solution is robust against edge cases\n- Provide clear and concise output for each test case\nWe will implement a simulation of the robot's movement in a bounded rectangular room. The robot will move in a pattern that reflects off walls, and we will track its position to determine when it cleans the dirty cell. The solution will efficiently handle up to 10,000 test cases by simulating the robot's movement and checking for the cleaning condition. We will use basic control structures and loops to simulate the movement and reflections.\n", "requirement analysis:\nThe requirements focus on ensuring the robot can clean a specific dirty cell efficiently while handling reflections from walls. The solution must be optimized for multiple test cases and consider edge cases where the robot starts near the dirty cell.\nrequirement pool:\n- Implement the main algorithm to calculate the time to clean the dirty cell.\n- Ensure the robot handles reflections from walls correctly.\n- Optimize the solution for large numbers of test cases.\n- Consider edge cases where the robot starts near the dirty cell.\n- Provide clear output format as specified.\nWe will implement a function that simulates the robot's movement and calculates the time it takes to clean the dirty cell. The robot moves in a straight line and reflects off walls, changing its direction when it hits a boundary. The function will iterate over each test case, updating the robot's position and direction until it cleans the dirty cell. The algorithm will be efficient enough to handle up to 10,000 test cases by using simple arithmetic operations to determine the time to reach the dirty cell.\n", "requirement analysis:\nThe robot cleaner must efficiently navigate a rectangular room, cleaning a specified dirty cell. It should handle reflections at boundaries and ensure that it eventually cleans the dirty cell. The solution must be optimized to handle up to 10,000 test cases efficiently.\nrequirement pool:\n- Implement the robot's movement and cleaning logic.\n- Handle boundary reflections correctly.\n- Optimize the solution for large input sizes.\n- Ensure the solution is robust against edge cases.\n- Provide detailed documentation and examples.\nWe will implement a function that simulates the robot's movement and cleaning process. The robot will move in a straight line, reflecting off walls when necessary. The function will calculate the time taken for the robot to clean the dirty cell by considering the minimum time it takes to reach the same row or column as the dirty cell. This approach ensures efficiency and handles up to 10,000 test cases effectively.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot moves diagonally and reflects off walls, cleaning the entire row and column it occupies each second. The task is to determine the time taken for the robot to clean a specific dirty cell. The solution must handle multiple test cases efficiently, considering the constraints on room size and number of test cases.\nrequirement pool:\n- Implement the robot's movement and cleaning logic.\n- Handle boundary reflections accurately.\n- Optimize the solution for large input sizes.\n- Ensure the solution is robust against edge cases.\n- Provide clear and concise output for each test case.\nWe will implement a function that simulates the robot's movement and cleaning process. The robot moves diagonally and reflects off walls, cleaning the entire row and column it occupies each second. The function will calculate the time taken for the robot to clean a specific dirty cell. We will use simple arithmetic to determine the time based on the robot's initial position, the dirty cell's position, and the room's dimensions. The solution will handle multiple test cases efficiently by iterating through each test case and applying the same logic.\n", "requirement analysis:\nThe robot cleaner must efficiently navigate the room, reflecting off walls as necessary, to clean the specified dirty cell. The algorithm should handle multiple test cases and edge scenarios, ensuring the robot cleans the cell in minimal time.\nrequirement pool:\n- Implement the main algorithm for robot movement and cleaning\n- Optimize the algorithm for handling multiple test cases efficiently\n- Ensure accurate reflection handling at boundaries\n- Develop robust edge case handling\n- Provide clear output format for test results\nWe will implement a function that simulates the robot's movement and cleaning process. The robot will move in a straight line, reflecting off walls when necessary, and clean the row and column it is on each second. The function will calculate the time taken for the robot to clean the dirty cell by simulating its movement and checking if the dirty cell is in the same row or column as the robot's current position. The algorithm will handle multiple test cases efficiently by iterating over each test case and applying the same logic.\n"], "scores": [], "pass_results": [false, false, false, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": false, "pass": false, "pass_num": 0, "round": 235, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n", "mutate_method": "condense_two2one", "parent_index": 103}
