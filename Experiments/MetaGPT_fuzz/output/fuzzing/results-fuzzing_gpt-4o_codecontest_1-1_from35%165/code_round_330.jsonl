{"name": "1613_C. Poisoned Dagger", "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the a_i-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "tags": ["binary search"], "difficulty": 9, "id": 1613, "sample_io": [{"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["3\n4\n1\n470\n"]}], "test_list": [{"input": "1\n2 1000000000000000000\n1 1000000000\n", "output": ["999999999000000001\n"]}, {"input": "1\n2 1000000000000000000\n1000000 1000000000\n", "output": ["999999999001000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n1 1000000000000000000\n1000000000\n", "output": ["1000000000000000000\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000000\n", "output": ["999999998999000001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000000\n", "output": ["999999999001000100\n"]}, {"input": "1\n1 1000000000000000000\n1010000000\n", "output": ["1000000000000000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 64 1337\n", "output": ["3\n4\n1\n469\n"]}, {"input": "1\n2 1000000000000000000\n2 1001000000\n", "output": ["999999998999000002\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000000000\n", "output": ["999999999001100100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000000\n", "output": ["999999999001101100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 16 1337\n", "output": ["3\n4\n1\n493\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000100\n", "output": ["999999999001101000\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n1\n1\n471\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000100\n", "output": ["999999998901101000\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100000100\n", "output": ["999999998901102000\n"]}, {"input": "1\n2 1000000000000101000\n1101100 1100000100\n", "output": ["999999998901202000\n"]}, {"input": "1\n2 1000000000000101000\n1001101 1100000100\n", "output": ["999999998901102001\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000000100\n", "output": ["999999999001000000\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n4\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010000\n", "output": ["999999999001090100\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1000000000\n", "output": ["999999999001201100\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1000000100\n", "output": ["999999999001100900\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1100000110\n", "output": ["999999998901100990\n"]}, {"input": "1\n2 1000000001000101000\n1001100 1100000100\n", "output": ["999999999901102000\n"]}, {"input": "1\n2 1000000000001101000\n1101100 1100000100\n", "output": ["999999998902202000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000100\n", "output": ["999999999101000000\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1000\n5 5 64 1337\n", "output": ["4\n4\n1\n471\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000110000\n", "output": ["999999999000990100\n"]}, {"input": "1\n2 1000000000000101001\n1100100 1000000000\n", "output": ["999999999001201101\n"]}, {"input": "1\n2 1000000000010101000\n1000100 1100000110\n", "output": ["999999998911100990\n"]}, {"input": "1\n2 1000000001000101000\n1000100 1100000100\n", "output": ["999999999901101000\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1000000101\n", "output": ["999999999100999999\n"]}, {"input": "1\n2 0000000000000100000\n1000100 1000110000\n", "output": ["50000\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1100000110\n", "output": ["999999998911099990\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001000101\n", "output": ["999999999099999999\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 25 95 1337\n", "output": ["3\n4\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000101\n", "output": ["999999999100099999\n"]}, {"input": "1\n2 0000000000000100010\n1000100 1001110000\n", "output": ["50005\n"]}, {"input": "1\n2 1000000000100000000\n1100100 1001000001\n", "output": ["999999999100100099\n"]}, {"input": "1\n2 0000000000000101010\n1000100 1001110000\n", "output": ["50505\n"]}, {"input": "1\n2 1000000000000000000\n1000010 1000000000\n", "output": ["999999999001000010\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n", "output": ["1\n4\n1\n470\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000000\n", "output": ["999999998999000011\n"]}, {"input": "1\n2 1000000000000000000\n1000110 1000000000\n", "output": ["999999999001000110\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 25 64 1337\n", "output": ["3\n5\n1\n471\n"]}, {"input": "1\n2 1000000000000000000\n1001100 1000000000\n", "output": ["999999999001001100\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000000000\n", "output": ["999999999000101100\n"]}, {"input": "1\n2 1000000000000101000\n1000100 1000000101\n", "output": ["999999999001100999\n"]}, {"input": "4\n2 5\n1 5\n3 3\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n10 25 64 1337\n", "output": ["3\n1\n1\n473\n"]}, {"input": "1\n2 1000000000000101000\n1000000 1100000100\n", "output": ["999999998901100900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1100000100\n", "output": ["999999998901102010\n"]}, {"input": "1\n2 1000000000000101000\n0101100 1100000100\n", "output": ["999999998900202000\n"]}, {"input": "1\n2 1000000000000101000\n1000101 1100000100\n", "output": ["999999998901101001\n"]}, {"input": "1\n2 1000000000010000000\n1000100 1000000100\n", "output": ["999999999011000000\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000010010\n", "output": ["999999999001090090\n"]}, {"input": "1\n2 1000000000100101000\n1100100 1000000000\n", "output": ["999999999101201100\n"]}, {"input": "1\n2 1000000001000101000\n1001101 1100000100\n", "output": ["999999999901102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000100\n", "output": ["999999998902102000\n"]}, {"input": "1\n2 1000000000100000000\n1000000 1000000100\n", "output": ["999999999100999900\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1000111000\n", "output": ["999999999000989100\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1100000110\n", "output": ["999999998911110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100000100\n", "output": ["999999999901100900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1000000101\n", "output": ["999999999110999999\n"]}, {"input": "1\n2 1000000000010100000\n1000100 1110000110\n", "output": ["999999998901099990\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000101\n", "output": ["999999999100100009\n"]}, {"input": "4\n2 9\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["5\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000001010\n1000100 1001110000\n", "output": ["505\n"]}, {"input": "1\n2 1000000000000000010\n1 1001000100\n", "output": ["999999998998999911\n"]}, {"input": "1\n2 1000000000000000000\n1010110 1000000000\n", "output": ["999999999001010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 64 1337\n", "output": ["3\n11\n1\n469\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100000100\n", "output": ["999999998901200900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101000100\n", "output": ["999999998900102010\n"]}, {"input": "1\n2 1000000000000101000\n0001100 1100000100\n", "output": ["999999998900102000\n"]}, {"input": "1\n2 1000000000010000000\n1000000 1000000100\n", "output": ["999999999010999900\n"]}, {"input": "1\n2 1000000000100101000\n1100000 1000000000\n", "output": ["999999999101201000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1100000100\n", "output": ["999999999900102001\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100100100\n", "output": ["999999998902002000\n"]}, {"input": "1\n2 1000000000100000000\n1010000 1000000100\n", "output": ["999999999101009900\n"]}, {"input": "1\n2 1000000000000000000\n1000100 1000111000\n", "output": ["999999999000889100\n"]}, {"input": "1\n2 1000000001000101001\n1000000 1100000100\n", "output": ["999999999901100901\n"]}, {"input": "1\n2 1000000000110000000\n1000110 1000000101\n", "output": ["999999999111000009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000110\n", "output": ["999999998901109990\n"]}, {"input": "4\n2 5\n1 5\n3 15\n1 4 20\n5 3\n1 2 4 6 7\n4 1000\n5 16 95 1337\n", "output": ["3\n6\n1\n455\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001000100\n", "output": ["999999999100100010\n"]}, {"input": "4\n2 13\n1 5\n3 11\n1 4 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 1337\n", "output": ["9\n4\n1\n455\n"]}, {"input": "1\n2 0000000000000000010\n1000100 1001110000\n", "output": ["5\n"]}, {"input": "1\n2 1000000000000000000\n1 1001000100\n", "output": ["999999998998999901\n"]}, {"input": "1\n2 1000000000000000000\n0010110 1000000000\n", "output": ["999999999000010110\n"]}, {"input": "4\n2 5\n1 5\n3 19\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 8 64 1337\n", "output": ["3\n11\n1\n470\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100000100\n", "output": ["999999998901200901\n"]}, {"input": "1\n2 1000000000000101000\n0001100 0100000100\n", "output": ["999999999900102000\n"]}, {"input": "1\n2 1000000000101101000\n1001100 1100100100\n", "output": ["999999999002002000\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000100\n", "output": ["999999999101010900\n"]}, {"input": "1\n2 1000000000000010000\n1000100 1000111000\n", "output": ["999999999000899100\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000100\n", "output": ["999999999901100902\n"]}, {"input": "1\n2 1000000000110000100\n1000110 1000000101\n", "output": ["999999999111000109\n"]}, {"input": "1\n2 0000010000000100010\n1000100 1000110100\n", "output": ["9999000990010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000100\n", "output": ["999999999101100010\n"]}, {"input": "1\n2 1000000000000000000\n1 1011000100\n", "output": ["999999998988999901\n"]}, {"input": "1\n2 1000000000000101000\n1100001 1100010100\n", "output": ["999999998901190901\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1101001100\n", "output": ["999999998901101010\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0100000100\n", "output": ["999999999900101000\n"]}, {"input": "4\n2 9\n1 5\n3 10\n1 4 10\n5 2\n1 2 4 6 20\n4 1000\n2 5 64 1337\n", "output": ["5\n4\n1\n469\n"]}, {"input": "1\n2 1000000000100000000\n1011000 1000000101\n", "output": ["999999999101010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1000111000\n", "output": ["999999999000909100\n"]}, {"input": "1\n2 1000000001000101001\n1001001 1100000100\n", "output": ["999999999901101902\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1100000100\n", "output": ["999999999001100010\n"]}, {"input": "1\n2 1000000000000101000\n1100001 0100010100\n", "output": ["999999999901190901\n"]}, {"input": "1\n2 1000000000000101000\n0000100 0110000100\n", "output": ["999999999890101000\n"]}, {"input": "1\n2 1000000000100000000\n0011000 1000000101\n", "output": ["999999999100010899\n"]}, {"input": "1\n2 1000000000000010000\n1010100 1001111000\n", "output": ["999999998999909100\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1101000100\n", "output": ["999999999000100010\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110000100\n", "output": ["999999999990101000\n"]}, {"input": "1\n2 1000000000000010000\n1010101 1001111000\n", "output": ["999999998999909101\n"]}, {"input": "1\n2 1000000000100101000\n0001100 0110000100\n", "output": ["999999999990102000\n"]}, {"input": "1\n2 1000000001000010000\n1010101 1001111000\n", "output": ["999999999999909101\n"]}, {"input": "1\n2 1000000000100111000\n0001100 0110000100\n", "output": ["999999999990112000\n"]}, {"input": "1\n2 1000000001000010000\n1011101 1001111000\n", "output": ["999999999999910101\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110000100\n", "output": ["999999999990112001\n"]}, {"input": "4\n2 5\n1 5\n3 19\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 5 64 1337\n", "output": ["3\n10\n1\n471\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n5 25 64 1337\n", "output": ["5\n4\n1\n471\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 14\n5 3\n0 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n4\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 5 5 1337\n", "output": ["3\n4\n1\n499\n"]}, {"input": "1\n2 1000000000000101000\n1001100 1100100100\n", "output": ["999999998901002000\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1100000100\n", "output": ["999999998901201000\n"]}, {"input": "1\n2 1000000000000101000\n0001101 1100000100\n", "output": ["999999998900102001\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000100\n", "output": ["999999999000000000\n"]}, {"input": "4\n2 5\n1 5\n3 4\n1 4 10\n5 3\n1 2 4 5 7\n4 1100\n5 25 64 1337\n", "output": ["3\n2\n1\n521\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010010000\n", "output": ["999999998991090100\n"]}, {"input": "1\n2 0000000000000101000\n1100100 1000000000\n", "output": ["50500\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 16 1337\n", "output": ["3\n4\n1\n494\n"]}, {"input": "1\n2 1000000000000101000\n1010000 1000000100\n", "output": ["999999999001110900\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1100000110\n", "output": ["999999998901100991\n"]}, {"input": "1\n2 1000000001000001000\n1001100 1100000100\n", "output": ["999999999901002000\n"]}, {"input": "1\n2 1000000000001101000\n1001100 1100000110\n", "output": ["999999998902101990\n"]}, {"input": "4\n2 8\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["4\n4\n1\n476\n"]}, {"input": "1\n2 1000000000000100010\n1000100 1000110000\n", "output": ["999999999000990110\n"]}, {"input": "1\n2 1000000000000101001\n1000100 1000000000\n", "output": ["999999999001101101\n"]}, {"input": "4\n2 5\n1 5\n3 2\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n2 9 16 1337\n", "output": ["3\n1\n1\n493\n"]}, {"input": "1\n2 1000000000100000000\n1000100 1001001101\n", "output": ["999999999099998999\n"]}, {"input": "1\n2 0000000001000100000\n1000100 1001110000\n", "output": ["500050000\n"]}, {"input": "1\n2 0010000000000100010\n1000100 1001110000\n", "output": ["9999998999990110\n"]}, {"input": "4\n2 1\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 124 1337\n", "output": ["1\n4\n1\n440\n"]}, {"input": "4\n2 5\n1 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1000\n9 25 64 1337\n", "output": ["3\n5\n1\n473\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 6\n5 3\n1 2 4 5 7\n4 1000\n5 5 8 1337\n", "output": ["3\n5\n1\n499\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n2 8 112 1337\n", "output": ["3\n4\n1\n445\n"]}, {"input": "1\n2 1000000000000101000\n0000100 1000001000\n", "output": ["999999999000100100\n"]}, {"input": "1\n2 1000000000000101000\n0111100 1100000100\n", "output": ["999999998900212000\n"]}, {"input": "1\n2 1000000000000101000\n1000111 1100000100\n", "output": ["999999998901101011\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1000000100\n", "output": ["999999999011000010\n"]}, {"input": "1\n2 1000000000000100000\n1000101 1000010010\n", "output": ["999999999001090091\n"]}, {"input": "1\n2 1000000001000101100\n1001101 1100000100\n", "output": ["999999999901102101\n"]}, {"input": "1\n2 1000000000100000000\n1001000 1000000100\n", "output": ["999999999101000900\n"]}, {"input": "1\n2 1000000000010101000\n1010100 1101000110\n", "output": ["999999998910110990\n"]}, {"input": "1\n2 1000000001000101000\n1000000 1100001100\n", "output": ["999999999901099900\n"]}, {"input": "1\n2 1000000000110000000\n1000100 1100000101\n", "output": ["999999999010999999\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1001100101\n", "output": ["999999999100000009\n"]}, {"input": "1\n2 0001000000000001010\n1000100 1001110000\n", "output": ["999998999891110\n"]}, {"input": "1\n2 1000000000000000010\n1 0001000100\n", "output": ["999999999998999911\n"]}, {"input": "1\n2 1000000000000000001\n1010110 1000000000\n", "output": ["999999999001010111\n"]}, {"input": "1\n2 1000000000000101000\n1101000 1100000100\n", "output": ["999999998901201900\n"]}, {"input": "1\n2 1000000000000101000\n1001110 1101001100\n", "output": ["999999998900101010\n"]}, {"input": "1\n2 1000000000100100000\n1100000 1000000000\n", "output": ["999999999101200000\n"]}, {"input": "1\n2 1000000001000101000\n0001101 1101000100\n", "output": ["999999999899102001\n"]}, {"input": "1\n2 1000000000001101001\n1001100 1100100100\n", "output": ["999999998902002001\n"]}, {"input": "1\n2 1000000001000101001\n1001000 1100000100\n", "output": ["999999999901101901\n"]}, {"input": "1\n2 1000000000110000000\n1001110 1000000101\n", "output": ["999999999111001009\n"]}, {"input": "1\n2 1000000000010100000\n1010100 1110000111\n", "output": ["999999998901109989\n"]}, {"input": "1\n2 1000000000000000010\n0010110 1000000000\n", "output": ["999999999000010120\n"]}, {"input": "1\n2 1000000001000101001\n1000001 1100000110\n", "output": ["999999999901100892\n"]}, {"input": "1\n2 0000010000000100010\n1100100 1000110100\n", "output": ["9999001090010\n"]}, {"input": "1\n2 1000000000100000000\n1100110 1000000101\n", "output": ["999999999101100009\n"]}, {"input": "1\n2 1000000000000101000\n1100000 1100010100\n", "output": ["999999998901190900\n"]}, {"input": "1\n2 1000000000001101000\n1001110 1001001100\n", "output": ["999999999001101010\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1010\n2 5 64 1337\n", "output": ["5\n4\n1\n474\n"]}, {"input": "1\n2 1000000001000101001\n1011001 1100000100\n", "output": ["999999999901111902\n"]}, {"input": "4\n2 1\n2 5\n3 10\n4 4 10\n5 3\n1 2 4 5 7\n4 1001\n3 24 64 668\n", "output": ["1\n5\n1\n470\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 2\n1 2 4 6 20\n4 1100\n2 5 64 1337\n", "output": ["5\n4\n1\n519\n"]}, {"input": "1\n2 1000000000100101000\n0000100 0110100100\n", "output": ["999999999990001000\n"]}, {"input": "1\n2 1000000000100101000\n0101100 0110000100\n", "output": ["999999999990202000\n"]}, {"input": "1\n2 1000000000100111000\n0001101 0110100100\n", "output": ["999999999990012001\n"]}, {"input": "4\n2 5\n1 5\n3 10\n1 4 10\n5 3\n1 2 4 5 7\n4 1000\n5 11 64 336\n", "output": ["3\n4\n1\n669\n"]}, {"input": "4\n2 9\n1 5\n3 10\n2 4 10\n5 3\n1 2 6 5 7\n4 1000\n4 25 64 1337\n", "output": ["5\n4\n1\n470\n"]}, {"input": "1\n2 1000000000010101001\n1000100 1100000100\n", "output": ["999999998911101001\n"]}, {"input": "1\n2 1000000000000101000\n1100100 1110000100\n", "output": ["999999998891201000\n"]}, {"input": "1\n2 1000000000000101000\n0001111 1100000100\n", "output": ["999999998900102011\n"]}, {"input": "1\n2 1000000000000000000\n0000100 1000000101\n", "output": ["999999998999999999\n"]}, {"input": "1\n2 1000000000000100000\n1000100 1010011000\n", "output": ["999999998991089100\n"]}, {"input": "1\n2 0100000000000101000\n1100100 1000000000\n", "output": ["99999999001201100\n"]}, {"input": "4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 4 4 5 7\n4 1000\n3 5 10 1337\n", "output": ["3\n4\n1\n497\n"]}, {"input": "1\n2 1000000000000101000\n0010000 1000000100\n", "output": ["999999999000110900\n"]}, {"input": "4\n2 8\n2 5\n3 10\n1 4 10\n5 3\n1 2 4 3 7\n4 1010\n5 5 64 1337\n", "output": ["5\n4\n1\n476\n"]}, {"input": "1\n2 1000000000100000000\n1010100 1001001101\n", "output": ["999999999100008999\n"]}, {"input": "1\n2 0010000010000100010\n1000100 1001110000\n", "output": ["10000008999990110\n"]}, {"input": "4\n2 5\n1 5\n3 11\n1 1 20\n5 3\n1 2 4 8 7\n4 1000\n5 25 95 517\n", "output": ["3\n6\n1\n488\n"]}, {"input": "4\n2 5\n1 5\n3 8\n1 4 10\n5 3\n2 2 4 5 7\n4 1000\n5 25 64 1467\n", "output": ["3\n3\n1\n471\n"]}, {"input": "1\n2 1000000000100101000\n0000100 1000001000\n", "output": ["999999999100100100\n"]}, {"input": "1\n2 1000000000010000000\n1000110 1001000100\n", "output": ["999999999010000010\n"]}, {"input": "1\n2 1000000000000110000\n1000101 1000010010\n", "output": ["999999999001100091\n"]}, {"input": "4\n2 4\n1 5\n3 3\n1 4 12\n5 3\n0 2 3 5 7\n4 1001\n5 25 64 1337\n", "output": ["2\n1\n1\n471\n"]}, {"input": "1\n2 1000000000001101000\n0011100 1100000100\n", "output": ["999999998901112000\n"]}, {"input": "1\n2 1000000000000000000\n1001000 1000000100\n", "output": ["999999999001000900\n"]}], "task_id": "codecontest/115", "prompt": "Monocarp is engaging in yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. Monocarp executes the i-th attack at the beginning of the a_i-th second from the start of the fight. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "repair_prompt": ["Monocarp is engaging in yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100^{500} seconds, during which Monocarp attacks the dragon with a poisoned dagger. Monocarp executes the i-th attack at the beginning of the a_i-th second from the start of the fight. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\n\nFor example, suppose k = 4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\n\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7]."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to deal at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): Each test case is a tuple containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration for each test case.\n    \"\"\"\n    def calculate_damage(attacks: List[int], k: int) -> int:\n        \"\"\"Calculate the total damage dealt with a given poison duration k.\n\n        Args:\n            attacks (List[int]): List of attack times.\n            k (int): Poison duration.\n\n        Returns:\n            int: Total damage dealt.\n        \"\"\"\n        total_damage = 0\n        n = len(attacks)\n        for i in range(n - 1):\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n        total_damage += k  # Add damage for the last attack\n        return total_damage\n\n    results = []\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, max(attacks) + h\n        while left < right:\n            mid = (left + right) // 2\n            if calculate_damage(attacks, mid) >= h:\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required total damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum poison durations for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Sort the attack times to facilitate binary search\n        attacks.sort()\n\n        # Initialize binary search bounds\n        low, high = 1, h\n\n        while low < high:\n            mid = (low + high) // 2\n            total_damage = 0\n\n            # Calculate total damage with current poison duration `mid`\n            for i in range(n):\n                if i == n - 1:\n                    total_damage += mid\n                else:\n                    total_damage += min(mid, attacks[i + 1] - attacks[i])\n\n            # Adjust binary search bounds based on total damage\n            if total_damage >= h:\n                high = mid\n            else:\n                low = mid + 1\n\n        results.append(low)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration for each test case to ensure the dragon receives at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Minimum required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: List of minimum poison durations for each test case.\n    \"\"\"\n    def calculate_damage(attacks: List[int], k: int) -> int:\n        \"\"\"Calculate the total damage inflicted with a given poison duration.\n\n        Args:\n            attacks (List[int]): List of attack times.\n            k (int): Duration of poison effect.\n\n        Returns:\n            int: Total damage inflicted.\n        \"\"\"\n        total_damage = 0\n        for i in range(len(attacks) - 1):\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n        total_damage += k  # Add damage for the last attack\n        return total_damage\n\n    results = []\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum poison duration\n        low, high = 1, max(attacks) + h\n        while low < high:\n            mid = (low + high) // 2\n            if calculate_damage(attacks, mid) >= h:\n                high = mid\n            else:\n                low = mid + 1\n        results.append(low)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    # Call the function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required total damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: A list of minimum poison durations for each test case.\n    \"\"\"\n    def calculate_damage(attacks: List[int], k: int) -> int:\n        \"\"\"Calculate the total damage inflicted with a given poison duration.\n\n        Args:\n            attacks (List[int]): List of attack times.\n            k (int): Duration of poison effect.\n\n        Returns:\n            int: Total damage inflicted.\n        \"\"\"\n        total_damage = 0\n        n = len(attacks)\n        for i in range(n - 1):\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n        total_damage += k  # Add damage for the last attack\n        return total_damage\n\n    results = []\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            if calculate_damage(attacks, mid) >= h:\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to deal at least 'h' damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to the dragon.\n            - attack_times (List[int]): List of attack times.\n\n    Returns:\n        List[int]: A list of minimum poison durations for each test case.\n    \"\"\"\n    def calculate_damage(attack_times: List[int], k: int) -> int:\n        \"\"\"Calculate the total damage dealt with a given poison duration 'k'.\n\n        Args:\n            attack_times (List[int]): List of attack times.\n            k (int): Poison duration.\n\n        Returns:\n            int: Total damage dealt.\n        \"\"\"\n        total_damage = 0\n        n = len(attack_times)\n        for i in range(n - 1):\n            total_damage += min(k, attack_times[i + 1] - attack_times[i])\n        total_damage += k  # Add damage for the last attack\n        return total_damage\n\n    results = []\n    for n, h, attack_times in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            if calculate_damage(attack_times, mid) >= h:\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attack_times = list(map(int, input().split()))\n        test_cases.append((n, h, attack_times))\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to ensure the dragon receives at least h damage.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Minimum required damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: A list of minimum poison durations for each test case.\n    \"\"\"\n    results = []\n    \n    for n, h, attacks in test_cases:\n        # Sort the attack times\n        attacks.sort()\n        \n        # Binary search for the minimum poison duration\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            if can_achieve_damage(n, h, attacks, mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        results.append(left)\n    \n    return results\n\ndef can_achieve_damage(n: int, h: int, attacks: List[int], k: int) -> bool:\n    \"\"\"Check if a given poison duration can achieve the required damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Minimum required damage.\n        attacks (List[int]): List of attack times.\n        k (int): Poison duration to test.\n\n    Returns:\n        bool: True if the poison duration can achieve the required damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n    \n    for i in range(n):\n        if i == n - 1:\n            total_damage += k\n        else:\n            total_damage += min(k, attacks[i + 1] - attacks[i])\n        \n        if total_damage >= h:\n            return True\n    \n    return total_damage >= h\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    \n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): Each test case contains:\n            - n (int): Number of attacks.\n            - h (int): Required damage to the dragon.\n            - a (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attack_times in test_cases:\n        # Sort attack times to ensure they are in order\n        attack_times.sort()\n\n        # Binary search for the minimum poison duration k\n        left, right = 1, h  # k must be at least 1 and at most h\n        while left < right:\n            mid = (left + right) // 2\n            if can_deal_damage(n, h, attack_times, mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\ndef can_deal_damage(n: int, h: int, attack_times: List[int], k: int) -> bool:\n    \"\"\"Check if a given poison duration k can deal at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage to the dragon.\n        attack_times (List[int]): List of attack times.\n        k (int): Poison duration to test.\n\n    Returns:\n        bool: True if the poison duration k can deal at least h damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n\n    for i in range(n):\n        if i == n - 1:\n            total_damage += k\n        else:\n            total_damage += min(k, attack_times[i + 1] - attack_times[i])\n\n    return total_damage >= h\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        a = list(map(int, input().split()))\n        test_cases.append((n, h, a))\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport sys\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration required to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: A list of minimum poison durations for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Sort the attack times\n        attacks.sort()\n\n        # Binary search for the minimum poison duration k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            total_damage = 0\n\n            # Calculate total damage with current poison duration mid\n            for i in range(n - 1):\n                total_damage += min(mid, attacks[i + 1] - attacks[i])\n            total_damage += mid  # Add damage for the last attack\n\n            if total_damage >= h:\n                right = mid\n            else:\n                left = mid + 1\n\n        results.append(left)\n\n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    input_data = sys.stdin.read().split()\n    \n    # Parse input\n    t = int(input_data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input_data[index])\n        h = int(input_data[index + 1])\n        index += 2\n        attacks = list(map(int, input_data[index:index + n]))\n        index += n\n        test_cases.append((n, h, attacks))\n    \n    # Call function and print results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef minimum_poison_duration(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum poison duration k for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): Each test case contains:\n            - n (int): Number of attacks.\n            - h (int): Required total damage.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: Minimum poison duration k for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum k\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            if is_sufficient_damage(mid, n, h, attacks):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef is_sufficient_damage(k: int, n: int, h: int, attacks: List[int]) -> bool:\n    \"\"\"Check if the poison duration k results in at least h total damage.\n\n    Args:\n        k (int): Poison duration to test.\n        n (int): Number of attacks.\n        h (int): Required total damage.\n        attacks (List[int]): List of attack times.\n\n    Returns:\n        bool: True if the total damage is at least h, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        h = int(data[index + 1])\n        index += 2\n        attacks = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, h, attacks))\n\n    # Output results\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef minimum_poison_duration(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Determine the minimum poison duration required to deal at least h damage to the dragon.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of attacks.\n            - h (int): Required damage to the dragon.\n            - attacks (List[int]): List of attack times.\n\n    Returns:\n        List[int]: A list of minimum poison durations for each test case.\n    \"\"\"\n    results = []\n\n    for n, h, attacks in test_cases:\n        # Binary search for the minimum poison duration k\n        left, right = 1, h  # Start with the range [1, h]\n        while left < right:\n            mid = (left + right) // 2\n            if can_deal_damage(n, h, attacks, mid):\n                right = mid\n            else:\n                left = mid + 1\n        results.append(left)\n\n    return results\n\ndef can_deal_damage(n: int, h: int, attacks: List[int], k: int) -> bool:\n    \"\"\"Check if a given poison duration k can deal at least h damage.\n\n    Args:\n        n (int): Number of attacks.\n        h (int): Required damage to the dragon.\n        attacks (List[int]): List of attack times.\n        k (int): Poison duration to test.\n\n    Returns:\n        bool: True if the poison duration k can deal at least h damage, False otherwise.\n    \"\"\"\n    total_damage = 0\n    for i in range(n - 1):\n        total_damage += min(k, attacks[i + 1] - attacks[i])\n    total_damage += k  # Add damage for the last attack\n\n    return total_damage >= h\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, h = map(int, input().split())\n        attacks = list(map(int, input().split()))\n        test_cases.append((n, h, attacks))\n    results = minimum_poison_duration(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining the minimum duration of a poison effect (k) that will ensure the dragon receives at least h damage. The challenge is to efficiently calculate the damage over time given the constraints of attack timings and the poison effect's duration. The solution must handle multiple test cases and large input sizes, ensuring optimal performance.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k.\n- Ensure the solution handles up to 1000 test cases efficiently.\n- Optimize the algorithm for large values of h and a_i.\n- Provide clear and concise output for each test case.\n- Consider edge cases where attacks are closely spaced.\nWe will use a binary search approach to efficiently determine the minimum value of k. The key observation is that the damage dealt by the poison effect is cumulative and can be calculated by iterating over the attack times. By using binary search, we can efficiently find the smallest k that results in at least h damage. This approach ensures that we handle up to 1000 test cases and large input sizes effectively.\n", "requirement analysis:\nThe problem requires calculating the minimum duration of poison effect (k) needed to deal at least h damage to the dragon. The challenge is to efficiently compute this for multiple test cases, considering the constraints on attack times and damage requirements.\nrequirement pool:\n- Implement the main algorithm to calculate minimum k for each test case.\n- Ensure the solution handles large input sizes efficiently.\n- Optimize the algorithm for performance.\n- Validate input and output formats strictly.\n- Consider edge cases such as minimum and maximum values for inputs.\nWe will implement a binary search algorithm to efficiently determine the minimum value of k for each test case. The binary search will be used to find the smallest k such that the total damage dealt is at least h. This approach is efficient given the constraints, as it reduces the problem to a logarithmic number of checks, each of which can be computed in linear time relative to the number of attacks.\n", "requirement analysis:\nThe main challenge is to determine the minimum duration of the poison effect (k) that will ensure the dragon receives at least h damage. The solution must efficiently handle large input sizes and provide clear feedback to the player about the damage dealt and the effectiveness of their attacks.\nrequirement pool:\n- Implement the core algorithm to calculate the minimum k for each test case\n- Optimize the algorithm for performance with large input sizes\n- Ensure the game provides clear feedback on damage dealt\n- Design a responsive UI for both desktop and mobile\n- Include detailed instructions and game mechanics explanation\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) that ensures the dragon receives at least h damage. This approach is chosen because it allows us to handle large input sizes effectively, as binary search reduces the time complexity to O(n log(max_time)), where max_time is the maximum possible time difference between attacks.\n", "requirement analysis:\nThe game requires a balance between strategic planning and real-time decision making. The poison effect duration (k) is crucial for determining the minimum damage needed to defeat the dragon. The solution should efficiently compute the minimum k for various test cases, ensuring performance optimization for large input sizes.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k\n- Design intuitive UI for displaying attack and health status\n- Optimize performance for handling large numbers and computations\n- Ensure cross-platform compatibility\n- Provide real-time feedback on game progress\nWe will implement a binary search algorithm to efficiently determine the minimum value of k. The key challenge is to calculate the total damage inflicted by the poison over time, considering the overlapping poison effects. We will use binary search on k to find the smallest k that results in at least h damage. This approach is efficient and suitable for handling large input sizes.\n", "requirement analysis:\nThe game requires a balance between strategic depth and performance. The poison effect mechanics should be intuitive, and the game should handle large numbers efficiently. The user interface should provide clear feedback on the dragon's health and the impact of each attack.\nrequirement pool:\n- Implement the core game mechanics for poison effect and damage calculation.\n- Optimize the game for handling large-scale battles efficiently.\n- Develop a user-friendly interface that provides real-time feedback.\n- Allow players to choose different poison strengths.\n- Include a tutorial to help players understand the game mechanics.\nWe will implement a function to determine the minimum poison duration 'k' required to deal at least 'h' damage to the dragon. The function will iterate over the attack times and calculate the total damage dealt for different values of 'k'. We will use binary search to efficiently find the minimum 'k' that satisfies the condition. This approach ensures that the solution is optimized for performance, even with large input sizes.\n", "requirement analysis:\nThe main challenge is to determine the minimum duration of the poison effect (k) that ensures the dragon receives at least h damage. The solution must efficiently handle large numbers and multiple test cases, providing accurate results quickly.\nrequirement pool:\n- Implement the core algorithm to calculate minimum k\n- Optimize the algorithm for performance with large inputs\n- Design a user-friendly input/output interface\n- Provide detailed feedback on damage calculation\n- Ensure the solution is scalable for future enhancements\nWe will implement a binary search algorithm to efficiently determine the minimum duration of the poison effect (k) that ensures the dragon receives at least h damage. This approach is chosen because it allows us to handle large input sizes effectively, leveraging the sorted nature of attack times to minimize the search space.\n", "requirement analysis:\nThe game requires a strategic approach to determine the minimum poison duration needed to defeat the dragon. The challenge lies in calculating the optimal k value that ensures the dragon's health is reduced to zero or below within the given constraints. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement the core game logic to calculate the minimum poison duration.\n- Ensure the solution handles large numbers and multiple test cases efficiently.\n- Provide real-time feedback on the dragon's health during the game.\n- Allow players to choose different poison strengths for strategic variety.\n- Optimize the game's performance for large-scale battles.\nWe will implement a function to determine the minimum poison duration (k) required to deal at least h damage to the dragon. The function will iterate over the attack times and calculate the total damage for different values of k using a binary search approach to optimize performance. This approach efficiently handles large input sizes and multiple test cases.\n", "requirement analysis:\nThe game requires a strategic approach to determine the minimum poison duration needed to defeat the dragon. The challenge lies in calculating the optimal k value for various attack sequences and dragon health points. The solution should efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement the core game logic to calculate minimum k.\n- Develop a user interface that displays attack sequences and dragon health.\n- Create a tutorial to help players understand game mechanics.\n- Add difficulty levels to cater to different player skills.\n- Implement a scoring system to track player performance.\nWe will implement a function to calculate the minimum poison duration (k) required to deal at least h damage to the dragon. The function will iterate over the attack times and calculate the total damage based on the poison duration. We will use binary search to efficiently find the minimum k value, as it allows us to handle large input sizes effectively. The solution will be implemented in a single Python file, using standard input and output for handling multiple test cases.\n", "requirement analysis:\nThe requirement is to determine the minimum duration of the poison effect (k) such that the total damage dealt to the dragon is at least h. The challenge is to efficiently calculate this for multiple test cases, considering the constraints on the number of attacks and the large possible value of h.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum k for each test case.\n- Ensure the solution handles large values of h efficiently.\n- Optimize the algorithm for performance given the constraints.\n- Provide clear and concise output for each test case.\n- Consider edge cases such as minimum and maximum values of n and h.\nWe will use a binary search approach to efficiently determine the minimum k for each test case. The idea is to simulate the damage dealt by the poison effect and adjust k until the total damage is at least h. Given the constraints, binary search is suitable for finding the minimum k due to its logarithmic time complexity.\n", "requirement analysis:\nThe game requires a strategic approach to determine the minimum poison duration needed to defeat the dragon. The algorithm must efficiently calculate the damage dealt over time, considering the reapplication of poison effects. The solution should handle large input sizes and provide accurate results for each test case.\nrequirement pool:\n- Implement the main algorithm to calculate minimum poison duration.\n- Ensure the solution handles large input sizes efficiently.\n- Develop a user-friendly interface to display attack and damage information.\n- Optimize the game for performance and responsiveness.\n- Include visual elements to represent the dragon's health and attack impact.\nWe will implement a function to determine the minimum poison duration (k) required to deal at least h damage to the dragon. The function will iterate over the attack times and calculate the total damage based on the poison duration. We will use a binary search approach to efficiently find the minimum k, as it allows us to handle large input sizes effectively. The solution will be implemented in Python, leveraging its built-in capabilities for handling large integers.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 10, "round": 330, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\n\nThe first line of the test case contains two integers n and h (1 \u2264 n \u2264 100; 1 \u2264 h \u2264 10^{18}) \u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9; a_i < a_{i + 1}), where a_i is the second when the i-th attack is performed.\n\nOutput\n\nFor each test case, print a single integer \u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\n\nExample\n\nInput\n\n\n4\n2 5\n1 5\n3 10\n2 4 10\n5 3\n1 2 4 5 7\n4 1000\n3 25 64 1337\n\n\nOutput\n\n\n3\n4\n1\n470\n\nNote\n\nIn the first example, for k=3, damage is dealt in seconds [1, 2, 3, 5, 6, 7].\n\nIn the second example, for k=4, damage is dealt in seconds [2, 3, 4, 5, 6, 7, 10, 11, 12, 13].\n\nIn the third example, for k=1, damage is dealt in seconds [1, 2, 4, 5, 7].", "mutate_method": "rephrase_one", "parent_index": 20}
