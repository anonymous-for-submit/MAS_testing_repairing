{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other, and the people of Baltia want to organize a successful party with very strict rules on what a party is and when it is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with. Alternatively, no two people at the party are friends with each other, so that everyone can just be on their phones without anyone else bothering them. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Consider edge cases where the number of people or friendship pairs may be minimal or maximal.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other, and the people of Baltia want to organize a successful party with very strict rules on what a party is and when it is successful. On the island of Baltia, a party is a gathering of exactly 5 people and is considered successful if either all the people at the party are friends with each other, meaning they can all talk to each other without having to worry about talking to someone they are not friends with. Alternatively, no two people at the party are friends with each other, so that everyone can just be on their phones without anyone else bothering them. Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Consider edge cases where the number of people or friendship pairs may be minimal or maximal.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in the given graph.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Try to find a clique or independent set of size 5\n    from itertools import combinations\n\n    for nodes in combinations(range(1, n + 1), 5):\n        if is_clique(nodes) or is_independent_set(nodes):\n            return list(nodes)\n\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a clique of size 5 or an independent set of size 5 in the given friendship graph.\n\n    Args:\n        n (int): Number of people (nodes in the graph).\n        m (int): Number of friendships (edges in the graph).\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or an independent set, or -1 if not found.\n    \"\"\"\n    # Initialize adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    \n    # Populate the adjacency list with friendships\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n    \n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n    \n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n    \n    # Try to find a clique of size 5\n    for node in range(1, n + 1):\n        neighbors = list(adjacency_list[node])\n        if len(neighbors) >= 4:\n            for i in range(len(neighbors)):\n                for j in range(i + 1, len(neighbors)):\n                    for k in range(j + 1, len(neighbors)):\n                        for l in range(k + 1, len(neighbors)):\n                            potential_clique = [node, neighbors[i], neighbors[j], neighbors[k], neighbors[l]]\n                            if is_clique(potential_clique):\n                                return potential_clique\n    \n    # Try to find an independent set of size 5\n    for node in range(1, n + 1):\n        potential_independent_set = [node]\n        for other_node in range(1, n + 1):\n            if other_node != node and other_node not in adjacency_list[node]:\n                potential_independent_set.append(other_node)\n                if len(potential_independent_set) == 5:\n                    if is_independent_set(potential_independent_set):\n                        return potential_independent_set\n    \n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Union\n\ndef find_successful_party(n: int, m: int, friendships: List[tuple]) -> Union[List[int], int]:\n    \"\"\"Finds a clique or independent set of size 5 in a graph of friendships.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[tuple]): A list of tuples representing friendships.\n\n    Returns:\n        Union[List[int], int]: A list of 5 people forming a clique or independent set, or -1 if neither is found.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # If no clique of size 5 is found, check for independent sets of size 5\n    # by analyzing the complement graph\n    complement_graph = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Output interface\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\nfrom typing import List, Tuple\nimport networkx as nx\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of size 5.\n\n    Args:\n        N (int): Number of people.\n        M (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set is a set of nodes with no edges between them\n    # We can find independent sets by checking complement graph for cliques\n    complement_graph = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party configuration is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n    result = find_successful_party(N, M, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in the given graph.\n\n    Args:\n        n (int): Number of nodes in the graph.\n        m (int): Number of edges in the graph.\n        friendships (List[Tuple[int, int]]): List of edges representing friendships.\n\n    Returns:\n        List[int]: A list of 5 node indices forming a clique or independent set, or -1 if not found.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = [[] for _ in range(n + 1)]\n    for u, v in friendships:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    def bron_kerbosch(clique: List[int], candidates: List[int], excluded: List[int]) -> List[int]:\n        \"\"\"Bron-Kerbosch algorithm to find cliques.\"\"\"\n        if len(clique) == 5:\n            return clique\n        if not candidates and not excluded:\n            return []\n        \n        for node in candidates[:]:\n            new_clique = clique + [node]\n            new_candidates = [n for n in candidates if n in adjacency_list[node]]\n            new_excluded = [n for n in excluded if n in adjacency_list[node]]\n            result = bron_kerbosch(new_clique, new_candidates, new_excluded)\n            if result:\n                return result\n            candidates.remove(node)\n            excluded.append(node)\n        return []\n\n    def find_clique_of_size_5() -> List[int]:\n        \"\"\"Find a clique of size 5 using Bron-Kerbosch algorithm.\"\"\"\n        candidates = list(range(1, n + 1))\n        return bron_kerbosch([], candidates, [])\n\n    def find_independent_set_of_size_5() -> List[int]:\n        \"\"\"Find an independent set of size 5 using a greedy approach.\"\"\"\n        independent_set = []\n        for node in range(1, n + 1):\n            if all(node not in adjacency_list[other] for other in independent_set):\n                independent_set.append(node)\n            if len(independent_set) == 5:\n                return independent_set\n        return []\n\n    # Attempt to find a clique of size 5\n    clique = find_clique_of_size_5()\n    if clique:\n        return clique\n\n    # Attempt to find an independent set of size 5\n    independent_set = find_independent_set_of_size_5()\n    if independent_set:\n        return independent_set\n\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output interface\nresult = find_successful_party(n, m, friendships)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration either as a clique or an independent set of size 5.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Initialize adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    \n    # Populate the adjacency list with friendships\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n    \n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n    \n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n    \n    # Try to find a clique of size 5\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for o in range(l + 1, n + 1):\n                        if is_clique([i, j, k, l, o]):\n                            return [i, j, k, l, o]\n    \n    # Try to find an independent set of size 5\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for o in range(l + 1, n + 1):\n                        if is_independent_set([i, j, k, l, o]):\n                            return [i, j, k, l, o]\n    \n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Call the function to find the successful party configuration\n    result = find_successful_party(n, m, friendships)\n    \n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a group of 5 people who are either all friends or no friends at all.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if such a group exists, otherwise -1.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Helper function to check if a set of nodes form a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes form an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Check all combinations of 5 people\n    from itertools import combinations\n\n    for group in combinations(range(1, n + 1), 5):\n        if is_clique(group) or is_independent_set(group):\n            return list(group)\n\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in a graph.\n\n    Args:\n        n (int): Number of people (nodes).\n        m (int): Number of friendships (edges).\n        friendships (List[Tuple[int, int]]): List of friendships represented as tuples of node pairs.\n\n    Returns:\n        List[int]: A list of 5 people forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Try to find a clique or independent set of size 5\n    from itertools import combinations\n\n    for nodes in combinations(range(1, n + 1), 5):\n        if is_clique(nodes) or is_independent_set(nodes):\n            return list(nodes)\n\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique of size 5 or an independent set of size 5 in a graph.\n\n    Args:\n        n (int): Number of people (nodes).\n        m (int): Number of friendships (edges).\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not found.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check for a clique of size 5\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check for an independent set of size 5\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Check for a clique of size 5\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for o in range(l + 1, n + 1):\n                        if is_clique([i, j, k, l, o]):\n                            return [i, j, k, l, o]\n\n    # Check for an independent set of size 5\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for o in range(l + 1, n + 1):\n                        if is_independent_set([i, j, k, l, o]):\n                            return [i, j, k, l, o]\n\n    # If neither is found, return -1\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in the given friendship graph.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Try to find a clique of size 5\n    def find_clique_or_independent_set() -> List[int]:\n        from itertools import combinations\n\n        # Check all combinations of 5 nodes\n        for nodes in combinations(range(1, n + 1), 5):\n            if is_clique(nodes) or is_independent_set(nodes):\n                return list(nodes)\n        return -1\n\n    # Find and return the result\n    result = find_clique_or_independent_set()\n    return result\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M.\nrequirement pool:\n- Efficiently determine if a successful party can be organized with given constraints.\n- Handle edge cases where the number of people or friendships is minimal or maximal.\n- Provide clear and concise output as per the requirements.\n- Ensure the solution is scalable for large inputs.\n- Optimize for performance and memory usage.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (where everyone knows each other) or an independent set of size 5 (where no one knows each other) in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these subsets using combinatorial techniques and graph traversal methods.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships, which can be computationally intensive given the constraints. Efficient graph traversal and analysis techniques are necessary to solve this problem within the given limits.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles edge cases, such as minimal and maximal input sizes.\n- Optimize the solution for performance with large datasets.\n- Provide clear and formatted output as specified in the requirements.\n- Consider multiple successful configurations if they exist.\nWe will use graph theory to solve this problem. The problem can be represented as a graph where nodes are people and edges are friendships. We need to find a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these subgraphs using efficient graph traversal techniques.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all mutual friends or have no friendships among them. This involves graph theory concepts such as cliques and independent sets. The solution must efficiently handle up to 200,000 people and friendships, suggesting the need for optimized graph traversal and analysis techniques.\nrequirement pool:\n- Develop an efficient algorithm to find a successful party configuration.\n- Ensure the solution handles edge cases with minimal and maximal inputs.\n- Optimize the solution for performance with large datasets.\n- Provide clear and formatted output as specified.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory concepts to solve this problem. Specifically, we will utilize the NetworkX library to efficiently manage and analyze the graph of friendships. The solution involves checking for cliques of size 5 and independent sets of size 5 within the graph. NetworkX provides functions to find cliques and can be used to check for independent sets by analyzing the complement graph.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships, which can be efficiently managed using graph theory concepts like cliques and independent sets.\nrequirement pool:\n- Implement an efficient algorithm to find a successful party of 5 people.\n- Ensure the solution handles edge cases with minimal or maximal friendships.\n- Optimize the algorithm to run within time limits for large inputs.\n- Provide clear documentation and comments within the code.\n- Include test cases to validate the solution against various scenarios.\nWe will use graph theory concepts to solve this problem efficiently. Specifically, we will utilize the NetworkX library to represent the friendships as a graph and check for cliques and independent sets of size 5. NetworkX provides efficient methods to find cliques, which are subsets of nodes where every node is connected to every other node, and independent sets, where no nodes are connected.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves graph theory concepts, specifically clique detection and independent set detection. The constraints on N and M suggest the need for efficient algorithms that can handle large graphs.\nrequirement pool:\n- Implement an efficient algorithm to check for a clique of size 5.\n- Implement an efficient algorithm to check for an independent set of size 5.\n- Optimize the solution to handle edge cases with minimal and maximal input sizes.\n- Ensure the solution adheres to the input and output format strictly.\n- Provide multiple solutions if more than one successful party configuration is possible.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and check for two conditions: a clique of size 5 (where every pair of the 5 people are friends) and an independent set of size 5 (where no two of the 5 people are friends). Given the constraints, we need an efficient approach to handle up to 200,000 nodes and edges. We will use adjacency lists to represent the graph and employ combinatorial techniques to check for the required conditions.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party.\n- Ensure the solution handles edge cases with minimal and maximal inputs.\n- Optimize the solution for time complexity given the constraints.\n- Provide clear and concise output as per the problem statement.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to model the friendships as an undirected graph. The problem can be solved by checking for cliques of size 5 (where all are friends) or independent sets of size 5 (where none are friends). We will use adjacency lists to represent the graph and employ efficient algorithms to find these subgraphs.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M.\nrequirement pool:\n- Efficiently check all combinations of 5 people for the party conditions.\n- Handle edge cases where N or M are at their minimum or maximum values.\n- Optimize the solution to run within time limits for large inputs.\n- Ensure the solution is robust and handles all possible input scenarios.\n- Provide clear and concise output as per the problem statement.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (all friends) or an independent set of size 5 (no friends) in the graph. We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these specific subgraphs using combinatorial techniques and graph traversal methods.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M. The solution must handle large inputs and edge cases effectively.\nrequirement pool:\n- Develop an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles the maximum constraints of N and M.\n- Optimize the algorithm for performance to handle edge cases.\n- Provide clear and concise output as per the problem statement.\n- Consider multiple successful party configurations if possible.\nWe will use a graph-based approach to solve this problem. The problem can be represented as a graph where each person is a node and each friendship is an edge. We need to find a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will use a combination of depth-first search (DFS) and combinatorial checks to find the required group of people.\n", "requirement analysis:\nThe problem requires determining if a group of 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles edge cases with minimal and maximal inputs.\n- Optimize the solution for performance with large datasets.\n- Provide clear and concise output as per the problem statement.\n- Consider multiple successful configurations if they exist.\nWe will use graph theory to solve this problem. The problem can be represented as a graph where nodes are people and edges are friendships. We need to find a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). We will use adjacency lists to represent the graph and check for these conditions efficiently. Given the constraints, we will focus on optimizing the search for these subgraphs using efficient graph traversal techniques.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M. The solution must handle edge cases where the number of people or friendships is at its minimum or maximum.\nrequirement pool:\n- Efficiently determine if a successful party can be organized.\n- Ensure the solution handles up to 200,000 people and friendships.\n- Provide output in the specified format.\n- Consider edge cases with minimal or maximal inputs.\n- Optimize for performance and memory usage.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by representing the friendships as an undirected graph where nodes represent people and edges represent friendships. We need to find either a complete subgraph (clique) of size 5 or an independent set of size 5. We will use adjacency lists to represent the graph and check combinations of nodes to find the required subgraph. Given the constraints, we will optimize the search using efficient graph traversal techniques.\n"], "scores": [], "pass_results": [false, true, true, true, false, true, false, false, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 190, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "expand_one2two", "parent_index": 122}
