{"name": "1591_C. Minimize Distance", "description": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "tags": ["greedy", "math"], "difficulty": 9, "id": 1591, "sample_io": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}], "test_list": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["30\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 1 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["21\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n41\n7\n3000010100\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["13\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n7\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n12\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n51\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n44\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 9 3\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n10\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n37\n7\n3000000000\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["13\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n45\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["27\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010000000\n", "output": ["16\n44\n8\n3010000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["25\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n46\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 4 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1010000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3010000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n39\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n11\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 4 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["29\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["16\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 4\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n6\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n34\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 5 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["31\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 8 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["20\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n40\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 3 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 7\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["27\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 4 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 4 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 1\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n7000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n1 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n23\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n48\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 1 3 4 3\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 0 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 9 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n48\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["18\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 0\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["30\n41\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 6 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -23 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n49\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 4\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 16 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["38\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000001 1000000000\n", "output": ["25\n44\n9\n3000000001\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 3 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n-1 2 3 4 5\n9 3\n-5 -10 -15 9 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 10 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n28\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 0\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["18\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 5\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 1 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["14\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 3 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n49\n7\n3000010100\n"]}, {"input": "4\n5 2\n2 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["15\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n2 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["31\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 0000000000 1000110000\n", "output": ["30\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n1 2 3 2 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["17\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 0 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n19\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n4 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n43\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 6\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 14 8 3 7 0\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 0 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n42\n10\n3000000001\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1001000000 1000010000\n", "output": ["13\n39\n8\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -9 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n32\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 5\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1000010000\n", "output": ["25\n63\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1001000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3001000000\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["30\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 4 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1010010000\n", "output": ["25\n57\n27\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 8 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["32\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 6 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["26\n40\n27\n3000010000\n"]}, {"input": "4\n5 2\n1 2 4 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["15\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 8 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n12\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 2\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n15\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 6\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["26\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1010110000\n", "output": ["30\n43\n13\n3010110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 8\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n43\n9\n7000100000\n"]}, {"input": "4\n5 1\n1 2 3 7 2\n9 3\n-14 -18 -13 6 5 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000100000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000100000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 1 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n44\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 4\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n1001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -6 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n35\n8\n3010100000\n"]}, {"input": "4\n5 2\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["7\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n73\n8\n3000010100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -18 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1000010000\n", "output": ["25\n57\n32\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -26 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n54\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["18\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -14 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n11\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["13\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 1 8 3 7 4\n5 4\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n37\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n1 0 3 5 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n19\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n32\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000100001 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000100001\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-7 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n139\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n0 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["28\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -6 -15 10 5 8 4 0 0\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n35\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 0\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -20 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["25\n140\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000000100\n", "output": ["30\n40\n8\n3000000100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-2 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n129\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000111000\n", "output": ["27\n43\n13\n1000111000\n"]}, {"input": "4\n5 2\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["11\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -4 -15 10 3 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 1\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 5 4\n5 3\n2 2 5 3 3\n4 2\n1000001000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000001000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 3 8 0 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["20\n41\n10\n3000010000\n"]}], "task_id": "codecontest/47", "prompt": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Assume that all depots are distinct and have unique x-coordinates.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "repair_prompt": ["A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Assume that all depots are distinct and have unique x-coordinates.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver goods to depots on a number line.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = sorted([d for d in depots if d > 0])\n        negative_depots = sorted([-d for d in depots if d < 0])\n\n        def calculate_distance(depots: List[int], k: int) -> int:\n            \"\"\"Calculate the round-trip distance for depots in one direction.\"\"\"\n            distance = 0\n            while depots:\n                # Take the farthest depot in the current group\n                farthest = depots[-1]\n                # Calculate round-trip distance for this group\n                distance += 2 * farthest\n                # Remove depots that can be delivered in one trip\n                depots = depots[:-k]\n            return distance\n\n        # Calculate total minimum distance\n        total_distance = calculate_distance(positive_depots, k) + calculate_distance(negative_depots, k)\n\n        # Consider the last trip which doesn't need to return\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[-1], negative_depots[-1])\n        elif positive_depots:\n            total_distance -= positive_depots[-1]\n        elif negative_depots:\n            total_distance -= negative_depots[-1]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of depots that can be visited in one trip.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum travel distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate positive and negative depot positions\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n\n        # Calculate the total distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Subtract the farthest depot as it doesn't need to be returned to the origin\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    for _ in range(t):\n        n, k = int(data[index]), int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n\n    # Output interface\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be delivered in one trip.\n            - x (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k, x in test_cases:\n        # Sort the depot positions\n        x.sort()\n        \n        # Separate depots into positive and negative positions\n        positive = [pos for pos in x if pos > 0]\n        negative = [-pos for pos in x if pos < 0]\n        \n        # Sort negative positions in descending order to handle them like positive\n        negative.sort()\n        \n        # Calculate the minimum distance\n        min_distance = 0\n        \n        # Handle positive positions\n        while positive:\n            # Take the farthest k depots\n            min_distance += 2 * positive[-1]\n            positive = positive[:-k]\n        \n        # Handle negative positions\n        while negative:\n            # Take the farthest k depots\n            min_distance += 2 * negative[-1]\n            negative = negative[:-k]\n        \n        # Subtract the farthest single trip (either positive or negative)\n        if x:\n            min_distance -= max(x[-1], -x[0])\n        \n        results.append(min_distance)\n    \n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    for _ in range(t):\n        n, k = int(data[index]), int(data[index + 1])\n        index += 2\n        x = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, x))\n    \n    # Output interface\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver goods to depots on a number line.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of depots that can be delivered in one trip.\n            - depots (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Sort depot positions\n        depots.sort()\n\n        # Separate depots into positive and negative positions\n        positive_depots = [d for d in depots if d > 0]\n        negative_depots = [-d for d in depots if d < 0]\n\n        # Calculate minimum distance for positive and negative depots\n        def calculate_distance(depots: List[int], k: int) -> int:\n            distance = 0\n            # Process depots in groups of k, starting from the farthest\n            for i in range(len(depots) - 1, -1, -k):\n                distance += 2 * depots[i]  # Round trip distance\n            return distance\n\n        # Total minimum distance is the sum of distances for positive and negative depots\n        total_distance = calculate_distance(positive_depots, k) + calculate_distance(negative_depots, k)\n\n        # Consider the farthest depot only once (either positive or negative)\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[-1], negative_depots[-1])\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of depots that can be visited in one trip.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative coordinates\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Deliver to positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n        \n        # Deliver to negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n        \n        # Subtract the farthest trip as it doesn't require a return\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n        \n        results.append(total_distance)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef calculate_minimum_distance(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver goods to depots on a number line.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of positions of depots on the number line.\n\n    Returns:\n        List[int]: A list of integers representing the minimum distance for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Sort the depot positions\n        depots.sort()\n\n        # Separate depots into positive and negative positions\n        positive_depots = [d for d in depots if d > 0]\n        negative_depots = [-d for d in depots if d < 0]\n\n        # Sort negative depots in descending order to handle them like positive\n        negative_depots.sort()\n\n        # Calculate the total distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(len(positive_depots) - 1, -1, -k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(len(negative_depots) - 1, -1, -k):\n            total_distance += 2 * negative_depots[i]\n\n        # Reduce the distance by the farthest depot, as it doesn't need to be returned\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[-1], negative_depots[-1])\n        elif positive_depots:\n            total_distance -= positive_depots[-1]\n        elif negative_depots:\n            total_distance -= negative_depots[-1]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input().strip())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().strip().split())\n        depots = list(map(int, input().strip().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver all bags to the depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k, depots in test_cases:\n        # Separate positive and negative depot positions\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n        \n        # Calculate the total distance for positive and negative depots\n        total_distance = 0\n        \n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n        \n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n        \n        # If there are both positive and negative depots, subtract the farthest one\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n        \n        results.append(total_distance)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver goods to all depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of depots that can be visited in one trip.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate positive and negative depot positions\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n\n        # Calculate the total distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # If there are both positive and negative depots, subtract the farthest one\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output the results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n\n    # Output results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum batch size.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum travel distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n\n        # Calculate the total distance for positive depots\n        total_distance = 0\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Calculate the total distance for negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # If there are depots on both sides, subtract the farthest one trip\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n\n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver all bags to the depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be delivered in one trip.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n\n        # Calculate the total distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # If there are both positive and negative depots, we can save one trip\n        # by not returning to the origin after the farthest trip\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to calculate the minimum distance needed to deliver goods to depots on a number line. The salesman can carry a limited number of bags at a time, and the solution must be efficient enough to handle up to 200,000 depots across multiple test cases. The solution should consider both positive and negative coordinates and ensure the minimum distance is calculated accurately.\nrequirement pool:\n- Implement the main algorithm to calculate minimum distance.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution handles both positive and negative coordinates.\n- Test the solution against edge cases for accuracy.\n- Provide detailed documentation for the algorithm.\nWe will implement a function to calculate the minimum distance required to deliver goods to depots on a number line. The approach involves sorting the depot positions, dividing them into groups based on the maximum number of bags that can be carried at once, and calculating the round-trip distance for each group. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle large input sizes. The solution will consider both positive and negative coordinates and ensure the minimum distance is calculated accurately.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle large inputs and provide accurate results for multiple test cases.\nrequirement pool:\n- Implement an algorithm to calculate the minimum travel distance.\n- Ensure the solution handles up to 200,000 depots efficiently.\n- Optimize the algorithm for speed and accuracy.\n- Test the solution against a variety of test cases for reliability.\n- Provide a user-friendly interface for input and output.\nWe will implement an algorithm that sorts the depot positions and calculates the minimum travel distance by grouping the depots into batches of size k. The algorithm will handle both positive and negative depot positions separately to optimize the travel distance. We will use Python's built-in sorting and list manipulation capabilities to efficiently manage the depot positions.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle large input sizes and multiple test cases.\nrequirement pool:\n- Implement an efficient algorithm to calculate minimum travel distance.\n- Optimize the solution for handling up to 2 \u22c5 10^5 depots.\n- Ensure the solution is robust and handles edge cases.\n- Provide clear and concise output for each test case.\n- Document the code for maintainability and readability.\nWe will implement a solution that efficiently calculates the minimum travel distance using a greedy approach. The key idea is to sort the depot positions and deliver goods in batches of up to k bags, minimizing the number of trips to the farthest depots. We will use Python's built-in sorting and list manipulation capabilities to handle large input sizes effectively.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots located on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and provide accurate results for both positive and negative depot positions.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum delivery distance.\n- Optimize the solution for handling up to 200,000 depots efficiently.\n- Ensure the solution handles both positive and negative depot positions.\n- Provide clear and concise output for each test case.\n- Include error handling for invalid inputs.\nWe will implement a function to calculate the minimum distance required to deliver goods to depots on a number line. The function will handle multiple test cases efficiently, considering both positive and negative depot positions. We will use sorting to group depots and calculate the distance for each group of deliveries. The solution will be optimized to handle up to 200,000 depots by leveraging efficient data structures and algorithms.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line. The constraints involve handling up to 10,500 test cases and ensuring the solution is efficient for large input sizes. The key challenge is optimizing the delivery route to minimize travel distance while considering the carrying capacity.\nrequirement pool:\n- Implement an algorithm to calculate the minimum travel distance.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Consider edge cases such as depots with the same position.\n- Provide detailed output for each test case.\nWe will implement a function to calculate the minimum travel distance using a greedy approach. The key idea is to separate depots into positive and negative coordinates, sort them, and then deliver goods in batches of size k. This approach ensures that we minimize the number of trips by always delivering to the farthest depots first in each direction. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle the input size constraints.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle up to 10,500 test cases with a total of 200,000 depots across all cases.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum distance.\n- Optimize the algorithm for large input sizes.\n- Ensure the solution is scalable and efficient.\n- Provide clear and correct output for each test case.\n- Consider edge cases and validate input constraints.\nWe will implement a function to calculate the minimum distance required to deliver goods to depots on a number line. The approach involves sorting the depot positions, dividing them into groups based on the maximum number of bags that can be carried at once, and calculating the total distance by considering the farthest depot in each group. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle large input sizes.\n", "requirement analysis:\nThe requirement is to calculate the minimum distance for delivering goods to depots located on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement efficient algorithm for minimum distance calculation\n- Ensure solution handles up to 10,500 test cases\n- Optimize for large input sizes up to 2 \u22c5 10^5 depots\n- Provide clear and concise output format\n- Maintain code readability and modularity\nWe will implement an efficient algorithm to calculate the minimum distance required to deliver all bags to the depots. The approach involves sorting the depot positions and grouping them based on the maximum number of bags that can be carried at once. We will handle both positive and negative depot positions separately to ensure optimal route calculation. The algorithm will iterate over the sorted positions, calculate the distance for each group, and sum these distances to get the total minimum distance. We will use Python's built-in sorting and list manipulation capabilities to achieve this efficiently.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle multiple test cases and large input sizes.\nrequirement pool:\n- Implement an algorithm to calculate the minimum travel distance.\n- Optimize the solution for handling up to 2 \u22c5 10^5 depots.\n- Ensure the solution can process multiple test cases efficiently.\n- Consider edge cases such as depots with the same position.\n- Provide clear and concise output for each test case.\nWe will implement an algorithm that sorts the depot positions and calculates the minimum distance by grouping the depots into batches of size k. The algorithm will handle both positive and negative depot positions separately to ensure optimal travel distance. We will use Python's built-in sorting and list manipulation capabilities to efficiently manage the input size constraints.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle large input sizes and multiple test cases.\nrequirement pool:\n- Implement an algorithm to calculate the minimum travel distance.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Provide clear input and output handling.\n- Consider edge cases such as depots at the same location.\nWe will implement an algorithm that calculates the minimum travel distance by considering the depots on both sides of the origin separately. The depots will be sorted, and the salesman will deliver goods in batches of size up to k, starting from the farthest depot and moving towards the origin. This approach ensures that the travel distance is minimized by reducing unnecessary trips. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle large input sizes.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots located on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and provide the correct minimum distance for each test case.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum distance.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases, such as all depots at the same location.\n- Provide clear documentation and comments in the code.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to calculate the minimum distance required to deliver all bags to the depots. The approach involves sorting the depot positions, dividing them into positive and negative coordinates, and then calculating the distance for each segment based on the maximum distance we can cover in one trip (up to k bags). We will use Python's built-in sorting and list manipulation capabilities to efficiently handle the input size constraints.\n"], "scores": [], "pass_results": [true, true, true, true, true, true, true, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 9, "round": 260, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "mutate_method": "add_1_sentence_at_end", "parent_index": 8}
