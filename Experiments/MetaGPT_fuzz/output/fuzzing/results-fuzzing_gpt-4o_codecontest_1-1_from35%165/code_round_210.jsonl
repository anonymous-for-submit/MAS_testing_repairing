{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, there are N inhabitants, labeled from 1 to N. There are exactly M pairs of people who are friends with one another. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of precisely 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other. This means they can all talk to each other, without having to worry about talking to someone they are not friends with. Or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Consider all possible combinations to ensure the success criteria are met.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, there are N inhabitants, labeled from 1 to N. There are exactly M pairs of people who are friends with one another. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of precisely 5 individuals. The party is considered to be successful if either all the people at the party are friends with each other. This means they can all talk to each other, without having to worry about talking to someone they are not friends with. Or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Consider all possible combinations to ensure the success criteria are met.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people either forming a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency matrix for the graph\n    adjacency_matrix = [[False] * n for _ in range(n)]\n    \n    for u, v in friendships:\n        adjacency_matrix[u-1][v-1] = True\n        adjacency_matrix[v-1][u-1] = True\n\n    # Check all combinations of 5 people\n    for combination in combinations(range(n), 5):\n        if is_clique(combination, adjacency_matrix) or is_independent_set(combination, adjacency_matrix):\n            return [person + 1 for person in combination]\n    \n    return -1\n\ndef is_clique(nodes: Tuple[int], adjacency_matrix: List[List[bool]]) -> bool:\n    \"\"\"Checks if the given nodes form a clique.\n\n    Args:\n        nodes (Tuple[int]): Nodes to check.\n        adjacency_matrix (List[List[bool]]): Adjacency matrix of the graph.\n\n    Returns:\n        bool: True if nodes form a clique, False otherwise.\n    \"\"\"\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            if not adjacency_matrix[nodes[i]][nodes[j]]:\n                return False\n    return True\n\ndef is_independent_set(nodes: Tuple[int], adjacency_matrix: List[List[bool]]) -> bool:\n    \"\"\"Checks if the given nodes form an independent set.\n\n    Args:\n        nodes (Tuple[int]): Nodes to check.\n        adjacency_matrix (List[List[bool]]): Adjacency matrix of the graph.\n\n    Returns:\n        bool: True if nodes form an independent set, False otherwise.\n    \"\"\"\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            if adjacency_matrix[nodes[i]][nodes[j]]:\n                return False\n    return True\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in the given graph.\n\n    Args:\n        n (int): Number of inhabitants.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not found.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # Return -1 if neither a clique nor an independent set of size 5 is found\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a clique or independent set of size 5 in the friendship graph.\n\n    Args:\n        n (int): Number of inhabitants.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not found.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    # An independent set can be found by checking complement graph for cliques\n    complement_G = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_G))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\nfrom typing import List, Tuple, Union\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> Union[List[int], int]:\n    \"\"\"Finds a successful party configuration of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        Union[List[int], int]: List of 5 node indices if a successful party configuration is found, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Iterate over all combinations of 5 nodes\n    for combination in combinations(graph.nodes, 5):\n        subgraph = graph.subgraph(combination)\n        \n        # Check if the subgraph is a clique\n        if nx.is_clique(subgraph):\n            return list(combination)\n        \n        # Check if the subgraph is an independent set\n        if nx.is_independent_set(subgraph):\n            return list(combination)\n\n    # Return -1 if no valid combination is found\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of inhabitants.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people if a successful party is found, otherwise -1.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    # An independent set in a graph G is a clique in the complement of G\n    complement_G = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_G))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in the given graph.\n\n    Args:\n        n (int): Number of people (nodes).\n        m (int): Number of friendships (edges).\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not found.\n    \"\"\"\n    # Create a graph using networkx\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for nodes in itertools.combinations(graph.nodes, 5):\n        subgraph = graph.subgraph(nodes)\n        if nx.is_clique(subgraph):\n            return list(nodes)\n\n    # Check for an independent set of size 5\n    complement_graph = nx.complement(graph)\n    for nodes in itertools.combinations(complement_graph.nodes, 5):\n        subgraph = complement_graph.subgraph(nodes)\n        if nx.is_clique(subgraph):\n            return list(nodes)\n\n    # If neither a clique nor an independent set of size 5 is found\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of friendship pairs.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party configuration is found, otherwise -1.\n    \"\"\"\n    # Create an adjacency matrix to represent the graph\n    graph = [[False] * n for _ in range(n)]\n    \n    # Fill the adjacency matrix with the given friendships\n    for u, v in friendships:\n        graph[u-1][v-1] = True\n        graph[v-1][u-1] = True\n\n    # Check all combinations of 5 people\n    for comb in combinations(range(n), 5):\n        if is_clique(graph, comb) or is_independent_set(graph, comb):\n            return [x + 1 for x in comb]  # Convert to 1-based index\n\n    return -1\n\ndef is_clique(graph: List[List[bool]], nodes: Tuple[int, int, int, int, int]) -> bool:\n    \"\"\"Checks if the given nodes form a clique.\n\n    Args:\n        graph (List[List[bool]]): The adjacency matrix of the graph.\n        nodes (Tuple[int, int, int, int, int]): A tuple of 5 nodes.\n\n    Returns:\n        bool: True if the nodes form a clique, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if not graph[nodes[i]][nodes[j]]:\n                return False\n    return True\n\ndef is_independent_set(graph: List[List[bool]], nodes: Tuple[int, int, int, int, int]) -> bool:\n    \"\"\"Checks if the given nodes form an independent set.\n\n    Args:\n        graph (List[List[bool]]): The adjacency matrix of the graph.\n        nodes (Tuple[int, int, int, int, int]): A tuple of 5 nodes.\n\n    Returns:\n        bool: True if the nodes form an independent set, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if graph[nodes[i]][nodes[j]]:\n                return False\n    return True\n\nif __name__ == \"__main__\":\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people based on friendships.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party can be formed, otherwise -1.\n    \"\"\"\n    # Create a graph from the friendships\n    graph = nx.Graph()\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return list(clique)\n\n    # Check for independent sets of size 5\n    # Since NetworkX does not provide a direct method for finding independent sets of a specific size,\n    # we will use a heuristic approach by checking combinations of nodes.\n    nodes = list(graph.nodes)\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            for k in range(j + 1, len(nodes)):\n                for l in range(k + 1, len(nodes)):\n                    for o in range(l + 1, len(nodes)):\n                        subset = [nodes[i], nodes[j], nodes[k], nodes[l], nodes[o]]\n                        if is_independent_set(graph, subset):\n                            return subset\n\n    return -1\n\ndef is_independent_set(graph: nx.Graph, nodes: List[int]) -> bool:\n    \"\"\"Checks if a given set of nodes forms an independent set in the graph.\n\n    Args:\n        graph (nx.Graph): The graph.\n        nodes (List[int]): The list of nodes to check.\n\n    Returns:\n        bool: True if the nodes form an independent set, False otherwise.\n    \"\"\"\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            if graph.has_edge(nodes[i], nodes[j]):\n                return False\n    return True\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\n\ndef find_successful_party() -> None:\n    \"\"\"Finds a group of 5 people who either all know each other (clique) or none know each other (independent set).\n\n    Reads input from standard input, which includes:\n    - n: the number of people\n    - m: the number of friendships\n    - m pairs of integers representing friendships\n\n    Outputs:\n    - 5 integers representing the people in a successful party, or -1 if no such group exists.\n    \"\"\"\n    # Read the number of people and friendships\n    n, m = map(int, input().split())\n    \n    # Read the list of friendships\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n    \n    # Iterate over all combinations of 5 people\n    for combo in combinations(range(1, n + 1), 5):\n        subgraph = G.subgraph(combo)\n        \n        # Check if the subgraph is a clique or an independent set\n        if subgraph.number_of_edges() == 10 or subgraph.number_of_edges() == 0:\n            print(' '.join(map(str, combo)))\n            return\n    \n    # If no successful party is found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    find_successful_party()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people either forming a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create adjacency matrix for the graph\n    adjacency_matrix = [[False] * n for _ in range(n)]\n    \n    for a, b in friendships:\n        adjacency_matrix[a-1][b-1] = True\n        adjacency_matrix[b-1][a-1] = True\n\n    # Check all combinations of 5 people\n    for combination in combinations(range(n), 5):\n        if is_clique(combination, adjacency_matrix) or is_independent_set(combination, adjacency_matrix):\n            return [person + 1 for person in combination]\n    \n    return -1\n\ndef is_clique(nodes: Tuple[int], adjacency_matrix: List[List[bool]]) -> bool:\n    \"\"\"Checks if the given nodes form a clique.\n\n    Args:\n        nodes (Tuple[int]): Nodes to check.\n        adjacency_matrix (List[List[bool]]): Graph adjacency matrix.\n\n    Returns:\n        bool: True if nodes form a clique, False otherwise.\n    \"\"\"\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            if not adjacency_matrix[nodes[i]][nodes[j]]:\n                return False\n    return True\n\ndef is_independent_set(nodes: Tuple[int], adjacency_matrix: List[List[bool]]) -> bool:\n    \"\"\"Checks if the given nodes form an independent set.\n\n    Args:\n        nodes (Tuple[int]): Nodes to check.\n        adjacency_matrix (List[List[bool]]): Graph adjacency matrix.\n\n    Returns:\n        bool: True if nodes form an independent set, False otherwise.\n    \"\"\"\n    for i in range(len(nodes)):\n        for j in range(i + 1, len(nodes)):\n            if adjacency_matrix[nodes[i]][nodes[j]]:\n                return False\n    return True\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to check all possible combinations of 5 people.\n- Ensure the solution handles edge cases where M is 0 or very large.\n- Optimize the solution to run within time limits for maximum constraints.\n- Provide clear and formatted output as specified in the requirements.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to model the friendships as an undirected graph. Each person is a node, and each friendship is an edge. We will then check combinations of 5 nodes to see if they form a complete subgraph (clique) or an independent set (no edges between them). Given the constraints, we will use efficient graph traversal techniques to ensure scalability.\n", "requirement analysis:\nThe problem requires finding a combination of 5 people from N inhabitants such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently, given the constraints on N and M. The solution must be optimized to handle the upper limits of input size.\nrequirement pool:\n- Develop an efficient algorithm to check all combinations of 5 people for the party criteria.\n- Ensure the solution handles edge cases, such as no friendships or maximum friendships.\n- Optimize the solution for time complexity to handle large inputs within reasonable time.\n- Provide clear and correct output format as specified in the requirements.\n- Consider multiple successful party configurations and return any valid one.\nWe will use a graph-based approach to solve this problem. The inhabitants and their friendships can be represented as a graph where each person is a node and each friendship is an edge. We need to find a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). Given the constraints, we will use a combination of adjacency list representation and efficient graph traversal techniques to check for these conditions. The NetworkX library will be used for its efficient graph operations.\n", "requirement analysis:\nThe problem requires finding a combination of 5 people such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M. The solution must be optimized to handle the upper limits of input size.\nrequirement pool:\n- Develop an efficient algorithm to check all combinations of 5 people for the party criteria.\n- Ensure the solution handles edge cases, such as no friendships or all possible friendships.\n- Optimize the solution to run within acceptable time limits for maximum input sizes.\n- Provide clear and correct output format as specified in the requirements.\n- Consider multiple successful party configurations if they exist.\nWe will use a graph-based approach to solve this problem. The inhabitants and their friendships can be represented as a graph where each person is a node and each friendship is an edge. We need to find a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). Given the constraints, we will use a combination of adjacency list representation and efficient graph traversal techniques to check for these conditions. The NetworkX library can be used to simplify graph operations.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship dynamics. The solution must efficiently handle large inputs and provide clear outputs. The algorithm should consider all possible combinations of individuals to meet the success criteria.\nrequirement pool:\n- Develop an efficient algorithm to check all combinations of 5 individuals.\n- Ensure the solution handles edge cases, such as no friendships or complete friendships.\n- Optimize the algorithm for performance with large datasets.\n- Provide clear and concise output format as specified.\n- Consider scalability for future extensions or larger populations.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding cliques of size 5 or independent sets of size 5 in the graph. We will use the NetworkX library, which provides efficient graph algorithms to help us identify these structures. The algorithm will iterate over all possible combinations of 5 people and check if they form a clique or an independent set. Given the constraints, we need to ensure the solution is optimized for performance, especially for large values of N and M.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from N inhabitants such that either all are friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently due to the large possible input size. The solution must handle edge cases where no such subset exists.\nrequirement pool:\n- Develop an efficient algorithm to check all combinations of 5 people.\n- Ensure the solution can handle the maximum constraints of N and M.\n- Optimize the algorithm to reduce time complexity.\n- Implement edge case handling for scenarios with no possible successful party.\n- Provide clear documentation and comments within the code.\nWe will use a graph-based approach to solve this problem. The inhabitants and their friendships can be represented as a graph where nodes are people and edges are friendships. We need to find a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected). Given the constraints, we will use a combination of adjacency list representation and efficient graph traversal techniques to check for these conditions. The NetworkX library can be used to handle graph operations efficiently.\n", "requirement analysis:\nThe problem requires finding a combination of 5 people who either all know each other or none know each other. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints of up to 200,000 inhabitants and friendships.\nrequirement pool:\n- Develop an efficient algorithm to check all combinations of 5 people.\n- Ensure the solution handles edge cases, such as no friendships or maximum friendships.\n- Optimize the solution for performance with large datasets.\n- Provide clear and concise output as per the requirements.\n- Consider multiple successful party configurations if possible.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (where all nodes are connected) or an independent set of size 5 (where no nodes are connected) in the graph. Given the constraints, we will use adjacency lists to represent the graph and check combinations efficiently. We will leverage itertools for combinations and networkx for graph operations to simplify the implementation.\n", "requirement analysis:\nThe problem requires finding a combination of 5 people from a given set of inhabitants such that they either all know each other or none of them know each other. This involves checking combinations of friendships and non-friendships efficiently due to the large possible input size.\nrequirement pool:\n- Efficiently check all combinations of 5 people for the success criteria.\n- Handle edge cases where no friendships exist or everyone is friends with everyone.\n- Optimize the solution to handle the maximum constraints of N and M.\n- Provide clear error handling and output formatting.\n- Consider multiple successful party configurations if they exist.\nWe will use graph theory to model the friendships as an undirected graph. The problem can be solved by checking combinations of 5 nodes (people) in the graph to see if they form a complete subgraph (clique) or an independent set. Given the constraints, we will use efficient graph traversal and combination generation techniques to ensure scalability.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship dynamics. The solution must efficiently handle large inputs and provide clear outputs. Edge cases, such as no friendships or all individuals being friends, must be considered.\nrequirement pool:\n- Efficiently determine if a successful party can be organized.\n- Handle large inputs up to 200,000 individuals and friendships.\n- Provide clear output indicating party success or failure.\n- Consider all possible combinations of individuals.\n- Optimize for edge cases with no friendships or complete friendships.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding cliques of size 5 or independent sets of size 5 in the graph. We will use the NetworkX library, which provides efficient graph algorithms to help us identify these structures. The approach involves creating a graph from the input data and then checking for cliques and independent sets of the required size.\n", "requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship conditions. The solution must efficiently handle large datasets and provide clear output. Edge cases such as minimum friendships and maximum population need careful consideration.\nrequirement pool:\n- Efficiently determine if a successful party can be organized.\n- Handle large input sizes up to 200,000 people and friendships.\n- Provide clear output indicating party success or failure.\n- Optimize algorithm for performance and accuracy.\n- Consider edge cases and ensure robustness.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding cliques of size 5 or independent sets of size 5 in the graph. We will use the NetworkX library to handle graph operations efficiently. The algorithm will iterate over all possible combinations of 5 people and check if they form a clique or an independent set.\n", "requirement analysis:\nThe problem requires finding a combination of 5 people such that either all are friends or none are friends. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to check all combinations of 5 people.\n- Ensure the solution handles the maximum constraints of N and M.\n- Optimize the solution to reduce unnecessary computations.\n- Provide clear output as per the problem statement.\n- Consider edge cases such as no friendships or all possible friendships.\nWe will use graph theory to model the friendships as an undirected graph. Each person is a node, and each friendship is an edge. We will then check combinations of 5 nodes to see if they form a complete subgraph (clique) or an independent set (no edges between them). Given the constraints, we will use efficient graph traversal techniques to ensure scalability.\n"], "scores": [], "pass_results": [false, true, true, false, false, false, true, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 4, "round": 210, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "rephrase_one", "parent_index": 125}
