{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. To be deemed successful, either everyone at the party is friends with one another (so that they can all converse without concern about talking to someone they are not friends with) or none of the people at the party are friends with each other (ensuring that everyone can be on their phones without being disturbed). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Consider all possible combinations to ensure no potential successful party is overlooked. Algorithms and data structures can play a crucial role in identifying feasible combinations efficiently.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. To be deemed successful, either everyone at the party is friends with one another (so that they can all converse without concern about talking to someone they are not friends with) or none of the people at the party are friends with each other (ensuring that everyone can be on their phones without being disturbed). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Consider all possible combinations to ensure no potential successful party is overlooked. Algorithms and data structures can play a crucial role in identifying feasible combinations efficiently.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or none are friends.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people if a successful party is found, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in G is a clique in the complement of G\n    complement_G = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_G))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function to find a successful party\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or none are friends.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency matrix to represent the graph\n    graph = [[False] * n for _ in range(n)]\n    \n    # Fill the adjacency matrix with the given friendships\n    for a, b in friendships:\n        graph[a-1][b-1] = True\n        graph[b-1][a-1] = True\n\n    # Check all combinations of 5 people\n    for combo in combinations(range(n), 5):\n        if is_clique(graph, combo) or is_independent_set(graph, combo):\n            return [x + 1 for x in combo]  # Convert to 1-based index\n\n    return -1\n\ndef is_clique(graph: List[List[bool]], nodes: Tuple[int, int, int, int, int]) -> bool:\n    \"\"\"Checks if the given nodes form a clique (complete subgraph).\n\n    Args:\n        graph (List[List[bool]]): The adjacency matrix of the graph.\n        nodes (Tuple[int, int, int, int, int]): A tuple of node indices.\n\n    Returns:\n        bool: True if the nodes form a clique, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if not graph[nodes[i]][nodes[j]]:\n                return False\n    return True\n\ndef is_independent_set(graph: List[List[bool]], nodes: Tuple[int, int, int, int, int]) -> bool:\n    \"\"\"Checks if the given nodes form an independent set (no edges between them).\n\n    Args:\n        graph (List[List[bool]]): The adjacency matrix of the graph.\n        nodes (Tuple[int, int, int, int, int]): A tuple of node indices.\n\n    Returns:\n        bool: True if the nodes form an independent set, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if graph[nodes[i]][nodes[j]]:\n                return False\n    return True\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or all strangers.\n\n    Args:\n        N: The number of people.\n        M: The number of friendships.\n        friendships: A list of tuples where each tuple represents a friendship between two people.\n\n    Returns:\n        A list of 5 integers representing the people in the successful party, or -1 if no such party exists.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    \n    # Fill the adjacency list with the given friendships\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n    \n    # Generate all combinations of 5 people\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        # Check if the combination is a clique (all are friends)\n        if all(b in adjacency_list[a] for a, b in itertools.combinations(combination, 2)):\n            return list(combination)\n        \n        # Check if the combination is an independent set (none are friends)\n        if all(b not in adjacency_list[a] for a, b in itertools.combinations(combination, 2)):\n            return list(combination)\n    \n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n    \n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\nfrom typing import List, Tuple, Union\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> Union[List[int], int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or all strangers.\n\n    Args:\n        N (int): The number of people.\n        M (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        Union[List[int], int]: A list of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, N + 1))\n    G.add_edges_from(friendships)\n\n    # Check all combinations of 5 nodes\n    for combination in combinations(G.nodes, 5):\n        subgraph = G.subgraph(combination)\n        # Check if the subgraph is a clique (complete graph)\n        if nx.is_clique(subgraph):\n            return list(combination)\n        # Check if the subgraph is an independent set (no edges)\n        if subgraph.number_of_edges() == 0:\n            return list(combination)\n\n    # If no successful party is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n    \n    # Call the function to find a successful party\n    result = find_successful_party(N, M, friendships)\n    \n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people either forming a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function to find a successful party\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or none are friends.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party or -1 if no such party exists.\n    \"\"\"\n    # Create a graph from the friendships\n    graph = nx.Graph()\n    graph.add_nodes_from(range(1, n + 1))\n    graph.add_edges_from(friendships)\n\n    # Check all combinations of 5 people\n    for group in combinations(range(1, n + 1), 5):\n        subgraph = graph.subgraph(group)\n        # Check if the group is a clique (all are friends)\n        if nx.is_clique(subgraph):\n            return list(group)\n        # Check if the group is an independent set (none are friends)\n        if subgraph.number_of_edges() == 0:\n            return list(group)\n\n    # Return -1 if no successful party is found\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or all strangers.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party, or -1 if no such party exists.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    \n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n    \n    # Check all combinations of 5 people\n    for group in combinations(range(1, n + 1), 5):\n        if is_clique(group, adjacency_list) or is_independent_set(group, adjacency_list):\n            return list(group)\n    \n    return -1\n\ndef is_clique(group: Tuple[int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if the given group forms a clique in the graph.\n\n    Args:\n        group (Tuple[int]): A tuple of people.\n        adjacency_list (dict): The adjacency list of the graph.\n\n    Returns:\n        bool: True if the group forms a clique, False otherwise.\n    \"\"\"\n    for i in range(len(group)):\n        for j in range(i + 1, len(group)):\n            if group[j] not in adjacency_list[group[i]]:\n                return False\n    return True\n\ndef is_independent_set(group: Tuple[int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if the given group forms an independent set in the graph.\n\n    Args:\n        group (Tuple[int]): A tuple of people.\n        adjacency_list (dict): The adjacency list of the graph.\n\n    Returns:\n        bool: True if the group forms an independent set, False otherwise.\n    \"\"\"\n    for i in range(len(group)):\n        for j in range(i + 1, len(group)):\n            if group[j] in adjacency_list[group[i]]:\n                return False\n    return True\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or all strangers.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an adjacency matrix to represent friendships\n    adj_matrix = [[False] * n for _ in range(n)]\n    \n    for a, b in friendships:\n        adj_matrix[a-1][b-1] = True\n        adj_matrix[b-1][a-1] = True\n\n    # Check all combinations of 5 people\n    for comb in combinations(range(n), 5):\n        if is_clique(comb, adj_matrix) or is_independent_set(comb, adj_matrix):\n            return [x + 1 for x in comb]  # Convert to 1-based index\n\n    return -1\n\ndef is_clique(comb: Tuple[int], adj_matrix: List[List[bool]]) -> bool:\n    \"\"\"Checks if the given combination of nodes forms a clique.\n\n    Args:\n        comb (Tuple[int]): A combination of node indices.\n        adj_matrix (List[List[bool]]): The adjacency matrix of the graph.\n\n    Returns:\n        bool: True if the combination forms a clique, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if not adj_matrix[comb[i]][comb[j]]:\n                return False\n    return True\n\ndef is_independent_set(comb: Tuple[int], adj_matrix: List[List[bool]]) -> bool:\n    \"\"\"Checks if the given combination of nodes forms an independent set.\n\n    Args:\n        comb (Tuple[int]): A combination of node indices.\n        adj_matrix (List[List[bool]]): The adjacency matrix of the graph.\n\n    Returns:\n        bool: True if the combination forms an independent set, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if adj_matrix[comb[i]][comb[j]]:\n                return False\n    return True\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in the given friendship graph.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not found.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Check all combinations of 5 people\n    from itertools import combinations\n    for combination in combinations(range(1, n + 1), 5):\n        if is_clique(combination) or is_independent_set(combination):\n            return list(combination)\n\n    # Return -1 if no successful party is found\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people where each person is friends with every other person in the group.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples where each tuple represents a friendship between two people.\n\n    Returns:\n        List[int]: A list of 5 people forming a successful party, or -1 if no such group exists.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    \n    # Populate the adjacency list with the given friendships\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n    \n    # Check all combinations of 5 people\n    for group in combinations(range(1, n + 1), 5):\n        if is_successful_party(group, adjacency_list):\n            return list(group)\n    \n    return -1\n\ndef is_successful_party(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if a given group of 5 people forms a successful party.\n\n    Args:\n        group (Tuple[int, int, int, int, int]): A tuple of 5 people.\n        adjacency_list (dict): The adjacency list representing friendships.\n\n    Returns:\n        bool: True if the group forms a successful party, False otherwise.\n    \"\"\"\n    # Check if every pair in the group is friends\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] not in adjacency_list[group[i]]:\n                return False\n    return True\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe requirements focus on identifying combinations of 5 people that either all know each other or none know each other. This involves graph theory concepts such as cliques and independent sets. Efficient algorithms are necessary to handle the upper limit of 200,000 people and friendships.\nrequirement pool:\n- Implement an algorithm to find cliques of size 5.\n- Implement an algorithm to find independent sets of size 5.\n- Optimize for large datasets to ensure scalability.\n- Ensure the solution is efficient and runs within time limits.\n- Provide clear output format as specified in requirements.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and look for cliques of size 5 (where everyone is friends with each other) or independent sets of size 5 (where no one is friends with each other). Given the constraints, we will use efficient graph traversal techniques and data structures to ensure scalability. The NetworkX library can be useful for handling graph operations efficiently.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves checking combinations of people and their friendship status. Given the constraints, efficient graph traversal and combination generation are crucial. The solution must handle up to 200,000 people and friendships, necessitating optimized algorithms.\nrequirement pool:\n- Develop an algorithm to efficiently find a successful party combination.\n- Ensure the solution can handle the maximum input size within reasonable time limits.\n- Provide clear output format as specified in the requirements.\n- Optimize for both time and space complexity.\n- Consider edge cases such as no friendships or all possible friendships.\nWe will use graph theory to model the friendships as an undirected graph. Each person is a node, and each friendship is an edge. We will then check combinations of 5 nodes to see if they form a complete subgraph (clique) or an independent set (no edges between them). Given the constraints, we will use efficient graph traversal techniques and combinatorial generation to ensure scalability.\n", "requirement analysis:\nThe problem requires identifying a combination of 5 people who are either all friends or none are friends. This involves checking combinations of people and their friendship status, which can be efficiently managed using graph theory concepts such as cliques and independent sets. Given the constraints, the solution must be optimized for both time and space to handle the upper limits of input size.\nrequirement pool:\n- Implement an efficient algorithm to find a successful party combination.\n- Ensure the solution can handle the maximum input size within reasonable time limits.\n- Provide clear output format as specified in the requirements.\n- Optimize the solution for both time and space complexity.\n- Consider edge cases such as no friendships or all possible friendships.\nWe will use graph theory to solve this problem. The problem can be reduced to finding a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). We will represent the friendships as an undirected graph and use adjacency lists for efficient traversal. We will then check all combinations of 5 people to see if they form a clique or an independent set. Given the constraints, we will use itertools to generate combinations and set operations to check friendship conditions efficiently.\n", "requirement analysis:\nThe problem requires identifying a combination of 5 people who are either all friends or none are friends. This involves checking all possible combinations of 5 people from N and verifying their friendship status. The challenge lies in efficiently handling large values of N and M, necessitating the use of efficient graph algorithms and data structures.\nrequirement pool:\n- Implement an efficient algorithm to check all combinations of 5 people.\n- Ensure the solution can handle the maximum constraints of N and M.\n- Optimize the solution for time complexity.\n- Provide clear output formatting as specified.\n- Consider edge cases with minimal friendships.\nWe will use a graph-based approach to solve this problem. Each person is a node, and each friendship is an edge in the graph. We need to check all combinations of 5 nodes to see if they form a complete subgraph (clique) or an independent set (no edges between them). Given the constraints, we will use efficient graph traversal techniques and combinatorial checks to ensure scalability. The NetworkX library can be useful for handling graph operations efficiently.\n", "requirement analysis:\nThe problem requires identifying a combination of 5 people who are either all friends or none are friends. This involves checking combinations of people against the friendship data, which can be represented as a graph. Efficient graph traversal and combination generation techniques are necessary to handle the upper limits of N and M.\nrequirement pool:\n- Implement an efficient algorithm to find a successful party.\n- Ensure the solution can handle the maximum constraints of N and M.\n- Optimize the algorithm for speed and memory usage.\n- Provide clear and user-friendly output.\n- Consider edge cases and validate input data.\nWe will use a graph-based approach to solve this problem. Each person is a node, and each friendship is an edge in the graph. We need to find a combination of 5 nodes that either form a complete subgraph (clique) or have no edges between them (independent set). Given the constraints, we will use a combination of adjacency list representation for the graph and efficient combinatorial checks to determine if a valid party can be formed. The NetworkX library can be used to handle graph operations efficiently.\n", "requirement analysis:\nThe problem requires identifying combinations of 5 people from a set of N people such that either all are friends or none are friends. This involves checking combinations against the friendship pairs provided. Efficient algorithms and data structures are necessary to handle the large input sizes.\nrequirement pool:\n- Implement efficient combination generation for party planning.\n- Develop a method to check friendship status among combinations.\n- Optimize for large datasets to ensure scalability.\n- Provide clear output format as specified.\n- Consider edge cases and ensure robustness.\nWe will use a graph-based approach to solve this problem. Each person will be represented as a node, and each friendship as an edge in the graph. We will use combinations to generate all possible groups of 5 people and check if they form a clique (all are friends) or an independent set (none are friends). The NetworkX library will be used for efficient graph operations.\n", "requirement analysis:\nThe requirements focus on efficiently determining if a successful party can be organized given the constraints of friendships among people. The solution must handle large inputs and provide results quickly, leveraging algorithms and data structures to explore all possible combinations.\nrequirement pool:\n- Implement efficient graph traversal algorithms to identify cliques or independent sets.\n- Ensure the solution scales with the maximum constraints of N and M.\n- Optimize data structures for storing and querying friendship relations.\n- Provide clear output format as specified in the requirements.\n- Consider edge cases where no successful party can be organized.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 or an independent set of size 5 in the graph. We will represent the friendships as an undirected graph and use efficient graph traversal techniques to identify these sets. Given the constraints, we will use adjacency lists for efficient storage and querying of friendships. We will also leverage combinations to explore potential groups of 5 people and check their friendship status.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that either all are friends or none are friends. This involves checking combinations of people and their friendship status, which can be efficiently managed using graph theory concepts. The constraints on N and M suggest the need for efficient algorithms to handle potentially large datasets.\nrequirement pool:\n- Implement a graph-based approach to model friendships.\n- Develop an efficient algorithm to check all combinations of 5 people.\n- Optimize for large input sizes to ensure quick computation.\n- Provide clear output format as specified in the requirements.\n- Consider edge cases with minimal or maximal friendships.\nWe will use a graph-based approach to model the friendships among people. Each person will be a node, and each friendship will be an edge between two nodes. We will then check all combinations of 5 nodes to see if they form a complete subgraph (clique) or an independent set. Given the constraints, we will use efficient graph traversal and combination generation techniques to ensure scalability.\n", "requirement analysis:\nThe problem requires identifying a combination of 5 people from a group of N such that either all are friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, given the constraints on N and M. The solution must handle large inputs and provide a quick determination of a successful party or indicate impossibility.\nrequirement pool:\n- Implement an efficient algorithm to check all combinations of 5 people.\n- Optimize the solution for large values of N and M.\n- Provide clear output format as specified in the requirements.\n- Ensure the solution is robust against edge cases.\n- Consider user-friendly error messages for invalid inputs.\nWe will use graph theory to solve this problem efficiently. The problem can be represented as a graph where nodes are people and edges are friendships. We need to find a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). We will use adjacency lists to represent the graph and check combinations of 5 people using efficient graph traversal techniques.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves checking combinations of people and their friendship status. Given the constraints, efficient algorithms and data structures like graphs and adjacency lists are crucial to handle the large input sizes.\nrequirement pool:\n- Implement an efficient algorithm to check all combinations of 5 people.\n- Use graph data structures to represent friendships.\n- Optimize for large input sizes to ensure quick computation.\n- Provide clear output format as specified.\n- Consider edge cases with no friendships or complete friendships.\nWe will use a graph-based approach to solve this problem. Each person is a node, and each friendship is an edge in the graph. We will use an adjacency list to represent the graph. The challenge is to efficiently check all combinations of 5 people to see if they form a successful party. We will leverage combinations from the itertools library to generate all possible groups of 5 people and then check the friendship conditions for each group. Given the constraints, this approach should be efficient enough.\n"], "scores": [], "pass_results": [true, true, false, true, false, true, false, false, true, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 310, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "add_1_sentence_at_end", "parent_index": 191}
