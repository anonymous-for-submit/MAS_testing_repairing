{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir has a rectangular piece of paper with a checkered grid that is n \u00d7 m in size. At the start, each square on the grid is white.\n\nLet's represent the cell with coordinates i downwards and j sideways by (i, j). The top left cell will be called (1, 1). And the bottom right cell will be called (n, m).\n\nCasimir sketches ticks of varying sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn in this manner:\n\n  1. First, the central cell (i, j) is colored black.\n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also colored black. \n  3. Therefore, all the cells at positions (i - h, j \u00b1 h) for every h from 0 to d are colored. Specifically, a tick is made up of 2d + 1 black cells.\n\nA cell that is already painted will stay black if painted again. Below is an illustration of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou receive a description of a checkered field of size n \u00d7 m. Casimir claims that this field was created by marking some (maybe 0) ticks on it. The ticks could vary in sizes, but each tick must have a size of at least k (that is, d \u2265 k for every tick).\n\nEvaluate whether this field can indeed result from drawing some (possibly none) ticks of sizes d \u2265 k or not. Consider edge cases where the field dimensions or the values of k result in limited or no space for ticks. It is crucial to analyze whether the distribution of black cells can only be explained by ticks of the given constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir has a rectangular piece of paper with a checkered grid that is n \u00d7 m in size. At the start, each square on the grid is white.\n\nLet's represent the cell with coordinates i downwards and j sideways by (i, j). The top left cell will be called (1, 1). And the bottom right cell will be called (n, m).\n\nCasimir sketches ticks of varying sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn in this manner:\n\n  1. First, the central cell (i, j) is colored black.\n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also colored black. \n  3. Therefore, all the cells at positions (i - h, j \u00b1 h) for every h from 0 to d are colored. Specifically, a tick is made up of 2d + 1 black cells.\n\nA cell that is already painted will stay black if painted again. Below is an illustration of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou receive a description of a checkered field of size n \u00d7 m. Casimir claims that this field was created by marking some (maybe 0) ticks on it. The ticks could vary in sizes, but each tick must have a size of at least k (that is, d \u2265 k for every tick).\n\nEvaluate whether this field can indeed result from drawing some (possibly none) ticks of sizes d \u2265 k or not. Consider edge cases where the field dimensions or the values of k result in limited or no space for ticks. It is crucial to analyze whether the distribution of black cells can only be explained by ticks of the given constraints.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if each grid in the test cases can be formed by ticks of size at least k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: A list of strings, either 'YES' or 'NO', for each test case.\n    \"\"\"\n    def is_valid_tick_center(x: int, y: int, k: int, grid: List[str], n: int, m: int) -> bool:\n        \"\"\"Checks if a tick of size at least k can be centered at (x, y).\n\n        Args:\n            x (int): Row index of the potential tick center.\n            y (int): Column index of the potential tick center.\n            k (int): Minimum size of the tick.\n            grid (List[str]): The grid itself.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n\n        Returns:\n            bool: True if a valid tick can be centered at (x, y), False otherwise.\n        \"\"\"\n        length = 0\n        while True:\n            if x - length < 0 or y - length < 0 or y + length >= m:\n                break\n            if grid[x - length][y - length] != '*' or grid[x - length][y + length] != '*':\n                break\n            length += 1\n        return length > k\n\n    results = []\n    for n, m, k, grid in test_cases:\n        can_form = True\n        # Create a copy of the grid to mark used cells\n        used = [[False] * m for _ in range(n)]\n        \n        # Check each cell if it can be the center of a tick\n        for x in range(n):\n            for y in range(m):\n                if grid[x][y] == '*' and not used[x][y]:\n                    if is_valid_tick_center(x, y, k, grid, n, m):\n                        # Mark the cells used by this tick\n                        length = 0\n                        while True:\n                            if x - length < 0 or y - length < 0 or y + length >= m:\n                                break\n                            if grid[x - length][y - length] != '*' or grid[x - length][y + length] != '*':\n                                break\n                            used[x - length][y - length] = True\n                            used[x - length][y + length] = True\n                            length += 1\n                    else:\n                        can_form = False\n                        break\n            if not can_form:\n                break\n        results.append(\"YES\" if can_form else \"NO\")\n    \n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().split('\\n')\nt = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(t):\n    n, m, k = map(int, data[index].split())\n    grid = [data[index + i + 1] for i in range(n)]\n    test_cases.append((n, m, k, grid))\n    index += n + 1\n\n# Output interface\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each grid can be formed by ticks of a minimum size.\n\n    Args:\n        t: Number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the grid.\n            - m: Number of columns in the grid.\n            - k: Minimum size of the tick.\n            - grid: A list of strings representing the grid.\n\n    Returns:\n        A list of strings, each being \"YES\" or \"NO\" for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Function to check if a tick can be formed with center at (i, j)\n        def can_form_tick(i: int, j: int, size: int) -> bool:\n            for d in range(size):\n                if i - d < 0 or j - d < 0 or j + d >= m:\n                    return False\n                if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                    return False\n            return True\n\n        # Mark all possible ticks\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Try to form the largest possible tick with center at (i, j)\n                    size = 0\n                    while can_form_tick(i, j, size + 1):\n                        size += 1\n                    # If the tick size is at least k, mark the cells\n                    if size >= k:\n                        for d in range(size):\n                            marked[i - d][j - d] = True\n                            marked[i - d][j + d] = True\n\n        # Verify if all '*' in the grid are part of a tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if a given grid can be formed by drawing ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a valid tick\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells of the tick\n                        for d in range(k + 1):\n                            marked[i - d][j - d] = True\n                            marked[i - d][j + d] = True\n\n        # Verify if all '*' in the grid are part of a valid tick\n        all_ticks_covered = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    all_ticks_covered = False\n                    break\n            if not all_ticks_covered:\n                break\n\n        if all_ticks_covered:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Output results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Evaluates each test case to determine if a grid can be formed by ticks of at least size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing grid dimensions, tick size, and grid data.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        if k == 0:\n            results.append(\"YES\")\n            continue\n\n        can_form = True\n        tick_positions = [[False] * m for _ in range(n)]\n\n        # Check each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed centered at (i, j)\n                    if i - k >= 0 and j - k >= 0 and j + k < m:\n                        valid_tick = True\n                        for d in range(1, k + 1):\n                            if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                                valid_tick = False\n                                break\n                        if valid_tick:\n                            for d in range(k + 1):\n                                tick_positions[i - d][j - d] = True\n                                tick_positions[i - d][j + d] = True\n\n        # Verify if all '*' are part of a valid tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not tick_positions[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n## Input interface\nimport sys\n\ndef main():\n    input_data = sys.stdin.read().strip().split('\\n')\n    t = int(input_data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, input_data[index].split())\n        grid = [input_data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, grid))\n        index += n + 1\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef validate_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Validate tick patterns in a grid for multiple test cases.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to track tick validation\n        tick_valid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a valid tick can be formed with center at (i, j)\n                    if is_valid_tick(i, j, n, m, k, grid, tick_valid):\n                        mark_tick(i, j, k, tick_valid)\n\n        # Check if all '*' in the grid are part of a valid tick\n        if all(grid[i][j] == '.' or tick_valid[i][j] for i in range(n) for j in range(m)):\n            results.append('YES')\n        else:\n            results.append('NO')\n\n    return results\n\ndef is_valid_tick(i: int, j: int, n: int, m: int, k: int, grid: List[str], tick_valid: List[List[bool]]) -> bool:\n    \"\"\"Check if a valid tick can be formed with center at (i, j).\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        k (int): Minimum size of the tick.\n        grid (List[str]): The grid represented as a list of strings.\n        tick_valid (List[List[bool]]): 2D list to track tick validation.\n\n    Returns:\n        bool: True if a valid tick can be formed, False otherwise.\n    \"\"\"\n    length = 0\n    while True:\n        # Check boundaries and if the tick can extend further\n        if (i - length - 1 >= 0 and j - length - 1 >= 0 and\n            j + length + 1 < m and grid[i - length - 1][j - length - 1] == '*' and\n            grid[i - length - 1][j + length + 1] == '*'):\n            length += 1\n        else:\n            break\n\n    return length >= k\n\ndef mark_tick(i: int, j: int, k: int, tick_valid: List[List[bool]]) -> None:\n    \"\"\"Mark the cells of a valid tick in the tick_valid grid.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Minimum size of the tick.\n        tick_valid (List[List[bool]]): 2D list to track tick validation.\n    \"\"\"\n    for length in range(k):\n        tick_valid[i - length - 1][j - length - 1] = True\n        tick_valid[i - length - 1][j + length + 1] = True\n\n# Input interface\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m, k = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    test_cases.append((n, m, k, grid))\n\n# Output interface\nresults = validate_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if each grid in the test cases can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                        size += 1\n\n                    # If a tick of at least size k can be formed, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Check if all '*' in the grid are part of a tick\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if each grid in the test cases can form ticks of minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: A list of \"YES\" or \"NO\" for each test case indicating if the grid can form the required ticks.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells of the tick\n                        for d in range(k + 1):\n                            marked[i - d][j - d] = True\n                            marked[i - d][j + d] = True\n\n        # Verify if all '*' in the grid are part of a valid tick\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        grid = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, grid))\n        index += n + 1\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if each grid in the test cases can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: A list of \"YES\" or \"NO\" for each test case indicating if the grid can be formed by ticks.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    valid_tick = True\n                    for d in range(1, k + 1):\n                        if grid[i - d][j - d] != '*' or grid[i - d][j + d] != '*':\n                            valid_tick = False\n                            break\n                    if valid_tick:\n                        # Mark the cells of the tick\n                        for d in range(k + 1):\n                            marked[i - d][j - d] = True\n                            marked[i - d][j + d] = True\n                        marked[i][j] = True\n\n        # Verify if all '*' in the grid are part of a tick\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each grid in the test cases can be explained by ticks of size at least k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    def is_valid_tick_center(x: int, y: int, k: int, grid: List[str], n: int, m: int) -> bool:\n        \"\"\"Check if a tick of size k can be centered at (x, y).\n\n        Args:\n            x (int): Row index of the center.\n            y (int): Column index of the center.\n            k (int): Minimum size of the tick.\n            grid (List[str]): The grid itself.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n\n        Returns:\n            bool: True if a valid tick can be centered at (x, y), False otherwise.\n        \"\"\"\n        for i in range(1, k + 1):\n            if x - i < 0 or y - i < 0 or y + i >= m:\n                return False\n            if grid[x - i][y - i] != '*' or grid[x - i][y + i] != '*':\n                return False\n        return True\n\n    def mark_tick(x: int, y: int, k: int, grid: List[List[str]], n: int, m: int):\n        \"\"\"Mark the cells of a tick centered at (x, y) as used.\n\n        Args:\n            x (int): Row index of the center.\n            y (int): Column index of the center.\n            k (int): Minimum size of the tick.\n            grid (List[List[str]]): The grid itself.\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n        \"\"\"\n        grid[x][y] = '.'\n        for i in range(1, k + 1):\n            grid[x - i][y - i] = '.'\n            grid[x - i][y + i] = '.'\n\n    results = []\n    for n, m, k, grid in test_cases:\n        grid = [list(row) for row in grid]  # Convert grid to a list of lists for mutability\n        can_form = True\n\n        for x in range(n - 1, -1, -1):\n            for y in range(m):\n                if grid[x][y] == '*':\n                    if is_valid_tick_center(x, y, k, grid, n, m):\n                        mark_tick(x, y, k, grid, n, m)\n                    else:\n                        can_form = False\n                        break\n            if not can_form:\n                break\n\n        if can_form:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if each grid in the test cases can form ticks of at least size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: A list of \"YES\" or \"NO\" for each test case indicating if the grid can form the required ticks.\n    \"\"\"\n    def is_valid_tick(n: int, m: int, k: int, grid: List[str], x: int, y: int) -> bool:\n        \"\"\"Check if a tick of size at least k can be formed with center at (x, y).\n\n        Args:\n            n (int): Number of rows in the grid.\n            m (int): Number of columns in the grid.\n            k (int): Minimum size of the tick.\n            grid (List[str]): The grid itself.\n            x (int): Row index of the potential tick center.\n            y (int): Column index of the potential tick center.\n\n        Returns:\n            bool: True if a valid tick can be formed, False otherwise.\n        \"\"\"\n        # Check if a tick of size k can be formed with (x, y) as the center\n        for size in range(1, k + 1):\n            if x - size < 0 or y - size < 0 or y + size >= m:\n                return False\n            if grid[x - size][y - size] != '*' or grid[x - size][y + size] != '*':\n                return False\n        return True\n\n    results = []\n    for n, m, k, grid in test_cases:\n        # Create a boolean grid to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Traverse the grid to find all valid ticks\n        for x in range(n):\n            for y in range(m):\n                if grid[x][y] == '*' and is_valid_tick(n, m, k, grid, x, y):\n                    # Mark the cells of the tick\n                    for size in range(k):\n                        marked[x - size][y - size] = True\n                        marked[x - size][y + size] = True\n\n        # Check if all '*' in the grid are part of a valid tick\n        valid = True\n        for x in range(n):\n            for y in range(m):\n                if grid[x][y] == '*' and not marked[x][y]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, considering the constraints on grid size and tick size. Edge cases, such as small grids or large k values, must be handled to ensure accurate results.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks.\n- Ensure the solution handles all edge cases effectively.\n- Optimize the solution for performance given the constraints.\n- Provide detailed comments and documentation for the code.\n- Include test cases to validate the solution.\nWe will iterate over each test case and for each grid, we will check if the black cells can be explained by ticks of size at least k. We will use a helper function to verify if a tick can be centered at a given cell and extend in both diagonal directions. The approach will involve checking each black cell to see if it can be the center of a valid tick, and if not, the test case will be marked as NO.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by ticks of a minimum size. The constraints are small, allowing for a direct simulation approach. The solution must handle multiple test cases and edge cases where ticks cannot be formed due to grid size or configuration.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks.\n- Optimize the solution for efficiency.\n- Ensure the solution handles edge cases correctly.\n- Provide clear and concise output for each test case.\n- Maintain code readability and simplicity.\nWe will simulate the process of drawing ticks on the grid and verify if the given grid can be formed by ticks of a minimum size. The approach involves iterating over each cell and checking if it can be the center of a tick of size at least k. If a cell is part of a tick, we mark it and continue. If any '*' cannot be explained by a tick, we return NO for that test case.\n", "requirement analysis:\nThe task requires determining if a given grid can be formed by drawing ticks of a minimum size. The solution must efficiently handle multiple test cases and edge cases, ensuring that the output is clear and correct. The constraints on grid size and tick size must be carefully considered to ensure accurate results.\nrequirement pool:\n- Implement the main algorithm to detect valid tick formations.\n- Optimize the solution for performance with large inputs.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and concise output for each test case.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. We will use a nested loop to verify the tick formation by checking the diagonals. The solution will be optimized to handle up to 100 test cases efficiently, considering the constraints on grid size and tick size.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, ensuring that all black cells can be explained by valid ticks. Edge cases include small grids and large k values, which may limit tick placement.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks.\n- Ensure the solution handles edge cases effectively.\n- Optimize the solution for performance with maximum constraints.\n- Provide clear and concise output for each test case.\n- Maintain compatibility with the input-output format requirements.\nWe will implement a function to evaluate each test case by checking if the grid can be formed by ticks of at least size k. The function will iterate over each cell in the grid, attempting to form a tick centered at that cell and verifying if it satisfies the conditions. We will use simple loops and condition checks to ensure efficiency and clarity. The solution will handle edge cases by checking the boundaries and ensuring that ticks do not exceed the grid limits.\n", "requirement analysis:\nThe requirement is to determine if a given grid can be formed by drawing ticks of a minimum size k. The solution should efficiently handle up to 100 test cases, each with a grid size of up to 10x19. The algorithm must accurately identify valid tick patterns and ensure that all black cells can be explained by these patterns.\nrequirement pool:\n- Implement the main algorithm to validate tick patterns on the grid.\n- Optimize the solution for performance with multiple test cases.\n- Ensure the output format is clear and adheres to the requirements.\n- Handle edge cases where grid dimensions or k values limit tick placement.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function to validate tick patterns on a grid using a straightforward approach. The function will iterate over each cell in the grid and attempt to identify valid tick patterns based on the given constraints. We will use basic list operations and loops to efficiently check each cell and its surrounding area for potential tick formations. The solution will be optimized to handle multiple test cases by processing each grid independently and outputting results in a clear format.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, considering the constraints of grid size and tick size. Edge cases, such as small grids or large k values, must be handled to ensure accurate results.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is robust against edge cases.\n- Provide clear and consistent output formatting.\n- Maintain code readability and simplicity for future maintenance.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. If a tick can be formed, it will mark the cells as part of a tick. The solution will handle edge cases by ensuring that ticks do not extend beyond the grid boundaries and that all black cells can be explained by ticks of the required size.\n", "requirement analysis:\nThe task requires evaluating a grid to determine if it can be formed by ticks of a minimum size. The solution must efficiently handle multiple test cases and edge cases, ensuring that the output is consistent with the input constraints.\nrequirement pool:\n- Implement the main algorithm to detect valid tick formations.\n- Optimize the solution for performance with multiple test cases.\n- Ensure the solution handles edge cases effectively.\n- Provide clear and consistent output formatting.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to evaluate each test case by checking if the grid can be formed by ticks of a minimum size k. The function will iterate over each cell in the grid, attempting to form a tick centered at that cell and verifying if it meets the size requirement. We will use efficient grid traversal and validation techniques to ensure performance across multiple test cases. The solution will handle edge cases such as small grid sizes and isolated black cells that cannot form valid ticks.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, considering the constraints of grid size and tick size. Edge cases, such as small grids or large k values, must be handled to ensure accurate results.\nrequirement pool:\n- Implement the main algorithm to check for valid tick formations.\n- Optimize the solution for efficiency with large inputs.\n- Ensure the solution handles edge cases correctly.\n- Maintain code readability and simplicity.\n- Provide detailed comments and documentation.\nWe will implement a function to determine if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. If a cell is part of a tick, it will be marked, and the function will ensure all marked cells can be explained by ticks. The solution will handle edge cases such as small grids or large k values efficiently.\n", "requirement analysis:\nThe problem requires determining if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, considering the constraints of grid size and tick size. Edge cases, such as small grids or large k values, must be handled to ensure accurate results.\nrequirement pool:\n- Implement the main logic to check if the grid can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is robust against edge cases.\n- Provide clear and consistent output formatting.\n- Maintain code readability and simplicity for future maintenance.\nWe will iterate over each test case and for each grid, we will check if the black cells can be explained by ticks of size at least k. We will use a helper function to verify if a tick can be centered at a given cell and extend in both diagonal directions for the required size. The approach will involve checking each black cell to see if it can be the center of a valid tick or part of a tick of the required size.\n", "requirement analysis:\nThe requirement is to determine if a given grid can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases, each with a grid size of up to 10x19. The challenge lies in accurately identifying valid tick patterns and ensuring that all black cells can be explained by these patterns.\nrequirement pool:\n- Implement the main logic to validate tick patterns on the grid.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the output format is consistent with the requirements.\n- Handle edge cases where grid dimensions limit tick placement.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function to validate if a given grid can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. We will use a simple nested loop to traverse the grid and a helper function to verify tick patterns. The solution will be optimized to handle up to 100 test cases efficiently by leveraging the constraints on grid size.\n"], "scores": [], "pass_results": [false, false, true, false, false, false, false, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 1, "round": 228, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "add_1_sentence_at_end", "parent_index": 99}
