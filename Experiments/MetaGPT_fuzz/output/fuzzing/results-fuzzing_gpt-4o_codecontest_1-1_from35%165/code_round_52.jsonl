{"name": "1591_C. Minimize Distance", "description": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "tags": ["greedy", "math"], "difficulty": 9, "id": 1591, "sample_io": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}], "test_list": [{"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["30\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n0 1 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["21\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n46\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n10\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n41\n7\n3000010100\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["13\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n44\n7\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 6 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n46\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n12\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n41\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n51\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 2 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n23\n1000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n41\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n44\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n50\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 8 3 9 3\n5 3\n1 2 6 3 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n10\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n37\n7\n3000000000\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["13\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n45\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["27\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n27\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 6 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["30\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n46\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010000000\n", "output": ["16\n44\n8\n3010000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n8\n3000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["13\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["25\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n41\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 8 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n49\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n46\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n10\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n53\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 4 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1010000000 1000000010 1000000000\n", "output": ["29\n44\n11\n3010000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n39\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 2 3 4 5\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["27\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n11\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n46\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 4 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["29\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["16\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 4\n2 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["11\n44\n6\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -12 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n42\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n34\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n2 2 3 5 7\n9 3\n-9 -25 -15 6 6 8 3 7 4\n5 3\n1 0 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["31\n53\n8\n3000000001\n"]}, {"input": "4\n5 1\n1 1 3 8 1\n9 3\n-9 -18 -6 6 5 8 3 0 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["20\n42\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["20\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["30\n40\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n3000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n43\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 3 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 7\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["27\n41\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n41\n10\n3000010000\n"]}, {"input": "4\n5 1\n1 2 4 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 2 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["27\n41\n7\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 1\n2 4 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n41\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 1\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n43\n25\n7000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n1 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n43\n23\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n48\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 1 3 4 3\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["18\n40\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 0 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 6 8 3 9 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n48\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 1\n9 3\n-9 -22 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["18\n50\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 1 3 4 0\n9 3\n-9 -12 -6 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n10\n3000000010\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["30\n41\n7\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 4 4\n5 3\n2 2 5 6 3\n4 2\n0000000000 1000000000 1000000000 1000000000\n", "output": ["25\n39\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -23 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n49\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 4\n-5 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n42\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 16 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["38\n41\n10\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000001 1000000000\n", "output": ["25\n44\n9\n3000000001\n"]}, {"input": "4\n5 1\n0 3 3 4 5\n9 3\n-9 -18 -15 6 5 3 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n-1 2 3 4 5\n9 3\n-5 -10 -15 9 7 8 3 7 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 7 8 3 7 4\n5 1\n2 2 2 10 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n40\n28\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 0\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 5 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["18\n46\n9\n3001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 5\n9 3\n-9 -18 -1 6 6 8 3 7 4\n5 5\n1 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 1 4 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["21\n46\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -18 -15 5 6 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["14\n44\n10\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -25 3 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n49\n7\n3000010100\n"]}, {"input": "4\n5 2\n2 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1000000000 1000010000\n", "output": ["15\n41\n8\n3000010000\n"]}, {"input": "4\n5 1\n2 2 3 7 5\n9 3\n-5 -10 -15 6 2 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["31\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 0 3 4 9\n9 3\n-5 -18 -15 6 5 8 3 7 4\n5 3\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["25\n44\n11\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 0000000000 1000110000\n", "output": ["30\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n1 2 3 2 2\n9 3\n-14 -18 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["17\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 7\n5 1\n2 3 3 0 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n45\n19\n3000010000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 7 4\n5 1\n4 2 3 5 3\n4 3\n1000000000 1000001000 1000000000 1000010000\n", "output": ["23\n43\n29\n3000010000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 6\n1 2 5 0 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["27\n46\n5\n3000000000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -10 -12 6 14 8 3 7 0\n5 1\n2 2 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n23\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -18 -15 6 0 8 3 7 4\n5 3\n1 2 6 3 4\n4 2\n1000000001 1000000000 1000000000 1000000000\n", "output": ["25\n42\n10\n3000000001\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -15 6 0 8 3 7 4\n5 3\n2 2 3 4 3\n4 3\n1000001000 1000000000 1001000000 1000010000\n", "output": ["13\n39\n8\n3001000000\n"]}, {"input": "4\n5 1\n1 2 3 7 5\n9 3\n-5 -10 -9 6 2 8 3 0 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["29\n32\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 5\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["29\n44\n5\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1000010000\n", "output": ["25\n63\n9\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 3\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1001000000 1000000000 1000110000\n", "output": ["30\n45\n13\n3001000000\n"]}, {"input": "4\n5 1\n1 2 6 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 4\n5 3\n2 2 5 3 2\n4 2\n1000000000 1000100000 1000000000 1000000000\n", "output": ["30\n41\n9\n3000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 4 8 3 12 4\n5 1\n2 2 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n25\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 3\n1000000000 1000000000 1000000000 1010010000\n", "output": ["25\n57\n27\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 8 5\n9 3\n-9 -18 -15 6 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010000000 1000000000\n", "output": ["32\n46\n7\n3010000000\n"]}, {"input": "4\n5 1\n0 2 3 6 5\n9 3\n-5 -10 -12 6 7 8 3 7 0\n5 1\n2 4 2 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["26\n40\n27\n3000010000\n"]}, {"input": "4\n5 2\n1 2 4 4 5\n9 3\n-5 -10 -15 6 -1 8 3 7 0\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["15\n39\n7\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 7 0\n9 3\n-5 -10 -15 6 2 8 3 0 4\n5 3\n2 2 3 8 3\n4 3\n1000000000 1000000001 1000000000 1000010000\n", "output": ["19\n37\n12\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 9\n9 3\n-5 -18 -8 6 5 8 3 7 4\n5 2\n4 2 5 3 3\n4 2\n1000000000 1000000000 1000000010 1000000000\n", "output": ["29\n44\n15\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 6\n9 3\n-5 -10 -15 6 5 8 3 7 5\n5 3\n2 2 3 2 5\n4 3\n1000000000 1000000000 1000010000 1001010000\n", "output": ["26\n41\n9\n3001010000\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -10 -15 10 5 8 3 7 4\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1010110000\n", "output": ["30\n43\n13\n3010110000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 6 5 8 3 7 8\n5 3\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n43\n9\n7000100000\n"]}, {"input": "4\n5 1\n1 2 3 7 2\n9 3\n-14 -18 -13 6 5 8 3 7 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["23\n44\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000100000 1000000000 1000000000 1000010000\n", "output": ["25\n57\n27\n1000100000\n"]}, {"input": "4\n5 1\n1 3 3 4 5\n9 3\n-9 -18 -15 1 5 8 3 7 8\n5 3\n1 2 5 0 2\n4 2\n1000000000 1000000000 1010010000 1000000000\n", "output": ["27\n44\n7\n3010010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -15 6 6 8 3 7 4\n5 3\n1 1 5 3 2\n4 4\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n46\n7\n1001000000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -6 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1000000000 1000000000 1010100000\n", "output": ["16\n35\n8\n3010100000\n"]}, {"input": "4\n5 2\n1 1 3 1 1\n9 3\n-9 -22 -6 6 6 0 3 7 4\n5 3\n1 3 6 0 4\n4 2\n1000000010 1000000000 1000000000 1000000000\n", "output": ["7\n44\n8\n3000000010\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 2\n-5 -10 -25 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["25\n73\n8\n3000010100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -18 -15 6 5 1 3 12 4\n5 1\n2 0 3 5 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n50\n21\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1000010000\n", "output": ["25\n57\n32\n1000010000\n"]}, {"input": "4\n5 1\n1 3 3 11 5\n9 3\n-9 -18 -26 6 6 8 3 7 4\n5 3\n1 1 8 3 2\n4 2\n1001000000 1000000000 1000000000 1000000000\n", "output": ["35\n54\n10\n3001000000\n"]}, {"input": "4\n5 1\n2 1 3 4 1\n9 3\n-9 -18 -6 6 5 8 3 7 4\n5 3\n1 1 6 3 4\n4 2\n1000000000 1001000000 1000000000 1010100000\n", "output": ["18\n44\n8\n3010100000\n"]}, {"input": "4\n5 1\n1 1 3 4 1\n9 3\n-9 -14 -6 6 6 7 3 9 3\n5 3\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["16\n44\n11\n7000000010\n"]}, {"input": "4\n5 2\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010100\n", "output": ["13\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-9 -4 -15 2 1 8 3 7 4\n5 4\n2 2 5 3 2\n4 1\n1000000000 1000100000 1000000000 1000000000\n", "output": ["25\n37\n9\n7000100000\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 3\n-5 -13 -15 6 5 1 3 12 4\n5 1\n1 0 3 5 3\n4 2\n1000000000 1000000000 1000000000 1000010000\n", "output": ["23\n47\n19\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 6\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n57\n32\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000100001 1000000000 1000000000 1000010100\n", "output": ["25\n48\n8\n3000100001\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-7 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000000 1000000010 1010010000\n", "output": ["25\n139\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 0 3 4 1\n9 3\n-9 -10 -6 6 6 7 3 9 3\n5 2\n1 2 7 5 4\n4 1\n1000000010 1000000000 1000000000 1000000000\n", "output": ["14\n40\n17\n7000000010\n"]}, {"input": "4\n5 1\n0 2 3 4 10\n9 3\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000010100\n", "output": ["28\n48\n8\n3000010100\n"]}, {"input": "4\n5 1\n1 2 3 8 5\n9 4\n-5 -6 -15 10 5 8 4 0 0\n5 3\n2 7 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000110000\n", "output": ["30\n35\n13\n3000110000\n"]}, {"input": "4\n5 1\n1 2 3 4 0\n9 6\n-14 -18 -13 6 2 8 6 11 4\n5 3\n4 2 5 3 2\n4 2\n1000000000 1000000000 1000000000 1000000000\n", "output": ["16\n40\n9\n3000000000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 1\n-5 -10 -20 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["25\n140\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 10\n9 5\n-5 -10 -20 6 5 9 1 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000001 1000000000 1000000000 1000000100\n", "output": ["30\n40\n8\n3000000100\n"]}, {"input": "4\n5 1\n0 2 3 4 5\n9 1\n-2 -10 -15 6 7 8 3 14 7\n5 1\n2 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["23\n129\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -6 -15 10 5 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000111000\n", "output": ["27\n43\n13\n1000111000\n"]}, {"input": "4\n5 2\n0 2 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 14 7\n5 1\n4 3 3 5 3\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["11\n135\n31\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 5 5\n9 4\n-5 -4 -15 10 3 8 4 0 4\n5 3\n2 7 3 3 3\n4 5\n1000000000 1000000000 1000000000 1000110000\n", "output": ["27\n41\n13\n1000110000\n"]}, {"input": "4\n5 1\n0 0 3 4 5\n9 1\n-5 -10 -15 6 7 8 3 4 7\n5 1\n4 3 3 5 1\n4 5\n1000000000 1000000001 1000000010 1010010000\n", "output": ["19\n115\n27\n1010010000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 5 4\n5 3\n2 2 5 3 3\n4 2\n1000001000 1000000000 1000000000 1000000000\n", "output": ["25\n41\n9\n3000001000\n"]}, {"input": "4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 3 8 0 7 4\n5 3\n2 2 3 4 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["25\n39\n8\n3000010000\n"]}, {"input": "4\n5 1\n1 2 3 4 2\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 4 3 3 3\n4 3\n1000000000 1000000000 1000000000 1000010000\n", "output": ["20\n41\n10\n3000010000\n"]}], "task_id": "codecontest/47", "prompt": "A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Assume all depot coordinates are distinct and non-negative.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "repair_prompt": ["A total of n depots are located on a number line. Depot i lies at the point x_i for 1 \u2264 i \u2264 n.\n\nYou are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from the origin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.\n\nCalculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. Assume all depot coordinates are distinct and non-negative.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum delivery distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot coordinates.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate positive and negative coordinates\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n\n        # Calculate the total distance\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Find the farthest point to avoid double counting\n        if positive_depots and negative_depots:\n            farthest_point = max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            farthest_point = positive_depots[0]\n        elif negative_depots:\n            farthest_point = negative_depots[0]\n        else:\n            farthest_point = 0\n\n        # Subtract the farthest point once as it is not returned\n        total_distance -= farthest_point\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver goods to depots on a number line.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot positions on the number line.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n\n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n\n        # Calculate the total distance for positive and negative depots\n        total_distance = 0\n\n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n\n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n\n        # Subtract the farthest depot as it is visited only once\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n\n        results.append(total_distance)\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    t = int(data[0])\n    index = 1\n\n    test_cases = []\n    for _ in range(t):\n        n, k = int(data[index]), int(data[index + 1])\n        index += 2\n        depots = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n\n    # Output interface\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver all bags to the depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k, depots in test_cases:\n        # Separate depots into positive and negative positions\n        positive_depots = sorted([d for d in depots if d > 0])\n        negative_depots = sorted([-d for d in depots if d < 0])\n        \n        # Function to calculate total distance for a list of depots\n        def calculate_distance(depots: List[int], k: int) -> int:\n            distance = 0\n            # Process depots in groups of k, starting from the farthest\n            for i in range(len(depots) - 1, -1, -k):\n                distance += 2 * depots[i]  # Round trip to the farthest depot in the group\n            return distance\n        \n        # Calculate total distance for positive and negative depots separately\n        total_distance = calculate_distance(positive_depots, k) + calculate_distance(negative_depots, k)\n        \n        # Add the result for the current test case\n        results.append(total_distance)\n    \n    return results\n\n# Input interface\ndef main():\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    \n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver goods to depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): Positions of depots on a number line.\n\n    Returns:\n        List[int]: Minimum distance for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k, depots in test_cases:\n        # Sort depot positions\n        depots.sort()\n        \n        # Calculate the total distance\n        total_distance = 0\n        i = n - 1\n        \n        while i >= 0:\n            # Deliver to the farthest depot first\n            total_distance += 2 * depots[i]\n            # Move to the next group of depots\n            i -= k\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, call the calculation function, and print results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    \n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    \n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver all goods to the depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n, k, depots = case\n        # Sort the depot positions\n        depots.sort()\n        \n        # Separate depots into positive and negative\n        positive_depots = [d for d in depots if d > 0]\n        negative_depots = [-d for d in depots if d < 0]\n        \n        # Sort negative depots in descending order to handle them as positive distances\n        negative_depots.sort(reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n        \n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n        \n        # Subtract the farthest depot distance as it doesn't need to be returned\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n        \n        results.append(total_distance)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    \n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport sys\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver to all depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of depots that can be visited in one trip.\n            - x (List[int]): List of depot coordinates.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k, x in test_cases:\n        # Separate positive and negative coordinates\n        positive = sorted([coord for coord in x if coord > 0])\n        negative = sorted([-coord for coord in x if coord < 0])\n        \n        # Calculate the distance for positive and negative separately\n        def calculate_distance(coords: List[int], k: int) -> int:\n            distance = 0\n            while coords:\n                # Take the farthest point in the current batch\n                distance += 2 * coords[-1]\n                # Remove up to k depots from the list\n                coords = coords[:-k]\n            return distance\n        \n        # Calculate total minimum distance\n        total_distance = calculate_distance(positive, k) + calculate_distance(negative, k)\n        \n        # Consider the farthest point only once\n        if positive and negative:\n            total_distance -= max(positive[-1], negative[-1])\n        elif positive:\n            total_distance -= positive[-1]\n        elif negative:\n            total_distance -= negative[-1]\n        \n        results.append(total_distance)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input and output the results.\"\"\"\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, k = map(int, data[index].split())\n        x = list(map(int, data[index + 1].split()))\n        test_cases.append((n, k, x))\n        index += 2\n    \n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver goods to depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of bags that can be carried at once.\n            - depots (List[int]): List of depot positions on a number line.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n, k, depots = case\n        depots.sort()\n        \n        # Separate depots into positive and negative\n        positive_depots = [d for d in depots if d > 0]\n        negative_depots = [-d for d in depots if d < 0]\n        negative_depots.sort()\n        \n        total_distance = 0\n        \n        # Calculate distance for positive depots\n        for i in range(len(positive_depots) - 1, -1, -k):\n            total_distance += 2 * positive_depots[i]\n        \n        # Calculate distance for negative depots\n        for i in range(len(negative_depots) - 1, -1, -k):\n            total_distance += 2 * negative_depots[i]\n        \n        # Subtract the farthest depot as it doesn't need to be returned to the origin\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[-1], negative_depots[-1])\n        elif positive_depots:\n            total_distance -= positive_depots[-1]\n        elif negative_depots:\n            total_distance -= negative_depots[-1]\n        \n        results.append(total_distance)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    \n    # Call the function and print results\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum distance required to deliver goods to depots.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of depots.\n            - k (int): Carrying capacity.\n            - depots (List[int]): List of depot coordinates.\n\n    Returns:\n        List[int]: List of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k, depots in test_cases:\n        # Separate positive and negative coordinates\n        positive_depots = sorted([d for d in depots if d > 0])\n        negative_depots = sorted([-d for d in depots if d < 0])\n        \n        # Calculate distance for positive depots\n        positive_distance = 0\n        for i in range(len(positive_depots) - 1, -1, -k):\n            positive_distance += 2 * positive_depots[i]\n        \n        # Calculate distance for negative depots\n        negative_distance = 0\n        for i in range(len(negative_depots) - 1, -1, -k):\n            negative_distance += 2 * negative_depots[i]\n        \n        # Total minimum distance is the sum of positive and negative distances\n        # minus the largest single trip (either positive or negative)\n        total_distance = positive_distance + negative_distance\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[-1], negative_depots[-1])\n        elif positive_depots:\n            total_distance -= positive_depots[-1]\n        elif negative_depots:\n            total_distance -= negative_depots[-1]\n        \n        results.append(total_distance)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport sys\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum delivery distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Number of depots to select.\n            - depots (List[int]): List of depot coordinates.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n    for n, k, depots in test_cases:\n        # Sort the depot coordinates\n        depots.sort()\n        \n        # Initialize the minimum distance to a large number\n        min_distance = float('inf')\n        \n        # Iterate over possible selections of k depots\n        for i in range(n - k + 1):\n            # Calculate the distance for the current selection\n            current_distance = depots[i + k - 1] - depots[i]\n            # Update the minimum distance if the current one is smaller\n            min_distance = min(min_distance, current_distance)\n        \n        # Append the result for the current test case\n        results.append(min_distance)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    input_data = sys.stdin.read().split()\n    index = 0\n    t = int(input_data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(t):\n        n, k = int(input_data[index]), int(input_data[index + 1])\n        index += 2\n        depots = list(map(int, input_data[index:index + n]))\n        index += n\n        test_cases.append((n, k, depots))\n    \n    results = calculate_minimum_distance(t, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef calculate_minimum_distance(t: int, test_cases: List[tuple]) -> List[int]:\n    \"\"\"Calculate the minimum travel distance for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of depots.\n            - k (int): Maximum number of depots that can be visited in one trip.\n            - depots (List[int]): List of depot positions.\n\n    Returns:\n        List[int]: A list of minimum distances for each test case.\n    \"\"\"\n    results = []\n    \n    for n, k, depots in test_cases:\n        # Separate positive and negative depots\n        positive_depots = sorted([d for d in depots if d > 0], reverse=True)\n        negative_depots = sorted([-d for d in depots if d < 0], reverse=True)\n        \n        # Calculate the total distance\n        total_distance = 0\n        \n        # Process positive depots\n        for i in range(0, len(positive_depots), k):\n            total_distance += 2 * positive_depots[i]\n        \n        # Process negative depots\n        for i in range(0, len(negative_depots), k):\n            total_distance += 2 * negative_depots[i]\n        \n        # Adjust for the last trip (no return to origin)\n        if positive_depots and negative_depots:\n            total_distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            total_distance -= positive_depots[0]\n        elif negative_depots:\n            total_distance -= negative_depots[0]\n        \n        results.append(total_distance)\n    \n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        depots = list(map(int, input().split()))\n        test_cases.append((n, k, depots))\n    \n    # Output interface\n    results = calculate_minimum_distance(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle multiple test cases and large input sizes, ensuring optimal performance.\nrequirement pool:\n- Implement an algorithm to calculate the minimum delivery distance.\n- Ensure the solution can handle up to 2 \u22c5 10^5 depots efficiently.\n- Optimize the algorithm for both positive and negative depot coordinates.\n- Provide clear and concise output for each test case.\n- Consider edge cases such as all depots at the same location.\nWe will implement an algorithm that calculates the minimum delivery distance by sorting the depot coordinates and grouping them based on the maximum number of bags that can be carried at once. The algorithm will handle both positive and negative coordinates separately to ensure optimal travel distance. We will use Python's built-in sorting and list manipulation capabilities to efficiently manage the data.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots located on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and multiple test cases, ensuring optimal route calculation.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum distance for deliveries.\n- Ensure the solution can handle up to 10,500 test cases efficiently.\n- Optimize the algorithm for large datasets to minimize computational time.\n- Provide clear and concise output for each test case.\n- Consider edge cases such as depots with the same position.\nWe will implement a function to calculate the minimum distance required to deliver goods to depots on a number line. The function will handle multiple test cases efficiently by sorting depot positions and grouping deliveries based on the maximum number of bags that can be carried at once. We will use Python's built-in sorting and list manipulation capabilities to optimize the solution for large datasets.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle large inputs and provide accurate results for both positive and negative coordinates.\nrequirement pool:\n- Implement the main algorithm to calculate minimum distance.\n- Optimize the algorithm for large input sizes.\n- Ensure the algorithm handles both positive and negative coordinates.\n- Provide clear input and output handling for multiple test cases.\n- Develop a user-friendly interface for input and output.\nWe will implement a function to calculate the minimum distance required to deliver all bags to the depots. The approach involves sorting the depot positions, dividing them into groups based on the maximum number of bags that can be carried at once, and calculating the total distance by considering the farthest depot in each group. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle large inputs. The solution will account for both positive and negative coordinates by treating them separately and summing the distances.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots located on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and provide accurate results for both positive and negative coordinates.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum distance.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles both positive and negative coordinates.\n- Provide clear and concise output for each test case.\n- Enhance user experience with detailed documentation.\nWe will implement a function to calculate the minimum distance required to deliver goods to depots on a number line. The function will handle multiple test cases and efficiently manage large input sizes by sorting the depot positions and grouping them based on the maximum number of bags that can be carried at once. We will use Python's built-in sorting and list manipulation capabilities to achieve this.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line. The key challenge is optimizing the route given the constraint of carrying a limited number of bags at a time. The solution must efficiently handle large input sizes and multiple test cases.\nrequirement pool:\n- Implement the main algorithm to calculate minimum distance.\n- Ensure the solution handles up to 10,500 test cases efficiently.\n- Optimize the algorithm for large input sizes.\n- Provide clear and correct output for each test case.\n- Consider edge cases such as all depots at the same location.\nWe will implement a function to calculate the minimum distance required to deliver all goods to the depots. The approach involves sorting the depot positions, grouping them based on the maximum number of bags that can be carried at once, and calculating the total distance by considering the farthest depot in each group. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle the input size constraints.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line. The key challenges include handling both positive and negative coordinates, optimizing the number of trips based on the carrying capacity, and ensuring the solution is efficient for large input sizes.\nrequirement pool:\n- Implement the main algorithm to calculate minimum distance\n- Optimize the algorithm for large input sizes\n- Ensure the algorithm handles both positive and negative coordinates\n- Test the algorithm against all edge cases\n- Document the solution and provide usage examples\nWe will implement an algorithm that sorts the depot coordinates and calculates the minimum distance by grouping the depots into batches of size k. The algorithm will handle both positive and negative coordinates separately to ensure efficient delivery. We will use Python's built-in sorting and list manipulation capabilities to achieve this efficiently.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line, considering the constraint of carrying a limited number of bags at a time. The solution must efficiently handle large input sizes and provide accurate results.\nrequirement pool:\n- Implement the main algorithm to calculate the minimum distance.\n- Ensure the solution handles up to 2 \u22c5 10^5 depots efficiently.\n- Optimize the algorithm for both positive and negative coordinates.\n- Provide clear documentation and comments in the code.\n- Include test cases to validate the solution.\nWe will implement a function to calculate the minimum distance required to deliver goods to depots on a number line. The approach involves sorting the depot positions, grouping them based on the maximum number of bags that can be carried at once, and calculating the total distance by considering the farthest depot in each group. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle the input size constraints.\n", "requirement analysis:\nThe requirements focus on calculating the minimum distance for delivering goods to depots with constraints on carrying capacity. The solution must handle multiple test cases efficiently and ensure scalability for large inputs.\nrequirement pool:\n- Optimize delivery route for minimum distance\n- Handle large number of depots efficiently\n- Ensure accurate calculations\n- Provide easy-to-use interface\n- Support for negative depot coordinates\nWe will implement a function to calculate the minimum distance required to deliver goods to depots. The function will handle multiple test cases efficiently by sorting the depot coordinates and grouping them based on the carrying capacity. We will use Python's built-in sorting and list manipulation capabilities to achieve this. The solution will account for both positive and negative coordinates, treating them symmetrically in terms of distance calculation.\n", "requirement analysis:\nThe requirements focus on calculating the minimum distance for delivering goods to depots on a number line. The solution must handle multiple test cases efficiently, considering constraints on the number of depots and the capacity of bags carried at once. The algorithm should be optimized for performance and accuracy, especially with large input sizes.\nrequirement pool:\n- Implement efficient algorithm to calculate minimum delivery distance\n- Ensure solution handles up to 10,500 test cases\n- Optimize for large input sizes up to 2 \u22c5 10^5 depots\n- Provide clear and accurate output for each test case\n- Maintain code readability and ease of maintenance\nWe will implement an efficient algorithm to calculate the minimum delivery distance using sorting and grouping of depot coordinates. The algorithm will handle multiple test cases and optimize for large input sizes by leveraging Python's built-in sorting capabilities.\n", "requirement analysis:\nThe problem requires calculating the minimum distance to deliver goods to depots on a number line. The salesman can carry a limited number of bags at a time, necessitating multiple trips. The solution must efficiently handle large input sizes and multiple test cases, ensuring minimal travel distance.\nrequirement pool:\n- Implement an algorithm to calculate the minimum travel distance.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles multiple test cases efficiently.\n- Consider edge cases such as overlapping depot positions.\n- Provide detailed documentation and examples for users.\nWe will implement an algorithm that sorts the depot positions and calculates the minimum travel distance by grouping the depots into batches of size k. The algorithm will handle both positive and negative depot positions by treating them symmetrically, ensuring that the salesman always returns to the origin after delivering each batch, except for the last trip. We will use Python's built-in sorting and list manipulation capabilities to efficiently handle large input sizes.\n"], "scores": [], "pass_results": [true, true, false, true, true, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 52, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10 500). Description of the test cases follows.\n\nThe first line of each test case contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line of each test case contains n integers x_1, x_2, \u2026, x_n (-10^9 \u2264 x_i \u2264 10^9). It is possible that some depots share the same position.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case, output a single integer denoting the minimum distance you need to cover to deliver all the bags of goods to the depots. \n\nExample\n\nInput\n\n\n4\n5 1\n1 2 3 4 5\n9 3\n-5 -10 -15 6 5 8 3 7 4\n5 3\n2 2 3 3 3\n4 2\n1000000000 1000000000 1000000000 1000000000\n\n\nOutput\n\n\n25\n41\n7\n3000000000\n\nNote\n\nIn the first test case, you can carry only one bag at a time. Thus, the following is a solution sequence that gives a minimum travel distance: 0 \u2192 2 \u2192 0 \u2192 4 \u2192 0 \u2192 3 \u2192 0 \u2192 1 \u2192 0 \u2192 5, where each 0 means you go the origin and grab one bag, and each positive integer means you deliver the bag to a depot at this coordinate, giving a total distance of 25 units. It must be noted that there are other sequences that give the same distance.\n\nIn the second test case, you can follow the following sequence, among multiple such sequences, to travel minimum distance: 0 \u2192 6 \u2192 8 \u2192 7 \u2192 0 \u2192 5 \u2192 4 \u2192 3 \u2192 0 \u2192 (-5) \u2192 (-10) \u2192 (-15), with distance 41. It can be shown that 41 is the optimal distance for this test case.", "mutate_method": "add_1_sentence_at_end", "parent_index": 8}
