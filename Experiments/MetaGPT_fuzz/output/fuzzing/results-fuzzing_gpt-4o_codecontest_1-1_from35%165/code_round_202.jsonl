{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows:\n\n1. First, the center cell (i, j) is painted black. The central cell can be considered as the starting point of the tick.  \n2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells.\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows:\n\n1. First, the center cell (i, j) is painted black. The central cell can be considered as the starting point of the tick.  \n2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells.\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_draw_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a checkered field can be obtained by drawing ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The grid representation as a list of strings.\n\n    Returns:\n        List[str]: A list of \"YES\" or \"NO\" for each test case indicating if the ticks can be drawn.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark the cells that can be part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a valid tick\n        for i in range(k, n):\n            for j in range(k, m - k):\n                if field[i][j] == '*' and all(\n                    field[i - d][j - d] == '*' and field[i - d][j + d] == '*' for d in range(1, k + 1)\n                ):\n                    # Mark the cells of the tick\n                    for d in range(k + 1):\n                        marked[i - d][j - d] = True\n                        marked[i - d][j + d] = True\n\n        # Verify if all '*' in the field are part of a tick\n        can_draw = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    can_draw = False\n                    break\n            if not can_draw:\n                break\n\n        results.append(\"YES\" if can_draw else \"NO\")\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n\n    # Output interface\n    results = can_draw_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if each grid can be formed by ticks of size at least k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that can be part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if this cell can be the center of a tick of size at least k\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                            grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' cells are covered by valid ticks\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        grid = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, grid))\n        index += n + 1\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef can_form_ticks(t: int, test_cases: list[tuple[int, int, int, list[str]]]) -> list[str]:\n    \"\"\"Determines if all black cells in each test case can be part of valid ticks.\n\n    Args:\n        t: The number of test cases.\n        test_cases: A list of tuples, each containing:\n            - n: Number of rows in the field.\n            - m: Number of columns in the field.\n            - k: Minimum size of the tick.\n            - field: A list of strings representing the field.\n\n    Returns:\n        A list of strings, each being 'YES' or 'NO' for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell is part of a valid tick\n        tick_formed = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the field\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick can be formed with center at (i, j)\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n\n                    # If the tick size is at least k, mark the cells as part of a tick\n                    if size > k:\n                        for s in range(size):\n                            tick_formed[i - s][j - s] = True\n                            tick_formed[i - s][j + s] = True\n\n        # Check if all '*' cells are part of a valid tick\n        all_ticks_formed = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_formed[i][j]:\n                    all_ticks_formed = False\n                    break\n            if not all_ticks_formed:\n                break\n\n        results.append('YES' if all_ticks_formed else 'NO')\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = data[index+1:index+1+n]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a checkered field can be obtained by drawing ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The grid represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark the cells that can be part of a tick\n        tick_possible = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    size -= 1  # Adjust size to the maximum possible tick size\n\n                    if size >= k:\n                        # Mark the cells that can be part of a tick\n                        for s in range(size + 1):\n                            tick_possible[i - s][j - s] = True\n                            tick_possible[i - s][j + s] = True\n\n        # Verify if all '*' in the field can be part of a tick\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_possible[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if all black cells in the field can be part of valid ticks.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either 'YES' or 'NO'.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a grid to mark valid tick cells\n        valid_tick_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed\n                    if can_form_tick(i, j, k, n, m, field, valid_tick_grid):\n                        mark_tick(i, j, k, valid_tick_grid)\n\n        # Check if all black cells are part of valid ticks\n        if all(field[i][j] == '.' or valid_tick_grid[i][j] for i in range(n) for j in range(m)):\n            results.append('YES')\n        else:\n            results.append('NO')\n\n    return results\n\ndef can_form_tick(i: int, j: int, k: int, n: int, m: int, field: List[str], valid_tick_grid: List[List[bool]]) -> bool:\n    \"\"\"Checks if a tick of size k can be formed starting from (i, j).\n\n    Args:\n        i (int): Row index of the starting cell.\n        j (int): Column index of the starting cell.\n        k (int): Minimum size of the tick.\n        n (int): Number of rows in the field.\n        m (int): Number of columns in the field.\n        field (List[str]): The field represented as a list of strings.\n        valid_tick_grid (List[List[bool]]): Grid to mark valid tick cells.\n\n    Returns:\n        bool: True if a tick can be formed, False otherwise.\n    \"\"\"\n    # Check if there is enough space to form a tick of size k\n    if i - k < 0 or j - k < 0 or j + k >= m:\n        return False\n\n    # Check if the cells form a valid tick\n    for d in range(1, k + 1):\n        if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n            return False\n\n    return True\n\ndef mark_tick(i: int, j: int, k: int, valid_tick_grid: List[List[bool]]) -> None:\n    \"\"\"Marks the cells of a valid tick starting from (i, j).\n\n    Args:\n        i (int): Row index of the starting cell.\n        j (int): Column index of the starting cell.\n        k (int): Size of the tick.\n        valid_tick_grid (List[List[bool]]): Grid to mark valid tick cells.\n    \"\"\"\n    # Mark the center of the tick\n    valid_tick_grid[i][j] = True\n\n    # Mark the arms of the tick\n    for d in range(1, k + 1):\n        valid_tick_grid[i - d][j - d] = True\n        valid_tick_grid[i - d][j + d] = True\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if a checkered field can be obtained by drawing ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): Each test case contains:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The grid representation.\n\n    Returns:\n        List[str]: \"YES\" if the field can be formed by ticks of at least size k, otherwise \"NO\".\n    \"\"\"\n    def is_valid_tick_center(x: int, y: int, k: int, field: List[str]) -> bool:\n        \"\"\"Check if a cell can be the center of a valid tick of size at least k.\n\n        Args:\n            x (int): Row index of the potential tick center.\n            y (int): Column index of the potential tick center.\n            k (int): Minimum size of the tick.\n            field (List[str]): The grid representation.\n\n        Returns:\n            bool: True if the cell can be the center of a valid tick, False otherwise.\n        \"\"\"\n        # Check if there is enough space for a tick of size k\n        for size in range(1, k + 1):\n            if (x - size < 0 or y - size < 0 or y + size >= len(field[0]) or\n                field[x - size][y - size] != '*' or field[x - size][y + size] != '*'):\n                return False\n        return True\n\n    def mark_tick(x: int, y: int, k: int, field: List[List[str]]) -> None:\n        \"\"\"Mark the cells of a valid tick starting from the center.\n\n        Args:\n            x (int): Row index of the tick center.\n            y (int): Column index of the tick center.\n            k (int): Size of the tick.\n            field (List[List[str]]): The grid representation.\n        \"\"\"\n        field[x][y] = '.'\n        for size in range(1, k + 1):\n            field[x - size][y - size] = '.'\n            field[x - size][y + size] = '.'\n\n    results = []\n    for n, m, k, field in test_cases:\n        # Convert field to a mutable list of lists\n        mutable_field = [list(row) for row in field]\n        possible = True\n\n        # Traverse the grid from bottom to top\n        for x in range(n - 1, -1, -1):\n            for y in range(m):\n                if mutable_field[x][y] == '*':\n                    if is_valid_tick_center(x, y, k, mutable_field):\n                        mark_tick(x, y, k, mutable_field)\n                    else:\n                        possible = False\n                        break\n            if not possible:\n                break\n\n        # Check if all '*' are part of valid ticks\n        for row in mutable_field:\n            if '*' in row:\n                possible = False\n                break\n\n        results.append(\"YES\" if possible else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if each field can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a grid to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a valid tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n\n                    # If a valid tick of at least size k is found, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the field are covered by valid ticks\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().strip().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a checkered field can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): Representation of the field as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Initialize a grid to track tick formation\n        tick_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if can_form_tick(i, j, n, m, k, field, tick_grid):\n                        mark_tick(i, j, k, tick_grid)\n\n        # Verify if all '*' in the field are part of a tick\n        if all(field[i][j] == '.' or tick_grid[i][j] for i in range(n) for j in range(m)):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef can_form_tick(i: int, j: int, n: int, m: int, k: int, field: List[str], tick_grid: List[List[bool]]) -> bool:\n    \"\"\"Check if a tick of size k can be formed with (i, j) as the center.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        n (int): Number of rows in the field.\n        m (int): Number of columns in the field.\n        k (int): Minimum size of the tick.\n        field (List[str]): Representation of the field.\n        tick_grid (List[List[bool]]): Grid to track tick formation.\n\n    Returns:\n        bool: True if a tick can be formed, False otherwise.\n    \"\"\"\n    size = 0\n    while True:\n        # Check bounds and if the tick can extend\n        if (i - size >= 0 and j - size >= 0 and j + size < m and\n            field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n            size += 1\n        else:\n            break\n\n    return size >= k\n\ndef mark_tick(i: int, j: int, k: int, tick_grid: List[List[bool]]) -> None:\n    \"\"\"Mark the cells of a tick of size k in the tick grid.\n\n    Args:\n        i (int): Row index of the center.\n        j (int): Column index of the center.\n        k (int): Size of the tick.\n        tick_grid (List[List[bool]]): Grid to track tick formation.\n    \"\"\"\n    for size in range(k):\n        tick_grid[i - size][j - size] = True\n        tick_grid[i - size][j + size] = True\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().split('\\n')\nt = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(t):\n    n, m, k = map(int, data[index].split())\n    field = [data[index + i + 1] for i in range(n)]\n    test_cases.append((n, m, k, field))\n    index += n + 1\n\n# Output interface\nresults = can_form_ticks(t, test_cases)\nfor result in results:\n    print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a checkered field can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): Each test case is a tuple containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The grid represented as a list of strings.\n\n    Returns:\n        List[str]: A list of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Function to check if a tick can be formed centered at (i, j)\n        def can_form_tick(i: int, j: int) -> bool:\n            length = 0\n            while True:\n                if i - length < 0 or j - length < 0 or j + length >= m:\n                    break\n                if field[i - length][j - length] != '*' or field[i - length][j + length] != '*':\n                    break\n                length += 1\n            return length > k\n\n        # Mark all possible ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and can_form_tick(i, j):\n                    length = 0\n                    while True:\n                        if i - length < 0 or j - length < 0 or j + length >= m:\n                            break\n                        if field[i - length][j - length] != '*' or field[i - length][j + length] != '*':\n                            break\n                        marked[i - length][j - length] = True\n                        marked[i - length][j + length] = True\n                        length += 1\n\n        # Check if all '*' are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if all '*' in each test case can form valid ticks of size at least k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): Each test case is a tuple containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The field represented as a list of strings.\n\n    Returns:\n        List[str]: A list of 'YES' or 'NO' for each test case indicating if all '*' can form valid ticks.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark the cells that can be part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to find potential tick centers\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if can_form_tick(i, j, n, m, k, field, marked):\n                        mark_tick(i, j, k, marked)\n\n        # Verify if all '*' are part of a valid tick\n        if all(field[i][j] == '*' and marked[i][j] for i in range(n) for j in range(m) if field[i][j] == '*'):\n            results.append('YES')\n        else:\n            results.append('NO')\n\n    return results\n\ndef can_form_tick(i: int, j: int, n: int, m: int, k: int, field: List[str], marked: List[List[bool]]) -> bool:\n    \"\"\"Check if a tick of size k can be formed with (i, j) as the center.\n\n    Args:\n        i (int): Row index of the potential tick center.\n        j (int): Column index of the potential tick center.\n        n (int): Number of rows in the field.\n        m (int): Number of columns in the field.\n        k (int): Minimum size of the tick.\n        field (List[str]): The field represented as a list of strings.\n        marked (List[List[bool]]): 2D list to mark cells that can be part of a valid tick.\n\n    Returns:\n        bool: True if a tick of size k can be formed, False otherwise.\n    \"\"\"\n    # Check if there are enough '*' diagonally to form a tick of size k\n    for d in range(1, k + 1):\n        if i - d < 0 or j - d < 0 or j + d >= m:\n            return False\n        if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n            return False\n    return True\n\ndef mark_tick(i: int, j: int, k: int, marked: List[List[bool]]):\n    \"\"\"Mark the cells that are part of a valid tick.\n\n    Args:\n        i (int): Row index of the tick center.\n        j (int): Column index of the tick center.\n        k (int): Size of the tick.\n        marked (List[List[bool]]): 2D list to mark cells that can be part of a valid tick.\n    \"\"\"\n    # Mark the center of the tick\n    marked[i][j] = True\n    # Mark the diagonals of the tick\n    for d in range(1, k + 1):\n        marked[i - d][j - d] = True\n        marked[i - d][j + d] = True\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirements focus on determining if a given checkered field can be obtained by drawing ticks of a specified minimum size. The solution must handle multiple test cases efficiently and provide accurate results for each case. Edge cases, such as fields with no ticks or fields with ticks smaller than the minimum size, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test cases\n- Handle edge cases gracefully\n- Ensure output clarity\n- Improve performance for large inputs\nWe will implement a function to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. We will use a simple nested loop to traverse the grid and check the conditions for each potential tick center. The solution will be optimized for multiple test cases by processing each test case independently and efficiently.\n", "requirement analysis:\nThe problem requires determining if a given checkered field can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases, each with a grid size of up to 10x19. The key challenge is to verify the possibility of forming the given pattern with the constraints provided.\nrequirement pool:\n- Implement the main logic to check if the field can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will iterate over each test case and for each grid, we will attempt to identify if the given pattern can be formed by ticks of size at least k. The approach involves checking each '*' cell to see if it can be the center of a tick of size at least k. We will use a greedy approach to mark cells that can be part of a valid tick and then verify if all '*' cells are covered by these ticks.\n", "requirement analysis:\nThe problem requires determining if a given field can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, ensuring that all black cells can be part of valid ticks. The constraints are manageable, but edge cases such as minimal field sizes and maximum tick sizes need careful handling.\nrequirement pool:\n- Implement the main logic to determine if the field can be formed by ticks.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed comments and documentation for the code.\n- Consider edge cases and test thoroughly.\nWe will implement a function that checks if the given field can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the field, and for each black cell ('*'), it will attempt to form a tick centered at that cell. The tick formation will be validated by checking the diagonals up to the required size k. If all black cells can be part of valid ticks, the function will return 'YES', otherwise 'NO'. We will use simple list operations and loops to achieve this, ensuring the solution is efficient given the constraints.\n", "requirement analysis:\nThe requirements focus on determining if a given checkered field can be obtained by drawing ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results. Edge cases, such as small grid sizes and varying tick sizes, must be considered to ensure robustness.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test cases\n- Handle edge cases gracefully\n- Ensure clear output format\n- Improve algorithm performance\nWe will implement a function to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. We will use simple loops and condition checks to ensure the tick can be formed without exceeding grid boundaries. The solution will be optimized for multiple test cases by processing each test case independently and efficiently.\n", "requirement analysis:\nThe problem requires determining if a given field can be formed by drawing ticks of a minimum size k. The solution must efficiently check each test case, ensuring that all black cells can be part of valid ticks. Edge cases include small fields and fields with no ticks.\nrequirement pool:\n- Implement the main logic to check if the field can be formed by ticks of size at least k.\n- Optimize the solution to handle maximum input sizes efficiently.\n- Ensure the output format is consistent and clear for each test case.\n- Handle edge cases such as small fields and fields with no ticks.\n- Maintain code readability and simplicity for future maintenance.\nWe will implement a function that checks if a given field can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, and for each black cell ('*'), it will attempt to form a tick of size at least k. If a tick can be formed, it will mark the cells as part of a valid tick. The solution will ensure that all black cells are part of valid ticks, otherwise, it will return 'NO'. The approach will efficiently handle the constraints by using a grid traversal technique.\n", "requirement analysis:\nThe requirements focus on determining if a given checkered field can be obtained by drawing ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results for each. Edge cases, such as fields with no ticks or fields with isolated black cells, must be considered.\nrequirement pool:\n- Implement tick detection algorithm\n- Optimize for multiple test cases\n- Handle edge cases gracefully\n- Ensure output clarity\n- Maintain code readability\nWe will implement a function to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. We will use a simple nested loop to traverse the grid and a helper function to verify tick validity. The solution will be optimized for multiple test cases by processing each test case independently and efficiently.\n", "requirement analysis:\nThe problem requires determining if a given field can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases with fields as large as 10x19. The key challenge is to correctly identify valid tick formations and ensure all black cells can be explained by these ticks.\nrequirement pool:\n- Efficiently process up to 100 test cases.\n- Correctly identify and validate tick formations.\n- Ensure output is consistent and easy to understand.\n- Handle edge cases where ticks overlap or are minimal.\n- Maintain code readability and simplicity.\nWe will implement a function to determine if a given field can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. If a cell is part of a tick, it will be marked as such, and we will ensure all '*' cells are covered by valid ticks. The solution will efficiently handle up to 100 test cases with fields as large as 10x19 by using a direct simulation approach.\n", "requirement analysis:\nThe problem requires determining if a given checkered field can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases with fields as large as 10x19. The key challenge is to verify the possibility of forming the field with the given constraints.\nrequirement pool:\n- Implement the main logic to check if the field can be formed with ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will implement a function to determine if a given checkered field can be formed by drawing ticks of a minimum size k. The approach involves iterating over each cell in the grid and checking if it can be the center of a tick of size at least k. We will use a simple nested loop to traverse the grid and verify the tick conditions. The solution will be efficient enough to handle the maximum constraints due to the small grid size.\n", "requirement analysis:\nThe problem requires determining if a given checkered field can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases, with each field having dimensions up to 10x19. The key challenge is to verify if all '*' cells can be part of valid ticks of size at least k.\nrequirement pool:\n- Implement the main logic to check if the field can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will implement a function that checks if a given checkered field can be formed by drawing ticks of a minimum size k. The approach involves iterating over each cell in the grid and attempting to form a tick centered at that cell. If a tick can be formed, we mark the cells as part of a tick. We use a simple nested loop to check the conditions for forming a tick and ensure that all '*' cells are part of valid ticks.\n", "requirement analysis:\nThe problem requires determining if a given checkered field can be formed by drawing ticks of a minimum size k. The solution must efficiently handle up to 100 test cases, with each field having dimensions up to 10x19. The key challenge is to verify the possibility of forming the field with the given constraints, ensuring that all black cells can be part of valid ticks.\nrequirement pool:\n- Implement the main logic to determine if the field can be formed by ticks of size at least k.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is easy to understand and maintain.\n- Provide detailed comments and documentation for the code.\n- Include additional test cases to cover edge scenarios.\nWe will iterate over each test case and for each field, we will attempt to identify all possible ticks of size at least k. We will use a greedy approach to mark potential tick centers and verify if they can form valid ticks by checking the required diagonal cells. If all '*' cells can be part of valid ticks, we return 'YES', otherwise 'NO'. This approach ensures that we efficiently handle the constraints of the problem.\n"], "scores": [], "pass_results": [true, false, true, true, true, false, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 202, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "expand_one2two", "parent_index": 1}
