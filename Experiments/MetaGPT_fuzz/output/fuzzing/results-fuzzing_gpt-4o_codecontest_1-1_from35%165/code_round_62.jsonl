{"name": "1622_B. Berland Music", "description": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n  * the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); \n  * every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). \n\n\n\nAmong all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.\n\nPrint the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "tags": ["data structures", "greedy", "math", "sortings"], "difficulty": 8, "id": 1622, "sample_io": [{"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}], "test_list": [{"input": "1\n7\n1 2 3 4 5 6 7\n0101010\n", "output": ["1 5 2 6 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n50\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n10101010101010101010101010101010101010101010101010\n", "output": ["26 1 27 2 28 3 29 4 30 5 31 6 32 7 33 8 34 9 35 10 36 11 37 12 38 13 39 14 40 15 41 16 42 17 43 18 44 19 45 20 46 21 47 22 48 23 49 24 50 25\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 5 2 6 3 4 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n3 1 2\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["2 1\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101010\n", "output": ["4 5 1 6 2 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 1 2\n1 6 5 8 2 7 4 3\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1101000\n", "output": ["5 6 1 7 2 3 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n3 1 2\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110001\n", "output": ["2 1\n1 6 2 7 3 4 5\n5 6 4 8 2 1 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n1 2 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n3 2 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 1 3\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100010\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 7 5\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 6 2 7 3 4 5\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["2 1\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110011\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 5 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01100100\n", "output": ["2 1\n3 2 1\n1 7 6 5 2 8 4 3\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n1 2 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 5 2 6 3 4 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 1 6 2 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111001\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 1 2 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n1 2 3\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n1 4 2 5 6 3 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n00010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001000\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 7 4 5 6\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111011\n", "output": ["2 1\n1 6 2 7 3 4 5\n3 4 2 8 5 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 2 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 5 6 7 2 3 4\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n4 5 6 7 1 2 3\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n11111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n2 3 1 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110100\n", "output": ["2 1\n3 2 1\n5 6 4 8 1 7 3 2\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n2 3 1\n4 5 3 8 6 1 2 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1001000\n", "output": ["6 1 2 7 3 4 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00100001\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 7 6 4 3 5 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n01110100\n", "output": ["2 1\n2 3 1\n1 6 5 8 2 7 4 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01111111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 3 2 8 5 4 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 5 2 6 3 7 4\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n3 2 1\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111000\n8\n2 3 1 8 5 4 7 6\n11110111\n", "output": ["2 1\n1 5 6 7 2 3 4\n3 4 2 8 1 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n11010010\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 6 1 8 3 2 7 4\n"]}, {"input": "3\n2\n2 1\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111010\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 4 5 6 1 7 2\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 4 5 6 7 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101000\n8\n2 3 1 8 5 4 7 6\n01110111\n", "output": ["2 1\n1 6 2 7 3 4 5\n1 4 3 8 2 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01111101\n", "output": ["2 1\n3 2 1\n1 4 3 8 6 5 2 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n2 3 4 5 6 1 7\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101010\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 5 2 6 3 7 4\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0110000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 6 7 2 3 4 5\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n001\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n2 1 3\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01111001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 5 4 8 6 2 3 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 4 2 5 6 7 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0001010\n8\n2 3 1 8 5 4 7 6\n00010001\n", "output": ["2 1\n1 2 3 6 4 7 5\n2 3 1 8 5 4 6 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n010\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n2 3 1\n4 5 3 8 1 6 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110110\n", "output": ["2 1\n3 2 1\n1 5 4 8 2 6 7 3\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101000\n8\n2 3 1 8 5 4 7 6\n10010011\n", "output": ["2 1\n5 6 1 7 2 3 4\n5 2 1 8 4 3 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 2 1\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010011\n", "output": ["2 1\n3 1 2\n4 5 1 8 3 2 7 6\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n00110001\n", "output": ["2 1\n3 2 1\n1 2 6 8 4 3 5 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n011\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 2 3\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100001\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n1 6 2 3 4 5 7\n1 6 5 8 3 2 4 7\n"]}, {"input": "1\n7\n1 2 3 4 5 6 7\n1100010\n", "output": ["5 6 1 2 3 7 4\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0111010\n8\n2 3 1 8 5 4 7 6\n00110111\n", "output": ["2 1\n1 4 5 6 2 7 3\n1 2 4 8 3 5 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111000\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n4 5 6 7 1 2 3\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n10010000\n", "output": ["2 1\n1 4 2 5 3 6 7\n7 2 1 8 4 3 6 5\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1101110\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 4 1 5 6 7 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n110\n8\n2 3 1 8 5 4 7 6\n11110110\n", "output": ["2 1\n3 2 1\n4 5 3 8 1 6 7 2\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11100101\n", "output": ["1 2\n3 1 2\n5 6 4 3 1 7 2 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n1111100\n8\n2 3 1 8 5 4 7 6\n11000011\n", "output": ["2 1\n3 4 5 6 7 1 2\n5 6 1 4 3 2 8 7\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101011\n8\n2 3 1 8 5 4 7 6\n01100001\n", "output": ["2 1\n1 4 2 5 3 6 7\n1 7 6 5 3 2 4 8\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0100000\n8\n2 3 1 8 5 4 7 6\n11110011\n", "output": ["2 1\n1 7 2 3 4 5 6\n4 5 3 8 2 1 7 6\n"]}, {"input": "3\n2\n1 2\n10\n7\n1 2 3 4 5 6 7\n0101001\n8\n2 3 1 8 5 4 7 6\n11011011\n", "output": ["2 1\n1 5 2 6 3 4 7\n3 4 1 8 5 2 7 6\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110101\n", "output": ["1 2\n3 1 2\n1 5 4 8 2 6 3 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["2 1\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11111001\n", "output": ["2 1\n3 1 2\n4 5 3 8 6 1 2 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01110001\n", "output": ["2 1\n3 1 2\n1 6 5 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n11010001\n", "output": ["2 1\n3 1 2\n5 6 1 8 3 2 4 7\n"]}, {"input": "3\n2\n1 2\n11\n3\n3 1 2\n101\n8\n2 3 1 8 5 4 7 6\n01100101\n", "output": ["1 2\n3 1 2\n1 6 5 4 2 7 3 8\n"]}, {"input": "3\n2\n1 2\n10\n3\n3 1 2\n000\n8\n2 3 1 8 5 4 7 6\n11110101\n", "output": ["2 1\n3 1 2\n4 5 3 8 1 6 2 7\n"]}], "task_id": "codecontest/155", "prompt": "Berland Music is a music streaming service built specifically to support Berland local artist, and its developers are currently working on a song recommendation module. So imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation. After listening to each of them, Monocarp pressed either a like or a dislike button, and let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it. Now the service has to re-evaluate the song ratings in such a way that: the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). Among all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x. Print the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "repair_prompt": ["Berland Music is a music streaming service built specifically to support Berland local artist, and its developers are currently working on a song recommendation module. So imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to p_i, where 1 \u2264 p_i \u2264 n and every integer from 1 to n appears exactly once. In other words, p is a permutation. After listening to each of them, Monocarp pressed either a like or a dislike button, and let his vote sequence be represented with a string s, such that s_i=0 means that he disliked the i-th song, and s_i=1 means that he liked it. Now the service has to re-evaluate the song ratings in such a way that: the new ratings q_1, q_2, ..., q_n still form a permutation (1 \u2264 q_i \u2264 n; each integer from 1 to n appears exactly once); every song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i, j such that s_i=1 and s_j=0, q_i>q_j should hold). Among all valid permutations q find the one that has the smallest value of \u2211_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x. Print the permutation q_1, q_2, ..., q_n. If there are multiple answers, you can print any of them.\n\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): List of initial ratings for the songs.\n            - s (str): String of user feedback ('1' for liked, '0' for disliked).\n\n    Returns:\n        List[List[int]]: List of adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_songs = []\n        disliked_songs = []\n\n        # Separate songs into liked and disliked based on feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked_songs.append((p[i], i))\n            else:\n                disliked_songs.append((p[i], i))\n\n        # Sort liked songs in descending order and disliked songs in ascending order\n        liked_songs.sort(reverse=True, key=lambda x: x[0])\n        disliked_songs.sort(key=lambda x: x[0])\n\n        # Assign new ratings\n        new_ratings = [0] * n\n        current_rating = n\n\n        # Assign ratings to liked songs first\n        for _, index in liked_songs:\n            new_ratings[index] = current_rating\n            current_rating -= 1\n\n        # Assign ratings to disliked songs\n        for _, index in disliked_songs:\n            new_ratings[index] = current_rating\n            current_rating -= 1\n\n        results.append(new_ratings)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Read number of test cases\n    t = int(input())\n\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function\n    results = re_evaluate_ratings(t, test_cases)\n\n    # Output interface\n    for result in results:\n        print(' '.join(map(str, result)))\n\n# Ensure the main function is called when the script is executed\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user preferences.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): Each test case contains:\n            - n (int): Number of songs.\n            - p (List[int]): List of current ratings for the songs.\n            - s (str): String indicating user preference ('1' for liked, '0' for disliked).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate songs into liked and disliked categories\n        liked = []\n        disliked = []\n\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked in descending order and disliked in ascending order\n        liked.sort(reverse=True)\n        disliked.sort()\n\n        # Assign highest ratings to liked songs and lowest to disliked songs\n        re_evaluated = [0] * n\n        liked_index = 0\n        disliked_index = 0\n\n        for i in range(n):\n            if s[i] == '1':\n                re_evaluated[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                re_evaluated[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(re_evaluated)\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        p = list(map(int, data[index + 1].split()))\n        s = data[index + 2]\n        test_cases.append((n, p, s))\n        index += 3\n\n    # Output interface\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef adjust_song_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjust song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings for the songs.\n            - s (str): Feedback string where '1' indicates liked and '0' indicates disliked.\n\n    Returns:\n        List[List[int]]: Adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate liked and disliked songs\n        for i in range(n):\n            if s[i] == '1':\n                liked.append((p[i], i))\n            else:\n                disliked.append((p[i], i))\n\n        # Sort liked and disliked songs by their predicted ratings\n        liked.sort(reverse=True)\n        disliked.sort(reverse=True)\n\n        # Assign new ratings\n        new_ratings = [0] * n\n        current_rating = n\n\n        # Assign ratings to disliked songs first\n        for _, index in disliked:\n            new_ratings[index] = current_rating\n            current_rating -= 1\n\n        # Assign ratings to liked songs\n        for _, index in liked:\n            new_ratings[index] = current_rating\n            current_rating -= 1\n\n        results.append(new_ratings)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output adjusted ratings.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print results\n    results = adjust_song_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): List of predicted ratings.\n            - s (str): Feedback string where '1' indicates liked and '0' indicates disliked.\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate liked and disliked songs\n        liked = [(p[i], i) for i in range(n) if s[i] == '1']\n        disliked = [(p[i], i) for i in range(n) if s[i] == '0']\n\n        # Sort liked and disliked songs by their predicted ratings\n        liked.sort()\n        disliked.sort()\n\n        # Create a new ratings list\n        new_ratings = [0] * n\n\n        # Assign new ratings starting from the lowest for disliked and highest for liked\n        current_rating = 1\n        for _, index in disliked:\n            new_ratings[index] = current_rating\n            current_rating += 1\n        for _, index in liked:\n            new_ratings[index] = current_rating\n            current_rating += 1\n\n        results.append(new_ratings)\n\n    return results\n\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef adjust_song_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Adjust song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): Each test case contains:\n            - n (int): Number of songs.\n            - p (List[int]): List of song ratings.\n            - s (str): String of '0's and '1's indicating dislike and like respectively.\n\n    Returns:\n        List[List[int]]: Adjusted ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate liked and disliked songs\n        liked = [(p[i], i) for i in range(n) if s[i] == '1']\n        disliked = [(p[i], i) for i in range(n) if s[i] == '0']\n\n        # Sort liked and disliked songs by their original ratings\n        liked.sort()\n        disliked.sort()\n\n        # Assign new ratings\n        new_ratings = [0] * n\n        current_rating = 1\n\n        # Assign ratings to disliked songs first\n        for _, index in disliked:\n            new_ratings[index] = current_rating\n            current_rating += 1\n\n        # Assign ratings to liked songs\n        for _, index in liked:\n            new_ratings[index] = current_rating\n            current_rating += 1\n\n        results.append(new_ratings)\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        p = list(map(int, data[index:index+n]))\n        index += n\n        s = data[index]\n        index += 1\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = adjust_song_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user preferences.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): Predicted ratings as a permutation of numbers from 1 to n.\n            - s (str): String of length n indicating user preference ('1' for liked, '0' for disliked).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort indices based on predicted ratings\n        liked_indices.sort(key=lambda x: p[x], reverse=True)\n        disliked_indices.sort(key=lambda x: p[x], reverse=True)\n\n        # Assign highest ratings to liked songs and lowest to disliked songs\n        re_evaluated_ratings = [0] * n\n        current_rating = n\n\n        for index in liked_indices:\n            re_evaluated_ratings[index] = current_rating\n            current_rating -= 1\n\n        for index in disliked_indices:\n            re_evaluated_ratings[index] = current_rating\n            current_rating -= 1\n\n        results.append(re_evaluated_ratings)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): A list of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): List of predicted ratings.\n            - s (str): String of feedback ('0' for dislike, '1' for like).\n\n    Returns:\n        List[List[int]]: A list of lists, where each list contains the re-evaluated ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate the indices of liked and disliked songs\n        liked_indices = [i for i in range(n) if s[i] == '1']\n        disliked_indices = [i for i in range(n) if s[i] == '0']\n\n        # Sort the ratings for liked and disliked songs\n        liked_ratings = sorted((p[i] for i in liked_indices), reverse=True)\n        disliked_ratings = sorted((p[i] for i in disliked_indices), reverse=True)\n\n        # Assign new ratings\n        new_ratings = [0] * n\n        current_rating = n\n\n        # Assign highest ratings to liked songs\n        for i in liked_indices:\n            new_ratings[i] = current_rating\n            current_rating -= 1\n\n        # Assign remaining ratings to disliked songs\n        for i in disliked_indices:\n            new_ratings[i] = current_rating\n            current_rating -= 1\n\n        results.append(new_ratings)\n\n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input, process test cases, and output results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Call the function and print the results\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user preferences.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): List of initial ratings.\n            - s (str): String indicating user preference ('1' for liked, '0' for disliked).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate songs into liked and disliked categories\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked songs in descending order and disliked songs in ascending order\n        liked.sort(reverse=True)\n        disliked.sort()\n\n        # Assign ratings\n        new_ratings = [0] * n\n        liked_index = 0\n        disliked_index = 0\n\n        for i in range(n):\n            if s[i] == '1':\n                new_ratings[i] = liked[liked_index]\n                liked_index += 1\n            else:\n                new_ratings[i] = disliked[disliked_index]\n                disliked_index += 1\n\n        results.append(new_ratings)\n\n    return results\n\n## Input interface\nimport sys\n\ndef main():\n    input_data = sys.stdin.read().strip().split('\\n')\n    t = int(input_data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n = int(input_data[index])\n        p = list(map(int, input_data[index + 1].split()))\n        s = input_data[index + 2]\n        test_cases.append((n, p, s))\n        index += 3\n\n    # Output interface\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on Monocarp's feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): List of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): List of initial ratings.\n            - s (str): String indicating Monocarp's feedback ('0' for dislike, '1' for like).\n\n    Returns:\n        List[List[int]]: List of re-evaluated ratings for each test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        liked = []\n        disliked = []\n\n        # Separate liked and disliked songs based on Monocarp's feedback\n        for i in range(n):\n            if s[i] == '1':\n                liked.append(p[i])\n            else:\n                disliked.append(p[i])\n\n        # Sort liked and disliked ratings\n        liked.sort()\n        disliked.sort()\n\n        # Create a new permutation of ratings\n        new_ratings = []\n        liked_index = 0\n        disliked_index = 0\n\n        for i in range(n):\n            if s[i] == '1':\n                new_ratings.append(liked[liked_index])\n                liked_index += 1\n            else:\n                new_ratings.append(disliked[disliked_index])\n                disliked_index += 1\n\n        results.append(new_ratings)\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        p = list(map(int, data[index:index+n]))\n        index += n\n        s = data[index]\n        index += 1\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef re_evaluate_ratings(t: int, test_cases: List[Tuple[int, List[int], str]]) -> List[List[int]]:\n    \"\"\"Re-evaluate song ratings based on user feedback.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, List[int], str]]): A list of test cases, each containing:\n            - n (int): Number of songs.\n            - p (List[int]): List of initial ratings for the songs.\n            - s (str): String of feedback where '1' means liked and '0' means disliked.\n\n    Returns:\n        List[List[int]]: A list of lists, where each list contains the re-evaluated ratings for a test case.\n    \"\"\"\n    results = []\n\n    for n, p, s in test_cases:\n        # Separate liked and disliked songs\n        liked = [(p[i], i) for i in range(n) if s[i] == '1']\n        disliked = [(p[i], i) for i in range(n) if s[i] == '0']\n\n        # Sort liked songs in descending order and disliked songs in ascending order\n        liked.sort(reverse=True)\n        disliked.sort()\n\n        # Assign new ratings\n        new_ratings = [0] * n\n        current_rating = n\n\n        # Assign highest ratings to liked songs\n        for _, index in liked:\n            new_ratings[index] = current_rating\n            current_rating -= 1\n\n        # Assign remaining ratings to disliked songs\n        for _, index in disliked:\n            new_ratings[index] = current_rating\n            current_rating -= 1\n\n        results.append(new_ratings)\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        p = list(map(int, input().split()))\n        s = input().strip()\n        test_cases.append((n, p, s))\n\n    # Output interface\n    results = re_evaluate_ratings(t, test_cases)\n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"], "plans": ["requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings. The solution should handle multiple test cases efficiently due to the large input size constraints.\nrequirement pool:\n- Implement the song recommendation algorithm to re-evaluate ratings.\n- Ensure the algorithm handles up to 10,000 test cases efficiently.\n- Optimize the algorithm to minimize the sum of absolute differences.\n- Support a large number of songs per test case, up to 200,000.\n- Provide flexibility in outputting any valid permutation with minimal cost.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on user feedback and adjust their ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to handle permutations and minimize the sum of absolute differences.\n", "requirement analysis:\nThe main requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system should ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings. The solution must handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Develop the song recommendation algorithm to re-evaluate ratings based on user feedback.\n- Ensure the algorithm can handle up to 10,000 test cases efficiently.\n- Create a user interface that allows users to like or dislike songs easily.\n- Implement a feature to display a list of liked songs.\n- Enhance the visual appeal of the user interface.\nWe will implement a function that processes each test case independently. The function will separate the songs into liked and disliked categories based on the input string. It will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring the permutation constraint is maintained. The solution will efficiently handle up to 200,000 songs across all test cases by using sorting and indexing techniques.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system should ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings.\nrequirement pool:\n- Implement the song recommendation algorithm to adjust ratings based on user feedback.\n- Ensure the algorithm is efficient and can handle up to 200,000 songs across multiple test cases.\n- Develop a user interface for liking and disliking songs.\n- Integrate the recommendation module with the existing music streaming service.\n- Conduct user testing to refine the recommendation algorithm.\nWe will implement a function that processes multiple test cases to adjust song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings. We will use sorting and permutation techniques to achieve this efficiently.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings. The solution should handle multiple test cases efficiently due to the large input size constraints.\nrequirement pool:\n- Implement the song recommendation algorithm to re-evaluate ratings.\n- Optimize the algorithm for performance with large datasets.\n- Ensure the solution meets the input/output format requirements.\n- Develop a user interface for displaying song recommendations.\n- Integrate feedback mechanisms for user interactions.\nWe will implement a function that processes multiple test cases to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences from the original predicted ratings. We will use sorting and permutation techniques to achieve this efficiently, given the constraints. The solution will handle up to 200,000 songs across all test cases, so it must be optimized for performance.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that can adjust song ratings based on user feedback while maintaining a permutation of ratings. The solution must ensure that liked songs have higher ratings than disliked ones and minimize the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement the song recommendation algorithm to adjust ratings based on user feedback.\n- Ensure the new ratings form a valid permutation.\n- Optimize the algorithm for performance given the constraints.\n- Handle edge cases where all songs are liked or disliked.\n- Provide flexibility in outputting any valid permutation with minimal absolute difference.\nWe will implement a function that processes multiple test cases to adjust song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while maintaining a permutation of ratings. We will use sorting and list manipulation techniques to achieve the minimal sum of absolute differences between original and new ratings.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system should ensure that liked songs have higher ratings than disliked ones while minimizing the difference from predicted ratings. The solution must handle multiple test cases efficiently.\nrequirement pool:\n- Implement the song recommendation algorithm\n- Ensure liked songs have higher ratings than disliked ones\n- Optimize for minimum difference from predicted ratings\n- Support multiple test cases efficiently\n- Enhance user interface for feedback collection\nWe will implement a function that processes multiple test cases. For each test case, we will separate the songs into liked and disliked categories based on the input string. We will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring that the permutation constraint is satisfied. The solution will be efficient enough to handle the upper limits of input size.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference from the original predicted ratings. The solution should handle multiple test cases efficiently, given the constraints on input size.\nrequirement pool:\n- Develop the song recommendation algorithm to re-evaluate ratings based on user feedback.\n- Ensure the algorithm can handle up to 10,000 test cases efficiently.\n- Create a user interface that allows users to like or dislike songs easily.\n- Implement a responsive design for the application.\n- Incorporate analytics to track user engagement and preferences.\nWe will implement a function that processes multiple test cases to re-evaluate song ratings based on user feedback. The function will ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences from the original predicted ratings. We will use sorting and permutation techniques to achieve this efficiently, given the constraints on input size.\n", "requirement analysis:\nThe main requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The system must ensure that liked songs have higher ratings than disliked ones while minimizing the difference between predicted and re-evaluated ratings. The solution should handle multiple test cases efficiently and adhere to the input-output format specified.\nrequirement pool:\n- Develop the song recommendation algorithm to re-evaluate ratings based on user feedback.\n- Ensure the solution handles up to 10,000 test cases efficiently.\n- Implement a user-friendly interface for liking and disliking songs.\n- Optimize the algorithm to minimize the sum of absolute differences between predicted and re-evaluated ratings.\n- Ensure compatibility with mobile devices for accessibility.\nWe will implement a function that processes multiple test cases efficiently. For each test case, we will separate the songs into liked and disliked categories based on the input string. We will then assign the highest available ratings to liked songs and the lowest to disliked songs, ensuring that the permutation constraint is maintained. The solution will be optimized to handle the maximum constraints efficiently.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The re-evaluated ratings must form a permutation and ensure that liked songs have higher ratings than disliked ones. The goal is to minimize the sum of absolute differences between predicted and re-evaluated ratings.\nrequirement pool:\n- Develop the song recommendation module.\n- Implement the re-evaluation of song ratings based on user feedback.\n- Ensure the re-evaluated ratings form a valid permutation.\n- Optimize the algorithm to handle up to 200,000 songs efficiently.\n- Provide multiple valid outputs if possible.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on Monocarp's feedback and adjust the ratings to form a valid permutation while minimizing the sum of absolute differences. We will use Python's built-in sorting capabilities to achieve this efficiently.\n", "requirement analysis:\nThe requirement is to develop a song recommendation module that re-evaluates song ratings based on user feedback. The solution must ensure that liked songs have higher ratings than disliked ones while minimizing the sum of absolute differences between original and new ratings.\nrequirement pool:\n- Implement the song recommendation algorithm that respects user feedback.\n- Optimize the algorithm for performance given the constraints.\n- Ensure the solution handles up to 200,000 songs efficiently.\n- Provide a user-friendly interface for liking/disliking songs.\n- Support local artists by prioritizing their songs in recommendations.\nWe will implement a function that processes multiple test cases efficiently. The function will sort the songs based on user feedback and adjust the ratings to ensure liked songs have higher ratings than disliked ones. We will use Python's built-in sorting capabilities to achieve this efficiently.\n"], "scores": [], "pass_results": [false, false, true, false, false, true, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 62, "examples": "\nInput\n\nThe first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of testcases.\n\nThe first line of each testcase contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of songs.\n\nThe second line of each testcase contains n integers p_1, p_2, ..., p_n (1 \u2264 p_i \u2264 n) \u2014 the permutation of the predicted ratings.\n\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\n\nThe sum of n over all testcases doesn't exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each testcase, print a permutation q \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that \u2211_{i=1}^n |p_i-q_i| is minimum possible, you can print any of them.\n\nExample\n\nInput\n\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\n\nOutput\n\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. \u2211_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.", "mutate_method": "condense_two2one", "parent_index": 33}
