{"name": "1591_B. Array Eversion", "description": "You are given an array a of length n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe start with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "tags": ["greedy"], "difficulty": 8, "id": 1591, "sample_io": [{"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}], "test_list": [{"input": "2\n1\n998244353\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 1 1\n", "output": ["1\n3\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 1\n", "output": ["0\n2\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 8 2\n2\n1 1 1 1\n", "output": ["1\n1\n0\n"]}, {"input": "3\n5\n2 8 1 4 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["2\n2\n0\n"]}, {"input": "3\n5\n2 1 1 5 6\n5\n5 3 4 4 1\n2\n0 1 1 1\n", "output": ["0\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n802364611\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 4 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n4 2 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 3 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 1 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n1 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n4 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 3 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n68829976\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n4 4 1 5 3\n5\n5 3 2 3 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n4 2 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n2 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 2 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n93788297\n4\n0 2 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n2 2 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 3 0 2\n", "output": ["0\n2\n"]}, {"input": "2\n1\n998244353\n4\n1 1 0 3\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 2 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 4 1 5 3\n5\n5 3 2 0 1\n4\n1 1 0 1\n", "output": ["1\n3\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n2 1 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n56749180\n4\n2 4 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1528037704\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n2 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 3 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n0 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n2 1 2 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n37862951\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n5 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 4 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n134212618\n4\n2 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n13173955\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 1 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n314070686\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 1 6 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n802364611\n4\n2 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n551353738\n4\n4 1 4 5\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n23458602\n4\n4 3 1 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 2 1 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n7 2 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 3 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n41454457\n4\n4 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 2 0 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n23458602\n4\n4 4 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n176445854\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 1 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n381715760\n4\n0 2 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 3 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n0 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 4\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n1 1 4 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n993551853\n4\n2 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 1 0 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 1\n", "output": ["0\n2\n"]}, {"input": "2\n1\n94783419\n4\n0 1 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n998244353\n4\n2 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 3 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1981447801\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 2 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 1 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n925217660\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n627592454\n4\n3 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n2 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 2 6 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n3 4 1 1 3\n5\n5 5 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n624918540\n4\n2 0 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n2 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 4 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n144612869\n4\n1 7 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n134212618\n4\n4 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n626625781\n4\n1 2 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n6643808\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n4\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 6 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n0 4 0 5 3\n5\n7 3 2 4 1\n3\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n144612869\n4\n1 6 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n53238141\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n517602066\n4\n3 2 4 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n381715760\n4\n5 1 0 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n4 7 0 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n316067198\n4\n0 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n556389862\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n23458602\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 1 2 1\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 4 2 5 2\n5\n5 3 2 4 1\n4\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n993551853\n4\n3 1 1 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1258355607\n4\n3 0 2 4\n", "output": ["0\n0\n"]}, {"input": "2\n1\n94783419\n4\n3 1 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1961051652\n4\n1 0 2 6\n", "output": ["0\n0\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 5 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n75994590\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 4 3\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 8 0 2 3\n5\n5 3 2 4 2\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n533265820\n4\n0 4 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n494500097\n4\n4 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n627592454\n4\n1 2 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n27909634\n4\n4 1 0 10\n", "output": ["0\n0\n"]}, {"input": "2\n1\n925217660\n4\n2 4 6 6\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n-1 1 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n29355313\n4\n1 2 2 2\n", "output": ["0\n0\n"]}, {"input": "3\n5\n0 4 1 5 3\n5\n10 3 0 5 1\n2\n1 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n134212618\n4\n1 4 2 7\n", "output": ["0\n0\n"]}, {"input": "2\n1\n7874846\n4\n2 2 0 2\n", "output": ["0\n0\n"]}, {"input": "2\n1\n535334137\n3\n1 1 3 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n1746739171\n4\n2 2 12 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n313193651\n4\n3 3 1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n7680692\n4\n7 2 2 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n3713787\n4\n4 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n41454457\n4\n5 0 2 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n316067198\n4\n-1 2 0 5\n", "output": ["0\n0\n"]}, {"input": "2\n1\n711911604\n4\n4 2 2 3\n", "output": ["0\n1\n"]}, {"input": "2\n1\n39720822\n4\n2 4 -1 2\n", "output": ["0\n1\n"]}, {"input": "2\n1\n323915514\n4\n1 0 2 1\n", "output": ["0\n1\n"]}, {"input": "2\n1\n1258355607\n4\n6 0 2 4\n", "output": ["0\n1\n"]}, {"input": "2\n1\n94783419\n4\n6 1 2 2\n", "output": ["0\n1\n"]}, {"input": "3\n5\n2 1 1 5 3\n5\n5 0 2 4 1\n2\n0 1 1 1\n", "output": ["1\n2\n0\n"]}, {"input": "2\n1\n112473576\n4\n1 1 2 3\n", "output": ["0\n0\n"]}, {"input": "2\n1\n313193651\n4\n2 0 0 3\n", "output": ["0\n0\n"]}], "task_id": "codecontest/46", "prompt": "You are provided with an array a of size n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe begin with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "repair_prompt": ["You are provided with an array a of size n.\n\nLet's define the eversion operation. Let x = a_n. Then array a is partitioned into two parts: left and right. The left part contains the elements of a that are not greater than x (\u2264 x). The right part contains the elements of a that are strictly greater than x (> x). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\n\nFor example, if the array a is [2, 4, 1, 5, 3], the eversion goes like this: [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5].\n\nWe begin with the array a and perform eversions on this array. We can prove that after several eversions the array a stops changing. Output the minimum number k such that the array stops changing after k eversions.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. "], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversion operations needed for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each being a list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the minimum number of eversion operations\n                   needed for each test case to stabilize the array.\n    \"\"\"\n    def perform_eversion(arr: List[int]) -> List[int]:\n        \"\"\"Perform a single eversion operation on the array.\n\n        Args:\n            arr (List[int]): The array to perform eversion on.\n\n        Returns:\n            List[int]: The array after performing the eversion operation.\n        \"\"\"\n        if not arr:\n            return arr\n        \n        pivot = arr[-1]\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    results = []\n    for case in test_cases:\n        current_array = case\n        steps = 0\n        while True:\n            new_array = perform_eversion(current_array)\n            if new_array == current_array:\n                break\n            current_array = new_array\n            steps += 1\n        results.append(steps)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    for case in test_cases:\n        max_element = float('-inf')\n        eversion_count = 0\n        # Traverse the array from the end to the start\n        for element in reversed(case):\n            if element > max_element:\n                max_element = element\n                eversion_count += 1\n        results.append(eversion_count)\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversion operations needed for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results, each representing the minimum number of eversion operations needed.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            last_element = current_array[-1]\n            partition_index = len(current_array) - 1\n            \n            # Find the partition index where elements start being greater than the last element\n            for i in range(len(current_array) - 2, -1, -1):\n                if current_array[i] > last_element:\n                    partition_index = i\n                    break\n            \n            # Partition the array and concatenate\n            new_array = current_array[:partition_index + 1] + current_array[partition_index + 1:]\n            \n            # Check if the array has stabilized\n            if new_array == current_array:\n                break\n            \n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each being a list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        last_element = case[-1]\n        eversion_count = 0\n        max_so_far = float('-inf')\n        \n        # Iterate from the end to the start\n        for i in range(n - 1, -1, -1):\n            if case[i] > last_element:\n                # If we find an element greater than the last element, we need an eversion\n                eversion_count += 1\n                # Update the last element to the maximum found so far\n                last_element = max_so_far\n            # Update the maximum element found so far\n            max_so_far = max(max_so_far, case[i])\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\ndef main():\n    \"\"\"Main function to read input and output the results.\"\"\"\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each test case is a list of integers.\n\n    Returns:\n        List[int]: List of integers representing the number of eversions for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        eversion_count = 0\n        current_array = case[:]\n        \n        while True:\n            # Perform the eversion operation\n            last_element = current_array[-1]\n            left_part = [x for x in current_array if x <= last_element]\n            right_part = [x for x in current_array if x > last_element]\n            new_array = left_part + right_part\n            \n            # Check if the array has stabilized\n            if new_array == current_array:\n                break\n            \n            # Update the current array and increment the eversion count\n            current_array = new_array\n            eversion_count += 1\n        \n        results.append(eversion_count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    # Call the function and print results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: A list of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    def perform_eversion(arr: List[int]) -> List[int]:\n        \"\"\"Perform a single eversion operation on the array.\n\n        Args:\n            arr (List[int]): The array to perform eversion on.\n\n        Returns:\n            List[int]: The array after performing the eversion.\n        \"\"\"\n        if not arr:\n            return arr\n        pivot = arr[-1]\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        return left + right\n\n    results = []\n    for case in test_cases:\n        current = case\n        steps = 0\n        while True:\n            next_array = perform_eversion(current)\n            if next_array == current:\n                break\n            current = next_array\n            steps += 1\n        results.append(steps)\n    \n    return results\n\nif __name__ == \"__main__\":\n    # Input interface\n    t = int(input())\n    cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        cases.append(a)\n\n    # Output interface\n    results = min_eversions(t, cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversion operations needed for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of results, each representing the minimum number of eversion operations needed for the corresponding test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        eversion_count = 0\n        last_element = case[-1]\n        \n        # Perform eversion operations until the array stabilizes\n        while True:\n            # Find the partition point where elements are greater than the last element\n            partition_index = n\n            for i in range(n - 1, -1, -1):\n                if case[i] > last_element:\n                    partition_index = i\n                    break\n            \n            # If no partition point found, array is stable\n            if partition_index == n:\n                break\n            \n            # Perform eversion operation by reversing the subarray from partition_index to end\n            eversion_count += 1\n            case = case[:partition_index] + case[partition_index:][::-1]\n            last_element = case[-1]\n        \n        results.append(eversion_count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversion operations needed for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing a list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the minimum number of eversion operations\n                   needed for each test case.\n    \"\"\"\n    results = []\n    \n    for case in test_cases:\n        n = len(case)\n        if n == 0:\n            results.append(0)\n            continue\n        \n        # The last element of the array\n        last_element = case[-1]\n        \n        # Initialize the number of eversion operations\n        eversion_count = 0\n        \n        # Traverse the array from the end to the start\n        for i in range(n - 1, -1, -1):\n            if case[i] > last_element:\n                # If the current element is greater than the last element,\n                # we need to perform an eversion operation\n                eversion_count += 1\n                # Update the last element to the current element\n                last_element = case[i]\n        \n        results.append(eversion_count)\n    \n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    t = int(data[0])\n    index = 1\n\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append(a)\n\n    # Output interface\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport sys\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions needed for each test case.\n\n    Args:\n        t (int): The number of test cases.\n        test_cases (List[List[int]]): A list of test cases, each containing a list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the minimum number of eversions for each test case.\n    \"\"\"\n    results = []\n    for case in test_cases:\n        n = len(case)\n        last_element = case[-1]\n        eversion_count = 0\n        max_so_far = float('-inf')\n        \n        # Traverse the array from the end to the start\n        for i in range(n - 1, -1, -1):\n            if case[i] > last_element:\n                # If current element is greater than the last element, we need an eversion\n                eversion_count += 1\n                # Update the last element to the maximum found so far\n                last_element = max_so_far\n            # Update the maximum element found so far\n            max_so_far = max(max_so_far, case[i])\n        \n        results.append(eversion_count)\n    \n    return results\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    input_data = sys.stdin.read().split()\n    t = int(input_data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(t):\n        n = int(input_data[index])\n        index += 1\n        a = list(map(int, input_data[index:index + n]))\n        index += n\n        test_cases.append(a)\n    \n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef min_eversions(t: int, test_cases: List[List[int]]) -> List[int]:\n    \"\"\"Calculate the minimum number of eversions required for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[List[int]]): List of test cases, each containing an array of integers.\n\n    Returns:\n        List[int]: List of minimum eversions required for each test case.\n    \"\"\"\n    def eversion_count(arr: List[int]) -> int:\n        \"\"\"Determine the number of eversions required to stabilize the array.\n\n        Args:\n            arr (List[int]): The array to be processed.\n\n        Returns:\n            int: The number of eversions required.\n        \"\"\"\n        n = len(arr)\n        if n <= 1:\n            return 0\n\n        # Check if the array is already sorted\n        if arr == sorted(arr):\n            return 0\n\n        # Initialize the number of eversions\n        eversions = 0\n\n        # Start from the end of the array and find the first element\n        # that is not in its sorted position\n        max_seen = arr[-1]\n        for i in range(n - 2, -1, -1):\n            if arr[i] > max_seen:\n                eversions += 1\n                max_seen = arr[i]\n\n        return eversions\n\n    results = []\n    for case in test_cases:\n        results.append(eversion_count(case))\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        test_cases.append(a)\n\n    # Output results\n    results = min_eversions(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe requirement is to determine the minimum number of eversions needed for an array to stabilize. The challenge lies in efficiently partitioning the array and determining when no further changes occur. The solution must handle multiple test cases and large input sizes within the given constraints.\nrequirement pool:\n- Implement the eversion operation efficiently.\n- Ensure the solution handles up to 100 test cases with a total of 200,000 elements.\n- Optimize the algorithm to minimize computational complexity.\n- Provide clear documentation and comments in the code.\n- Include edge case handling for arrays with identical elements.\nWe will implement a function that performs the eversion operation on an array. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array stabilizes, meaning no further changes occur. The solution will efficiently handle multiple test cases and large input sizes by leveraging Python's list operations.\n", "requirement analysis:\nThe task requires implementing an eversion operation on an array and determining the minimum number of operations needed for the array to stabilize. The solution must handle multiple test cases efficiently and ensure the partitioning is stable.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles up to 100 test cases efficiently\n- Optimize the solution for large input sizes\n- Provide clear and correct output for each test case\n- Document the code for better understanding\nWe will implement the eversion operation by iterating over the array from the end to the start, keeping track of the maximum element encountered. The number of eversions required is equal to the number of times we encounter a new maximum element when traversing the array from the end. This approach ensures that we efficiently determine the number of eversions needed for the array to stabilize.\n", "requirement analysis:\nThe requirements focus on efficiently processing arrays through a series of eversions until they stabilize. The solution must handle multiple test cases, ensuring accuracy and performance across potentially large datasets.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles multiple test cases efficiently\n- Optimize the code for large input sizes\n- Provide clear documentation of the eversion process\n- Test the solution against edge cases for accuracy\nWe will implement a function to perform the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array no longer changes. We will use efficient list operations to ensure the solution handles large inputs within the constraints.\n", "requirement analysis:\nThe task requires implementing an efficient algorithm to perform the eversion operation on an array until it stabilizes. The solution must handle multiple test cases and large input sizes efficiently. The key challenge is ensuring the partitioning is stable and the algorithm terminates correctly after the minimum number of eversions.\nrequirement pool:\n- Implement the eversion operation efficiently.\n- Ensure the solution handles the maximum input constraints.\n- Provide clear and correct output for each test case.\n- Maintain stability in the partitioning process.\n- Optimize for readability and maintainability.\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array no longer changes. The function will handle multiple test cases efficiently by iterating through each test case and applying the eversion logic. We will use Python's built-in list operations to maintain stability and efficiency.\n", "requirement analysis:\nThe requirements focus on performing a series of operations on an array until it stabilizes. The key challenge is efficiently partitioning the array and determining the number of operations needed for stabilization. The solution must handle multiple test cases and large input sizes while ensuring performance and clarity.\nrequirement pool:\n- Implement the eversion operation correctly\n- Ensure the solution handles edge cases\n- Optimize the algorithm for performance\n- Provide clear output for each test case\n- Maintain code readability and ease of maintenance\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. We will count the number of eversions needed until the array no longer changes. The solution will efficiently handle multiple test cases and large input sizes by using a simple loop and list operations.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The solution must efficiently handle up to 200,000 elements across multiple test cases, ensuring the output is correct and concise.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation within the code.\n- Consider edge cases and validate the solution against them.\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array no longer changes. The solution will efficiently handle multiple test cases and large input sizes by leveraging Python's built-in list operations.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The key challenge is to efficiently determine the minimum number of eversions needed for the array to stop changing, especially given the constraints on input size.\nrequirement pool:\n- Implement the eversion operation efficiently.\n- Ensure the solution handles up to 100 test cases with large arrays.\n- Optimize for readability and maintainability.\n- Include edge case handling for arrays with identical elements.\n- Provide detailed comments and documentation.\nWe will implement a function to perform the eversion operation on an array until it stabilizes. The function will iterate over the array, partitioning it into two parts based on the last element, and then concatenate these parts. This process will be repeated until the array no longer changes. The solution will be efficient enough to handle the maximum constraints by using a simple loop and list operations.\n", "requirement analysis:\nThe task requires implementing an algorithm to perform eversions on an array until it stabilizes. The solution must efficiently handle up to 200,000 elements across multiple test cases. The key challenge is to determine the minimum number of eversions required for stabilization.\nrequirement pool:\n- Implement the eversion operation as described in the requirements.\n- Ensure the solution handles the maximum input size efficiently.\n- Optimize the code for readability and maintainability.\n- Provide detailed comments and documentation within the code.\n- Include edge case handling and validation.\nWe will implement a function that performs the eversion operation on an array until it stabilizes. The function will efficiently handle multiple test cases and large input sizes by iterating through the array and partitioning it based on the last element. We will use Python's built-in list operations to maintain simplicity and readability.\n", "requirement analysis:\nThe requirements focus on processing arrays through a defined eversion operation until they stabilize. The challenge lies in efficiently handling large arrays and ensuring the process is optimized for performance and memory usage. The solution must be robust enough to handle multiple test cases and provide accurate results consistently.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles large arrays within constraints\n- Optimize the code for performance and memory usage\n- Provide clear documentation of the eversion process\n- Test the solution against diverse test cases for accuracy\nWe will implement the eversion operation using a simple loop to partition the array based on the last element. The process will be repeated until the array stabilizes. We will use Python's built-in list operations to efficiently handle the partitioning and concatenation. Given the constraints, the solution will be optimized for performance by minimizing unnecessary operations and memory usage.\n", "requirement analysis:\nThe requirements focus on performing a series of operations on an array until it stabilizes. The key challenge is efficiently partitioning the array and determining the number of operations needed for stabilization. The solution must handle multiple test cases and large input sizes while ensuring clarity and accuracy in output.\nrequirement pool:\n- Implement the eversion operation efficiently\n- Ensure the solution handles multiple test cases\n- Optimize the algorithm for large input sizes\n- Provide clear and concise output\n- Document the process for better understanding\nWe will implement a function to perform the eversion operation on an array. The function will partition the array into two parts based on the last element and concatenate them. We will repeat this process until the array stops changing. The solution will handle multiple test cases efficiently by iterating through each test case and applying the eversion operation until stabilization. The approach will focus on minimizing the number of operations by checking if the array is already sorted or can be sorted in fewer steps.\n"], "scores": [], "pass_results": [false, false, true, false, true, false, true, true, true, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 7, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 100). Description of the test cases follows.\n\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^5).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 2 \u22c5 10^5.\n\nOutput\n\nFor each test case print a single integer k \u2014 the number of eversions after which the array stops changing.\n\nExample\n\nInput\n\n\n3\n5\n2 4 1 5 3\n5\n5 3 2 4 1\n4\n1 1 1 1\n\n\nOutput\n\n\n1\n2\n0\n\nNote\n\nConsider the fist example.\n\n  * The first eversion: a = [1, 4, 2, 5, 3], x = 3. [2, 4, 1, 5, 3] \u2192 [2, 1, 3], [4, 5] \u2192 [2, 1, 3, 4, 5]. \n  * The second and following eversions: a = [2, 1, 3, 4, 5], x = 5. [2, 1, 3, 4, 5] \u2192 [2, 1, 3, 4, 5], [] \u2192 [2, 1, 3, 4, 5]. This eversion does not change the array, so the answer is 1. \n\n\n\nConsider the second example. \n\n  * The first eversion: a = [5, 3, 2, 4, 1], x = 1. [5, 3, 2, 4, 1] \u2192 [1], [5, 3, 2, 4] \u2192 [1, 5, 3, 2, 4]. \n  * The second eversion: a = [1, 5, 3, 2, 4], x = 4. [1, 5, 3, 2, 4] \u2192 [1, 3, 2, 4], [5] \u2192 [1, 3, 2, 4, 5]. \n  * The third and following eversions: a = [1, 3, 2, 4, 5], x = 5. [1, 3, 2, 4, 5] \u2192 [1, 3, 2, 4, 5], [] \u2192 [1, 3, 2, 4, 5]. This eversion does not change the array, so the answer is 2. ", "mutate_method": "rephrase_one", "parent_index": 7}
