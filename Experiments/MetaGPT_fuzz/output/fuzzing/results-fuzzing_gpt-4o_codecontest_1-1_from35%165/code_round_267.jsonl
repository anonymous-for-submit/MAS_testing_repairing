{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. M pairs of people are friends with one another. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The gathering is deemed successful if either all the participants are friends with each other. This means they can all converse without worrying about speaking to someone unacquainted. Alternatively, no two people at the party are friends with each other (allowing everyone to be on their phones without disruptions). Please help the people of Baltia organize a successful party or inform them that it's impossible to achieve. Consider edge cases where N is less than 5, making a successful party impossible by definition.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. M pairs of people are friends with one another. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The gathering is deemed successful if either all the participants are friends with each other. This means they can all converse without worrying about speaking to someone unacquainted. Alternatively, no two people at the party are friends with each other (allowing everyone to be on their phones without disruptions). Please help the people of Baltia organize a successful party or inform them that it's impossible to achieve. Consider edge cases where N is less than 5, making a successful party impossible by definition.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration in the form of a clique or independent set of size 5.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a clique or independent set, or -1 if none found.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_edges_from(friendships)\n\n    # Search for cliques of size 5\n    cliques = list(nx.find_cliques(graph))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Search for independent sets of size 5\n    # An independent set in a graph is a set of vertices no two of which are adjacent.\n    # We can find independent sets by looking for cliques in the complement graph.\n    complement_graph = nx.complement(graph)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no clique or independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Function call\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(N: int, M: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration in the graph.\n\n    Args:\n        N (int): Number of people.\n        M (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: A list of 5 people forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    cliques = list(nx.find_cliques(G))\n    for clique in cliques:\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set is a set of vertices in a graph, no two of which are adjacent.\n    # To find independent sets, we can use the complement graph.\n    complement_graph = nx.complement(G)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no valid party configuration is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Output interface\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration.\n\n    Args:\n        n (int): Number of participants.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: List of participants forming a clique or independent set of size 5, or -1 if not possible.\n    \"\"\"\n    # Create a graph using NetworkX\n    graph = nx.Graph()\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    cliques = list(nx.find_cliques(graph))\n    for clique in cliques:\n        if len(clique) == 5:\n            return sorted(clique)\n\n    # Check for independent sets of size 5\n    # To find independent sets, we need to find the complement graph\n    complement_graph = nx.complement(graph)\n    independent_sets = list(nx.find_cliques(complement_graph))\n    for independent_set in independent_sets:\n        if len(independent_set) == 5:\n            return sorted(independent_set)\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people if a successful party is found, otherwise -1.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in a graph is a set of vertices no two of which are adjacent.\n    # We can find independent sets by checking complement graph cliques.\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If no successful party is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: list) -> list:\n    \"\"\"Finds a successful party configuration in a graph of friendships.\n\n    Args:\n        n (int): Number of participants.\n        m (int): Number of friendships.\n        friendships (list): List of tuples representing friendships.\n\n    Returns:\n        list: A list of participants forming a clique or independent set of size 5, or -1 if none found.\n    \"\"\"\n    # Create a graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return sorted(clique)\n\n    # Check for independent sets of size 5\n    # An independent set in a graph is a set of vertices no two of which are adjacent.\n    # We can find independent sets by checking complements of cliques in the complement graph.\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return sorted(independent_set)\n\n    # If no clique or independent set of size 5 is found, return -1\n    return -1\n\n# Input interface\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nimport networkx as nx\nfrom typing import List, Tuple\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in the given friendship graph.\n\n    Args:\n        N: The number of people.\n        M: The number of friendships.\n        friendships: A list of tuples representing friendships between people.\n\n    Returns:\n        A list of 5 people forming a clique or independent set, or -1 if none exist.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_edges_from(friendships)\n\n    # Check for cliques of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for independent sets of size 5\n    # An independent set in a graph G is a clique in the complement graph of G\n    complement_G = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_G):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # Return -1 if no clique or independent set of size 5 is found\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people.\n\n    Args:\n        n (int): The number of participants.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 participant indices forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    if n < 5:\n        return -1\n\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Helper function to check if a set of nodes form a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes form an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Check all combinations of 5 nodes to find a clique or independent set\n    from itertools import combinations\n\n    for combination in combinations(range(1, n + 1), 5):\n        if is_clique(combination) or is_independent_set(combination):\n            return list(combination)\n\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Output interface\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party configuration.\n\n    Args:\n        n (int): Number of participants.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 participants forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Check for a clique of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        if all(b in adjacency_list[a] for a, b in itertools.combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        if all(b not in adjacency_list[a] for a, b in itertools.combinations(combination, 2)):\n            return list(combination)\n\n    # Return -1 if no valid configuration is found\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and get the result\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people either as a clique or an independent set.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or an independent set, or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Check all combinations of 5 nodes for cliques or independent sets\n    from itertools import combinations\n\n    for combination in combinations(range(1, n + 1), 5):\n        if is_clique(combination) or is_independent_set(combination):\n            return list(combination)\n\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find a successful party configuration either as a clique or an independent set of size 5.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or an independent set, or -1 if not possible.\n    \"\"\"\n    # Initialize adjacency list for the graph\n    graph = {i: set() for i in range(1, n + 1)}\n    \n    # Populate the graph with friendships\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    def is_clique(nodes: List[int]) -> bool:\n        \"\"\"Check if the given nodes form a clique.\"\"\"\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in graph[nodes[i]]:\n                    return False\n        return True\n    \n    def is_independent_set(nodes: List[int]) -> bool:\n        \"\"\"Check if the given nodes form an independent set.\"\"\"\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in graph[nodes[i]]:\n                    return False\n        return True\n    \n    def dfs(node: int, path: List[int], target_size: int, check_function) -> List[int]:\n        \"\"\"Perform DFS to find either a clique or an independent set.\"\"\"\n        if len(path) == target_size:\n            if check_function(path):\n                return path\n            return []\n        \n        for neighbor in range(node + 1, n + 1):\n            path.append(neighbor)\n            result = dfs(neighbor, path, target_size, check_function)\n            if result:\n                return result\n            path.pop()\n        \n        return []\n    \n    # Try to find a clique of size 5\n    for start_node in range(1, n + 1):\n        result = dfs(start_node, [start_node], 5, is_clique)\n        if result:\n            return result\n    \n    # Try to find an independent set of size 5\n    for start_node in range(1, n + 1):\n        result = dfs(start_node, [start_node], 5, is_independent_set)\n        if result:\n            return result\n    \n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe requirements focus on determining the possibility of organizing a successful party based on friendship connections. The solution must efficiently handle large inputs and provide accurate results. Edge cases, such as when N is less than 5, must be considered as they inherently make a successful party impossible.\nrequirement pool:\n- Implement the main algorithm to check for successful party conditions.\n- Optimize the solution for large datasets to ensure performance within constraints.\n- Handle edge cases where N is less than 5.\n- Provide clear output formatting as per requirements.\n- Consider multiple successful party configurations if possible.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and look for cliques of size 5 (where everyone is friends with each other) or independent sets of size 5 (where no one is friends with each other). We will use the NetworkX library, which is efficient for handling large graphs and provides built-in functions for finding cliques.\n", "requirement analysis:\nThe requirements focus on determining the feasibility of organizing a successful party based on friendship connections. The solution must efficiently handle large numbers of people and friendships, ensuring that the output is clear and concise. Edge cases, such as when the number of people is less than 5, must be handled appropriately.\nrequirement pool:\n- Efficiently determine if a successful party can be organized.\n- Handle edge cases where N is less than 5.\n- Provide clear output indicating the feasibility of a party.\n- Optimize for large datasets.\n- Consider multiple successful party configurations.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by checking for cliques of size 5 or independent sets of size 5 in the graph. We will use adjacency lists to represent the graph and explore combinations of nodes to find valid parties. NetworkX, a Python library for graph analysis, can be used to simplify operations like finding cliques.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and ensuring the solution is efficient given the constraints on N and M.\nrequirement pool:\n- Develop an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles edge cases, such as when N < 5.\n- Optimize the solution for large inputs to prevent timeouts.\n- Provide clear and formatted output as specified.\n- Consider multiple successful configurations if they exist.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by checking for cliques of size 5 (where all participants are friends) or independent sets of size 5 (where no participants are friends). We will utilize the NetworkX library to handle graph operations efficiently, as it provides functions to find cliques and independent sets.\n", "requirement analysis:\nThe problem requires determining if a group of exactly 5 people can be selected such that they are either all friends or none are friends. This involves checking for cliques of size 5 or independent sets of size 5 in a graph. The constraints suggest the need for efficient graph algorithms due to the large possible input size.\nrequirement pool:\n- Implement an efficient algorithm to find cliques of size 5.\n- Implement an efficient algorithm to find independent sets of size 5.\n- Optimize the solution for large input sizes.\n- Ensure the solution handles edge cases, such as when N < 5.\n- Provide clear documentation and comments in the code.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and check for cliques of size 5 or independent sets of size 5. Given the constraints, we need an efficient algorithm. We can use adjacency lists to represent the graph and then apply a combination of depth-first search (DFS) and backtracking to find the required sets. The NetworkX library can be useful for handling graph operations efficiently.\n", "requirement analysis:\nThe problem requires finding a subset of 5 people from a larger group such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M. The solution must handle edge cases where N is less than 5, making a successful party impossible.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party configuration.\n- Ensure the solution handles the maximum constraints of N and M efficiently.\n- Provide clear and concise output as per the specified format.\n- Consider edge cases where N is less than 5.\n- Optimize for multiple successful party configurations if possible.\nWe will use graph theory to solve this problem efficiently. The problem can be approached by checking for cliques of size 5 (where all participants are friends) or independent sets of size 5 (where no participants are friends). We will utilize the NetworkX library to handle graph operations efficiently, given the constraints on N and M.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who either all know each other or none know each other. This involves graph theory concepts such as cliques and independent sets. The constraints on N and M suggest the need for efficient algorithms that can handle large graphs.\nrequirement pool:\n- Implement an efficient algorithm to check for cliques of size 5.\n- Implement an efficient algorithm to check for independent sets of size 5.\n- Optimize the solution to handle the maximum constraints of N and M.\n- Ensure the solution handles edge cases, such as when N < 5.\n- Provide clear and concise output as per the problem statement.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and look for cliques of size 5 or independent sets of size 5. A clique is a subset of vertices such that every two distinct vertices are adjacent, and an independent set is a subset of vertices such that no two vertices are adjacent. Given the constraints, we will use efficient algorithms to check for these conditions. We will utilize the NetworkX library, which provides efficient graph algorithms, to help us identify cliques and independent sets.\n", "requirement analysis:\nThe problem requires determining if a group of exactly 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently given the constraints on N and M.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party.\n- Ensure the solution handles edge cases, such as when N < 5.\n- Optimize for large input sizes to meet performance constraints.\n- Provide clear and concise output as per the problem statement.\n- Consider multiple successful party configurations if possible.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (where all participants are friends) or an independent set of size 5 (where no participants are friends). Given the constraints, we will use adjacency lists to represent friendships and employ efficient graph traversal techniques to check for these conditions. We will also handle edge cases where N < 5 immediately by returning -1.\n", "requirement analysis:\nThe problem requires determining if a group of exactly 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M.\nrequirement pool:\n- Implement an efficient algorithm to check for a successful party.\n- Ensure the solution handles edge cases, such as when N < 5.\n- Optimize the solution for large inputs within the given constraints.\n- Provide clear and formatted output as specified.\n- Consider multiple successful party configurations if possible.\nWe will use a graph-based approach to solve this problem. The problem can be reduced to finding a clique of size 5 (where all participants are friends) or an independent set of size 5 (where no participants are friends). Given the constraints, we will use adjacency lists to represent friendships and check combinations efficiently. We will leverage the itertools library to generate combinations and check the conditions for a successful party.\n", "requirement analysis:\nThe problem requires determining if a group of exactly 5 people can be selected such that they are either all friends or none are friends. This involves checking combinations of friendships and non-friendships efficiently, especially given the constraints on N and M.\nrequirement pool:\n- Implement the main algorithm to check for successful party conditions.\n- Optimize the solution to handle the upper limits of N and M efficiently.\n- Ensure the solution outputs in the correct format for all test cases.\n- Consider edge cases where N is less than 5.\n- Explore potential optimizations for specific graph structures.\nWe will use graph theory to solve this problem. The friendships can be represented as an undirected graph where nodes are people and edges are friendships. We need to check for cliques of size 5 (where all nodes are connected) or independent sets of size 5 (where no nodes are connected). Given the constraints, we will use efficient graph traversal techniques and combinatorial checks to determine the possibility of a successful party.\n", "requirement analysis:\nThe problem requires determining if a group of exactly 5 people can be formed such that they are either all friends or none are friends. This involves checking for cliques of size 5 or independent sets of size 5 in a graph representation of friendships. The constraints on N and M suggest the need for efficient graph algorithms to handle potentially large inputs.\nrequirement pool:\n- Implement an efficient algorithm to find cliques of size 5.\n- Implement an efficient algorithm to find independent sets of size 5.\n- Optimize the solution for large values of N and M.\n- Ensure the solution handles edge cases where N < 5.\n- Provide clear and concise output formatting.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and check for cliques of size 5 or independent sets of size 5. For detecting cliques, we can use a combination of adjacency list representation and depth-first search (DFS) to explore potential cliques. For independent sets, we can use a similar approach but ensure no two nodes in the set are connected. Given the constraints, we need to ensure the solution is efficient, possibly using optimizations like pruning during DFS.\n"], "scores": [], "pass_results": [false, true, true, false, true, true, true, false, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 5, "round": 267, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "add_1_sentence_at_end", "parent_index": 145}
