{"name": "1579_C. Ticks", "description": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m. Initially, all cells of the field are white.\n\nLet us denote the cell with coordinates i vertically and j horizontally by (i, j). The upper left cell will be referred to as (1, 1) and the lower right cell as (n, m).\n\nCasimir draws ticks of different sizes on the field. A tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: \n\n  1. First, the center cell (i, j) is painted black. \n  2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. \n  3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted. In particular, a tick consists of 2d + 1 black cells. \n\n\n\nAn already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3.\n\n<image>\n\nYou are given a description of a checkered field of size n \u00d7 m. Casimir claims that this field came about after he drew some (possibly 0) ticks on it. The ticks could be of different sizes, but the size of each tick is at least k (that is, d \u2265 k for all the ticks).\n\nDetermine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "tags": ["greedy", "implementation"], "difficulty": 9, "id": 1579, "sample_io": [{"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n"]}], "test_list": [{"input": "1\n1 1 1\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 1\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 1\n.....\n", "output": ["YES\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n..*...\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 5 2\n.....\n", "output": ["YES\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n...*.....\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nNO\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n1 1 0\n.\n", "output": ["YES\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n.*...\n.*.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 2 2\n....*\n*..+-\n..+..\n.../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n./..*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 4\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 2\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n.....*\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/./*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 1 2\n*\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*.*...*.*\n.*../..*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n1 6 1\n.*....\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n.*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n....*\n*..+-\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n+...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n-+.*.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n**.......\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*.\n./..\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 0\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n3 4 1\n...*\n*.*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n...*.\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n*..*/\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n.-**..*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n..//\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 3 1\n/..*\n.*.*\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 2 3\n/...*\n*..+-\n..+./\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n*..*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 3\n*-*...*.*\n.*.....).\n....*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/.*.\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n../..\n.....\n*.*-*\n.*.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n/*.+-\n..*./\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n/..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/*..\n*.*.\n.*..\n.0..\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.../.\n.....\n*.*.*\n.*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n/..*\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n./..*\n*..+-\n-.*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n/.*.\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+./*\n./+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n..-...\n.....*\n*...*.\n.*.*.-\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n/..*\n*.*/\n*.-.\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+..\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n.*./\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n..*.\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.,-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n//.*\n*.+.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n.*.*\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n./-.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*/*-\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 1 1\n..*/\n*.*.\n.+-.\n..1.\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-./..\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n5 4 2\n.../..\n*.....\n*...*.\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+-\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../...\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.*.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n0..*\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 3\n-.....\n.....*\n.*...*\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n.*..\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*./\n.//.\n", "output": ["NO\n"]}, {"input": "1\n2 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n../..\n*.*.*\n-+..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*..\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n5 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n..*/\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..*.\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*.+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n*..0\n*.*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n-.....\n.....*\n.*...*\n.*.*..\n..*../\n", "output": ["NO\n"]}, {"input": "1\n3 4 1\n...*\n*.*.\n..*.\n.-/.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n.*//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n*../\n*.*.\n*...\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n.*/.\n*.).\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n*...\n*.*/\n/*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n..).\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.+.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n2 6 1\n../.-.\n*.....\n*...*.\n.*.*..\n...*..\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n..*/\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n-....\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n.*..\n*.*.\n.)..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n./*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n1 4 2\n...*\n*-+.\n/*..\n./..\n", "output": ["NO\n"]}, {"input": "1\n4 1 2\n..*.\n*.+.\n*.//\n.//.\n", "output": ["NO\n"]}, {"input": "1\n3 5 3\n....-\n.....\n*.*.*\n/*..*\n..)..\n", "output": ["NO\n"]}, {"input": "1\n4 2 1\n.*...\n.*.*.\n-/*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n.....\n.....\n*.*.*\n.*.*.\n/.*..\n", "output": ["NO\n"]}, {"input": "1\n1 9 1\n*.*...*.*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n...**\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n3 6 1\n.*../.\n..*.*.\n...*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n..**\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n2 5 1\n....*\n.*.+.\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n.*..\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n1 4 1\n/..*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....)\n*..+-\n..*..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*..+-\n..*..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n-+..*\n..+..\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n*/*.\n.*..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*.*...*\n.*.....*.\n....*....\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..+.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n.//.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n...*.\n.*.+-\n..*.-\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/..*\n).*.\n*...\n../.\n", "output": ["NO\n"]}, {"input": "1\n4 5 1\n....*\n*..+-\n..*-.\n.....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n/.*.\n.*.*\n.*/.\n..0.\n", "output": ["NO\n"]}, {"input": "1\n4 5 2\n....*\n*/.+-\n..+..\n-....\n", "output": ["NO\n"]}, {"input": "1\n4 4 1\n..*/\n**..\n.+..\n..0.\n", "output": ["NO\n"]}, {"input": "1\n5 5 2\n-....\n.....\n*.*.*\n*-.*.\n..*..\n", "output": ["NO\n"]}, {"input": "1\n3 9 1\n*-*...*.*\n.*.....*.\n-...*../.\n", "output": ["NO\n"]}, {"input": "1\n5 6 2\n......\n.....*\n*...).\n.*.*..\n/..*..\n", "output": ["NO\n"]}, {"input": "1\n4 4 2\n...*\n*.*.\n.*..\n../.\n", "output": ["NO\n"]}, {"input": "8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 2\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n...-.*.\n..*.*..\n...*./.\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n", "output": ["NO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\n"]}], "task_id": "codecontest/15", "prompt": "Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m, initially, all cells of the field are white. Let us denote the cell with coordinates i vertically and j horizontally by (i, j); the upper left cell will be referred to as (1, 1) and the lower right cell as (n, m). Casimir draws ticks of different sizes on the field; a tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: 1. First, the center cell (i, j) is painted black. After painting the center cell black, additional cells are painted black too. 2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. 3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted, meaning a tick consists of 2d + 1 black cells. An already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3. <image> You are given a description of a checkered field of size n \u00d7 m, which Casimir claims resulted from drawing some (possibly 0) ticks on it, where each tick's size is at least k (d \u2265 k for all ticks). Determine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not, ensuring the solution is efficient for large values of n and m.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "repair_prompt": ["Casimir has a rectangular piece of paper with a checkered field of size n \u00d7 m, initially, all cells of the field are white. Let us denote the cell with coordinates i vertically and j horizontally by (i, j); the upper left cell will be referred to as (1, 1) and the lower right cell as (n, m). Casimir draws ticks of different sizes on the field; a tick of size d (d > 0) with its center in cell (i, j) is drawn as follows: 1. First, the center cell (i, j) is painted black. After painting the center cell black, additional cells are painted black too. 2. Then exactly d cells on the top-left diagonally to the center and exactly d cells on the top-right diagonally to the center are also painted black. 3. That is all the cells with coordinates (i - h, j \u00b1 h) for all h between 0 and d are painted, meaning a tick consists of 2d + 1 black cells. An already painted cell will remain black if painted again. Below you can find an example of the 4 \u00d7 9 box, with two ticks of sizes 2 and 3. <image> You are given a description of a checkered field of size n \u00d7 m, which Casimir claims resulted from drawing some (possibly 0) ticks on it, where each tick's size is at least k (d \u2265 k for all ticks). Determine whether this field can indeed be obtained by drawing some (possibly none) ticks of sizes d \u2265 k or not, ensuring the solution is efficient for large values of n and m.\n\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determine if a checkered field can be formed by drawing ticks of a minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): Each test case is a tuple containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid itself represented as a list of strings.\n\n    Returns:\n        List[str]: A list of \"YES\" or \"NO\" for each test case indicating if the ticks can be formed.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to track painted cells\n        painted = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                        size += 1\n\n                    # If a tick of at least size k can be formed, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            painted[i - s][j - s] = True\n                            painted[i - s][j + s] = True\n\n        # Verify if all '*' in the grid are part of a tick\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not painted[i][j]:\n                    can_form = False\n                    break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        grid = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, grid))\n        index += n + 1\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if a checkered field can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The grid represented as a list of strings.\n\n    Returns:\n        List[str]: A list of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track the maximum tick size that can be formed at each cell\n        max_tick_size = [[0] * m for _ in range(n)]\n\n        # Traverse the grid from bottom to top\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                if field[i][j] == '*':\n                    if i + 1 < n and j - 1 >= 0 and j + 1 < m:\n                        # Calculate the maximum tick size using the cells below\n                        max_tick_size[i][j] = min(max_tick_size[i + 1][j - 1], max_tick_size[i + 1][j + 1]) + 1\n                    else:\n                        max_tick_size[i][j] = 1\n\n        # Check if all '*' can be part of a tick of size at least k\n        can_form = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    if max_tick_size[i][j] < k:\n                        # If a '*' cannot be part of a tick of size at least k, check if it can be part of a smaller tick\n                        if i + k - 1 < n and j - (k - 1) >= 0 and j + (k - 1) < m:\n                            if min(max_tick_size[i + k - 1][j - (k - 1)], max_tick_size[i + k - 1][j + (k - 1)]) < k:\n                                can_form = False\n                                break\n                        else:\n                            can_form = False\n                            break\n            if not can_form:\n                break\n\n        results.append(\"YES\" if can_form else \"NO\")\n\n    return results\n\n# Input interface\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    test_cases = []\n    index = 1\n    for _ in range(t):\n        n, m, k = map(int, data[index].split())\n        field = [data[index + i + 1] for i in range(n)]\n        test_cases.append((n, m, k, field))\n        index += n + 1\n\n    # Output interface\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if a checkered field can be formed by drawing ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The checkered field represented as a list of strings.\n\n    Returns:\n        List[str]: A list of strings, each being \"YES\" or \"NO\" indicating if the field can be formed.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell is part of a tick\n        ticked = [[False] * m for _ in range(n)]\n\n        # Function to check if a tick can be formed at a given position\n        def can_form_tick(x: int, y: int) -> bool:\n            \"\"\"Checks if a tick of size at least k can be formed at position (x, y).\"\"\"\n            length = 0\n            while (x - length >= 0 and y - length >= 0 and y + length < m and\n                   field[x - length][y - length] == '*' and field[x - length][y + length] == '*'):\n                length += 1\n            return length > k\n\n        # Mark all possible ticks\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and can_form_tick(i, j):\n                    length = 0\n                    while (i - length >= 0 and j - length >= 0 and j + length < m and\n                           field[i - length][j - length] == '*' and field[i - length][j + length] == '*'):\n                        ticked[i - length][j - length] = True\n                        ticked[i - length][j + length] = True\n                        length += 1\n\n        # Verify if all '*' are part of a tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not ticked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if a checkered field can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The grid representation with '*' for black cells and '.' for white cells.\n\n    Returns:\n        List[str]: A list of \"YES\" or \"NO\" for each test case indicating if the field can be formed.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to track if a cell is part of a tick\n        tick_marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with the current cell as the center\n                    if can_form_tick(i, j, n, m, k, field, tick_marked):\n                        mark_tick(i, j, k, tick_marked)\n\n        # Verify if all '*' cells are part of a tick\n        if all(field[i][j] == '.' or tick_marked[i][j] for i in range(n) for j in range(m)):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef can_form_tick(x: int, y: int, n: int, m: int, k: int, field: List[str], tick_marked: List[List[bool]]) -> bool:\n    \"\"\"Checks if a tick of size k can be formed with the cell (x, y) as the center.\n\n    Args:\n        x (int): Row index of the center cell.\n        y (int): Column index of the center cell.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        k (int): Minimum size of the tick.\n        field (List[str]): The grid representation.\n        tick_marked (List[List[bool]]): 2D list to track tick cells.\n\n    Returns:\n        bool: True if a tick can be formed, False otherwise.\n    \"\"\"\n    # Check if there is enough space to form a tick of size k\n    for d in range(k):\n        if (x - d < 0 or y - d < 0 or y + d >= m or\n            field[x - d][y - d] != '*' or field[x - d][y + d] != '*'):\n            return False\n    return True\n\ndef mark_tick(x: int, y: int, k: int, tick_marked: List[List[bool]]):\n    \"\"\"Marks the cells of a tick of size k with the cell (x, y) as the center.\n\n    Args:\n        x (int): Row index of the center cell.\n        y (int): Column index of the center cell.\n        k (int): Minimum size of the tick.\n        tick_marked (List[List[bool]]): 2D list to track tick cells.\n    \"\"\"\n    for d in range(k):\n        tick_marked[x - d][y - d] = True\n        tick_marked[x - d][y + d] = True\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List\n\ndef can_form_ticks(t: int, test_cases: List[tuple]) -> List[str]:\n    \"\"\"Determines if a checkered field can be obtained by drawing ticks of size d \u2265 k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[tuple]): A list of tuples, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The checkered field represented as a list of strings.\n\n    Returns:\n        List[str]: A list of strings, each being \"YES\" or \"NO\" for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n\n                    # If a tick of at least size k is found, mark the cells\n                    if size > k:\n                        for d in range(size):\n                            marked[i - d][j - d] = True\n                            marked[i - d][j + d] = True\n\n        # Verify if all '*' in the field are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Call the function and print results\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_draw_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if a checkered field can be obtained by drawing ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the field.\n            - m (int): Number of columns in the field.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The checkered field represented as a list of strings.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a grid to mark the positions of ticks\n        tick_grid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to check if it can be the center of a tick\n        for i in range(k, n - k):\n            for j in range(k, m - k):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be drawn\n                    can_draw = True\n                    for d in range(1, k + 1):\n                        if field[i - d][j - d] != '*' or field[i - d][j + d] != '*':\n                            can_draw = False\n                            break\n                    if can_draw:\n                        # Mark the tick positions in the grid\n                        tick_grid[i][j] = True\n                        for d in range(1, k + 1):\n                            tick_grid[i - d][j - d] = True\n                            tick_grid[i - d][j + d] = True\n\n        # Verify if all '*' in the field are covered by ticks\n        all_covered = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not tick_grid[i][j]:\n                    all_covered = False\n                    break\n            if not all_covered:\n                break\n\n        results.append(\"YES\" if all_covered else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n\n    # Output interface\n    results = can_draw_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_draw_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determine if a checkered field can be obtained by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (List[str]): The grid representation with '.' and '*' characters.\n\n    Returns:\n        List[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a valid tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be drawn with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                        size += 1\n\n                    # If a valid tick of at least size k is found, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the grid are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\ndef main():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    # Call the function and print results\n    results = can_draw_ticks(t, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef can_form_ticks(t: int, test_cases: list[tuple[int, int, int, list[str]]]) -> list[str]:\n    \"\"\"Determine if a checkered field can be formed by drawing ticks of a minimum size k.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, int, list[str]]]): Each test case contains:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (list[str]): The grid representation with '*' for black cells and '.' for white cells.\n\n    Returns:\n        list[str]: A list of \"YES\" or \"NO\" for each test case indicating if the grid can form valid ticks.\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to track if a cell is part of a valid tick\n        valid_tick = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    if can_form_tick_at(i, j, k, grid, n, m):\n                        mark_tick(i, j, k, valid_tick, n, m)\n\n        # Verify if all '*' cells are part of a valid tick\n        if all(grid[i][j] == '.' or valid_tick[i][j] for i in range(n) for j in range(m)):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef can_form_tick_at(x: int, y: int, k: int, grid: list[str], n: int, m: int) -> bool:\n    \"\"\"Check if a tick of size k can be formed with (x, y) as the center.\n\n    Args:\n        x (int): Row index of the center.\n        y (int): Column index of the center.\n        k (int): Minimum size of the tick.\n        grid (list[str]): The grid representation.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n\n    Returns:\n        bool: True if a tick can be formed, False otherwise.\n    \"\"\"\n    # Check if the tick can extend k cells diagonally in both directions\n    for d in range(1, k + 1):\n        if x - d < 0 or y - d < 0 or y + d >= m:\n            return False\n        if grid[x - d][y - d] != '*' or grid[x - d][y + d] != '*':\n            return False\n    return True\n\ndef mark_tick(x: int, y: int, k: int, valid_tick: list[list[bool]], n: int, m: int):\n    \"\"\"Mark the cells of a valid tick in the valid_tick grid.\n\n    Args:\n        x (int): Row index of the center.\n        y (int): Column index of the center.\n        k (int): Minimum size of the tick.\n        valid_tick (list[list[bool]]): 2D list to track valid tick cells.\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n    \"\"\"\n    # Mark the center of the tick\n    valid_tick[x][y] = True\n    # Mark the diagonals of the tick\n    for d in range(1, k + 1):\n        valid_tick[x - d][y - d] = True\n        valid_tick[x - d][y + d] = True\n\n# Interface to read input and output results\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\ndef can_form_ticks(t: int, test_cases: list[tuple[int, int, int, list[str]]]) -> list[str]:\n    \"\"\"Determine if all black cells in the grid can be part of a tick.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (list[tuple[int, int, int, list[str]]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - grid (list[str]): The grid representation with '.' and '*' characters.\n\n    Returns:\n        list[str]: List of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, grid in test_cases:\n        # Create a 2D list to mark cells that are part of a tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Check each cell to see if it can be the center of a tick\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while True:\n                        if (i - size >= 0 and j - size >= 0 and j + size < m and\n                                grid[i - size][j - size] == '*' and grid[i - size][j + size] == '*'):\n                            size += 1\n                        else:\n                            break\n\n                    # If the tick size is at least k, mark the cells\n                    if size > k:\n                        for s in range(size):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the grid are part of some tick\n        all_marked = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not marked[i][j]:\n                    all_marked = False\n                    break\n            if not all_marked:\n                break\n\n        if all_marked:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\n# Interface to read input and output results\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        grid = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, grid))\n\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef can_form_ticks(t: int, test_cases: List[Tuple[int, int, int, List[str]]]) -> List[str]:\n    \"\"\"Determines if a checkered field can be formed by drawing ticks of a specified minimum size.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, List[str]]]): A list of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - k (int): Minimum size of the tick.\n            - field (List[str]): The grid representation with '.' for empty and '*' for filled.\n\n    Returns:\n        List[str]: A list of results for each test case, either \"YES\" or \"NO\".\n    \"\"\"\n    results = []\n\n    for n, m, k, field in test_cases:\n        # Create a 2D list to mark cells that are part of a valid tick\n        marked = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell to find potential tick centers\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    # Check if a tick of size k can be formed with (i, j) as the center\n                    size = 0\n                    while (i - size >= 0 and j - size >= 0 and j + size < m and\n                           field[i - size][j - size] == '*' and field[i - size][j + size] == '*'):\n                        size += 1\n                    size -= 1  # Adjust size to the last valid tick size\n\n                    if size >= k:\n                        # Mark the cells of the tick\n                        for s in range(size + 1):\n                            marked[i - s][j - s] = True\n                            marked[i - s][j + s] = True\n\n        # Verify if all '*' in the field are part of a valid tick\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*' and not marked[i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        n, m, k = map(int, input().split())\n        field = [input().strip() for _ in range(n)]\n        test_cases.append((n, m, k, field))\n    results = can_form_ticks(t, test_cases)\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe task requires determining if a given checkered field can be formed by drawing ticks of a minimum size. The solution must efficiently handle multiple test cases and large grid sizes, ensuring accurate results. The output should be clear, providing a YES or NO for each test case.\nrequirement pool:\n- Efficiently handle large grid sizes and multiple test cases.\n- Provide accurate results for each test case.\n- Ensure the output format is clear and concise.\n- Optimize the solution for performance.\n- Handle edge cases effectively.\nWe will implement a function to determine if a given checkered field can be formed by drawing ticks of a minimum size. The function will iterate over each cell in the grid, checking if it can be the center of a tick of size at least k. If a tick can be formed, it will mark the cells as part of a tick. The solution will efficiently handle multiple test cases by processing each grid independently and using a set to track painted cells.\n", "requirement analysis:\nThe task requires determining if a given checkered field can be obtained by drawing ticks of a minimum size k. The solution must efficiently handle multiple test cases and large grid sizes. The input-output format must be strictly followed, and the solution should be robust against edge cases.\nrequirement pool:\n- Efficiently handle large grid sizes and multiple test cases\n- Strictly follow the input-output format\n- Ensure robustness against edge cases\n- Provide clear and concise output\n- Maintain code simplicity and readability\nWe will implement a function that checks if the given checkered field can be obtained by drawing ticks of a minimum size k. The function will iterate over each cell in the grid and attempt to verify if it can be the center of a tick of size at least k. We will use a simple nested loop structure to efficiently traverse the grid and check the conditions for tick formation. The solution will be optimized to handle multiple test cases and large grid sizes by ensuring that each cell is processed in constant time.\n", "requirement analysis:\nThe requirements focus on determining if a checkered field can be formed by drawing ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide accurate results, especially for larger fields. Edge cases and overlapping ticks must be considered to ensure correctness.\nrequirement pool:\n- Efficiently process multiple test cases\n- Accurately determine if fields can be formed by ticks\n- Optimize for large field sizes\n- Handle edge cases and overlapping ticks\n- Provide clear output for each test case\nWe will implement a function that checks if a given checkered field can be formed by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, and for each black cell ('*'), it will attempt to form a tick of size at least k. If a tick can be formed, it will mark the cells as part of a tick. The solution will ensure efficiency by only checking necessary cells and will handle edge cases by verifying the tick formation conditions.\n", "requirement analysis:\nThe task requires determining if a given checkered field can be obtained by drawing ticks of a minimum size k. The solution must efficiently handle multiple test cases and provide a clear YES or NO output for each. The constraints on n and m are relatively small, allowing for a straightforward approach, but the solution must still be optimized for clarity and efficiency.\nrequirement pool:\n- Efficiently determine if the field can be obtained by drawing ticks of size d \u2265 k.\n- Handle multiple test cases and provide correct output for each.\n- Ensure the solution is easy to understand and maintain.\n- Optimize the solution for large values of n and m.\n- Provide detailed comments and documentation in the code.\nWe will implement a function that checks if a given checkered field can be obtained by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, and for each black cell ('*'), it will attempt to form a tick of size at least k. If a tick can be formed, it will mark the cells as part of a tick. The solution will ensure efficiency by only checking necessary cells and will handle multiple test cases as described.\n", "requirement analysis:\nThe problem requires determining if a given checkered field can be obtained by drawing ticks of a minimum size k. The solution must efficiently handle multiple test cases and provide a clear YES or NO output for each. The constraints on n and m suggest that the solution should be optimized for small to medium-sized grids.\nrequirement pool:\n- Efficiently determine if the field can be obtained by drawing ticks of size d \u2265 k.\n- Handle multiple test cases and provide output for each.\n- Optimize the solution for edge cases and large inputs.\n- Ensure the output is clear and concise.\n- Maintain code readability and simplicity.\nWe will implement a function that checks if the given checkered field can be obtained by drawing ticks of size d \u2265 k. The function will iterate over each cell in the grid, and for each '*' found, it will attempt to verify if it can be the center of a tick of size at least k. This involves checking diagonally upwards to ensure there are enough '*' to form a valid tick. The solution will be efficient by only checking necessary cells and marking cells that have been verified as part of a tick to avoid redundant checks.\n", "requirement analysis:\nThe requirement is to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The solution must efficiently handle multiple test cases and large input sizes, ensuring that the output format is consistent and easy to understand.\nrequirement pool:\n- Efficiently handle large input sizes for n and m.\n- Ensure output format is consistent and easy to understand.\n- Optimize the solution for performance.\n- Handle edge cases and provide clear error messages.\n- Maintain compatibility with the input-output format.\nWe will implement a function to determine if a given checkered field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. We will use efficient iteration and condition checking to ensure the solution handles large input sizes effectively. The solution will be implemented in Python, leveraging its built-in data structures for simplicity and performance.\n", "requirement analysis:\nThe problem requires determining if a given checkered field can be obtained by drawing ticks of a minimum size k. The solution must efficiently handle multiple test cases and large field sizes, ensuring that the output format is consistent with the requirements.\nrequirement pool:\n- Efficiently determine if the field can be obtained by drawing ticks of size d \u2265 k.\n- Ensure the solution handles up to 100 test cases.\n- Optimize the solution for large values of n and m.\n- Provide clear and consistent output for each test case.\n- Maintain compatibility with the specified input-output format.\nWe will implement a function to determine if a given checkered field can be obtained by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, checking if it can be the center of a valid tick of size at least k. We will use a nested loop to verify the conditions for each potential tick center, ensuring that all required cells are black. The solution will be optimized to handle up to 100 test cases efficiently, with each grid having a maximum size of 10x19.\n", "requirement analysis:\nThe task requires determining if a given checkered field can be formed by drawing ticks of a minimum size k. The solution must efficiently handle multiple test cases and provide a clear YES or NO output for each. The constraints on n and m are relatively small, allowing for a straightforward approach, but the solution must still be optimized for clarity and efficiency.\nrequirement pool:\n- Efficiently determine if the field can be formed by ticks of size d \u2265 k\n- Handle multiple test cases and provide output for each\n- Optimize for large values of n and m\n- Ensure clarity and accuracy in output\n- Consider edge cases and unusual patterns\nWe will implement a function that checks if a given checkered field can be formed by drawing ticks of a minimum size k. The function will iterate over each cell in the grid, and for each black cell ('*'), it will attempt to form a tick centered at that cell. It will check if the tick can extend diagonally up to the required size k. If any black cell cannot be part of a valid tick, the function will return NO for that test case. The solution will efficiently handle multiple test cases by processing each grid independently.\n", "requirement analysis:\nThe requirement is to determine if a given checkered field can be obtained by drawing ticks of a minimum size k. The solution must efficiently handle multiple test cases and provide a clear YES or NO output for each. The constraints on n and m are relatively small, allowing for a straightforward approach to checking each possible tick center.\nrequirement pool:\n- Efficiently determine if the field can be obtained by drawing ticks of size at least k.\n- Handle multiple test cases and provide correct output for each.\n- Ensure the solution is easy to understand and maintain.\n- Optimize for performance with larger values of n and m.\n- Provide detailed error messages for invalid inputs.\nWe will iterate over each cell in the grid and check if it can be the center of a tick of size at least k. For each potential center, we will verify if the required cells are black. If a tick can be formed, we will mark those cells as part of a tick. Finally, we will check if all black cells in the grid are part of some tick.\n", "requirement analysis:\nThe requirements focus on determining if a checkered field can be obtained by drawing ticks of a specified minimum size. The solution must efficiently handle multiple test cases and provide clear results. The constraints on field size and tick size must be adhered to, ensuring the solution is scalable and performs well for large inputs.\nrequirement pool:\n- Efficiently process multiple test cases\n- Accurately determine if the field can be obtained by drawing ticks\n- Optimize performance for large field sizes\n- Ensure clarity and accuracy in output\n- Handle edge cases effectively\nWe will implement a function that checks if a given checkered field can be obtained by drawing ticks of a specified minimum size. The function will iterate over each cell in the grid, attempting to identify potential tick centers and verifying if they can form valid ticks of size at least k. The approach will involve checking diagonals from each potential center and ensuring all required cells are black. This will be done efficiently to handle the constraints of n and m.\n"], "scores": [], "pass_results": [true, true, false, true, true, false, true, false, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 6, "round": 298, "examples": "\nInput\n\nThe first line contains an integer t (1 \u2264 t \u2264 100) \u2014 the number test cases.\n\nThe following lines contain the descriptions of the test cases. \n\nThe first line of the test case description contains the integers n, m, and k (1 \u2264 k \u2264 n \u2264 10; 1 \u2264 m \u2264 19) \u2014 the field size and the minimum size of the ticks that Casimir drew. The following n lines describe the field: each line consists of m characters either being '.' if the corresponding cell is not yet painted or '*' otherwise.\n\nOutput\n\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should be YES if the given field can be obtained by drawing ticks of at least the given size and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes, and YES will all be recognized as positive answers).\n\nExample\n\nInput\n\n\n8\n2 3 1\n*.*\n...\n4 9 2\n*.*.*...*\n.*.*...*.\n..*.*.*..\n.....*...\n4 4 1\n*.*.\n****\n.**.\n....\n5 5 1\n.....\n*...*\n.*.*.\n..*.*\n...*.\n5 5 2\n.....\n*...*\n.*.*.\n..*.*\n...*.\n4 7 1\n*.....*\n.....*.\n..*.*..\n...*...\n3 3 1\n***\n***\n***\n3 5 1\n*...*\n.***.\n.**..\n\n\nOutput\n\n\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n\nNote\n\nThe first sample test case consists of two asterisks neither of which can be independent ticks since ticks of size 0 don't exist.\n\nThe second sample test case is already described in the statement (check the picture in the statement). This field can be obtained by drawing ticks of sizes 2 and 3, as shown in the figure.\n\nThe field in the third sample test case corresponds to three ticks of size 1. Their center cells are marked with \\color{blue}{blue}, \\color{red}{red} and \\color{green}{green} colors: *.*.  \n---  \n*\\color{blue}{*}**  \n.\\color{green}{*}\\color{red}{*}.  \n....  \n  \nThe field in the fourth sample test case could have been obtained by drawing two ticks of sizes 1 and 2. Their vertices are marked below with \\color{blue}{blue} and \\color{red}{red} colors respectively: .....  \n---  \n*...*  \n.*.*.  \n..\\color{red}{*}.*  \n...\\color{blue}{*}.  \n  \nThe field in the fifth sample test case can not be obtained because k = 2, and the last asterisk in the fourth row from the top with coordinates (4, 5) can only be a part of a tick of size 1.\n\nThe field in the sixth sample test case can not be obtained because the top left asterisk (1, 1) can't be an independent tick, since the sizes of the ticks must be positive, and cannot be part of a tick with the center cell in the last row, since it is separated from it by a gap (a point, '.') in (2, 2).\n\nIn the seventh sample test case, similarly, the field can not be obtained by the described process because the asterisks with coordinates (1, 2) (second cell in the first row), (3, 1) and (3, 3) (leftmost and rightmost cells in the bottom) can not be parts of any ticks.", "mutate_method": "expand_one2two", "parent_index": 187}
