{"name": "1600_F. Party Organization", "description": "On the great island of Baltia, there live N people, numbered from 1 to N. There are exactly M pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly 5 people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "tags": ["brute force", "math", "probabilities"], "difficulty": 12, "id": 1600, "sample_io": [{"input": "5 4\n1 2\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 4\n", "output": ["1 2 3 5 6\n"]}], "test_list": [{"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "10 8\n5 2\n1 8\n5 7\n1 9\n6 4\n2 7\n8 9\n3 10\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 9\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 0\n", "output": ["1 2 3 4 5\n"]}, {"input": "10 8\n2 7\n2 9\n7 9\n8 10\n5 3\n1 4\n10 6\n6 8\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 2\n4 5\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "6 3\n1 4\n1 3\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "6 3\n1 2\n4 2\n5 2\n", "output": ["1 3 4 5 6\n"]}, {"input": "6 4\n1 4\n4 1\n2 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "7 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["1 2 4 6 7\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n2 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n5 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 3\n6 4\n3 1\n1 6\n1 5\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n2 4\n1 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "8 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n1 6\n1 3\n2 4\n4 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n6 1\n1 6\n1 4\n2 6\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 1\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n1 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 5\n4 2\n5 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n6 2\n3 5\n4 5\n6 4\n3 1\n2 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 1\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n2 4\n2 1\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n1 6\n5 1\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 3\n3 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 5\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n1 3\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n3 5\n2 5\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n4 2\n5 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 6\n4 1\n2 4\n4 5\n", "output": ["-1\n"]}, {"input": "20 57\n13 14\n12 20\n18 3\n17 20\n15 2\n18 13\n12 19\n2 4\n9 2\n12 11\n14 1\n16 11\n11 14\n16 4\n16 15\n11 19\n15 4\n10 15\n12 5\n9 3\n10 2\n10 4\n20 19\n14 7\n19 2\n5 8\n6 14\n4 17\n2 17\n17 9\n13 9\n19 9\n18 8\n12 16\n18 5\n7 1\n8 3\n11 20\n6 13\n20 5\n13 8\n17 19\n7 6\n9 11\n18 9\n13 1\n12 14\n7 3\n10 16\n20 2\n5 3\n10 17\n6 1\n8 9\n7 5\n12 15\n15 11\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 1\n3 2\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n1 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n4 3\n", "output": ["-1\n"]}, {"input": "6 3\n1 2\n5 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n2 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n1 5\n6 4\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n2 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 4\n5 2\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 2\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n5 4\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 4\n1 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n4 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 3\n3 4\n3 5\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n1 5\n1 4\n1 2\n3 5\n4 5\n6 4\n3 2\n1 6\n1 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n2 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 1\n4 2\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n5 3\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n1 3\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n2 1\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n1 3\n2 3\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n2 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 1\n3 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n1 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 5\n1 3\n3 4\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 3\n4 3\n3 4\n3 2\n", "output": ["1 2 4 5 6\n"]}, {"input": "5 4\n1 4\n2 5\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n4 3\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n4 1\n4 2\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n1 4\n1 5\n", "output": ["2 3 4 5 6\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n2 1\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n2 3\n2 4\n3 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 4\n3 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n4 1\n3 4\n1 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 4\n3 1\n3 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n2 1\n3 4\n2 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 1\n1 4\n4 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n2 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "6 4\n1 2\n3 2\n3 4\n4 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "6 4\n1 4\n4 1\n3 4\n4 5\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n1 3\n4 1\n3 2\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n5 4\n3 2\n", "output": ["-1\n"]}, {"input": "6 3\n1 4\n4 3\n4 1\n", "output": ["1 2 3 5 6\n"]}, {"input": "5 4\n2 4\n4 3\n3 2\n3 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 2\n3 2\n3 1\n4 2\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n3 1\n1 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n2 3\n1 3\n3 4\n3 1\n", "output": ["-1\n"]}, {"input": "6 13\n5 6\n2 5\n1 4\n1 2\n3 5\n4 5\n6 2\n3 1\n1 6\n4 3\n2 4\n6 3\n1 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n2 3\n3 4\n5 2\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 4\n1 3\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n2 4\n3 2\n2 4\n1 3\n", "output": ["-1\n"]}, {"input": "5 4\n1 5\n4 1\n3 2\n5 1\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n3 2\n3 4\n4 5\n", "output": ["-1\n"]}, {"input": "5 4\n1 4\n3 1\n2 4\n2 4\n", "output": ["-1\n"]}, {"input": "5 4\n1 3\n4 1\n3 1\n4 5\n", "output": ["-1\n"]}], "task_id": "codecontest/76", "prompt": "On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of people who have a friendship with each other. The residents of Baltia wish to organize a successful party, but they have very strict rules on what constitutes a party. They also have very strict rules on when it is considered successful. On the island of Baltia, a party is a gathering of exactly 5 people. To be deemed successful, either everyone at the party is friends with one another (so that they can all converse without concern about talking to someone they are not friends with) or none of the people at the party are friends with each other (ensuring that everyone can be on their phones without being disturbed). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Consider all possible combinations to ensure no potential successful party is overlooked. Algorithms and data structures can play a vital role in recognizing feasible combinations efficiently.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "repair_prompt": ["On the great island of Baltia, there live N people, numbered from 1 to N. There are precisely M pairs of people who have a friendship with each other. The residents of Baltia wish to organize a successful party, but they have very strict rules on what constitutes a party. They also have very strict rules on when it is considered successful. On the island of Baltia, a party is a gathering of exactly 5 people. To be deemed successful, either everyone at the party is friends with one another (so that they can all converse without concern about talking to someone they are not friends with) or none of the people at the party are friends with each other (ensuring that everyone can be on their phones without being disturbed). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so. Consider all possible combinations to ensure no potential successful party is overlooked. Algorithms and data structures can play a vital role in recognizing feasible combinations efficiently.\n\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed."], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in a friendship graph.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[Tuple[int, int]]): List of friendship pairs.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not found.\n    \"\"\"\n    # Create adjacency list for graph representation\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Check for a clique of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        if all(adjacency_list[x].intersection(combination) == set(combination) - {x} for x in combination):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in itertools.combinations(range(1, n + 1), 5):\n        if all(adjacency_list[x].isdisjoint(combination) for x in combination):\n            return list(combination)\n\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result != -1:\n        print(' '.join(map(str, result)))\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in the given friendship graph.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a clique or independent set, or -1 if none exists.\n    \"\"\"\n    # Create an adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for u, v in friendships:\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Try to find a clique or independent set of size 5\n    from itertools import combinations\n\n    for combination in combinations(range(1, n + 1), 5):\n        if is_clique(combination) or is_independent_set(combination):\n            return list(combination)\n\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_successful_party(n, m, friendships)\n\n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\nimport networkx as nx\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who either all know each other or none know each other.\n\n    Args:\n        N (int): The number of people.\n        M (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Create a graph from the friendships\n    graph = nx.Graph()\n    graph.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for clique in nx.find_cliques(graph):\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    # An independent set in a graph is a clique in its complement\n    complement_graph = nx.complement(graph)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found\n    return -1\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a group of 5 people who either all know each other (clique) or none know each other (independent set).\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a clique or independent set, or -1 if no such group exists.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Check all combinations of 5 people\n    for group in combinations(range(1, n + 1), 5):\n        if is_clique(group, adjacency_list) or is_independent_set(group, adjacency_list):\n            return list(group)\n    \n    return -1\n\ndef is_clique(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if the given group of people forms a clique.\n\n    Args:\n        group (Tuple[int, int, int, int, int]): A tuple of 5 people.\n        adjacency_list (dict): The adjacency list of the graph.\n\n    Returns:\n        bool: True if the group forms a clique, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] not in adjacency_list[group[i]]:\n                return False\n    return True\n\ndef is_independent_set(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if the given group of people forms an independent set.\n\n    Args:\n        group (Tuple[int, int, int, int, int]): A tuple of 5 people.\n        adjacency_list (dict): The adjacency list of the graph.\n\n    Returns:\n        bool: True if the group forms an independent set, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] in adjacency_list[group[i]]:\n                return False\n    return True\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: List[tuple]) -> List[int]:\n    \"\"\"Finds a successful party by checking combinations of 5 nodes in a graph.\n\n    Args:\n        n (int): Number of people.\n        m (int): Number of friendships.\n        friendships (List[tuple]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a successful party or -1 if not possible.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    graph = nx.Graph()\n    graph.add_edges_from(friendships)\n\n    # Check all combinations of 5 nodes\n    for nodes in nx.combinations(graph.nodes, 5):\n        subgraph = graph.subgraph(nodes)\n        # Check if the subgraph is a clique or an independent set\n        if nx.is_clique(subgraph) or nx.is_independent_set(subgraph):\n            return list(nodes)\n\n    # Return -1 if no successful party is found\n    return -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Call the function to find a successful party\n    result = find_successful_party(n, m, friendships)\n    \n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or none are friends.\n\n    Args:\n        N: The number of people.\n        M: The number of friendships.\n        friendships: A list of tuples where each tuple represents a friendship between two people.\n\n    Returns:\n        A list of 5 integers representing the people in the successful party, or -1 if no such party exists.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Check all combinations of 5 people\n    for combination in combinations(range(1, N + 1), 5):\n        if is_clique(combination, adjacency_list) or is_independent_set(combination, adjacency_list):\n            return list(combination)\n\n    return -1\n\ndef is_clique(people: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if the given people form a clique.\n\n    Args:\n        people: A tuple of 5 people.\n        adjacency_list: The adjacency list of the graph.\n\n    Returns:\n        True if the people form a clique, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if people[j] not in adjacency_list[people[i]]:\n                return False\n    return True\n\ndef is_independent_set(people: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if the given people form an independent set.\n\n    Args:\n        people: A tuple of 5 people.\n        adjacency_list: The adjacency list of the graph.\n\n    Returns:\n        True if the people form an independent set, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if people[j] in adjacency_list[people[i]]:\n                return False\n    return True\n\n# Input interface\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Call the function and print the result\n    result = find_successful_party(N, M, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport networkx as nx\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique or independent set of size 5 in a friendship graph.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 people forming a clique or independent set, or -1 if no such set exists.\n    \"\"\"\n    # Create an undirected graph using NetworkX\n    G = nx.Graph()\n    G.add_nodes_from(range(1, n + 1))\n    G.add_edges_from(friendships)\n\n    # Check for a clique of size 5\n    for clique in nx.find_cliques(G):\n        if len(clique) == 5:\n            return clique\n\n    # Check for an independent set of size 5\n    # An independent set in a graph is a clique in its complement\n    complement_graph = nx.complement(G)\n    for independent_set in nx.find_cliques(complement_graph):\n        if len(independent_set) == 5:\n            return independent_set\n\n    # If neither a clique nor an independent set of size 5 is found, return -1\n    return -1\n\ndef main():\n    # Input interface\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    # Call the function to find a successful party\n    result = find_successful_party(n, m, friendships)\n    \n    # Output interface\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom itertools import combinations\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party of 5 people who are either all friends or none are friends.\n\n    Args:\n        n (int): The number of people.\n        m (int): The number of friendships.\n        friendships (List[Tuple[int, int]]): A list of tuples representing friendships.\n\n    Returns:\n        List[int]: A list of 5 integers representing the successful party, or -1 if not possible.\n    \"\"\"\n    # Create an adjacency list to represent friendships\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Check for a clique of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(b in adjacency_list[a] for a, b in combinations(combination, 2)):\n            return list(combination)\n\n    # Check for an independent set of size 5\n    for combination in combinations(range(1, n + 1), 5):\n        if all(b not in adjacency_list[a] for a, b in combinations(combination, 2)):\n            return list(combination)\n\n    # If neither a clique nor an independent set of size 5 is found\n    return -1\n\n# Input interface\ndef main():\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(result)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport itertools\n\ndef find_successful_party(N: int, M: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a successful party configuration of 5 people either as a clique or an independent set.\n\n    Args:\n        N: The number of people.\n        M: The number of friendships.\n        friendships: A list of tuples where each tuple represents a friendship between two people.\n\n    Returns:\n        A list of 5 integers representing the people in a successful party configuration,\n        or -1 if no such configuration exists.\n    \"\"\"\n    # Create an adjacency list to represent the graph\n    adjacency_list = {i: set() for i in range(1, N + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Generate all combinations of 5 people\n    for combination in itertools.combinations(range(1, N + 1), 5):\n        # Check if the combination is a clique\n        if is_clique(combination, adjacency_list):\n            return list(combination)\n        # Check if the combination is an independent set\n        if is_independent_set(combination, adjacency_list):\n            return list(combination)\n\n    return -1\n\ndef is_clique(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if a given group of people forms a clique.\n\n    Args:\n        group: A tuple of 5 people.\n        adjacency_list: The adjacency list representing the graph.\n\n    Returns:\n        True if the group forms a clique, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] not in adjacency_list[group[i]]:\n                return False\n    return True\n\ndef is_independent_set(group: Tuple[int, int, int, int, int], adjacency_list: dict) -> bool:\n    \"\"\"Checks if a given group of people forms an independent set.\n\n    Args:\n        group: A tuple of 5 people.\n        adjacency_list: The adjacency list representing the graph.\n\n    Returns:\n        True if the group forms an independent set, False otherwise.\n    \"\"\"\n    for i in range(5):\n        for j in range(i + 1, 5):\n            if group[j] in adjacency_list[group[i]]:\n                return False\n    return True\n\n# Input interface\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\nresult = find_successful_party(n, m, friendships)\n\n# Output interface\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef find_successful_party(n: int, m: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Finds a clique of size 5 or an independent set of size 5 in a given graph.\n\n    Args:\n        n (int): Number of people (nodes).\n        m (int): Number of friendships (edges).\n        friendships (List[Tuple[int, int]]): List of tuples representing friendships.\n\n    Returns:\n        List[int]: List of 5 people forming a clique or independent set, or -1 if not possible.\n    \"\"\"\n    # Create adjacency list for the graph\n    adjacency_list = {i: set() for i in range(1, n + 1)}\n    for a, b in friendships:\n        adjacency_list[a].add(b)\n        adjacency_list[b].add(a)\n\n    # Helper function to check if a set of nodes forms a clique\n    def is_clique(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] not in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Helper function to check if a set of nodes forms an independent set\n    def is_independent_set(nodes: List[int]) -> bool:\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                if nodes[j] in adjacency_list[nodes[i]]:\n                    return False\n        return True\n\n    # Try to find a clique of size 5\n    def find_clique() -> List[int]:\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                for k in range(j + 1, n + 1):\n                    for l in range(k + 1, n + 1):\n                        for o in range(l + 1, n + 1):\n                            if is_clique([i, j, k, l, o]):\n                                return [i, j, k, l, o]\n        return []\n\n    # Try to find an independent set of size 5\n    def find_independent_set() -> List[int]:\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                for k in range(j + 1, n + 1):\n                    for l in range(k + 1, n + 1):\n                        for o in range(l + 1, n + 1):\n                            if is_independent_set([i, j, k, l, o]):\n                                return [i, j, k, l, o]\n        return []\n\n    # Check for a clique of size 5\n    clique = find_clique()\n    if clique:\n        return clique\n\n    # Check for an independent set of size 5\n    independent_set = find_independent_set()\n    if independent_set:\n        return independent_set\n\n    # If neither is found, return -1\n    return -1\n\n# Input interface\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    friendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Call the function and print the result\n    result = find_successful_party(n, m, friendships)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n"], "plans": ["requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves checking combinations of people and their friendship status. Given the constraints, efficient graph traversal and combination generation are crucial.\nrequirement pool:\n- Implement an efficient algorithm to check all combinations of 5 people.\n- Optimize the solution to handle the maximum constraints of N and M.\n- Ensure the solution provides output in the required format.\n- Consider edge cases where no friendships exist or everyone is friends.\n- Provide documentation and comments for code clarity.\nWe will use a graph-based approach to solve this problem. The problem can be represented as a graph where each person is a node and each friendship is an edge. We need to find a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). Given the constraints, we will use a combination of graph traversal and combinatorial checks to efficiently determine if such a set exists. We will leverage the itertools library for generating combinations and use adjacency lists for graph representation.\n", "requirement analysis:\nThe problem requires finding a combination of 5 people such that they are either all friends or none are friends. This involves checking combinations of people and their friendship status, which can be efficiently managed using graph theory concepts like cliques and independent sets.\nrequirement pool:\n- Implement the main algorithm to find a successful party.\n- Optimize the solution to handle the maximum constraints efficiently.\n- Ensure the solution is tested against edge cases.\n- Provide clear and concise output as per the requirements.\n- Document the solution approach and edge case handling.\nWe will use graph theory concepts to solve this problem. Specifically, we will represent the friendships as an undirected graph where nodes are people and edges are friendships. We will then look for cliques of size 5 (where everyone is friends) or independent sets of size 5 (where no one is friends). To efficiently find these sets, we can use combinatorial algorithms and graph traversal techniques. Given the constraints, we need to ensure our solution is optimized for large inputs, possibly using adjacency lists and efficient search algorithms.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people from a larger set such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships efficiently, given the constraints on N and M. The solution must handle large inputs and provide a clear output format.\nrequirement pool:\n- Develop an efficient algorithm to check all combinations of 5 people.\n- Ensure the solution can handle the maximum constraints of N and M.\n- Optimize the algorithm to reduce unnecessary checks.\n- Provide clear documentation and comments in the code.\n- Consider edge cases and test thoroughly.\nWe will use a graph-based approach to solve this problem. The problem can be translated into finding a clique of size 5 (where everyone knows each other) or an independent set of size 5 (where no one knows each other) in a graph. We will represent the friendships as an adjacency list and use combinations to check for these conditions efficiently. Given the constraints, we will leverage the itertools library for combinations and networkx for graph operations to ensure scalability and efficiency.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who either all know each other or none know each other. This involves checking combinations of friendships and non-friendships among the people. Given the constraints, efficient graph algorithms are necessary to handle the large input sizes.\nrequirement pool:\n- Implement an efficient algorithm to find a successful party.\n- Ensure the solution can handle the maximum constraints of N and M.\n- Optimize the solution for speed and memory usage.\n- Provide clear and user-friendly output.\n- Consider edge cases and validate input data.\nWe will use a graph-based approach to solve this problem. The problem can be translated into finding a clique of size 5 (where everyone knows each other) or an independent set of size 5 (where no one knows each other) in a graph. We will represent the friendships as an adjacency list and use efficient graph traversal techniques to check for these conditions. Given the constraints, we will use combinations to check all possible groups of 5 people, but we will optimize the search by leveraging properties of cliques and independent sets.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people from a given set of friendships such that either all are friends or none are friends. This involves checking combinations of people and their friendship status, which can be efficiently managed using graph theory concepts. The constraints suggest the need for an algorithm that can handle large inputs efficiently.\nrequirement pool:\n- Develop an efficient algorithm to check all combinations of 5 people.\n- Implement graph data structures to represent friendships.\n- Optimize the solution to handle edge cases and large inputs.\n- Ensure the solution is tested against multiple test cases.\n- Provide clear documentation and comments in the code.\nWe will use graph theory to represent friendships as an undirected graph. Each person is a node, and each friendship is an edge. We will then check combinations of 5 nodes to see if they form a complete subgraph (clique) or an independent set. The NetworkX library will be used to handle graph operations efficiently.\n", "requirement analysis:\nThe problem requires identifying a subset of 5 people from a larger group such that they either all know each other or none know each other. This involves checking combinations of friendships and non-friendships, which can be efficiently managed using graph theory concepts like cliques and independent sets.\nrequirement pool:\n- Implement a function to check all combinations of 5 people.\n- Use graph data structures to represent friendships.\n- Optimize the solution for large values of N and M.\n- Ensure the solution is robust and handles edge cases.\n- Provide detailed comments and documentation.\nWe will use graph theory to solve this problem. The friendships can be represented as an undirected graph where nodes are people and edges are friendships. We need to find either a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). We will use adjacency lists to represent the graph and employ combinatorial techniques to check all possible combinations of 5 people. Given the constraints, we will optimize the search using efficient graph traversal and combination generation techniques.\n", "requirement analysis:\nThe requirements focus on identifying a successful party configuration among N people with M friendships. The solution must efficiently handle large inputs and provide clear output indicating either a successful party or impossibility.\nrequirement pool:\n- Efficiently process input data to identify potential party configurations.\n- Implement algorithms to check friendship conditions for party success.\n- Optimize for large datasets to ensure scalability.\n- Provide clear output format for successful party or impossibility.\n- Consider edge cases and ensure robustness of the solution.\nWe will use graph theory to solve this problem. Specifically, we will represent the friendships as an undirected graph and use combinatorial algorithms to check for cliques or independent sets of size 5. The NetworkX library will be useful for handling graph operations efficiently.\n", "requirement analysis:\nThe problem requires finding a combination of 5 people who are either all friends or none are friends. This involves checking combinations of people and their friendship status, which can be efficiently managed using graph theory concepts such as cliques and independent sets.\nrequirement pool:\n- Implement an efficient algorithm to check all combinations of 5 people.\n- Ensure the solution can handle the maximum constraints of N and M.\n- Optimize the solution to reduce unnecessary computations.\n- Provide clear and concise output as per the problem statement.\n- Consider edge cases where no friendships exist or everyone is friends.\nWe will use graph theory to solve this problem. The problem can be reduced to finding a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). We will represent the friendships as an adjacency list and use combinations to check for these conditions efficiently. Given the constraints, we will use a combination of adjacency list representation and efficient search algorithms to ensure the solution is scalable.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who are either all friends or none are friends. This involves checking combinations of people and their friendship status. Given the constraints, efficient graph traversal and combination generation are crucial.\nrequirement pool:\n- Implement an efficient algorithm to check all combinations of 5 people.\n- Optimize the solution for large values of N and M.\n- Ensure the solution outputs the correct format as specified.\n- Handle edge cases where no successful party can be formed.\n- Provide documentation and comments for code clarity.\nWe will use a graph-based approach to solve this problem. Each person is a node, and each friendship is an edge in the graph. We need to find a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). Given the constraints, we will use adjacency lists to represent the graph and employ efficient graph traversal techniques to check for these conditions. We will leverage combinations from the itertools library to generate potential groups of 5 people and check their friendship status using the graph representation.\n", "requirement analysis:\nThe problem requires identifying a group of 5 people who either all know each other or none know each other. This involves checking combinations of friendships and non-friendships among the people. Given the constraints, efficient graph traversal and combination checking are necessary to handle the large input sizes.\nrequirement pool:\n- Implement an efficient algorithm to check all combinations of 5 people.\n- Ensure the solution can handle the maximum constraints of N and M.\n- Optimize the solution for speed and memory usage.\n- Provide clear output as specified in the requirements.\n- Consider edge cases such as no friendships or all possible friendships.\nWe will use a graph-based approach to solve this problem. The problem can be represented as a graph where each person is a node and each friendship is an edge. We need to find a clique of size 5 (where everyone is friends with each other) or an independent set of size 5 (where no one is friends with each other). Given the constraints, we will use adjacency lists to represent the graph and employ a combination of graph traversal and combinatorial checks to efficiently find the required group of 5 people. This approach leverages the efficiency of graph theory algorithms while keeping the complexity manageable.\n"], "scores": [], "pass_results": [true, true, true, false, true, true, false, true, false, true], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 7, "round": 338, "examples": "\nInput\n\nThe first line contains two integer numbers, N (5 \u2264 N \u2264 2*10^5) and M (0 \u2264 M \u2264 2*10^5) \u2013 the number of people that live in Baltia, and the number of friendships. The next M lines each contains two integers U_i and V_i (1 \u2264 U_i,V_i \u2264 N) \u2013 meaning that person U_i is friends with person V_i. Two friends can not be in the list of friends twice (no pairs are repeated) and a person can be friends with themselves (U_i \u2260 V_i).\n\nOutput\n\nIf it's possible to organize a successful party, print 5 numbers indicating which 5 people should be invited to the party. If it's not possible to organize a successful party, print -1 instead. If there are multiple successful parties possible, print any.\n\nExamples\n\nInput\n\n\n6 3\n1 4\n4 2\n5 4\n\n\nOutput\n\n\n1 2 3 5 6\n\n\nInput\n\n\n5 4\n1 2\n2 3\n3 4\n4 5\n\n\nOutput\n\n\n-1", "mutate_method": "expand_one2two", "parent_index": 202}
