{"name": "1623_A. Robot Cleaner", "description": "A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of n rows and m columns. The rows of the floor are numbered from 1 to n from top to bottom, and columns of the floor are numbered from 1 to m from left to right. The cell on the intersection of the r-th row and the c-th column is denoted as (r,c). The initial position of the robot is (r_b, c_b).\n\nIn one second, the robot moves by dr rows and dc columns, that is, after one second, the robot moves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc = 1. If there is a vertical wall (the left or the right walls) in the movement direction, dc is reflected before the movement, so the new value of dc is -dc. And if there is a horizontal wall (the upper or lower walls), dr is reflected before the movement, so the new value of dr is -dr.\n\nEach second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at (r_d, c_d). The job of the robot is to clean that dirty cell.\n\n<image> Illustration for the first example. The blue arc is the robot. The red star is the target dirty cell. Each second the robot cleans a row and a column, denoted by yellow stripes.\n\nGiven the floor size n and m, the robot's initial position (r_b, c_b) and the dirty cell's position (r_d, c_d), find the time for the robot to do its job.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n", "tags": ["brute force", "implementation", "math"], "difficulty": 7, "id": 1623, "sample_io": [{"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}], "test_list": [{"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n15\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n9\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n9\n1\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 2\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n8\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n9\n9\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n9\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n8 8 5 8 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n1\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["3\n9\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n7\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n26\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n3\n0\n"]}, {"input": "5\n10 10 2 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 2\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["0\n10\n8\n3\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n9\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 5 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n10\n9\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 1 8\n2 1 1 1 2 1\n", "output": ["3\n9\n9\n6\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 3 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n6\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n7\n15\n3\n0\n"]}, {"input": "5\n10 10 6 2 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["6\n10\n9\n3\n1\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 1 1\n11 8 9 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["3\n10\n9\n3\n0\n"]}, {"input": "5\n25 10 5 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 3 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n2\n1\n"]}, {"input": "5\n14 10 5 1 4 8\n10 10 9 5 4 1\n17 11 5 6 2 1\n6 9 2 2 5 4\n2 2 1 1 2 1\n", "output": ["7\n7\n15\n2\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 8 7 6 2 1\n6 9 3 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 3 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 2 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n0\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 6 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 4 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n7\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n26\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 1 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n4\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 15 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n11\n1\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 3 8\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n1\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 2 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n11\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 2 8\n2 2 2 1 2 1\n", "output": ["7\n10\n9\n0\n0\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 9 2 1\n17 17 5 8 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n25\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n6 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n5\n1\n1\n"]}, {"input": "5\n25 10 2 1 2 8\n10 10 9 9 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["0\n9\n15\n3\n1\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 13 7 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n19\n3\n0\n"]}, {"input": "5\n14 10 1 1 4 8\n10 10 9 5 4 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["3\n7\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n10 10 9 9 1 1\n25 8 7 6 2 1\n6 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n1\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 2 6 2 1\n6 9 3 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n0\n2\n0\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n6\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 1 6 2 1\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n1\n3\n0\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["2\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n13\n15\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n29\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n9\n27\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 3 8\n2 1 1 1 2 1\n", "output": ["1\n9\n9\n1\n0\n"]}, {"input": "5\n7 10 2 1 2 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["0\n9\n9\n4\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 5 6 2 1\n6 9 2 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n15\n3\n1\n"]}, {"input": "5\n8 10 5 1 2 8\n10 10 9 9 2 1\n17 16 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n25\n3\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 9 7 1 1\n6 9 2 2 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n8\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 7 5 4 1\n17 11 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n15\n1\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 9 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["7\n9\n0\n3\n1\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 10 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["2\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n13 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n14\n15\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n29\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 10 5 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n27\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 19 9 9 1 1\n25 8 5 1 1 1\n6 9 2 2 5 3\n2 1 1 1 2 1\n", "output": ["1\n10\n0\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n5 8 5 6 1 1\n6 9 2 2 3 8\n2 1 1 1 2 1\n", "output": ["1\n9\n4\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 6 2 1\n6 9 2 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n3\n1\n"]}, {"input": "5\n14 16 6 1 2 8\n15 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 3 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n26\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n6 8 5 6 2 2\n6 9 4 2 5 8\n2 2 1 1 1 2\n", "output": ["7\n10\n5\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n6\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n25 13 7 6 2 2\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n18\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n9\n1\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 1\n10 10 9 9 2 1\n17 9 5 1 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["0\n9\n0\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 4 1\n17 17 5 5 2 1\n6 15 2 2 5 8\n3 2 1 2 2 1\n", "output": ["7\n7\n27\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 1 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 6 2 1\n6 9 2 2 6 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n4\n1\n"]}, {"input": "5\n18 8 6 2 2 8\n10 10 6 9 1 1\n25 8 5 6 2 2\n6 9 2 2 5 8\n2 1 0 1 2 1\n", "output": ["6\n10\n8\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n3\n0\n"]}, {"input": "5\n18 10 1 3 2 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n10\n9\n7\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 2 1\n25 8 5 6 1 1\n6 9 2 2 3 9\n2 1 1 1 0 1\n", "output": ["7\n9\n9\n1\n0\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n26\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 2 1\n5 8 1 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n0\n1\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 2 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n1\n1\n3\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["0\n10\n9\n7\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 4 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n0\n1\n0\n"]}, {"input": "5\n18 10 2 3 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["5\n10\n9\n7\n0\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 4 1 1 8\n2 2 1 2 2 2\n", "output": ["7\n9\n0\n7\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 9 2 1\n5 12 1 6 1 1\n6 8 4 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n10\n0\n5\n0\n"]}, {"input": "5\n7 10 1 2 1 8\n20 10 9 9 2 1\n5 12 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["0\n10\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n3\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 1\n5 21 1 12 1 1\n6 9 4 1 2 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n4\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 32 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n29\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 2 1\n17 11 5 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n14\n3\n1\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 9 3 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["4\n8\n9\n3\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n8 8 5 8 2 1\n6 9 4 2 1 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n6\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 5 5 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n10\n10\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 2\n2 2 1 2 2 2\n", "output": ["7\n9\n21\n0\n0\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n7 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n10\n7\n3\n1\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 5 9 2 1\n14 8 5 6 2 1\n6 9 4 2 5 8\n2 2 1 1 2 1\n", "output": ["4\n10\n9\n1\n0\n"]}, {"input": "5\n18 10 1 1 0 8\n10 10 9 9 1 1\n25 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n9\n4\n0\n"]}, {"input": "5\n14 10 6 1 2 5\n10 10 9 9 2 1\n17 17 5 3 3 1\n6 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["4\n9\n26\n3\n0\n"]}, {"input": "5\n23 10 6 2 2 8\n17 10 9 9 1 1\n25 8 5 4 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n11\n3\n0\n"]}, {"input": "5\n7 10 1 1 2 0\n10 10 9 9 2 1\n11 13 5 6 2 1\n6 9 2 2 5 8\n3 1 1 1 2 1\n", "output": ["1\n9\n15\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n9 10 9 9 1 1\n25 8 7 6 2 1\n12 9 3 1 5 8\n2 1 2 1 2 1\n", "output": ["1\n8\n9\n2\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 3 2 2 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n6\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 8 4 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n24\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 5 5 2 1\n6 9 2 2 2 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n0\n1\n"]}, {"input": "5\n14 10 6 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 4 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n27\n1\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 3 1\n17 17 3 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n8\n26\n3\n1\n"]}, {"input": "5\n18 10 1 1 2 8\n11 19 9 9 1 1\n25 8 5 6 1 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["1\n12\n9\n3\n0\n"]}, {"input": "5\n14 16 6 1 2 15\n10 10 9 9 2 1\n17 17 5 6 3 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["14\n9\n26\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 1 12 2 1\n6 9 2 2 3 8\n2 2 1 2 2 2\n", "output": ["7\n9\n1\n1\n0\n"]}, {"input": "5\n7 10 1 1 2 0\n10 10 9 1 2 1\n11 8 5 6 2 1\n6 9 2 3 5 8\n3 1 1 1 2 1\n", "output": ["1\n0\n9\n3\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 0 2 8\n2 2 1 1 2 1\n", "output": ["6\n9\n9\n0\n0\n"]}, {"input": "5\n14 10 2 1 2 3\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["0\n9\n27\n6\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 6 8\n3 2 1 2 2 2\n", "output": ["7\n9\n0\n4\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 2 8\n2 2 1 2 2 2\n", "output": ["7\n13\n15\n0\n0\n"]}, {"input": "5\n18 17 11 1 2 7\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["6\n9\n27\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 10 9 5 1 2\n25 8 5 6 2 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n9\n0\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 2 6 2 1\n6 9 2 2 5 0\n2 2 1 1 2 1\n", "output": ["7\n7\n0\n3\n0\n"]}, {"input": "5\n23 10 6 2 3 8\n10 10 9 9 1 1\n25 8 5 5 2 1\n6 9 2 2 5 8\n2 1 1 1 0 1\n", "output": ["6\n10\n10\n3\n0\n"]}, {"input": "5\n6 10 6 1 4 8\n10 10 10 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 0\n", "output": ["2\n9\n9\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n14 10 9 9 2 1\n17 28 3 6 1 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["7\n10\n30\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 11\n10 13 5 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n13\n27\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 2\n6 8 5 6 2 2\n6 9 4 2 5 8\n2 2 1 1 1 2\n", "output": ["7\n9\n5\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 3 1\n5 8 5 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n8\n4\n1\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n6\n14\n3\n1\n"]}, {"input": "5\n25 10 3 1 2 8\n10 10 9 9 2 2\n17 11 1 6 2 1\n6 9 2 2 5 6\n2 2 1 2 2 1\n", "output": ["7\n9\n1\n3\n1\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 10 2 2\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n22\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 4 2 5 6\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n1\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 4 1\n17 21 2 3 3 1\n5 9 2 2 5 8\n2 2 0 2 2 2\n", "output": ["7\n3\n1\n3\n0\n"]}, {"input": "5\n14 17 11 1 2 7\n10 10 9 9 2 1\n34 28 3 1 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["6\n9\n0\n3\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n10 10 9 9 2 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["0\n9\n9\n7\n0\n"]}, {"input": "5\n18 36 11 1 2 11\n10 10 5 9 2 2\n17 17 3 6 2 2\n6 9 2 2 5 8\n5 2 1 2 2 2\n", "output": ["10\n9\n26\n3\n0\n"]}, {"input": "5\n7 13 1 1 1 8\n14 10 9 4 1 1\n11 8 9 7 1 1\n6 26 2 2 5 8\n2 1 2 1 2 1\n", "output": ["0\n15\n8\n3\n0\n"]}, {"input": "5\n18 10 2 6 1 8\n10 10 9 9 1 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["2\n10\n9\n7\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 10 2 1\n5 12 1 6 1 1\n6 9 4 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n0\n5\n0\n"]}, {"input": "5\n10 10 1 2 1 8\n20 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 2 3 3\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n1\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 2\n5 21 1 12 1 1\n6 9 4 2 2 5\n3 1 1 1 2 1\n", "output": ["0\n17\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 1 1\n17 11 5 6 2 2\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n10\n14\n3\n1\n"]}, {"input": "5\n7 10 1 1 2 8\n10 10 9 9 1 1\n11 8 5 5 1 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n10\n0\n0\n"]}, {"input": "5\n18 10 6 1 2 2\n10 10 9 9 1 1\n7 8 5 6 2 1\n6 9 2 2 5 8\n2 2 0 1 2 1\n", "output": ["1\n10\n7\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 6\n10 10 9 9 2 1\n17 17 3 12 2 1\n6 9 2 2 5 2\n2 2 1 2 2 2\n", "output": ["5\n9\n21\n0\n0\n"]}, {"input": "5\n18 10 6 2 2 8\n10 10 1 9 1 1\n25 8 3 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n0\n9\n3\n0\n"]}, {"input": "5\n18 17 11 1 2 3\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["2\n9\n0\n3\n0\n"]}, {"input": "5\n18 10 0 1 0 8\n10 10 9 9 1 1\n25 8 5 6 1 1\n6 9 1 2 5 8\n2 1 1 1 2 1\n", "output": ["0\n10\n9\n4\n0\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 2 2 1\n17 12 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 1 2\n", "output": ["7\n9\n17\n3\n0\n"]}, {"input": "5\n7 10 1 1 4 8\n10 10 9 9 1 1\n11 8 9 6 1 1\n6 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["3\n10\n9\n3\n1\n"]}, {"input": "5\n14 10 6 1 2 5\n10 10 9 9 2 1\n17 17 5 3 3 1\n6 9 1 2 5 8\n2 2 0 2 2 2\n", "output": ["4\n9\n26\n4\n0\n"]}, {"input": "5\n23 10 6 2 2 8\n17 10 9 9 1 1\n25 8 5 4 2 1\n6 9 2 2 5 4\n2 1 1 1 2 1\n", "output": ["6\n10\n11\n2\n0\n"]}, {"input": "5\n23 10 11 2 2 8\n17 10 2 9 1 1\n25 8 5 1 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["6\n10\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 8 4 2 1\n6 9 2 2 5 8\n2 2 1 2 1 1\n", "output": ["7\n9\n24\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 17 3 5 2 1\n6 9 2 2 2 8\n2 2 1 2 2 1\n", "output": ["7\n9\n28\n0\n1\n"]}, {"input": "5\n14 10 6 1 2 6\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 4 2 5 8\n2 2 1 2 2 2\n", "output": ["5\n9\n27\n1\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 3 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n8\n27\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 2\n17 17 3 6 2 1\n6 9 2 1 5 2\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n1\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 6 5 6 1 2\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n4\n3\n0\n"]}, {"input": "5\n6 10 6 1 2 8\n10 10 9 6 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n3 2 1 2 2 1\n", "output": ["4\n9\n9\n3\n1\n"]}, {"input": "5\n18 17 11 1 2 8\n10 10 9 9 4 1\n17 17 3 6 2 1\n6 9 2 2 4 8\n3 2 1 2 2 2\n", "output": ["7\n7\n27\n2\n0\n"]}, {"input": "5\n7 10 1 1 2 8\n19 10 9 9 2 1\n11 8 5 6 1 1\n6 9 1 2 5 8\n2 1 0 1 2 1\n", "output": ["1\n10\n9\n4\n0\n"]}, {"input": "5\n10 10 6 1 2 6\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 1 8\n2 2 2 1 2 1\n", "output": ["5\n10\n9\n6\n0\n"]}, {"input": "5\n14 10 3 1 4 8\n10 9 9 9 4 1\n17 19 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["1\n7\n27\n3\n0\n"]}, {"input": "5\n18 10 1 2 2 8\n12 10 9 9 1 1\n25 13 7 6 2 1\n6 9 2 2 2 8\n2 1 1 1 2 1\n", "output": ["1\n10\n19\n0\n0\n"]}, {"input": "5\n25 10 3 1 2 8\n10 15 9 9 2 1\n17 11 5 6 2 1\n6 9 3 2 4 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n1\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 14 8 6 2 2\n10 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n20\n3\n0\n"]}, {"input": "5\n14 10 2 1 2 3\n10 10 9 9 1 1\n17 17 5 6 2 1\n6 9 2 2 1 8\n2 2 1 2 2 2\n", "output": ["0\n10\n27\n6\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 1 2 1\n6 9 2 2 4 8\n3 2 1 2 2 2\n", "output": ["7\n9\n0\n2\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n12 10 9 10 2 1\n17 11 5 6 2 1\n6 9 2 2 2 8\n2 2 1 2 2 2\n", "output": ["7\n9\n15\n0\n0\n"]}, {"input": "5\n14 17 11 1 4 10\n10 10 9 9 2 1\n17 28 3 6 2 1\n6 9 2 1 5 8\n2 2 1 2 2 2\n", "output": ["9\n9\n29\n3\n0\n"]}, {"input": "5\n18 10 1 1 2 8\n10 19 9 9 1 1\n25 10 5 6 1 1\n6 9 2 2 5 5\n2 1 1 1 2 1\n", "output": ["1\n10\n13\n3\n0\n"]}, {"input": "5\n8 10 5 1 2 7\n10 10 9 9 2 1\n17 16 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 1 1\n", "output": ["6\n9\n25\n3\n0\n"]}, {"input": "5\n7 10 1 3 4 8\n10 10 9 9 2 1\n11 8 5 6 1 1\n6 9 2 2 1 6\n2 1 0 1 2 1\n", "output": ["3\n9\n9\n4\n0\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n25 13 7 11 2 1\n6 9 2 2 5 8\n2 1 1 1 1 1\n", "output": ["1\n10\n14\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 10 9 9 4 1\n17 11 1 8 2 1\n6 9 3 2 5 0\n2 2 1 2 2 1\n", "output": ["7\n7\n1\n2\n1\n"]}, {"input": "5\n18 10 1 2 2 7\n10 10 9 9 1 1\n19 13 7 6 2 2\n6 9 2 2 4 8\n2 1 1 1 2 1\n", "output": ["1\n10\n18\n2\n0\n"]}, {"input": "5\n18 10 1 3 1 8\n19 10 9 9 1 1\n9 8 7 6 2 1\n6 9 6 1 5 8\n2 1 2 1 2 1\n", "output": ["0\n10\n9\n1\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n10 10 9 9 3 1\n5 8 3 6 1 1\n6 9 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n8\n6\n1\n0\n"]}, {"input": "5\n18 20 11 1 2 11\n10 10 5 9 2 1\n17 17 3 10 2 1\n6 9 2 2 5 8\n3 2 1 2 2 2\n", "output": ["10\n10\n23\n3\n0\n"]}, {"input": "5\n14 10 6 1 4 8\n10 9 9 9 5 1\n17 11 5 6 4 2\n6 9 3 2 5 6\n2 2 1 1 2 1\n", "output": ["7\n6\n14\n2\n0\n"]}, {"input": "5\n9 10 6 1 2 8\n10 10 1 9 4 1\n17 21 2 3 3 1\n5 9 2 2 3 8\n2 2 0 2 2 2\n", "output": ["7\n3\n1\n1\n0\n"]}, {"input": "5\n18 10 2 3 1 8\n10 10 9 9 2 1\n9 8 7 6 2 1\n10 9 6 1 5 8\n2 1 0 1 2 1\n", "output": ["5\n9\n9\n7\n0\n"]}, {"input": "5\n18 36 11 1 2 11\n10 10 5 9 2 2\n17 17 3 6 3 2\n6 9 2 2 5 8\n5 2 1 2 2 2\n", "output": ["10\n9\n0\n3\n0\n"]}, {"input": "5\n7 10 1 2 2 8\n20 10 9 9 2 2\n5 12 1 6 2 1\n6 8 2 2 3 8\n3 1 1 1 2 1\n", "output": ["1\n9\n1\n1\n0\n"]}, {"input": "5\n15 10 1 2 1 8\n19 14 9 9 2 1\n5 21 1 6 1 1\n6 9 4 3 2 5\n3 1 1 1 2 1\n", "output": ["0\n18\n0\n2\n0\n"]}, {"input": "5\n13 10 1 2 1 8\n19 14 9 9 2 3\n5 21 1 12 1 1\n6 9 4 2 2 5\n3 1 1 1 2 1\n", "output": ["0\n16\n0\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 1 1\n17 11 5 6 2 2\n6 9 2 2 6 8\n2 2 1 2 2 1\n", "output": ["7\n10\n14\n4\n1\n"]}, {"input": "5\n10 10 6 1 1 8\n9 10 9 9 1 1\n7 8 5 6 2 1\n8 9 2 2 5 8\n2 2 1 1 2 2\n", "output": ["7\n8\n7\n3\n1\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n17 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n14 10 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n27\n3\n1\n"]}, {"input": "5\n10 10 6 1 2 8\n10 10 9 9 1 1\n17 8 5 6 2 1\n6 16 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 9 2 1\n14 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n", "output": ["7\n9\n9\n3\n0\n"]}, {"input": "5\n14 10 6 1 2 8\n10 10 9 5 2 1\n17 11 5 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 1\n", "output": ["7\n9\n15\n3\n1\n"]}, {"input": "5\n14 17 11 1 2 8\n10 10 9 9 2 1\n17 17 3 6 2 1\n6 9 2 2 5 8\n2 2 1 2 2 2\n", "output": ["7\n9\n27\n3\n0\n"]}, {"input": "5\n18 10 6 1 2 8\n10 10 9 9 1 1\n25 8 5 6 2 1\n6 9 2 2 5 8\n2 1 1 1 2 1\n", "output": ["7\n10\n9\n3\n0\n"]}], "task_id": "codecontest/160", "prompt": "A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of n rows and m columns. The rows of the floor are numbered from 1 to n from top to bottom, and columns of the floor are numbered from 1 to m from left to right. The cell on the intersection of the r-th row and the c-th column is denoted as (r,c). The initial position of the robot is (r_b, c_b).\n\nIn one second, the robot moves by dr rows and dc columns, that is, after one second, the robot moves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc = 1. If there is a vertical wall (the left or the right walls) in the movement direction, dc is reflected before the movement, so the new value of dc is -dc. And if there is a horizontal wall (the upper or lower walls), dr is reflected before the movement, so the new value of dr is -dr.\n\nEach second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at (r_d, c_d). The job of the robot is to clean that dirty cell.\n\n<image> Illustration for the first example. The blue arc is the robot. The red star is the target dirty cell. Each second the robot cleans a row and a column, denoted by yellow stripes.\n\nGiven the floor size n and m, the robot's initial position (r_b, c_b) and the dirty cell's position (r_d, c_d), find the time for the robot to do its job. Make sure to consider edge cases where the robot might start on or immediately adjacent to the dirty cell. Consider scenarios where the robot might encounter multiple reflections before reaching the dirty cell.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n", "repair_prompt": ["A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of n rows and m columns. The rows of the floor are numbered from 1 to n from top to bottom, and columns of the floor are numbered from 1 to m from left to right. The cell on the intersection of the r-th row and the c-th column is denoted as (r,c). The initial position of the robot is (r_b, c_b).\n\nIn one second, the robot moves by dr rows and dc columns, that is, after one second, the robot moves from the cell (r, c) to (r + dr, c + dc). Initially dr = 1, dc = 1. If there is a vertical wall (the left or the right walls) in the movement direction, dc is reflected before the movement, so the new value of dc is -dc. And if there is a horizontal wall (the upper or lower walls), dr is reflected before the movement, so the new value of dr is -dr.\n\nEach second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at (r_d, c_d). The job of the robot is to clean that dirty cell.\n\n<image> Illustration for the first example. The blue arc is the robot. The red star is the target dirty cell. Each second the robot cleans a row and a column, denoted by yellow stripes.\n\nGiven the floor size n and m, the robot's initial position (r_b, c_b) and the dirty cell's position (r_d, c_d), find the time for the robot to do its job. Make sure to consider edge cases where the robot might start on or immediately adjacent to the dirty cell. Consider scenarios where the robot might encounter multiple reflections before reaching the dirty cell.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\n-------\nImportant Note: You must follow the input output format. Input must be taken from standard input and output must be given to standard output. The code will be tested against multiple test cases and all the test cases must be passed.\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n"], "completions": ["from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time taken for the robot to clean the dirty cell.\n\n    The robot moves diagonally and reflects off the walls. This function\n    calculates the number of steps required for the robot to reach the dirty cell.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: The time taken for the robot to clean the dirty cell.\n    \"\"\"\n    # Calculate the time to reach the dirty cell\n    # The robot moves diagonally, so we need to calculate the minimum number of steps\n    # required to reach the dirty cell considering the reflections.\n    \n    # Calculate the time to reach the dirty cell in row and column direction\n    time_row = abs(r_d - r_b)\n    time_col = abs(c_d - c_b)\n    \n    # The robot will reach the dirty cell when it can align both row and column\n    # Therefore, the time taken is the maximum of the two times calculated\n    return max(time_row, time_col)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time taken for the robot to clean the dirty cell.\n\n    The robot moves in a straight line and reflects off walls when it reaches\n    the boundaries of the room. The function calculates the time taken for the\n    robot to reach the dirty cell.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken to reach the dirty cell.\n    \"\"\"\n    # Initialize direction of movement\n    dr, dc = 1, 1  # dr: row direction, dc: column direction\n    time = 0\n\n    while True:\n        # Check if the robot is at the dirty cell\n        if r_b == r_d or c_b == c_d:\n            return time\n\n        # Move the robot\n        if r_b + dr > n or r_b + dr < 1:\n            dr *= -1  # Reflect off the horizontal wall\n        if c_b + dc > m or c_b + dc < 1:\n            dc *= -1  # Reflect off the vertical wall\n\n        r_b += dr\n        c_b += dc\n        time += 1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Simulates the robot's movement and calculates the time taken to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken to reach the dirty cell.\n    \"\"\"\n    # Initialize direction of movement\n    dr, dc = 1, 1  # dr: row direction, dc: column direction\n    time = 0\n\n    while True:\n        # Check if the robot is at the dirty cell\n        if r_b == r_d or c_b == c_d:\n            return time\n\n        # Move the robot\n        r_b += dr\n        c_b += dc\n        time += 1\n\n        # Check for reflection off the walls\n        if r_b == 1 or r_b == n:\n            dr *= -1\n        if c_b == 1 or c_b == m:\n            dc *= -1\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(t: int, test_cases: List[Tuple[int, int, int, int, int, int]]) -> List[int]:\n    \"\"\"Calculate the time it takes for a robot to clean a dirty cell in a bounded rectangular room.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, int, int, int]]): Each test case contains:\n            - n (int): Number of rows in the room.\n            - m (int): Number of columns in the room.\n            - rb (int): Starting row of the robot.\n            - cb (int): Starting column of the robot.\n            - rd (int): Row of the dirty cell.\n            - cd (int): Column of the dirty cell.\n\n    Returns:\n        List[int]: List of times for each test case indicating how long it takes for the robot to clean the dirty cell.\n    \"\"\"\n    results = []\n\n    for n, m, rb, cb, rd, cd in test_cases:\n        # Initialize direction of movement\n        dr, dc = 1, 1  # dr: row direction, dc: column direction\n\n        time = 0\n        while True:\n            # Check if the robot is on the dirty cell\n            if rb == rd or cb == cd:\n                results.append(time)\n                break\n\n            # Move the robot\n            if rb + dr > n or rb + dr < 1:\n                dr *= -1  # Reflect off the horizontal wall\n            if cb + dc > m or cb + dc < 1:\n                dc *= -1  # Reflect off the vertical wall\n\n            rb += dr\n            cb += dc\n            time += 1\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    # Get results\n    results = time_to_clean(t, test_cases)\n    # Output results\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\nimport sys\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time taken for the robot to clean the dirty cell.\n\n    The robot moves diagonally and reflects its direction upon hitting any wall.\n    The function checks if the robot's current row or column matches the dirty cell's position at each step.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken for the robot to clean the dirty cell.\n    \"\"\"\n    # Initial direction of movement\n    dr, dc = 1, 1\n    time = 0\n\n    while True:\n        # Check if the robot is on the dirty cell\n        if r_b == r_d or c_b == c_d:\n            return time\n\n        # Move the robot\n        r_b += dr\n        c_b += dc\n        time += 1\n\n        # Reflect the direction if hitting a wall\n        if r_b == 1 or r_b == n:\n            dr *= -1\n        if c_b == 1 or c_b == m:\n            dc *= -1\n\ndef main():\n    \"\"\"Main function to read input, process each test case, and output results.\"\"\"\n    input_data = sys.stdin.read().strip().split()\n    t = int(input_data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n = int(input_data[index])\n        m = int(input_data[index+1])\n        r_b = int(input_data[index+2])\n        c_b = int(input_data[index+3])\n        r_d = int(input_data[index+4])\n        c_d = int(input_data[index+5])\n        index += 6\n\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time taken for the robot to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the room.\n        m (int): Number of columns in the room.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken to reach the dirty cell.\n    \"\"\"\n    # Initialize the direction of movement\n    dr, dc = 1, 1\n    time = 0\n\n    # Simulate the robot's movement\n    while r_b != r_d or c_b != c_d:\n        # Move the robot diagonally\n        r_b += dr\n        c_b += dc\n        time += 1\n\n        # Reflect off the walls if necessary\n        if r_b == n or r_b == 1:\n            dr *= -1\n        if c_b == m or c_b == 1:\n            dc *= -1\n\n    return time\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n, m, r_b, c_b, r_d, c_d = map(int, data[i].split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        results.append(result)\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time taken for the robot to clean the dirty cell.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken to clean the dirty cell.\n    \"\"\"\n    # Calculate the time taken to reach the dirty cell directly\n    time_direct = abs(r_d - r_b) + abs(c_d - c_b)\n\n    # Calculate the time taken considering reflections\n    # If the robot is already on the dirty cell, no time is needed\n    if r_b == r_d and c_b == c_d:\n        return 0\n\n    # Calculate the minimum time considering reflections\n    # Reflecting off walls means considering the grid boundaries\n    time_reflect_row = min(r_d - r_b if r_d >= r_b else 2 * n - r_d - r_b,\n                           r_b - r_d if r_b >= r_d else 2 * n - r_b - r_d)\n    time_reflect_col = min(c_d - c_b if c_d >= c_b else 2 * m - c_d - c_b,\n                           c_b - c_d if c_b >= c_d else 2 * m - c_b - c_d)\n\n    # The minimum time considering both direct and reflection paths\n    return min(time_direct, time_reflect_row + time_reflect_col)\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        print(f\"Time to clean: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(n: int, m: int, r_b: int, c_b: int, r_d: int, c_d: int) -> int:\n    \"\"\"Calculate the time it takes for the robot to reach the dirty cell.\n\n    Args:\n        n (int): Number of rows in the grid.\n        m (int): Number of columns in the grid.\n        r_b (int): Initial row position of the robot.\n        c_b (int): Initial column position of the robot.\n        r_d (int): Row position of the dirty cell.\n        c_d (int): Column position of the dirty cell.\n\n    Returns:\n        int: Time taken to reach the dirty cell.\n    \"\"\"\n    # Initialize direction of movement\n    dr, dc = 1, 1  # dr: row direction, dc: column direction\n    time = 0\n\n    while (r_b != r_d) or (c_b != c_d):\n        # Check if the robot hits the vertical walls\n        if r_b == n and dr == 1:\n            dr = -1\n        elif r_b == 1 and dr == -1:\n            dr = 1\n\n        # Check if the robot hits the horizontal walls\n        if c_b == m and dc == 1:\n            dc = -1\n        elif c_b == 1 and dc == -1:\n            dc = 1\n\n        # Move the robot\n        r_b += dr\n        c_b += dc\n        time += 1\n\n    return time\n\ndef main():\n    \"\"\"Main function to handle input and output.\"\"\"\n    t = int(input())\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d = map(int, input().split())\n        result = time_to_clean(n, m, r_b, c_b, r_d, c_d)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(t: int, test_cases: List[Tuple[int, int, int, int, int, int]]) -> List[int]:\n    \"\"\"Calculate the time taken for the robot to clean the dirty cell for each test case.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, int, int, int]]): List of test cases, each containing:\n            - n (int): Number of rows in the grid.\n            - m (int): Number of columns in the grid.\n            - rb (int): Initial row position of the robot.\n            - cb (int): Initial column position of the robot.\n            - rd (int): Row position of the dirty cell.\n            - cd (int): Column position of the dirty cell.\n\n    Returns:\n        List[int]: List of times taken for the robot to clean the dirty cell for each test case.\n    \"\"\"\n    results = []\n\n    for n, m, rb, cb, rd, cd in test_cases:\n        time = 0\n        dr, dc = 1, 1  # Initial direction: down-right\n\n        while rb != rd and cb != cd:\n            # Move the robot\n            rb += dr\n            cb += dc\n            time += 1\n\n            # Reflect off the walls if necessary\n            if rb == n + 1 or rb == 0:\n                dr *= -1\n                rb += dr * 2  # Correct position after reflection\n            if cb == m + 1 or cb == 0:\n                dc *= -1\n                cb += dc * 2  # Correct position after reflection\n\n        results.append(time)\n\n    return results\n\nif __name__ == \"__main__\":\n    t = int(input())\n    test_cases = [tuple(map(int, input().split())) for _ in range(t)]\n    results = time_to_clean(t, test_cases)\n    for result in results:\n        print(result)\n", "from typing import List\n## main.py\n\nfrom typing import List, Tuple\n\ndef time_to_clean(t: int, test_cases: List[Tuple[int, int, int, int, int, int]]) -> List[int]:\n    \"\"\"Calculate the time taken for a robot to clean a dirty cell in a rectangular room.\n\n    Args:\n        t (int): Number of test cases.\n        test_cases (List[Tuple[int, int, int, int, int, int]]): Each test case contains:\n            - n (int): Number of rows in the room.\n            - m (int): Number of columns in the room.\n            - r_b (int): Initial row position of the robot.\n            - c_b (int): Initial column position of the robot.\n            - r_d (int): Row position of the dirty cell.\n            - c_d (int): Column position of the dirty cell.\n\n    Returns:\n        List[int]: List of times taken for each test case to clean the dirty cell.\n    \"\"\"\n    results = []\n\n    for n, m, r_b, c_b, r_d, c_d in test_cases:\n        # Calculate the time taken to reach the dirty cell\n        # The robot moves in a straight line and reflects off walls\n        # Calculate the minimum time to reach the dirty cell considering reflections\n\n        # Calculate time to reach the dirty cell directly\n        time_direct = abs(r_d - r_b) + abs(c_d - c_b)\n\n        # Calculate time considering reflections\n        # Reflecting over the row boundaries\n        time_reflect_row = min(\n            abs(r_d - r_b),\n            2 * (n - 1) - abs(r_d - r_b)\n        )\n        # Reflecting over the column boundaries\n        time_reflect_col = min(\n            abs(c_d - c_b),\n            2 * (m - 1) - abs(c_d - c_b)\n        )\n\n        # Total time considering reflections\n        time_with_reflections = time_reflect_row + time_reflect_col\n\n        # The minimum time to clean the dirty cell\n        min_time = min(time_direct, time_with_reflections)\n        results.append(min_time)\n\n    return results\n\n# Input interface\nif __name__ == \"__main__\":\n    # Read number of test cases\n    t = int(input())\n    # Read each test case\n    test_cases = [tuple(map(int, input(): \").split())) for _ in range(t)]\n    # Get results\n    results = time_to_clean(t, test_cases)\n    # Output results\n    for result in results:\n        print(result)\n"], "plans": ["requirement analysis:\nThe robot must navigate a grid, reflecting off walls, and clean a specified dirty cell. The solution should efficiently handle up to 10,000 test cases, considering edge cases where the robot starts near or on the dirty cell. The robot's movement is constrained by the room's dimensions, requiring careful handling of reflections.\nrequirement pool:\n- Implement robot movement and cleaning logic\n- Handle wall reflections accurately\n- Optimize for large number of test cases\n- Consider edge cases for initial positions\n- Provide detailed output for debugging\nWe will implement a function that simulates the robot's movement across the grid, taking into account reflections off the walls. The robot will move diagonally, and we will track its position until it cleans the dirty cell. The function will handle multiple test cases efficiently by iterating through each test case and calculating the time taken for the robot to reach the dirty cell. We will use simple arithmetic to determine the number of steps required, considering the room's boundaries and the robot's initial direction.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot must clean a specific dirty cell by moving in a pattern that reflects off walls. The solution must handle multiple test cases efficiently, considering edge cases where the robot starts on or near the dirty cell. The robot's movement logic involves reflecting its direction upon hitting walls, which must be accurately implemented to ensure the robot eventually cleans the dirty cell.\nrequirement pool:\n- Implement robot movement logic with wall reflections\n- Optimize for multiple test cases\n- Handle edge cases where robot starts on the dirty cell\n- Ensure accurate time calculation for cleaning\n- Provide clear documentation of movement logic\nWe will implement a function that simulates the robot's movement in a rectangular room. The robot will move in a straight line and reflect off walls when it reaches the boundaries of the room. The function will calculate the time taken for the robot to clean the dirty cell by considering the robot's initial position, the dirty cell's position, and the room's dimensions. We will handle multiple test cases efficiently by iterating through each test case and applying the movement logic. The solution will be optimized for performance to handle up to 10,000 test cases.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot moves diagonally and reflects off walls, cleaning rows and columns as it moves. The task is to determine the time taken for the robot to clean a specific dirty cell. The solution must handle multiple test cases efficiently, considering edge cases where the robot starts near or on the dirty cell.\nrequirement pool:\n- Implement the robot's movement and reflection logic.\n- Calculate the time taken for the robot to clean the dirty cell.\n- Optimize the solution for handling up to 10,000 test cases.\n- Ensure the solution handles edge cases effectively.\n- Provide clear documentation and comments in the code.\nWe will implement a function to simulate the robot's movement and calculate the time taken to clean the dirty cell. The robot moves diagonally and reflects off walls, so we need to handle these reflections accurately. The solution must efficiently handle up to 10,000 test cases, so we will use a simple loop to simulate the robot's movement and check for reflections. We will not use any external libraries as the problem is straightforward and can be solved with basic Python constructs.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot must clean a specific dirty cell by moving in a predictable pattern, reflecting off walls when necessary. The solution must handle multiple test cases efficiently, considering edge cases where the robot starts on or near the dirty cell.\nrequirement pool:\n- Implement the robot's movement logic to clean the dirty cell.\n- Ensure the robot reflects correctly off walls.\n- Optimize the solution for handling up to 10,000 test cases.\n- Consider edge cases where the robot starts on the dirty cell.\n- Provide clear documentation of the robot's movement logic.\nWe will simulate the robot's movement in a bounded rectangular room. The robot moves in a predictable pattern, reflecting off walls when necessary. We will calculate the time it takes for the robot to clean the dirty cell by simulating its path and checking when it aligns with the dirty cell's row or column. The solution will handle multiple test cases efficiently by iterating through each test case and applying the same logic.\n", "requirement analysis:\nThe requirements focus on simulating the robot's movement and cleaning process within a bounded room. Key aspects include handling reflections when encountering walls, ensuring the robot cleans the dirty cell efficiently, and managing multiple test cases effectively. Edge cases such as starting on or near the dirty cell must be considered.\nrequirement pool:\n- Implement robot movement logic with reflection handling\n- Optimize for large number of test cases\n- Ensure accurate cleaning of the dirty cell\n- Handle edge cases effectively\n- Provide clear documentation of movement logic\nWe will implement a function that simulates the robot's movement across the room, taking into account the reflections when hitting walls. The robot will move diagonally and reflect its direction upon hitting any wall. The function will calculate the time taken for the robot to clean the dirty cell by checking if the robot's current row or column matches the dirty cell's position at each step. The solution will be optimized to handle up to 10,000 test cases efficiently.\n", "requirement analysis:\nThe requirements focus on simulating the robot's movement in a rectangular room and ensuring it cleans a specified dirty cell. The solution must handle multiple test cases efficiently, account for reflections against walls, and provide accurate results for all scenarios.\nrequirement pool:\n- Implement the robot's movement logic with reflection handling\n- Optimize the algorithm for handling up to 10,000 test cases\n- Ensure accurate simulation of the robot's cleaning process\n- Handle edge cases where the robot starts on or near the dirty cell\n- Provide detailed documentation and examples for users\nWe will implement a function that simulates the robot's movement in a rectangular room. The robot will move diagonally, reflecting off walls when necessary. The function will calculate the time taken for the robot to clean the dirty cell by checking if the robot's current row or column matches the dirty cell's position. The algorithm will be optimized to handle up to 10,000 test cases efficiently by using simple arithmetic operations to determine the time to reach the dirty cell.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a rectangular room. The robot moves diagonally and reflects off walls, cleaning the row and column it is in each second. The task is to determine how long it takes for the robot to clean a specific dirty cell. The solution must handle multiple test cases efficiently, considering edge cases such as the robot starting on or near the dirty cell and multiple reflections.\nrequirement pool:\n- Implement the robot's movement and cleaning logic.\n- Handle reflections off walls accurately.\n- Optimize the solution for large numbers of test cases.\n- Consider edge cases where the robot starts on the dirty cell.\n- Ensure the solution is robust and handles all possible scenarios.\nWe will implement a function to simulate the robot's movement and cleaning process. The function will handle reflections off walls and determine the time taken to clean the dirty cell. We will use simple arithmetic operations to simulate the robot's movement and reflections, ensuring the solution is efficient for large numbers of test cases.\n", "requirement analysis:\nThe robot must efficiently clean the dirty cell by moving in a predictable pattern, reflecting off walls as needed. The solution should handle up to 10,000 test cases, ensuring performance and accuracy. Edge cases, such as starting on the dirty cell or encountering multiple reflections, must be considered.\nrequirement pool:\n- Implement robot movement logic with reflections\n- Optimize for large number of test cases\n- Handle edge cases like starting on the dirty cell\n- Ensure accurate time calculation for cleaning\n- Provide clear documentation of movement logic\nWe will implement a function that simulates the robot's movement across the grid, taking into account reflections off the walls. The robot will move in a predictable pattern, and we will calculate the time it takes to reach the dirty cell. We will handle multiple test cases efficiently by iterating through each test case and applying the movement logic. The solution will be optimized for performance to handle up to 10,000 test cases.\n", "requirement analysis:\nThe robot must efficiently navigate a rectangular room, cleaning a specific dirty cell. It should handle reflections off walls and ensure it cleans the cell in the minimum time possible. The solution must be optimized for a large number of test cases, ensuring quick computation and accurate results.\nrequirement pool:\n- Implement the robot's movement and cleaning logic.\n- Handle reflections off walls accurately.\n- Optimize the solution for large input sizes.\n- Ensure the robot starts cleaning immediately if on the dirty cell.\n- Provide detailed output for debugging and analysis.\nWe will implement a function that simulates the robot's movement across the grid. The robot will start at its initial position and move according to the given rules, reflecting off walls when necessary. The function will calculate the time taken for the robot to clean the dirty cell by checking if the robot's current row or column matches the dirty cell's position. We will use a simple loop to simulate the robot's movement and reflections, ensuring the solution is efficient enough to handle up to 10,000 test cases.\n", "requirement analysis:\nThe problem requires simulating the movement of a robot cleaner in a bounded rectangular room. The robot must clean a specific dirty cell by moving in a predictable pattern, reflecting off walls when necessary. The solution must handle multiple test cases efficiently, considering edge cases where the robot starts near or on the dirty cell. The algorithm should be optimized for performance given the constraints.\nrequirement pool:\n- Implement the robot's movement logic to clean the dirty cell.\n- Handle reflections off walls accurately to ensure correct movement.\n- Optimize the solution for handling up to 10,000 test cases efficiently.\n- Consider edge cases where the robot starts near or on the dirty cell.\n- Provide clear documentation and comments for the movement logic.\nWe will implement a function that simulates the robot's movement in a rectangular room. The robot will move in a predictable pattern, reflecting off walls when necessary. The function will calculate the time taken for the robot to clean the dirty cell by considering the initial position, the position of the dirty cell, and the room's dimensions. The solution will handle multiple test cases efficiently by iterating through each test case and applying the movement logic. We will use simple arithmetic operations to determine the time taken, ensuring the solution is optimized for performance given the constraints.\n"], "scores": [], "pass_results": [false, false, false, false, true, true, false, true, false, false], "pass_test_cases_num": [], "passed": true, "pass": true, "pass_num": 3, "round": 105, "examples": "\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 10^4). Description of the test cases follows.\n\nA test case consists of only one line, containing six integers n, m, r_b, c_b, r_d, and c_d (1 \u2264 n, m \u2264 100, 1 \u2264 r_b, r_d \u2264 n, 1 \u2264 c_b, c_d \u2264 m) \u2014 the sizes of the room, the initial position of the robot and the position of the dirt cell.\n\nOutput\n\nFor each test case, print an integer \u2014 the time for the robot to clean the dirty cell. We can show that the robot always cleans the dirty cell eventually.\n\nExample\n\nInput\n\n\n5\n10 10 6 1 2 8\n10 10 9 9 1 1\n9 8 5 6 2 1\n6 9 2 2 5 8\n2 2 1 1 2 1\n\n\nOutput\n\n\n7\n10\n9\n3\n0\n\nNote\n\nIn the first example, the floor has the size of 10\u00d7 10. The initial position of the robot is (6, 1) and the position of the dirty cell is (2, 8). See the illustration of this example in the problem statement.\n\nIn the second example, the floor is the same, but the initial position of the robot is now (9, 9), and the position of the dirty cell is (1, 1). In this example, the robot went straight to the dirty cell and clean it. \n\n<image>\n\nIn the third example, the floor has the size 9 \u00d7 8. The initial position of the robot is (5, 6), and the position of the dirty cell is (2, 1). \n\n<image>\n\nIn the fourth example, the floor has the size 6 \u00d7 9. The initial position of the robot is (2, 2) and the position of the dirty cell is (5, 8). \n\n<image>\n\nIn the last example, the robot was already standing in the same column as the dirty cell, so it can clean the cell right away. \n", "mutate_method": "add_1_sentence_at_end", "parent_index": 55}
