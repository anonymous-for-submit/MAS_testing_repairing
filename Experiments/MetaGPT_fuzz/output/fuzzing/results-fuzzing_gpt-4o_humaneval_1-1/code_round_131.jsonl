{"task_id": "HumanEval/160", "prompt": "def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list contains basic algebra operations, and the second list is a list of integers. Use the two given lists to construct the algebraic expression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + ) \nSubtraction ( - ) \nMultiplication ( * ) \nFloor division ( // ) \nExponentiation ( ** ) \nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": ["def check(do_algebra):\n\tassert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [8, 8, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [5, 1, 6]) == 5", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [12, 1, 6]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [2, 5, 7]) == 17", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [2, 3, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [6, 2, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [8, 2, 7]) == -120", "def check(do_algebra):\n\tassert do_algebra(['//', '**'], [4, 4, 4]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [5, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 2, 7]) == 71", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [9, 3, 8]) == 35", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "def check(do_algebra):\n\tassert do_algebra(['*', '-'], [6, 5, 7]) == 23", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "def check(do_algebra):\n\tassert do_algebra(['-', '*'], [3, 3, 6]) == -15", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 5, 2]) == -22", "def check(do_algebra):\n\tassert do_algebra(['+', '*'], [7, 3, 6]) == 25", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [3, 2, 8]) == 768", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [7, 3, 3]) == 189", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [8, 4, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [8, 2, 2]) == 128", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [3, 4, 4]) == 3", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [10, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [7, 3, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '-'], [6, 1, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [3, 7, 6]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "def check(do_algebra):\n\tassert do_algebra(['*', '*'], [5, 2, 7]) == 70", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 3, 4]) == -78", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [2, 7, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [10, 2, 8]) == 800", "def check(do_algebra):\n\tassert do_algebra(['+', '//'], [3, 6, 4]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 3, 5]) == 250", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [7, 3, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [3, 2, 4]) == 19", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "def check(do_algebra):\n\tassert do_algebra(['**', '-'], [3, 2, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "def check(do_algebra):\n\tassert do_algebra(['+', '+'], [4, 4, 1]) == 9", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [10, 7, 1]) == 4", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [8, 4, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [4, 8, 4]) == 36", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "test_case_list": ["assert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "assert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "assert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "assert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "assert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "assert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "assert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "assert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "assert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "assert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "assert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "assert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "assert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "assert do_algebra(['//', '//'], [8, 8, 7]) == 0", "assert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "assert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "assert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "assert do_algebra(['*', '**'], [5, 1, 6]) == 5", "assert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "assert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "assert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "assert do_algebra(['**', '//'], [12, 1, 6]) == 2", "assert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "assert do_algebra(['*', '+'], [2, 5, 7]) == 17", "assert do_algebra(['**', '*'], [2, 3, 1]) == 8", "assert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "assert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "assert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "assert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "assert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "assert do_algebra(['-', '**'], [6, 2, 2]) == 2", "assert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "assert do_algebra(['-', '**'], [8, 2, 7]) == -120", "assert do_algebra(['//', '**'], [4, 4, 4]) == 0", "assert do_algebra(['-', '//'], [5, 3, 8]) == 5", "assert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "assert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "assert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "assert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "assert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "assert do_algebra(['**', '+'], [8, 2, 7]) == 71", "assert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "assert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "assert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "assert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "assert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "assert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "assert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "assert do_algebra(['*', '+'], [9, 3, 8]) == 35", "assert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "assert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "assert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "assert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "assert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "assert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "assert do_algebra(['*', '-'], [6, 5, 7]) == 23", "assert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "assert do_algebra(['-', '*'], [3, 3, 6]) == -15", "assert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "assert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "assert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "assert do_algebra(['-', '**'], [3, 5, 2]) == -22", "assert do_algebra(['+', '*'], [7, 3, 6]) == 25", "assert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "assert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "assert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "assert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "assert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "assert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "assert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "assert do_algebra(['*', '**'], [3, 2, 8]) == 768", "assert do_algebra(['*', '**'], [7, 3, 3]) == 189", "assert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "assert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "assert do_algebra(['-', '+'], [8, 4, 3]) == 7", "assert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "assert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "assert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "assert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "assert do_algebra(['**', '*'], [8, 2, 2]) == 128", "assert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "assert do_algebra(['-', '+'], [3, 4, 4]) == 3", "assert do_algebra(['+', '-'], [10, 3, 8]) == 5", "assert do_algebra(['//', '*'], [7, 3, 4]) == 8", "assert do_algebra(['//', '-'], [6, 1, 2]) == 4", "assert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "assert do_algebra(['+', '-'], [3, 7, 6]) == 4", "assert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "assert do_algebra(['*', '*'], [5, 2, 7]) == 70", "assert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "assert do_algebra(['-', '**'], [3, 3, 4]) == -78", "assert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "assert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "assert do_algebra(['//', '//'], [2, 7, 1]) == 0", "assert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "assert do_algebra(['**', '*'], [10, 2, 8]) == 800", "assert do_algebra(['+', '//'], [3, 6, 4]) == 4", "assert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "assert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "assert do_algebra(['+', '**'], [7, 3, 5]) == 250", "assert do_algebra(['-', '//'], [7, 3, 2]) == 6", "assert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "assert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "assert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "assert do_algebra(['+', '**'], [3, 2, 4]) == 19", "assert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "assert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "assert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "assert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "assert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "assert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "assert do_algebra(['**', '-'], [3, 2, 9]) == 0", "assert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "assert do_algebra(['+', '+'], [4, 4, 1]) == 9", "assert do_algebra(['-', '+'], [10, 7, 1]) == 4", "assert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "assert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "assert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "assert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "assert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "assert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "assert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "assert do_algebra(['//', '*'], [8, 4, 2]) == 4", "assert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "assert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "assert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "assert do_algebra(['*', '+'], [4, 8, 4]) == 36", "assert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "nl": "\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    ", "func": "def do_algebra(operator, operand):", "examples": "Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    ", "repair_prompt": ["def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list contains basic algebra operations, and the second list is a list of integers. Use the two given lists to construct the algebraic expression and return the evaluation of this expression.\n\nThe basic algebra operations:\nAddition ( + ) \nSubtraction ( - ) \nMultiplication ( * ) \nFloor division ( // ) \nExponentiation ( ** ) \nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''"], "completions": ["from typing import List\n## main.py\n\nimport operator\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers to be used in the expression.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \n    Raises:\n    ValueError: If an invalid operator is provided or division by zero occurs.\n    \"\"\"\n    \n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Validate input lists\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate through operators and operands to evaluate the expression\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Invalid operator: {op}\")\n        \n        # Check for division by zero\n        if op == '//' and operands[i + 1] == 0:\n            raise ValueError(\"Division by zero is not allowed.\")\n        \n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the provided operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the requirements or contain invalid operators.\n    \"\"\"\n    # Validate input lists\n    if not operators or not operands:\n        raise ValueError(\"Operators and operands lists cannot be empty.\")\n    \n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    valid_operators = {'+', '-', '*', '//', '**'}\n    \n    for op in operators:\n        if op not in valid_operators:\n            raise ValueError(f\"Invalid operator '{op}' found. Valid operators are {valid_operators}.\")\n    \n    # Evaluate expression\n    result = operands[0]\n    for i, operator in enumerate(operators):\n        operand = operands[i + 1]\n        if operator == '+':\n            result += operand\n        elif operator == '-':\n            result -= operand\n        elif operator == '*':\n            result *= operand\n        elif operator == '//':\n            if operand == 0:\n                raise ValueError(\"Division by zero is not allowed.\")\n            result //= operand\n        elif operator == '**':\n            result **= operand\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Constructs and evaluates an algebraic expression from the given operators and operands.\n\n    Parameters:\n    operators (list of str): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operands (list of int): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the length of operators is not one less than the length of operands.\n    \"\"\"\n    # Validate input lengths\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Construct the expression string\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        expression += f\" {operator} {operands[i + 1]}\"\n\n    # Evaluate the expression using eval\n    try:\n        result = eval(expression)\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {e}\")\n\n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Constructs and evaluates an algebraic expression from the given operators and operands.\n    \n    Args:\n        operator: A list of strings representing algebraic operators.\n        operand: A list of integers representing operands.\n        \n    Returns:\n        The result of the evaluated expression as an integer.\n        \n    Raises:\n        ValueError: If the length of operators is not one less than the length of operands.\n        ValueError: If an invalid operator is provided.\n    \"\"\"\n    # Validate input lengths\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Validate operators\n    valid_operators = {'+', '-', '*', '//', '**'}\n    for op in operator:\n        if op not in valid_operators:\n            raise ValueError(f\"Invalid operator: {op}\")\n    \n    # Construct expression string\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        expression += f\" {op} {operand[i + 1]}\"\n    \n    # Evaluate expression using eval()\n    try:\n        result = eval(expression)\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {e}\")\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the length of operators is not equal to the length of operands minus one.\n    \"\"\"\n    # Validate input lengths\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Construct expression string\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        if operator not in ['+', '-', '*', '//', '**']:\n            raise ValueError(f\"Unsupported operator: {operator}\")\n        expression += f\" {operator} {operands[i + 1]}\"\n\n    # Evaluate expression using eval()\n    try:\n        result = eval(expression)\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {e}\")\n\n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operator (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the specified conditions.\n    \"\"\"\n    # Validate input lists\n    if not operator or not operand:\n        raise ValueError(\"Operator and operand lists cannot be empty.\")\n    \n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    valid_operators = {'+', '-', '*', '//', '**'}\n    for op in operator:\n        if op not in valid_operators:\n            raise ValueError(f\"Unsupported operator: {op}\")\n\n    # Construct expression string\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        expression += f\" {op} {operand[i + 1]}\"\n\n    # Evaluate expression using eval\n    try:\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ValueError(\"Division by zero encountered in the expression.\")\n    except Exception as e:\n        raise ValueError(f\"An error occurred while evaluating the expression: {e}\")\n\n    return result\n", "from typing import List\n## main.py\n\nimport operator\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"Evaluates an algebraic expression based on the given operators and operands.\n\n    Args:\n        operators: List of strings representing algebraic operations ('+', '-', '*', '//', '**').\n        operands: List of non-negative integers.\n\n    Returns:\n        Result of the evaluated expression as an integer.\n\n    Raises:\n        ValueError: If an invalid operator is encountered.\n        ZeroDivisionError: If division by zero is attempted.\n    \"\"\"\n    # Mapping of string operators to their corresponding functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n\n    # Validate input lengths\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"Number of operators must be one less than number of operands.\")\n\n    # Initialize the result with the first operand\n    result = operands[0]\n\n    # Iterate over operators and operands to compute the result\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Invalid operator: {op}\")\n\n        # Perform the operation\n        try:\n            result = operator_map[op](result, operands[i + 1])\n        except ZeroDivisionError:\n            raise ZeroDivisionError(\"Division by zero is not allowed.\")\n\n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the required conditions.\n    \"\"\"\n    # Validate input lists\n    if not operators or not operands:\n        raise ValueError(\"Operators and operands lists cannot be empty.\")\n    \n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    valid_operators = {'+', '-', '*', '//', '**'}\n    for op in operators:\n        if op not in valid_operators:\n            raise ValueError(f\"Invalid operator: {op}. Allowed operators are {valid_operators}.\")\n    \n    # Construct expression string\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        expression += f\" {operator} {operands[i + 1]}\"\n    \n    # Evaluate expression using eval\n    try:\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ValueError(\"Division by zero encountered in the expression.\")\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Constructs and evaluates an algebraic expression from the given operators and operands.\n\n    Parameters:\n    operator (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated algebraic expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the specified conditions.\n    \"\"\"\n    # Validate input lists\n    if not operator or not operand:\n        raise ValueError(\"Operator and operand lists must not be empty.\")\n    \n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    valid_operators = {'+', '-', '*', '//', '**'}\n    if not all(op in valid_operators for op in operator):\n        raise ValueError(\"Operators must be one of '+', '-', '*', '//', '**'.\")\n    \n    if not all(isinstance(num, int) and num >= 0 for num in operand):\n        raise ValueError(\"Operands must be non-negative integers.\")\n\n    # Construct the algebraic expression\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        expression += f\" {op} {operand[i + 1]}\"\n\n    try:\n        # Evaluate the expression\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ValueError(\"Division by zero encountered in the expression.\")\n    except OverflowError:\n        raise ValueError(\"Overflow error encountered in the expression.\")\n    except Exception as e:\n        raise ValueError(f\"An error occurred while evaluating the expression: {e}\")\n\n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operator (list[str]): A list of strings representing algebraic operations ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of integers representing the operands.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the number of operators is not one less than the number of operands.\n    ValueError: If an invalid operator is provided.\n    \"\"\"\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Initialize the result with the first operand\n    result = operand[0]\n\n    # Define a dictionary to map operators to their corresponding operations\n    operations = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n        '*': lambda x, y: x * y,\n        '//': lambda x, y: x // y,\n        '**': lambda x, y: x ** y\n    }\n\n    # Iterate over the operators and operands to compute the result\n    for i, op in enumerate(operator):\n        if op not in operations:\n            raise ValueError(f\"Invalid operator: {op}\")\n        result = operations[op](result, operand[i + 1])\n\n    return result\n\n# Example usage:\n# result = do_algebra(['+', '*', '-'], [3, 5, 2, 4])\n# print(result)  # Output should be 13\n"], "plans": ["requirement analysis:\nThe function should correctly parse and evaluate expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently.\nrequirement pool:\n- Implement the main function to evaluate expressions\n- Design a user-friendly interface for input\n- Ensure the function handles edge cases like division by zero\n- Optimize the function for performance\n- Provide detailed error messages for invalid inputs\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operators in sequence to the operands. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring correct order of operations. The function will handle basic error checking, such as division by zero, and return a detailed error message if an invalid operator is encountered.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle errors gracefully, such as mismatched list lengths or invalid operators. Performance is crucial, especially for large operand lists.\nrequirement pool:\n- Implement the main algebra evaluation function.\n- Develop a user interface for inputting operators and operands.\n- Create error handling for invalid inputs.\n- Optimize the function for performance with large inputs.\n- Provide a step-by-step explanation of the evaluation process.\nWe will implement a function that evaluates an algebraic expression based on two lists: one containing operators and the other containing operands. The function will validate the input lists to ensure they meet the requirements, such as the correct number of operators relative to operands. We will use Python's built-in capabilities for arithmetic operations and error handling to ensure efficient and accurate calculations. Additionally, we will provide detailed error messages for invalid inputs and a step-by-step explanation of the evaluation process.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The user interface should allow easy input of operators and operands, and display the result clearly.\nrequirement pool:\n- Implement the core algebra evaluation logic\n- Design a user-friendly interface for input\n- Ensure the application handles errors gracefully\n- Optimize the performance for large input sizes\n- Provide detailed documentation and examples\nWe will implement a function that constructs and evaluates an algebraic expression from two lists: operators and operands. The function will ensure the correct order of operations using Python's built-in eval function, which inherently respects operator precedence. We will validate the input to ensure the operator list is one less than the operand list and handle any mismatches gracefully by raising an appropriate error.\n", "requirement analysis:\nThe function should accurately compute algebraic expressions using given operators and operands. It must handle basic operations and ensure the length of the operator list is one less than the operand list. The focus is on simplicity and efficiency.\nrequirement pool:\n- Implement the main algebra computation function\n- Design intuitive UI for input\n- Optimize performance for large operand lists\n- Provide clear computation process explanation\n- Ensure compatibility with various input formats\nWe will implement a function that constructs and evaluates an algebraic expression from given operators and operands. The function will ensure that the length of the operator list is one less than the operand list. We will use Python's built-in eval function to evaluate the constructed expression, ensuring simplicity and efficiency. The function will handle basic operations: addition, subtraction, multiplication, floor division, and exponentiation.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle different operations and ensure the correct order of operations. The input validation is crucial to prevent errors due to mismatched list lengths or unsupported operations.\nrequirement pool:\n- Implement the main algebra evaluation function.\n- Develop input validation to ensure correct list lengths.\n- Optimize performance for handling large numbers.\n- Create a user-friendly interface for input and output.\n- Ensure compatibility across desktop and mobile platforms.\nWe will implement a function that evaluates algebraic expressions using the provided operators and operands. The function will ensure the correct order of operations by using Python's built-in eval function, which respects operator precedence. We will also include input validation to ensure the operator and operand lists are compatible. The function will handle large numbers efficiently by leveraging Python's inherent support for arbitrary-precision integers.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle errors gracefully if the input lists do not meet the specified conditions. The focus should be on simplicity and efficiency, ensuring quick computation and easy user interaction.\nrequirement pool:\n- Implement the main algebra evaluation function\n- Develop error handling for invalid input lists\n- Optimize performance for handling large numbers\n- Design a user-friendly interface for input\n- Ensure clear output of evaluated expressions\nWe will implement a function that evaluates an algebraic expression based on two input lists: operators and operands. The function will validate the input lists to ensure they meet the specified conditions. We will use Python's built-in eval function to compute the expression efficiently. Error handling will be implemented to manage invalid inputs gracefully.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle various operations and ensure the order of operations is respected. The user interface should allow easy input of operators and operands, and the system should be optimized for performance, especially with large operand lists.\nrequirement pool:\n- Implement core algebraic computation logic\n- Design intuitive UI for operator and operand input\n- Optimize performance for handling large lists\n- Ensure accurate order of operations\n- Provide error handling for invalid inputs\nWe will implement a function that processes lists of operators and operands to construct and evaluate an algebraic expression. The function will ensure the correct order of operations using Python's built-in capabilities. We will use the 'operator' module to map string operators to their corresponding functions, ensuring efficient computation. The function will handle edge cases like division by zero and invalid operators by raising appropriate exceptions.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle different operations and ensure the correct order of operations is applied. The input validation is crucial to prevent errors and ensure the lists meet the specified conditions.\nrequirement pool:\n- Implement the main function to evaluate algebraic expressions.\n- Develop input validation to ensure correct list lengths and types.\n- Optimize the function for performance with large numbers.\n- Create a user-friendly interface for inputting data.\n- Provide clear documentation and error messages.\nWe will implement a function that evaluates algebraic expressions using the provided operators and operands. The function will ensure the correct order of operations is applied by using Python's built-in eval function. Input validation will be implemented to ensure the lists meet the specified conditions. We will use Python's standard libraries to keep the implementation simple and efficient.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle errors gracefully when input lists do not meet specified conditions. Performance optimization is crucial for handling large numbers efficiently.\nrequirement pool:\n- Implement the main algebraic evaluation function\n- Ensure error handling for invalid input lists\n- Optimize performance for large number computations\n- Design a user-friendly interface for input\n- Display the algebraic expression clearly before evaluation\nWe will implement a function that constructs and evaluates an algebraic expression from two lists: operators and operands. The function will validate the input lists to ensure they meet the specified conditions. We will use Python's built-in eval function to evaluate the expression, which allows for efficient computation even with large numbers. Error handling will be implemented to manage invalid inputs gracefully.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The user interface should allow easy input of operators and operands, and display the result clearly.\nrequirement pool:\n- Implement the core algebra evaluation logic\n- Design a user-friendly interface for input\n- Optimize the performance of the evaluation\n- Provide a detailed explanation of the evaluation process\n- Ensure compatibility with various input formats\nWe will implement a function that evaluates algebraic expressions using the provided operators and operands. The function will handle the order of operations correctly by using Python's built-in capabilities for arithmetic operations. We will ensure that the function is efficient and easy to use by providing clear input and output formats. We will use Python's standard library, as it provides all necessary functionality for arithmetic operations without needing additional frameworks.\n"], "scores": [0.6124, 0.6124, 1.0, 1.0, 1.0, 1.0, 0.6124, 1.0, 1.0, 0.6124], "pass_results": [false, false, true, true, true, true, false, true, true, false], "pass_test_cases_num": [79, 79, 129, 129, 129, 129, 79, 129, 129, 79], "completion": "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operator (list[str]): A list of strings representing algebraic operations ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of integers representing the operands.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the number of operators is not one less than the number of operands.\n    ValueError: If an invalid operator is provided.\n    \"\"\"\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Initialize the result with the first operand\n    result = operand[0]\n\n    # Define a dictionary to map operators to their corresponding operations\n    operations = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n        '*': lambda x, y: x * y,\n        '//': lambda x, y: x // y,\n        '**': lambda x, y: x ** y\n    }\n\n    # Iterate over the operators and operands to compute the result\n    for i, op in enumerate(operator):\n        if op not in operations:\n            raise ValueError(f\"Invalid operator: {op}\")\n        result = operations[op](result, operand[i + 1])\n\n    return result\n\n# Example usage:\n# result = do_algebra(['+', '*', '-'], [3, 5, 2, 4])\n# print(result)  # Output should be 13\n", "passed": true, "pass": true, "pass_num": 6, "round": 131, "mutate_method": "rephrase_one", "parent_index": 131}
