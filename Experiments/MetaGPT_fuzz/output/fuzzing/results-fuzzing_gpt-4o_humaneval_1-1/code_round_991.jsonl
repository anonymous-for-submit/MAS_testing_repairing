{"task_id": "HumanEval/77", "prompt": "def iscube(a):\t\n'''Write a function that takes an integer a and returns True if this integer is a cube of some integer number. Note: you may assume the input is always valid.\nExamples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "entry_point": "iscube", "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "test": ["def check(iscube):\n\tassert iscube(68921) == True", "def check(iscube):\n\tassert iscube(1000000) == True", "def check(iscube):\n\tassert iscube(205379) == True", "def check(iscube):\n\tassert iscube(216) == True", "def check(iscube):\n\tassert iscube(314432) == True", "def check(iscube):\n\tassert iscube(274625) == True", "def check(iscube):\n\tassert iscube(157464) == True", "def check(iscube):\n\tassert iscube(941192) == True", "def check(iscube):\n\tassert iscube(178) == False", "def check(iscube):\n\tassert iscube(250047) == True", "def check(iscube):\n\tassert iscube(3) == False", "def check(iscube):\n\tassert iscube(179) == False", "def check(iscube):\n\tassert iscube(857375) == True", "def check(iscube):\n\tassert iscube(512) == True", "def check(iscube):\n\tassert iscube(405224) == True", "def check(iscube):\n\tassert iscube(176) == False", "def check(iscube):\n\tassert iscube(238328) == True", "def check(iscube):\n\tassert iscube(1) == True, \"First test error: \" + str(iscube(1))", "def check(iscube):\n\tassert iscube(1000) == True", "def check(iscube):\n\tassert iscube(4913) == True", "def check(iscube):\n\tassert iscube(373248) == True", "def check(iscube):\n\tassert iscube(262144) == True", "def check(iscube):\n\tassert iscube(2) == False, \"Second test error: \" + str(iscube(2))", "def check(iscube):\n\tassert iscube(0) == True, \"1st edge test error: \" + str(iscube(0))", "def check(iscube):\n\tassert iscube(2197) == True", "def check(iscube):\n\tassert iscube(2744) == True", "def check(iscube):\n\tassert iscube(175) == False", "def check(iscube):\n\tassert iscube(103823) == True", "def check(iscube):\n\tassert iscube(13824) == True", "def check(iscube):\n\tassert iscube(474552) == True", "def check(iscube):\n\tassert iscube(658503) == True", "def check(iscube):\n\tassert iscube(636056) == True", "def check(iscube):\n\tassert iscube(5) == False", "def check(iscube):\n\tassert iscube(4) == False", "def check(iscube):\n\tassert iscube(21952) == True", "def check(iscube):\n\tassert iscube(42875) == True", "def check(iscube):\n\tassert iscube(681472) == True", "def check(iscube):\n\tassert iscube(1) == True", "def check(iscube):\n\tassert iscube(884736) == True", "def check(iscube):\n\tassert iscube(12167) == True", "def check(iscube):\n\tassert iscube(180) == False, \"Fifth test error: \" + str(iscube(180))", "def check(iscube):\n\tassert iscube(1000) == True, \"Sixth test error: \" + str(iscube(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.", "def check(iscube):\n\tassert iscube(729) == True", "def check(iscube):\n\tassert iscube(753571) == True", "def check(iscube):\n\tassert iscube(54872) == True", "def check(iscube):\n\tassert iscube(1331) == True", "def check(iscube):\n\tassert iscube(185193) == True", "def check(iscube):\n\tassert iscube(438976) == True", "def check(iscube):\n\tassert iscube(180) == False", "def check(iscube):\n\tassert iscube(7) == False", "def check(iscube):\n\tassert iscube(8) == True", "def check(iscube):\n\tassert iscube(2) == False", "def check(iscube):\n\tassert iscube(1729) == False, \"2nd edge test error: \" + str(iscube(1728))", "def check(iscube):\n\tassert iscube(493039) == True", "def check(iscube):\n\tassert iscube(729000) == True", "def check(iscube):\n\tassert iscube(328509) == True", "def check(iscube):\n\tassert iscube(85184) == True", "def check(iscube):\n\tassert iscube(704969) == True", "def check(iscube):\n\tassert iscube(287496) == True", "def check(iscube):\n\tassert iscube(15625) == True", "def check(iscube):\n\tassert iscube(3375) == True", "def check(iscube):\n\tassert iscube(226981) == True", "def check(iscube):\n\tassert iscube(19683) == True", "def check(iscube):\n\tassert iscube(64) == True, \"Fourth test error: \" + str(iscube(64))", "def check(iscube):\n\tassert iscube(571787) == True", "def check(iscube):\n\tassert iscube(181) == False", "def check(iscube):\n\tassert iscube(185) == False", "def check(iscube):\n\tassert iscube(551368) == True", "def check(iscube):\n\tassert iscube(64) == True", "def check(iscube):\n\tassert iscube(-1) == True, \"Third test error: \" + str(iscube(-1))", "def check(iscube):\n\tassert iscube(74088) == True", "def check(iscube):\n\tassert iscube(8000) == True"], "test_case_list": ["assert iscube(68921) == True", "assert iscube(1000000) == True", "assert iscube(205379) == True", "assert iscube(216) == True", "assert iscube(314432) == True", "assert iscube(274625) == True", "assert iscube(157464) == True", "assert iscube(941192) == True", "assert iscube(178) == False", "assert iscube(250047) == True", "assert iscube(3) == False", "assert iscube(179) == False", "assert iscube(857375) == True", "assert iscube(512) == True", "assert iscube(405224) == True", "assert iscube(176) == False", "assert iscube(238328) == True", "assert iscube(1) == True, \"First test error: \" + str(iscube(1))", "assert iscube(1000) == True", "assert iscube(4913) == True", "assert iscube(373248) == True", "assert iscube(262144) == True", "assert iscube(2) == False, \"Second test error: \" + str(iscube(2))", "assert iscube(0) == True, \"1st edge test error: \" + str(iscube(0))", "assert iscube(2197) == True", "assert iscube(2744) == True", "assert iscube(175) == False", "assert iscube(103823) == True", "assert iscube(13824) == True", "assert iscube(474552) == True", "assert iscube(658503) == True", "assert iscube(636056) == True", "assert iscube(5) == False", "assert iscube(4) == False", "assert iscube(21952) == True", "assert iscube(42875) == True", "assert iscube(681472) == True", "assert iscube(1) == True", "assert iscube(884736) == True", "assert iscube(12167) == True", "assert iscube(180) == False, \"Fifth test error: \" + str(iscube(180))", "assert iscube(1000) == True, \"Sixth test error: \" + str(iscube(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.", "assert iscube(729) == True", "assert iscube(753571) == True", "assert iscube(54872) == True", "assert iscube(1331) == True", "assert iscube(185193) == True", "assert iscube(438976) == True", "assert iscube(180) == False", "assert iscube(7) == False", "assert iscube(8) == True", "assert iscube(2) == False", "assert iscube(1729) == False, \"2nd edge test error: \" + str(iscube(1728))", "assert iscube(493039) == True", "assert iscube(729000) == True", "assert iscube(328509) == True", "assert iscube(85184) == True", "assert iscube(704969) == True", "assert iscube(287496) == True", "assert iscube(15625) == True", "assert iscube(3375) == True", "assert iscube(226981) == True", "assert iscube(19683) == True", "assert iscube(64) == True, \"Fourth test error: \" + str(iscube(64))", "assert iscube(571787) == True", "assert iscube(181) == False", "assert iscube(185) == False", "assert iscube(551368) == True", "assert iscube(64) == True", "assert iscube(-1) == True, \"Third test error: \" + str(iscube(-1))", "assert iscube(74088) == True", "assert iscube(8000) == True"], "nl": "\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    ", "func": "def iscube(a):", "examples": "Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    ", "repair_prompt": ["def iscube(a):\t\n'''Write a function that takes an integer a and returns True if this integer is a cube of some integer number. Note: you may assume the input is always valid.\nExamples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Takes an integer a and returns True if this integer is a cube of some integer number.\n    \n    Args:\n        a: Integer to check\n    \n    Returns:\n        Boolean indicating if a is a perfect cube\n    \"\"\"\n    # Calculate the cube root of the absolute value of the number\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the cube_root equals the absolute value of the number\n    is_perfect_cube = cube_root ** 3 == abs(a)\n    \n    return is_perfect_cube\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"Determine if the given integer is a perfect cube.\n\n    This function calculates the cube root of the given integer and checks\n    if the result is an integer. It handles both positive and negative integers.\n\n    Args:\n        a (int): The integer to check.\n\n    Returns:\n        bool: True if the integer is a perfect cube, False otherwise.\n    \"\"\"\n    if a == 0:\n        return True  # 0 is a perfect cube (0^3 = 0)\n\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n\n    # Check if the cube of the cube_root equals the absolute value of a\n    is_perfect_cube = (cube_root ** 3 == abs(a))\n\n    # If a is negative, ensure the cube root is also negative\n    if a < 0:\n        return is_perfect_cube and (cube_root == -round((-a) ** (1/3)))\n\n    return is_perfect_cube\n", "from typing import List\n## main.py\n\nimport gmpy2\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determine if the given integer is a perfect cube.\n\n    This function uses the 'gmpy2' library to efficiently calculate the cube root\n    and checks if the result is an integer.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root using gmpy2's iroot function\n    cube_root, is_exact = gmpy2.iroot(a, 3)\n    \n    # Return the boolean indicating if the cube root is exact\n    return is_exact\n", "from typing import List\n## main.py\n\nimport gmpy2\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Function to check if the given integer is a perfect cube.\n\n    This function uses the 'gmpy2' library to efficiently calculate the integer\n    cube root of the given number and checks if cubing this root returns the\n    original number. It handles negative numbers and zero correctly.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if the integer is a perfect cube, False otherwise.\n\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    \"\"\"\n    # Calculate the integer cube root of the absolute value of a\n    cube_root = gmpy2.iroot(a, 3)[0]\n    \n    # Check if the cube of the cube root equals the original number\n    if cube_root ** 3 == a:\n        return True\n    elif (-cube_root) ** 3 == a:\n        return True\n    else:\n        return False\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"Checks if a given integer is a perfect cube.\n\n    This function calculates the cube root of the given integer and checks\n    if the result is an integer. It handles both positive and negative integers.\n\n    Args:\n        a: Integer to check.\n\n    Returns:\n        Boolean indicating if a is a perfect cube.\n    \"\"\"\n    if not isinstance(a, int):\n        raise ValueError(\"Input must be an integer.\")\n\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(a ** (1/3))\n\n    # Check if the cube of the rounded cube root equals the original number\n    return cube_root ** 3 == a\n", "from typing import List\n## main.py\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Takes an integer a and returns True if this integer is a cube of some integer number.\n    \n    Args:\n        a (int): Integer to check.\n        \n    Returns:\n        bool: Boolean indicating if the number is a perfect cube.\n    \"\"\"\n    if not isinstance(a, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    # Calculate the cube root of the absolute value of a\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if the cube of the cube_root equals the absolute value of a\n    is_perfect_cube = cube_root ** 3 == abs(a)\n    \n    return is_perfect_cube\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Function to check if the given integer is a perfect cube.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    if a == 0:\n        return True  # 0 is a perfect cube (0^3 = 0)\n    \n    # Calculate the cube root of the absolute value of 'a'\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the cube_root equals the absolute value of 'a'\n    if cube_root ** 3 == abs(a):\n        return True\n    else:\n        return False\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determines if the given integer is a perfect cube.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    if a == 0:\n        return True  # Zero is a perfect cube (0^3 = 0)\n    \n    # Calculate the cube root of the absolute value of 'a'\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if the cube of the cube_root equals the absolute value of 'a'\n    if cube_root ** 3 == abs(a):\n        return True\n    \n    return False\n", "from typing import List\n## main.py\n\nimport gmpy2\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determine if the given integer is a perfect cube.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root using gmpy2's iroot function\n    cube_root, is_exact = gmpy2.iroot(a, 3)\n    \n    # Check if the cube root is an integer\n    return is_exact\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determine if the given integer is a perfect cube.\n\n    This function calculates the cube root of the absolute value of the number\n    and checks if the result is an integer. It handles both positive and negative\n    integers, including zero.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root of the absolute value of the number\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if the cube of the cube root equals the absolute value of the number\n    is_perfect_cube = cube_root ** 3 == abs(a)\n    \n    return is_perfect_cube\n"], "plans": ["requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube. It must handle both positive and negative integers and return a boolean value. The implementation should be efficient, especially for large numbers, and the code should be well-documented for ease of understanding.\nrequirement pool:\n- Implement the cube detection algorithm\n- Optimize the function for performance\n- Ensure the function handles edge cases\n- Document the function with examples\n- Test the function with a variety of inputs\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root of the absolute value of the number and checking if the result is an integer. We will use the built-in `round` function to handle floating-point precision issues. This approach ensures that the function is efficient and handles both positive and negative integers.\n", "requirement analysis:\nThe function should efficiently determine if a given integer is a perfect cube by checking if the cube root of the number is an integer. It should handle both positive and negative integers and return results quickly even for large numbers.\nrequirement pool:\n- Implement cube detection logic\n- Optimize for large integer inputs\n- Handle negative integer inputs\n- Provide comprehensive documentation\n- Ensure compatibility with Python's standard library\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if it is an integer. We will use Python's built-in capabilities to ensure compatibility and efficiency, especially for large integers. The function will handle both positive and negative integers correctly.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube by checking if the cube root of the number is an integer. It should handle both positive and negative integers and return results efficiently.\nrequirement pool:\n- Implement cube detection logic\n- Optimize for performance\n- Handle negative integers correctly\n- Provide comprehensive documentation\n- Include test cases for edge scenarios\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if the result is an integer. We will use the 'gmpy2' library for efficient integer root calculations, which is suitable for handling large integers. This approach ensures both accuracy and performance.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube, including handling negative numbers and zero. It should be optimized for performance, especially for large integers, and provide clear documentation for ease of use.\nrequirement pool:\n- Accurate cube detection for all integers\n- Performance optimization for large numbers\n- Handle negative numbers correctly\n- Provide clear documentation\n- Include examples in the documentation\nWe will use the 'gmpy2' library, which provides efficient integer root calculations, to determine if a number is a perfect cube. This library is chosen for its high performance and accuracy, especially with large integers. The function will calculate the integer cube root and verify if cubing this root returns the original number, ensuring correct handling of negative numbers and zero.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube. It must handle both positive and negative integers and should be optimized for performance to handle large numbers efficiently.\nrequirement pool:\n- Implement the main function to check if a number is a perfect cube.\n- Optimize the function for performance with large numbers.\n- Ensure the function handles negative numbers correctly.\n- Provide comprehensive documentation and examples.\n- Include unit tests to verify function accuracy.\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if the result is an integer. We will use the math library for efficient computation of cube roots, ensuring the function handles both positive and negative integers correctly. The function will be optimized for performance to handle large numbers efficiently.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube. It must handle both positive and negative integers and return results efficiently. The implementation should be straightforward for easy integration into other projects.\nrequirement pool:\n- Implement the cube detection logic\n- Optimize for performance with large numbers\n- Ensure compatibility with both positive and negative integers\n- Provide comprehensive documentation\n- Include test cases for validation\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if the result is an integer. We will use the built-in Python math library for efficient computation, as it provides a reliable method for handling cube root calculations. This approach ensures compatibility with both positive and negative integers and optimizes performance for large numbers.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube. It must handle both positive and negative integers and return results efficiently, even for large numbers.\nrequirement pool:\n- Implement the main function to check for perfect cubes\n- Optimize the function for performance with large integers\n- Ensure the function handles negative numbers correctly\n- Provide comprehensive documentation and examples\n- Include test cases for edge scenarios\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if the result is an integer. We will use the 'math' library for efficient cube root calculation and handle both positive and negative integers. The function will be optimized for performance to handle large integers efficiently.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube, considering both positive and negative integers. It should be optimized for performance, especially for large numbers, and should handle edge cases like zero and negative numbers efficiently.\nrequirement pool:\n- Accurate cube detection for integers\n- Performance optimization for large integers\n- Handle edge cases like zero and negative numbers\n- Provide clear documentation and examples\n- Ensure compatibility with existing projects\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if the result is an integer. We will use the 'math' library for efficient computation. The function will handle both positive and negative integers, including zero, and will be optimized for performance with large numbers.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube, including handling negative numbers and zero. It should be optimized for performance, especially for large integers, and provide clear documentation for users.\nrequirement pool:\n- Accurate cube detection for all integers\n- Performance optimization for large numbers\n- Handle negative numbers correctly\n- Provide clear documentation\n- Include example usage in documentation\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if the result is an integer. We will use the 'gmpy2' library for efficient integer root calculations, which is known for its high performance and accuracy. This approach will handle both positive and negative integers, as well as zero.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube. It should handle both positive and negative integers, including zero. The solution should be efficient, especially for large numbers, and easy to integrate into other systems.\nrequirement pool:\n- Implement the main cube detection logic\n- Optimize the function for performance\n- Ensure compatibility with both positive and negative integers\n- Provide comprehensive documentation\n- Include test cases for various scenarios\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root of the absolute value of the number and checking if the result is an integer. We will use the 'math' library for efficient computation of the cube root. The function will handle both positive and negative integers, including zero, and will be optimized for performance with large numbers.\n"], "scores": [1.0, 0.9861, 0.0, 0.0, 0.9861, 1.0, 1.0, 1.0, 0.0, 1.0], "pass_results": [true, false, false, false, false, true, true, true, false, true], "pass_test_cases_num": [72, 71, 0, 0, 71, 72, 72, 72, 0, 72], "completion": "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determine if the given integer is a perfect cube.\n\n    This function calculates the cube root of the absolute value of the number\n    and checks if the result is an integer. It handles both positive and negative\n    integers, including zero.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root of the absolute value of the number\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if the cube of the cube root equals the absolute value of the number\n    is_perfect_cube = cube_root ** 3 == abs(a)\n    \n    return is_perfect_cube\n", "passed": true, "pass": true, "pass_num": 5, "round": 991, "mutate_method": "condense_two2one", "parent_index": 328}
