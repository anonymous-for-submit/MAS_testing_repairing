{"task_id": "HumanEval/55", "prompt": "def fib(n: int):\t\n'''Return n-th Fibonacci number.\n>>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    '''", "entry_point": "fib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "test": ["def check(fib):\n\tassert fib(29) == 514229", "def check(fib):\n\tassert fib(25) == 75025", "def check(fib):\n\tassert fib(34) == 5702887", "def check(fib):\n\tassert fib(7) == 13", "def check(fib):\n\tassert fib(32) == 2178309", "def check(fib):\n\tassert fib(27) == 196418", "def check(fib):\n\tassert fib(16) == 987", "def check(fib):\n\tassert fib(14) == 377", "def check(fib):\n\tassert fib(33) == 3524578", "def check(fib):\n\tassert fib(20) == 6765", "def check(fib):\n\tassert fib(8) == 21", "def check(fib):\n\tassert fib(31) == 1346269", "def check(fib):\n\tassert fib(6) == 8", "def check(fib):\n\tassert fib(17) == 1597", "def check(fib):\n\tassert fib(2) == 1", "def check(fib):\n\tassert fib(1) == 1", "def check(fib):\n\tassert fib(30) == 832040", "def check(fib):\n\tassert fib(11) == 89", "def check(fib):\n\tassert fib(3) == 2", "def check(fib):\n\tassert fib(19) == 4181", "def check(fib):\n\tassert fib(21) == 10946", "def check(fib):\n\tassert fib(4) == 3", "def check(fib):\n\tassert fib(10) == 55", "def check(fib):\n\tassert fib(12) == 144", "def check(fib):\n\tassert fib(9) == 34", "def check(fib):\n\tassert fib(13) == 233", "def check(fib):\n\tassert fib(0) == 0", "def check(fib):\n\tassert fib(15) == 610", "def check(fib):\n\tassert fib(22) == 17711", "def check(fib):\n\tassert fib(24) == 46368", "def check(fib):\n\tassert fib(18) == 2584", "def check(fib):\n\tassert fib(28) == 317811", "def check(fib):\n\tassert fib(35) == 9227465"], "test_case_list": ["assert fib(29) == 514229", "assert fib(25) == 75025", "assert fib(34) == 5702887", "assert fib(7) == 13", "assert fib(32) == 2178309", "assert fib(27) == 196418", "assert fib(16) == 987", "assert fib(14) == 377", "assert fib(33) == 3524578", "assert fib(20) == 6765", "assert fib(8) == 21", "assert fib(31) == 1346269", "assert fib(6) == 8", "assert fib(17) == 1597", "assert fib(2) == 1", "assert fib(1) == 1", "assert fib(30) == 832040", "assert fib(11) == 89", "assert fib(3) == 2", "assert fib(19) == 4181", "assert fib(21) == 10946", "assert fib(4) == 3", "assert fib(10) == 55", "assert fib(12) == 144", "assert fib(9) == 34", "assert fib(13) == 233", "assert fib(0) == 0", "assert fib(15) == 610", "assert fib(22) == 17711", "assert fib(24) == 46368", "assert fib(18) == 2584", "assert fib(28) == 317811", "assert fib(35) == 9227465"], "nl": "Return n-th Fibonacci number.\n    ", "func": "def fib(n: int):", "examples": ">>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    ", "repair_prompt": ["def fib(n: int):\t\n'''Return n-th Fibonacci number.\n>>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number.\n\n    This function uses an iterative approach to calculate the Fibonacci number\n    at position n in the sequence. It is optimized for performance with large\n    inputs by avoiding recursion.\n\n    Args:\n        n (int): Position in Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n        int: n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is a negative integer or not an integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n\n    return b\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    This function validates the input to ensure it is a non-negative integer.\n    If the input is invalid, it raises a ValueError with an appropriate message.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n        \n    Returns:\n        int: The n-th Fibonacci number.\n        \n    Raises:\n        ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    # Input validation\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Iterative calculation of Fibonacci number\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative or not an integer.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n\n    return b\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (must be a positive integer).\n        \n    Returns:\n        int: The n-th Fibonacci number.\n        \n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The position in the Fibonacci sequence must be a positive integer.\")\n    \n    # Base cases\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Iterative calculation for n >= 3\n    prev, curr = 0, 1\n    for _ in range(2, n):\n        prev, curr = curr, prev + curr\n    \n    return curr\n\n# Example usage:\n# To calculate the 10th Fibonacci number, call fib(10)\n# print(fib(10))  # Output: 34\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number.\n    \n    This function computes the n-th Fibonacci number using an iterative approach\n    with memoization to optimize performance for large input values.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence.\n        \n    Returns:\n        int: The n-th Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    # Initialize the base cases\n    fib_numbers = [0, 1]\n    \n    # Compute Fibonacci numbers iteratively\n    for i in range(2, n):\n        next_fib = fib_numbers[-1] + fib_numbers[-2]\n        fib_numbers.append(next_fib)\n    \n    return fib_numbers[-1]\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input cannot be negative.\")\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n    \n    Returns:\n        int: The n-th Fibonacci number.\n    \n    Raises:\n        ValueError: If n is negative or not an integer.\n    \"\"\"\n    # Validate input\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Handle base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Iterative calculation of Fibonacci number\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    \n    return curr\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is negative or not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Iterative approach with memoization\n    fib_numbers = [0, 1]  # Initializing the first two Fibonacci numbers\n    for i in range(2, n + 1):\n        next_fib = fib_numbers[i - 1] + fib_numbers[i - 2]\n        fib_numbers.append(next_fib)\n\n    return fib_numbers[n]\n\n# Example usage:\n# print(fib(10))  # Output: 55\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"Calculate the n-th Fibonacci number using an iterative approach.\n\n    This function assumes n is a positive integer and does not handle\n    negative or non-integer inputs.\n\n    Args:\n        n (int): The position in the Fibonacci sequence (1-indexed).\n\n    Returns:\n        int: The n-th Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Base cases\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    # Iterative calculation for n >= 3\n    prev, curr = 0, 1\n    for _ in range(2, n):\n        prev, curr = curr, prev + curr\n\n    return curr\n\n# Example usage:\n# print(fib(10))  # Output: 34\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    Parameters:\n    n (int): The position in the Fibonacci sequence to calculate.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Raises:\n    ValueError: If n is negative or not an integer.\n    \n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n"], "plans": ["requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1 correctly. The implementation should be optimized for performance, especially for large values of n.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large inputs\n- Provide comprehensive documentation and examples\n- Include error handling for invalid inputs\n- Create a user-friendly interface for the function\nWe will implement the Fibonacci calculation using an iterative approach to optimize performance for large inputs. This approach avoids the overhead of recursive calls and stack usage, making it suitable for handling large values of n efficiently. We will use Python's built-in capabilities without additional libraries, ensuring simplicity and ease of integration.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should be easy to use and provide accurate results for both small and large input values.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Create a user-friendly interface for input and output\n- Provide examples and documentation for users\n- Ensure compatibility with various Python versions\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. The function will include input validation to handle non-integer and negative values gracefully.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1, and provide examples for user understanding.\nrequirement pool:\n- Implement the Fibonacci calculation algorithm\n- Optimize for performance with large inputs\n- Include comprehensive documentation and examples\n- Ensure compatibility with existing Python libraries\n- Provide error handling for invalid inputs\nWe will implement the Fibonacci calculation using an iterative approach to ensure optimal performance for large inputs. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also include error handling for invalid inputs such as negative numbers or non-integers.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle edge cases such as small and large values of n and provide accurate results. User interaction should be minimal, focusing on inputting a number and receiving the output.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance with large inputs\n- Create a user-friendly interface for input and output\n- Provide educational content on the Fibonacci sequence\n- Include examples of Fibonacci numbers in the interface\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach for efficiency, especially with large inputs. We will use Python's built-in capabilities without external libraries, as the Fibonacci sequence can be computed efficiently with simple loops. The function will handle only positive integer inputs, as negative or non-integer values do not apply to the Fibonacci sequence.\n", "requirement analysis:\nThe requirement is to implement a function that returns the n-th Fibonacci number. The function should be efficient and handle large input values gracefully. It should also be easy to use and well-documented.\nrequirement pool:\n- Implement the Fibonacci function to return the n-th number\n- Optimize the function for performance with large inputs\n- Provide clear documentation and examples\n- Ensure compatibility with various Python versions\n- Include error handling for invalid inputs\nWe will implement the Fibonacci function using an iterative approach to ensure efficient computation for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. Additionally, we will use memoization to store previously computed Fibonacci numbers, further optimizing performance. The function will be simple to integrate into any project and will include comprehensive documentation in a README file.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and negative inputs gracefully. Documentation should include examples for clarity.\nrequirement pool:\n- Implement Fibonacci calculation function\n- Optimize for large input values\n- Include comprehensive documentation\n- Handle edge cases and errors\n- Provide example usage in documentation\nWe will implement the Fibonacci calculation using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also handle edge cases such as n=0 and negative inputs by returning appropriate messages or values. The function will be documented with examples to enhance usability and understanding.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle edge cases such as small and large values of n and provide accurate results. Additionally, the function should be easy to use and understand, with clear documentation and examples.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance with large inputs\n- Provide clear documentation and examples\n- Develop a user-friendly interface for input and output\n- Include educational content about the Fibonacci sequence\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. The function will include error handling for non-integer and negative inputs, providing informative error messages.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1, and be optimized for larger values of n. The function should be well-documented to facilitate understanding and integration.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Provide comprehensive documentation and examples\n- Ensure compatibility with various Python versions\n- Include error handling for invalid inputs\nWe will implement the Fibonacci calculation using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also use memoization to store previously computed Fibonacci numbers to further optimize performance. The function will include error handling for invalid inputs such as negative numbers or non-integer values.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle edge cases and provide accurate results for a range of inputs.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Create a user-friendly interface for input and output\n- Provide educational content on the Fibonacci sequence\n- Include example calculations for user reference\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle large inputs gracefully and provide clear examples for user understanding.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance\n- Include examples in the documentation\n- Ensure compatibility with Python 3.x\n- Provide error handling for invalid inputs\nWe will implement an iterative approach to calculate the n-th Fibonacci number. This method is efficient for large inputs and avoids the overhead of recursive calls. We will use Python's built-in capabilities without additional libraries to ensure compatibility and ease of use. The function will include error handling for invalid inputs such as negative numbers or non-integers.\n"], "scores": [1.0, 1.0, 1.0, 0.0303, 0.0303, 1.0, 1.0, 1.0, 0.0303, 1.0], "pass_results": [true, true, true, false, false, true, true, true, false, true], "pass_test_cases_num": [33, 33, 33, 1, 1, 33, 33, 33, 1, 33], "completion": "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    Parameters:\n    n (int): The position in the Fibonacci sequence to calculate.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Raises:\n    ValueError: If n is negative or not an integer.\n    \n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n", "passed": true, "pass": true, "pass_num": 7, "round": 536, "mutate_method": "condense_two2one", "parent_index": 255}
