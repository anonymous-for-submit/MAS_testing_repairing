{"task_id": "HumanEval/55", "prompt": "def fib(n: int):\t\n'''Return n-th Fibonacci number.\n>>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    '''", "entry_point": "fib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "test": ["def check(fib):\n\tassert fib(29) == 514229", "def check(fib):\n\tassert fib(25) == 75025", "def check(fib):\n\tassert fib(34) == 5702887", "def check(fib):\n\tassert fib(7) == 13", "def check(fib):\n\tassert fib(32) == 2178309", "def check(fib):\n\tassert fib(27) == 196418", "def check(fib):\n\tassert fib(16) == 987", "def check(fib):\n\tassert fib(14) == 377", "def check(fib):\n\tassert fib(33) == 3524578", "def check(fib):\n\tassert fib(20) == 6765", "def check(fib):\n\tassert fib(8) == 21", "def check(fib):\n\tassert fib(31) == 1346269", "def check(fib):\n\tassert fib(6) == 8", "def check(fib):\n\tassert fib(17) == 1597", "def check(fib):\n\tassert fib(2) == 1", "def check(fib):\n\tassert fib(1) == 1", "def check(fib):\n\tassert fib(30) == 832040", "def check(fib):\n\tassert fib(11) == 89", "def check(fib):\n\tassert fib(3) == 2", "def check(fib):\n\tassert fib(19) == 4181", "def check(fib):\n\tassert fib(21) == 10946", "def check(fib):\n\tassert fib(4) == 3", "def check(fib):\n\tassert fib(10) == 55", "def check(fib):\n\tassert fib(12) == 144", "def check(fib):\n\tassert fib(9) == 34", "def check(fib):\n\tassert fib(13) == 233", "def check(fib):\n\tassert fib(0) == 0", "def check(fib):\n\tassert fib(15) == 610", "def check(fib):\n\tassert fib(22) == 17711", "def check(fib):\n\tassert fib(24) == 46368", "def check(fib):\n\tassert fib(18) == 2584", "def check(fib):\n\tassert fib(28) == 317811", "def check(fib):\n\tassert fib(35) == 9227465"], "test_case_list": ["assert fib(29) == 514229", "assert fib(25) == 75025", "assert fib(34) == 5702887", "assert fib(7) == 13", "assert fib(32) == 2178309", "assert fib(27) == 196418", "assert fib(16) == 987", "assert fib(14) == 377", "assert fib(33) == 3524578", "assert fib(20) == 6765", "assert fib(8) == 21", "assert fib(31) == 1346269", "assert fib(6) == 8", "assert fib(17) == 1597", "assert fib(2) == 1", "assert fib(1) == 1", "assert fib(30) == 832040", "assert fib(11) == 89", "assert fib(3) == 2", "assert fib(19) == 4181", "assert fib(21) == 10946", "assert fib(4) == 3", "assert fib(10) == 55", "assert fib(12) == 144", "assert fib(9) == 34", "assert fib(13) == 233", "assert fib(0) == 0", "assert fib(15) == 610", "assert fib(22) == 17711", "assert fib(24) == 46368", "assert fib(18) == 2584", "assert fib(28) == 317811", "assert fib(35) == 9227465"], "nl": "Return n-th Fibonacci number.\n    ", "func": "def fib(n: int):", "examples": ">>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    ", "repair_prompt": ["def fib(n: int):\t\n'''Return n-th Fibonacci number.\n>>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach with memoization.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence to compute.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n\n    # Initialize the memoization array with base cases\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    memo[2] = 1\n\n    # Iteratively compute Fibonacci numbers and store them in memo\n    for i in range(3, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2]\n\n    return memo[n]\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach with memoization.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n    \n    Returns:\n        int: The n-th Fibonacci number.\n    \n    Raises:\n        ValueError: If n is negative or not an integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Memoization array to store Fibonacci numbers\n    fib_numbers = [0] * (n + 1)\n    fib_numbers[0] = 0\n    fib_numbers[1] = 1\n    \n    # Iteratively calculate Fibonacci numbers\n    for i in range(2, n + 1):\n        fib_numbers[i] = fib_numbers[i - 1] + fib_numbers[i - 2]\n    \n    return fib_numbers[n]\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using memoization.\n\n    Args:\n        n (int): The position in the Fibonacci sequence (1-indexed).\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    Examples:\n        >>> fib(10)\n        55\n        >>> fib(1)\n        1\n        >>> fib(8)\n        21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Memoization cache to store previously computed Fibonacci numbers\n    memo = {1: 1, 2: 1}\n\n    def _fib_memo(n: int) -> int:\n        \"\"\"Helper function to compute Fibonacci using memoization.\"\"\"\n        if n in memo:\n            return memo[n]\n        # Compute the Fibonacci number and store it in the memoization cache\n        memo[n] = _fib_memo(n - 1) + _fib_memo(n - 2)\n        return memo[n]\n\n    return _fib_memo(n)\n\n# Example usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using memoization.\n\n    Args:\n        n (int): The position in the Fibonacci sequence (1-indexed).\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    Example usage:\n        >>> fib(10)\n        55\n        >>> fib(1)\n        1\n        >>> fib(8)\n        21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Memoization cache\n    memo = {1: 1, 2: 1}\n\n    def _fib_memo(n: int) -> int:\n        \"\"\"Helper function to calculate Fibonacci using memoization.\"\"\"\n        if n in memo:\n            return memo[n]\n        # Recursive calculation with memoization\n        memo[n] = _fib_memo(n - 1) + _fib_memo(n - 2)\n        return memo[n]\n\n    return _fib_memo(n)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n\n    Args:\n        n (int): Position in Fibonacci sequence (1-indexed).\n\n    Returns:\n        int: n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The position in Fibonacci sequence must be a positive integer.\")\n\n    # Base cases\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    # Iterative calculation for n >= 3\n    prev, curr = 0, 1\n    for _ in range(2, n):\n        prev, curr = curr, prev + curr\n\n    return curr\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        position = 10  # Example position\n        result = fib(position)\n        print(f\"The {position}-th Fibonacci number is: {result}\")\n    except ValueError as e:\n        print(e)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Return the n-th Fibonacci number.\n    \n    This function computes the n-th Fibonacci number using an iterative approach\n    with memoization to optimize performance. It avoids the overhead of recursive\n    calls and stack overflow issues.\n\n    Args:\n        n (int): The index of the Fibonacci sequence.\n\n    Returns:\n        int: The n-th Fibonacci number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input cannot be negative\")\n    \n    # Memoization cache to store previously computed Fibonacci numbers\n    memo = {0: 0, 1: 1}\n    \n    if n in memo:\n        return memo[n]\n    \n    # Iteratively compute Fibonacci numbers and store in memo\n    for i in range(2, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2]\n    \n    return memo[n]\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        index = 10\n        print(f\"The {index}-th Fibonacci number is: {fib(index)}\")\n    except ValueError as e:\n        print(e)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    This function calculates the Fibonacci number at position n in the sequence.\n    It uses an iterative method to avoid the overhead of recursive calls and\n    potential stack overflow issues for large values of n.\n\n    Args:\n        n (int): The position in the Fibonacci sequence.\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is negative or not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"The input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"The input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n\n    return b\n\n# Example usage:\n# print(fib(10))  # Output: 55\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"Calculate the n-th Fibonacci number using an iterative approach.\n\n    This function computes the Fibonacci number at position n in the sequence.\n    The Fibonacci sequence is defined as follows:\n    - F(1) = 0\n    - F(2) = 1\n    - F(n) = F(n-1) + F(n-2) for n > 2\n\n    Args:\n        n (int): The position in the Fibonacci sequence (1-indexed).\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    prev, curr = 0, 1\n    for _ in range(2, n):\n        prev, curr = curr, prev + curr\n\n    return curr\n\n# Example usage:\n# print(fib(10))  # Output: 34\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number.\n\n    Args:\n        n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is negative or not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n\n    return b\n\n# Example usage:\n# try:\n#     result = fib(10)\n#     print(f\"The 10th Fibonacci number is: {result}\")\n# except ValueError as e:\n#     print(e)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n\n    Args:\n        n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is negative or not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n\n# Example usage:\n# try:\n#     result = fib(10)\n#     print(f\"The 10th Fibonacci number is: {result}\")\n# except ValueError as e:\n#     print(e)\n"], "plans": ["requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle large inputs gracefully and provide examples for user understanding.\nrequirement pool:\n- Implement the Fibonacci calculation algorithm\n- Optimize the algorithm for performance\n- Include example usage in documentation\n- Ensure compatibility with different Python versions\n- Provide error handling for invalid inputs\nWe will implement the Fibonacci calculation using an iterative approach to ensure optimal performance for large inputs. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also use memoization to store previously computed Fibonacci numbers to further enhance performance. The function will include inline documentation with examples to guide users on how to use it effectively.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1, and be optimized for larger values of n. Documentation should be clear to facilitate understanding and integration.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Provide comprehensive documentation and examples\n- Ensure compatibility with various Python versions\n- Include error handling for invalid inputs\nWe will implement the Fibonacci calculation using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also use memoization to store previously computed Fibonacci numbers to further optimize performance. The function will include error handling for invalid inputs such as negative numbers or non-integers.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle large inputs gracefully and provide examples for user understanding.\nrequirement pool:\n- Implement Fibonacci calculation algorithm\n- Optimize for performance with large inputs\n- Include examples in documentation\n- Ensure compatibility with different Python versions\n- Provide error handling for invalid inputs\nWe will implement the Fibonacci calculation using an efficient algorithm called memoization to optimize performance for large inputs. This approach will store previously computed Fibonacci numbers to avoid redundant calculations, significantly improving execution speed. We will also include clear and concise inline documentation with examples to enhance user understanding.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle large inputs gracefully and provide examples for user understanding.\nrequirement pool:\n- Implement efficient Fibonacci calculation\n- Optimize for large input values\n- Include example usage in documentation\n- Ensure compatibility with Python 3.x\n- Provide error handling for invalid inputs\nWe will implement an efficient Fibonacci calculation using memoization to optimize performance for large inputs. This approach will store previously computed Fibonacci numbers to avoid redundant calculations, significantly improving execution speed. We will also include clear documentation with examples to enhance usability.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number, handle large inputs efficiently, and provide clear documentation with examples.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Include comprehensive documentation and examples\n- Ensure compatibility with various Python versions\n- Add error handling for invalid inputs\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to optimize performance for large inputs. This approach avoids the overhead of recursive calls and stack usage, making it efficient for large numbers. We will use Python's built-in capabilities without additional libraries, ensuring compatibility across various Python versions. Comprehensive documentation with examples will be included to enhance usability.\n", "requirement analysis:\nThe function should efficiently compute the n-th Fibonacci number using an optimized algorithm to handle large inputs. It should be easy to use and integrate into other projects, with clear documentation provided.\nrequirement pool:\n- Implement the Fibonacci function with optimized performance\n- Provide comprehensive documentation for the function\n- Ensure the function is easy to integrate into other projects\n- Include examples of usage in different scenarios\n- Optimize the function for very large input values\nWe will implement the Fibonacci function using an iterative approach to optimize performance for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. Additionally, we will use memoization to store previously computed Fibonacci numbers, further enhancing performance. The function will be simple to integrate into other projects and will include comprehensive documentation with usage examples.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1, and be optimized for larger values of n. The function should be easy to understand and integrate into other projects.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Provide comprehensive documentation and examples\n- Include error handling for invalid inputs\n- Create a user-friendly interface for demonstration\nWe will implement the Fibonacci calculation using an iterative approach to optimize performance for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, ensuring simplicity and ease of integration.\n", "requirement analysis:\nThe requirement is to implement a function that returns the n-th Fibonacci number. The function should be efficient and handle both small and large input values. It should also be easy to use and understand.\nrequirement pool:\n- Implement the Fibonacci function to return the n-th number\n- Optimize the function for performance with large inputs\n- Create a user-friendly interface for input and output\n- Provide educational content on the Fibonacci sequence\n- Include examples of Fibonacci numbers for small inputs\nWe will implement a function to compute the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will also use Python's built-in capabilities to handle large integers efficiently.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle edge cases such as small and large values of n and provide accurate results. Additionally, the function should be easy to use and understand, with clear documentation and examples.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance with large inputs\n- Create a user-friendly interface for input and output\n- Provide educational content on the Fibonacci sequence\n- Ensure compatibility with mobile devices\nWe will implement a function to compute the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. The function will include error handling for non-integer and negative inputs, providing clear feedback to the user.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle edge cases such as small and large values of n and provide accurate results. Additionally, the function should be easy to use and understand, with clear documentation and examples.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance with large inputs\n- Provide clear documentation and examples\n- Develop a user-friendly interface for input and output\n- Include educational content about the Fibonacci sequence\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task. The function will include error handling for non-integer and negative inputs, returning an appropriate message.\n"], "scores": [0.9697, 1.0, 0.9697, 0.9697, 0.0303, 1.0, 1.0, 0.0303, 1.0, 1.0], "pass_results": [false, true, false, false, false, true, true, false, true, true], "pass_test_cases_num": [32, 33, 32, 32, 1, 33, 33, 1, 33, 33], "completion": "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n\n    Args:\n        n (int): The position in the Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is negative or not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n\n# Example usage:\n# try:\n#     result = fib(10)\n#     print(f\"The 10th Fibonacci number is: {result}\")\n# except ValueError as e:\n#     print(e)\n", "passed": true, "pass": true, "pass_num": 5, "round": 47, "mutate_method": "condense_two2one", "parent_index": 47}
