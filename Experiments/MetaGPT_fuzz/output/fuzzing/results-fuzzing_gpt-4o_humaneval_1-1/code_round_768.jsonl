{"task_id": "HumanEval/136", "prompt": "def largest_smallest_integers(lst):\t\n'''Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, return them as None. Ensure the function handles lists with mixed data types gracefully.\nExamples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''", "entry_point": "largest_smallest_integers", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "test": ["def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 2, 6, 8, 14, 7, 8, -13]) == (-13, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-7, -3, 1, 0, 5]) == (-3, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-2, -4, 0, -5, -103, 1]) == (-2, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 5, 6, 1, 7, 2, -7]) == (-7, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-3, -5, -4, -11]) == (-3, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 9, 5, 3, 9, 4, 2]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3, 1, 4, 6, 3, 6]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-4, -1, -6, -3]) == (-1, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([6, 9, 1, 4, 5, 11]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, -5, -9, -10]) == (-1, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, -7, -3, -3, 4]) == (-1, 4)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 2, -1, -4]) == (-1, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 9, 3, 2, 3, 3]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-3, 0, -2, -1, -102, 6]) == (-1, 6)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 3, 1, 8, 7, 9, 0]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-11, -7, -1, -3, 6]) == (-1, 6)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 3, 6, 9, 4, 7, -5]) == (-5, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([9, 7, 1, 2, 5, 11, -3]) == (-3, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5]) == (None, 5)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-2, -7, -4, -3, -102, 6]) == (-2, 6)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, -3, -5, -6, 0]) == (-1, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 7, 12, 9, 11, 6, 6, -4]) == (-4, 5)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-8, -8, -3, -2, 5]) == (-2, 5)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([8, 4, 3, 8, 6, 1, 10, -8]) == (-8, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 5, 3, 3, 3, 4]) == (None, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4, 5, 6, 5, 8, 7, 1, -9]) == (-9, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([6, 3, 1, 6, 8, 4, 4]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([7, 2, 4, 1, 4, 11, -6]) == (-6, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 3, 5, 4, 1, 10]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([11, 6, 7, 3, 6, 6, 5, -14]) == (-14, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, -6, -6, -2, 2]) == (-2, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([8, 2, 3, 11, 6, 5, -11]) == (-11, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([6, 2, 3, 5, 5, 8, -2]) == (-2, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([9, 8, 8, 1, 3, 3, -8]) == (-8, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 7, 1, 5, 3, 12, 2]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4, 9, 1, 5, 5, 9]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, -7, -1, 1, -104, 1]) == (-1, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, -1, -10, -11]) == (-1, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([6, 1, 2, 3, 6, 2, 3]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([0, -8, -7, -8]) == (-7, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4, 2, 5, 5, 9, 5, 2]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-3, -8, -7, 0, 1]) == (-3, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([7, 4, 2, 7, 7, 5, 2]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 1, 1, 8, 4, 11]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3, 4, 1, 9, 5, 7, -12]) == (-12, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([9, 6, 5, 6, 3, 2, -11]) == (-11, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([6, 7, 5, 7, 2, 11, 4]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 8, 1, 9, 3, 1, 3]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3, 6, 2, 6, 10, 9]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3, 3, 6, 1, 4, 8, -2]) == (-2, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3, 4, 5, 6, 1, 9, -2]) == (-2, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-5, -5, 1, 2, -95, 6]) == (-5, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-4, -3, -1, -4, -102, 4]) == (-1, 4)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 2, 5, 1, 10, 7, 5]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 3, 12, 7, 10, 6, 10, -12]) == (-12, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, -3, -8, 2, -97, 3]) == (-1, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, -4, -4, -3, 1]) == (-3, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 4, 4, 5, 10, 12, 5]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, -7, -4, -11, 1]) == (-4, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4, 7, 8, 9, 4, 5, -4]) == (-4, 4)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 0, -8, -5]) == (-5, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-4, -8, -7, -3, 5]) == (-3, 5)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, 1, -10, -6, 1]) == (-1, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-10, -5, -8, 2, -100, 5]) == (-5, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, -8, -7, -11, 5]) == (-6, 5)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([]) == (None, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, -9, -1, -6, -100, 2]) == (-1, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-9, -2, -7, -6, 4]) == (-2, 4)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 6, 3, 7, 9, 1, -6]) == (-6, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-3, -1, -5, -3, -102, 3]) == (-1, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4, -7, -4, -10, 1]) == (-4, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-9, -4, -3, -8, 4]) == (-3, 4)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([8, 1, 11, 9, 12, 7, 5, -11]) == (-11, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([7, 7, 7, 1, 5, 7, 5, -10]) == (-10, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3]) == (None, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, -1, -10, -8]) == (-1, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([0]) == (None, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3, -6, -3, -9]) == (-3, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([9, 2, 4, 1, 6, 5, -4]) == (-4, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, -3, -5, -6]) == (-1, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([9, 6, 4, 3, 7, 4, 4, -9]) == (-9, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-4, -9, -8, 2, -100, 2]) == (-4, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4]) == (None, 4)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-4, -8, 0, -8, 1]) == (-4, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3, 4, 2, 7, 5, 3, 4]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 7, 3, 7, 7, 3, -1]) == (-1, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, 2, -5, -2]) == (-1, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 6, 2, 5, 7, 3]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 6, 1, 9, 5, 4, 0]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, -3, -3, -3, 1]) == (-3, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, 1, -8, -3, 5]) == (-3, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-4, -6, 1, -8, 1]) == (-4, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4, 4, 2, 5, 4, 10]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 7, 4, 3, 5, 5, 0]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([4, 4, 5, 5, 5, 6]) == (None, 4)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-7, -6, 0, -8, 1]) == (-6, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 9, 6, 4, 3, 7]) == (None, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([1, 5, 8, 10, 1, 2, -3]) == (-3, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, 0, -2, -4]) == (-2, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 3, 5, 1, 13, 4, 5, -4]) == (-4, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, -8, 1, 0, -103, 5]) == (-6, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-6, -1, -3, -1, 1]) == (-1, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 8, 6, 7, 1, 10, -8]) == (-8, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-3, -4, -3, -3, 5]) == (-3, 5)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 3, 5, 9, 5, 9, 3]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-3, 1, -9, -8, 2]) == (-3, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-7, -4, -5, -6, 5]) == (-4, 5)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([3, 8, 2, 5, 9, 1, 2]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-1, -7, -10, -1, 1]) == (-1, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([5, 7, 4, 3, 3, 11, 2]) == (None, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 8, 13, 2, 11, 6, 10, -10]) == (-10, 2)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-7, -8, -7, -3, 3]) == (-3, 3)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([7, 1, 4, 5, 9, 8, 3]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([-2, -4, -10, -2]) == (-2, None)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([7, 9, 1, 8, 10, 6, 3]) == (None, 1)", "def check(largest_smallest_integers):\n\tassert largest_smallest_integers([2, 1, 4, 9, 11, 7, 6, -7]) == (-7, 1)"], "test_case_list": ["assert largest_smallest_integers([2, 2, 6, 8, 14, 7, 8, -13]) == (-13, 2)", "assert largest_smallest_integers([-7, -3, 1, 0, 5]) == (-3, 1)", "assert largest_smallest_integers([-2, -4, 0, -5, -103, 1]) == (-2, 1)", "assert largest_smallest_integers([2, 5, 6, 1, 7, 2, -7]) == (-7, 1)", "assert largest_smallest_integers([-3, -5, -4, -11]) == (-3, None)", "assert largest_smallest_integers([2, 9, 5, 3, 9, 4, 2]) == (None, 2)", "assert largest_smallest_integers([3, 1, 4, 6, 3, 6]) == (None, 1)", "assert largest_smallest_integers([-4, -1, -6, -3]) == (-1, None)", "assert largest_smallest_integers([6, 9, 1, 4, 5, 11]) == (None, 1)", "assert largest_smallest_integers([-1, -5, -9, -10]) == (-1, None)", "assert largest_smallest_integers([-1, -7, -3, -3, 4]) == (-1, 4)", "assert largest_smallest_integers([2, 2, -1, -4]) == (-1, 2)", "assert largest_smallest_integers([2, 9, 3, 2, 3, 3]) == (None, 2)", "assert largest_smallest_integers([2]) == (None, 2)", "assert largest_smallest_integers([-3, 0, -2, -1, -102, 6]) == (-1, 6)", "assert largest_smallest_integers([5, 3, 1, 8, 7, 9, 0]) == (None, 1)", "assert largest_smallest_integers([-11, -7, -1, -3, 6]) == (-1, 6)", "assert largest_smallest_integers([5, 3, 6, 9, 4, 7, -5]) == (-5, 3)", "assert largest_smallest_integers([9, 7, 1, 2, 5, 11, -3]) == (-3, 1)", "assert largest_smallest_integers([5]) == (None, 5)", "assert largest_smallest_integers([-2, -7, -4, -3, -102, 6]) == (-2, 6)", "assert largest_smallest_integers([-1, -3, -5, -6, 0]) == (-1, None)", "assert largest_smallest_integers([5, 7, 12, 9, 11, 6, 6, -4]) == (-4, 5)", "assert largest_smallest_integers([-8, -8, -3, -2, 5]) == (-2, 5)", "assert largest_smallest_integers([8, 4, 3, 8, 6, 1, 10, -8]) == (-8, 1)", "assert largest_smallest_integers([5, 5, 3, 3, 3, 4]) == (None, 3)", "assert largest_smallest_integers([4, 5, 6, 5, 8, 7, 1, -9]) == (-9, 1)", "assert largest_smallest_integers([6, 3, 1, 6, 8, 4, 4]) == (None, 1)", "assert largest_smallest_integers([7, 2, 4, 1, 4, 11, -6]) == (-6, 1)", "assert largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)", "assert largest_smallest_integers([1, 3, 5, 4, 1, 10]) == (None, 1)", "assert largest_smallest_integers([11, 6, 7, 3, 6, 6, 5, -14]) == (-14, 3)", "assert largest_smallest_integers([-6, -6, -6, -2, 2]) == (-2, 2)", "assert largest_smallest_integers([8, 2, 3, 11, 6, 5, -11]) == (-11, 2)", "assert largest_smallest_integers([6, 2, 3, 5, 5, 8, -2]) == (-2, 2)", "assert largest_smallest_integers([9, 8, 8, 1, 3, 3, -8]) == (-8, 1)", "assert largest_smallest_integers([1, 7, 1, 5, 3, 12, 2]) == (None, 1)", "assert largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]) == (None, 1)", "assert largest_smallest_integers([4, 9, 1, 5, 5, 9]) == (None, 1)", "assert largest_smallest_integers([-1, -7, -1, 1, -104, 1]) == (-1, 1)", "assert largest_smallest_integers([-6, -1, -10, -11]) == (-1, None)", "assert largest_smallest_integers([6, 1, 2, 3, 6, 2, 3]) == (None, 1)", "assert largest_smallest_integers([0, -8, -7, -8]) == (-7, None)", "assert largest_smallest_integers([4, 2, 5, 5, 9, 5, 2]) == (None, 2)", "assert largest_smallest_integers([-3, -8, -7, 0, 1]) == (-3, 1)", "assert largest_smallest_integers([7, 4, 2, 7, 7, 5, 2]) == (None, 2)", "assert largest_smallest_integers([1, 1, 1, 8, 4, 11]) == (None, 1)", "assert largest_smallest_integers([3, 4, 1, 9, 5, 7, -12]) == (-12, 1)", "assert largest_smallest_integers([9, 6, 5, 6, 3, 2, -11]) == (-11, 2)", "assert largest_smallest_integers([6, 7, 5, 7, 2, 11, 4]) == (None, 2)", "assert largest_smallest_integers([1, 8, 1, 9, 3, 1, 3]) == (None, 1)", "assert largest_smallest_integers([3, 6, 2, 6, 10, 9]) == (None, 2)", "assert largest_smallest_integers([3, 3, 6, 1, 4, 8, -2]) == (-2, 1)", "assert largest_smallest_integers([3, 4, 5, 6, 1, 9, -2]) == (-2, 1)", "assert largest_smallest_integers([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.", "assert largest_smallest_integers([-5, -5, 1, 2, -95, 6]) == (-5, 1)", "assert largest_smallest_integers([-4, -3, -1, -4, -102, 4]) == (-1, 4)", "assert largest_smallest_integers([5, 2, 5, 1, 10, 7, 5]) == (None, 1)", "assert largest_smallest_integers([1]) == (None, 1)", "assert largest_smallest_integers([5, 3, 12, 7, 10, 6, 10, -12]) == (-12, 3)", "assert largest_smallest_integers([-1, -3, -8, 2, -97, 3]) == (-1, 2)", "assert largest_smallest_integers([-6, -4, -4, -3, 1]) == (-3, 1)", "assert largest_smallest_integers([2, 4, 4, 5, 10, 12, 5]) == (None, 2)", "assert largest_smallest_integers([1, -7, -4, -11, 1]) == (-4, 1)", "assert largest_smallest_integers([4, 7, 8, 9, 4, 5, -4]) == (-4, 4)", "assert largest_smallest_integers([1, 0, -8, -5]) == (-5, 1)", "assert largest_smallest_integers([-4, -8, -7, -3, 5]) == (-3, 5)", "assert largest_smallest_integers([-1, 1, -10, -6, 1]) == (-1, 1)", "assert largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)", "assert largest_smallest_integers([-10, -5, -8, 2, -100, 5]) == (-5, 2)", "assert largest_smallest_integers([-6, -8, -7, -11, 5]) == (-6, 5)", "assert largest_smallest_integers([]) == (None, None)", "assert largest_smallest_integers([-1, -9, -1, -6, -100, 2]) == (-1, 2)", "assert largest_smallest_integers([-9, -2, -7, -6, 4]) == (-2, 4)", "assert largest_smallest_integers([5, 6, 3, 7, 9, 1, -6]) == (-6, 1)", "assert largest_smallest_integers([-3, -1, -5, -3, -102, 3]) == (-1, 3)", "assert largest_smallest_integers([4, -7, -4, -10, 1]) == (-4, 1)", "assert largest_smallest_integers([-9, -4, -3, -8, 4]) == (-3, 4)", "assert largest_smallest_integers([8, 1, 11, 9, 12, 7, 5, -11]) == (-11, 1)", "assert largest_smallest_integers([7, 7, 7, 1, 5, 7, 5, -10]) == (-10, 1)", "assert largest_smallest_integers([3]) == (None, 3)", "assert largest_smallest_integers([1, -1, -10, -8]) == (-1, 1)", "assert largest_smallest_integers([0]) == (None, None)", "assert largest_smallest_integers([3, -6, -3, -9]) == (-3, 3)", "assert largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)", "assert largest_smallest_integers([9, 2, 4, 1, 6, 5, -4]) == (-4, 1)", "assert largest_smallest_integers([-1, -3, -5, -6]) == (-1, None)", "assert largest_smallest_integers([9, 6, 4, 3, 7, 4, 4, -9]) == (-9, 3)", "assert largest_smallest_integers([-4, -9, -8, 2, -100, 2]) == (-4, 2)", "assert largest_smallest_integers([4]) == (None, 4)", "assert largest_smallest_integers([-4, -8, 0, -8, 1]) == (-4, 1)", "assert largest_smallest_integers([3, 4, 2, 7, 5, 3, 4]) == (None, 2)", "assert largest_smallest_integers([5, 7, 3, 7, 7, 3, -1]) == (-1, 3)", "assert largest_smallest_integers([-1, 2, -5, -2]) == (-1, 2)", "assert largest_smallest_integers([1, 6, 2, 5, 7, 3]) == (None, 1)", "assert largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)", "assert largest_smallest_integers([1, 6, 1, 9, 5, 4, 0]) == (None, 1)", "assert largest_smallest_integers([1, -3, -3, -3, 1]) == (-3, 1)", "assert largest_smallest_integers([-6, 1, -8, -3, 5]) == (-3, 1)", "assert largest_smallest_integers([-4, -6, 1, -8, 1]) == (-4, 1)", "assert largest_smallest_integers([4, 4, 2, 5, 4, 10]) == (None, 2)", "assert largest_smallest_integers([1, 7, 4, 3, 5, 5, 0]) == (None, 1)", "assert largest_smallest_integers([4, 4, 5, 5, 5, 6]) == (None, 4)", "assert largest_smallest_integers([-7, -6, 0, -8, 1]) == (-6, 1)", "assert largest_smallest_integers([5, 9, 6, 4, 3, 7]) == (None, 3)", "assert largest_smallest_integers([1, 5, 8, 10, 1, 2, -3]) == (-3, 1)", "assert largest_smallest_integers([-6, 0, -2, -4]) == (-2, None)", "assert largest_smallest_integers([5, 3, 5, 1, 13, 4, 5, -4]) == (-4, 1)", "assert largest_smallest_integers([-6, -8, 1, 0, -103, 5]) == (-6, 1)", "assert largest_smallest_integers([-6, -1, -3, -1, 1]) == (-1, 1)", "assert largest_smallest_integers([2, 8, 6, 7, 1, 10, -8]) == (-8, 1)", "assert largest_smallest_integers([-3, -4, -3, -3, 5]) == (-3, 5)", "assert largest_smallest_integers([2, 3, 5, 9, 5, 9, 3]) == (None, 2)", "assert largest_smallest_integers([-3, 1, -9, -8, 2]) == (-3, 1)", "assert largest_smallest_integers([-7, -4, -5, -6, 5]) == (-4, 5)", "assert largest_smallest_integers([3, 8, 2, 5, 9, 1, 2]) == (None, 1)", "assert largest_smallest_integers([-1, -7, -10, -1, 1]) == (-1, 1)", "assert largest_smallest_integers([5, 7, 4, 3, 3, 11, 2]) == (None, 2)", "assert largest_smallest_integers([2, 8, 13, 2, 11, 6, 10, -10]) == (-10, 2)", "assert largest_smallest_integers([-7, -8, -7, -3, 3]) == (-3, 3)", "assert largest_smallest_integers([7, 1, 4, 5, 9, 8, 3]) == (None, 1)", "assert largest_smallest_integers([-2, -4, -10, -2]) == (-2, None)", "assert largest_smallest_integers([7, 9, 1, 8, 10, 6, 3]) == (None, 1)", "assert largest_smallest_integers([2, 1, 4, 9, 11, 7, 6, -7]) == (-7, 1)"], "nl": "\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    ", "func": "def largest_smallest_integers(lst):", "examples": "Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    ", "repair_prompt": ["def largest_smallest_integers(lst):\t\n'''Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, return them as None. Ensure the function handles lists with mixed data types gracefully.\nExamples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    This function takes a list of mixed data types and returns a tuple (a, b),\n    where 'a' is the largest of negative integers, and 'b' is the smallest of\n    positive integers in the list. If there is no negative or positive integer,\n    it returns None for that position.\n\n    Parameters:\n    lst (list): A list containing mixed data types.\n\n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest\n    positive integer, or None if not present.\n    \"\"\"\n    largest_negative = None\n    smallest_positive = None\n\n    for item in lst:\n        if isinstance(item, int):\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n\n# Example usage:\n# result = largest_smallest_integers([3, -1, 2, -7, 'a', 5.5, -3])\n# print(result)  # Output should be (-1, 2)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    This function takes a list of mixed data types and returns a tuple (a, b),\n    where 'a' is the largest negative integer and 'b' is the smallest positive integer.\n    If no such integers exist, it returns None for the respective value.\n\n    Parameters:\n    lst (list): A list containing mixed data types.\n\n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest positive integer,\n           or None if not applicable.\n    \"\"\"\n    # Initialize variables to store the largest negative and smallest positive integers\n    largest_negative = None\n    smallest_positive = None\n\n    # Iterate through the list to filter and find the required integers\n    for item in lst:\n        if isinstance(item, int):  # Check if the item is an integer\n            if item < 0:\n                # Update largest_negative if the current item is more negative\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                # Update smallest_positive if the current item is smaller\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    This function takes a list of mixed data types and returns a tuple (a, b),\n    where 'a' is the largest of negative integers, and 'b' is the smallest of\n    positive integers in the list. If there is no negative or positive integers,\n    return them as None.\n\n    Parameters:\n    lst (list): A list containing mixed data types.\n\n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest\n    positive integer, or None if not applicable.\n    \"\"\"\n    largest_negative = None\n    smallest_positive = None\n\n    for item in lst:\n        if isinstance(item, int):\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n\n# Example usage:\n# result = largest_smallest_integers([1, -2, 3.5, 'a', -5, 7, 0, -1])\n# print(result)  # Output should be (-1, 1)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    This function takes a list of mixed data types and returns a tuple (a, b),\n    where 'a' is the largest of negative integers, and 'b' is the smallest of\n    positive integers in the list. If there is no negative or positive integers,\n    it returns None for that position.\n\n    Parameters:\n    lst (list): A list containing mixed data types.\n\n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest\n    positive integer, or None if not applicable.\n    \"\"\"\n    # Initialize variables to store the largest negative and smallest positive integers\n    largest_negative = None\n    smallest_positive = None\n\n    # Iterate through the list to filter and find the required integers\n    for item in lst:\n        if isinstance(item, int):  # Check if the item is an integer\n            if item < 0:\n                # Update largest_negative if the current item is more negative\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                # Update smallest_positive if the current item is smaller\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n\n# Example usage:\n# result = largest_smallest_integers([1, -2, 3.5, 'a', -5, 7, 0, -1])\n# print(result)  # Output should be (-1, 1)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    Args:\n        lst (list): A list containing mixed data types.\n    Returns:\n        tuple: A tuple (a, b) where 'a' is the largest negative integer and 'b' is the smallest positive integer.\n    \"\"\"\n    largest_negative = None\n    smallest_positive = None\n\n    for item in lst:\n        if isinstance(item, int):\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n\n# Example usage:\n# result = largest_smallest_integers([3, -1, -4, 2, 0, 5, -6, 'a', 4.5])\n# print(result)  # Output should be (-1, 2)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    This function takes a list of mixed data types and returns a tuple (a, b), where 'a' is the largest of negative integers,\n    and 'b' is the smallest of positive integers in the list. If there is no negative or positive integer, it returns None for that value.\n\n    Parameters:\n    lst (list): A list containing mixed data types.\n\n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest positive integer, or None if they do not exist.\n    \"\"\"\n    largest_negative = None\n    smallest_positive = None\n\n    for item in lst:\n        if isinstance(item, int):\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    This function takes a list of mixed data types and returns a tuple (a, b), where 'a' is the largest negative integer\n    and 'b' is the smallest positive integer. If there are no negative or positive integers, it returns None for those values.\n\n    Parameters:\n    lst (list): A list containing mixed data types.\n\n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest positive integer, or None if not present.\n    \"\"\"\n    # Initialize variables to store the largest negative and smallest positive integers\n    largest_negative = None\n    smallest_positive = None\n\n    # Iterate through the list to filter out non-integer types and find the required integers\n    for item in lst:\n        if isinstance(item, int):\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n\n# Example usage:\n# result = largest_smallest_integers([3, -1, 2.5, 'a', -5, 0, 7])\n# print(result)  # Output should be (-1, 3)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    This function takes a list of mixed data types and returns a tuple (a, b),\n    where 'a' is the largest negative integer and 'b' is the smallest positive integer.\n    If there are no negative or positive integers, it returns None for those values.\n\n    Parameters:\n    lst (list): A list containing mixed data types.\n\n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest positive integer,\n           or None if not applicable.\n    \"\"\"\n    largest_negative = None\n    smallest_positive = None\n\n    for item in lst:\n        if isinstance(item, int):\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    Finds the largest negative integer and the smallest positive integer in a list.\n\n    Args:\n        lst (list): A list containing mixed data types.\n\n    Returns:\n        tuple: A tuple (a, b) where 'a' is the largest negative integer and 'b' is the smallest positive integer.\n               Returns None for 'a' or 'b' if no such integers exist.\n    \"\"\"\n    largest_negative = None\n    smallest_positive = None\n\n    for item in lst:\n        if isinstance(item, int):\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n\n    return (largest_negative, smallest_positive)\n", "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    Function to return a tuple (a, b), where 'a' is the largest negative integer and 'b' is the smallest positive integer.\n    \n    Parameters:\n    lst (list): A list containing mixed data types.\n    \n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest positive integer, or None if not present.\n    \"\"\"\n    # Initialize variables to store the largest negative and smallest positive integers\n    largest_negative = None\n    smallest_positive = None\n    \n    # Iterate through the list to filter integers and identify the required values\n    for item in lst:\n        if isinstance(item, int):  # Check if the item is an integer\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n    \n    return (largest_negative, smallest_positive)\n"], "plans": ["requirement analysis:\nThe function must handle lists with mixed data types, returning a tuple with the largest negative and smallest positive integers. It should return None for either if not present. The function should be efficient and handle edge cases like empty lists or lists with no integers.\nrequirement pool:\n- Handle mixed data types in input lists\n- Return None for missing negative or positive integers\n- Optimize performance for large lists\n- Ensure accurate results for edge cases\n- Provide clear documentation\nWe will implement a function that iterates through the list, filtering out non-integer types. It will then find the largest negative integer and the smallest positive integer. The function will handle edge cases such as empty lists or lists without any integers by returning None for missing values. We will use Python's built-in capabilities to ensure efficient performance even with large lists.\n", "requirement analysis:\nThe function must handle lists with mixed data types, returning the largest negative and smallest positive integers. It should return None if no such integers exist. The function should be efficient and handle edge cases like empty lists or lists with no integers.\nrequirement pool:\n- Handle mixed data types in input lists\n- Return None for missing negative or positive integers\n- Optimize performance for large input lists\n- Provide clear documentation and examples\n- Include comprehensive test cases for edge scenarios\nWe will implement a function that iterates through the list, filtering out non-integer types and then determining the largest negative and smallest positive integers. We will use Python's built-in capabilities to handle the list operations efficiently. The function will handle edge cases such as empty lists and lists without integers by returning None for missing values.\n", "requirement analysis:\nThe function must handle lists with mixed data types, returning a tuple with the largest negative and smallest positive integers. If no such integers exist, it should return None for that position. The function should be efficient and handle edge cases like empty lists or lists with no integers.\nrequirement pool:\n- Handle mixed data types gracefully\n- Return None for missing negative or positive integers\n- Optimize performance for large lists\n- Provide clear documentation and examples\n- Include unit tests for edge cases\nWe will implement a function that iterates through the list, filtering out non-integer types and then determining the largest negative and smallest positive integers. The function will handle edge cases such as empty lists and lists without any integers. We will use Python's built-in capabilities to ensure efficient performance.\n", "requirement analysis:\nThe function must handle lists with mixed data types, returning a tuple with the largest negative and smallest positive integers. If no such integers exist, it should return None for that position. The function should be optimized for performance and provide clear documentation.\nrequirement pool:\n- Handle mixed data types gracefully\n- Return correct results for empty and single-element lists\n- Optimize performance for large lists\n- Provide clear documentation and examples\n- Include error handling for invalid inputs\nWe will create a function that iterates through the list, filtering out non-integer types and then determining the largest negative and smallest positive integers. We will use Python's built-in capabilities to handle the list operations efficiently. The function will handle edge cases such as empty lists and lists with no negative or positive integers by returning None for those cases.\n", "requirement analysis:\nThe function must handle lists with mixed data types, returning a tuple with the largest negative and smallest positive integers. It should return None for either if not present. The function should be efficient and handle edge cases like empty lists or lists with no integers.\nrequirement pool:\n- Handle mixed data types in input lists\n- Return None for missing negative or positive integers\n- Optimize performance for large input lists\n- Provide clear documentation and examples\n- Include unit tests for edge cases\nWe will use Python's built-in functions to filter and find the largest negative and smallest positive integers. The function will iterate over the list once, ensuring efficiency even for large lists. We will handle mixed data types by checking if elements are integers before processing them. Non-integer numeric types like floats will be ignored as per the requirement to focus on integers only.\n", "requirement analysis:\nThe function must handle lists with mixed data types, including integers, floats, and other non-numeric types. It should correctly identify the largest negative and smallest positive integers, returning None if they do not exist. Performance should be optimized for large lists.\nrequirement pool:\n- Handle mixed data types in input lists\n- Return None for missing negative or positive integers\n- Optimize performance for large input lists\n- Ensure correct handling of edge cases\n- Provide detailed error messages for invalid inputs\nWe will create a function that iterates through the list, filtering out non-integer types. It will then find the largest negative integer and the smallest positive integer. If no such integers exist, it will return None for those values. The function will handle large lists efficiently by using a single pass to determine the required values.\n", "requirement analysis:\nThe function must handle lists with mixed data types, returning the largest negative and smallest positive integers. It should return None for missing values and perform efficiently with large lists.\nrequirement pool:\n- Handle mixed data types gracefully\n- Return None for missing negative or positive integers\n- Optimize performance for large lists\n- Provide clear documentation and examples\n- Include error handling for invalid inputs\nWe will implement a function that iterates through the list, filtering out non-integer types. It will then find the largest negative integer and the smallest positive integer. The function will handle empty lists and lists without negative or positive integers by returning None for those cases. We will use Python's built-in functions to ensure optimal performance.\n", "requirement analysis:\nThe function must handle lists with mixed data types, returning the largest negative and smallest positive integers. It should return None for missing values and handle edge cases like empty lists or lists with no integers.\nrequirement pool:\n- Handle mixed data types in input lists\n- Return None for missing negative or positive integers\n- Optimize performance for large lists\n- Provide clear documentation and examples\n- Include comprehensive test cases for edge scenarios\nWe will create a function that iterates through the list, filtering out non-integer types. It will then find the largest negative integer and the smallest positive integer. The function will handle edge cases such as empty lists or lists without any integers by returning None for missing values. We will use Python's built-in functions to ensure optimal performance.\n", "requirement analysis:\nThe function must handle lists with mixed data types, returning the largest negative and smallest positive integers. If no such integers exist, it should return None. The function should be optimized for performance and provide clear, accurate results.\nrequirement pool:\n- Handle mixed data types gracefully\n- Return None for missing negative or positive integers\n- Optimize performance for large lists\n- Provide clear documentation and examples\n- Include comprehensive test cases\nWe will use Python's built-in functions to filter and find the largest negative and smallest positive integers. The function will iterate over the list once, ensuring optimal performance even for large lists. We will handle mixed data types by checking if each element is an integer before processing it.\n", "requirement analysis:\nThe function should accurately identify the largest negative integer and the smallest positive integer from a list, handling mixed data types gracefully. It should return None for either if not present, ensuring robust performance and clear results.\nrequirement pool:\n- Handle mixed data types gracefully\n- Return None when no negative or positive integers are present\n- Optimize performance for large lists\n- Ensure accurate results\n- Provide clear documentation\nWe will implement a function that iterates through the list, filtering out non-integer types and then identifying the largest negative integer and the smallest positive integer. We will use Python's built-in functions to ensure optimal performance and handle edge cases gracefully.\n"], "scores": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], "pass_results": [true, true, true, true, true, true, true, true, true, true], "pass_test_cases_num": [124, 124, 124, 124, 124, 124, 124, 124, 124, 124], "completion": "from typing import List\n## main.py\n\ndef largest_smallest_integers(lst: list) -> tuple:\n    \"\"\"\n    Function to return a tuple (a, b), where 'a' is the largest negative integer and 'b' is the smallest positive integer.\n    \n    Parameters:\n    lst (list): A list containing mixed data types.\n    \n    Returns:\n    tuple: A tuple containing the largest negative integer and the smallest positive integer, or None if not present.\n    \"\"\"\n    # Initialize variables to store the largest negative and smallest positive integers\n    largest_negative = None\n    smallest_positive = None\n    \n    # Iterate through the list to filter integers and identify the required values\n    for item in lst:\n        if isinstance(item, int):  # Check if the item is an integer\n            if item < 0:\n                if largest_negative is None or item > largest_negative:\n                    largest_negative = item\n            elif item > 0:\n                if smallest_positive is None or item < smallest_positive:\n                    smallest_positive = item\n    \n    return (largest_negative, smallest_positive)\n", "passed": true, "pass": true, "pass_num": 10, "round": 768, "mutate_method": "add_1_sentence_at_end", "parent_index": 112}
