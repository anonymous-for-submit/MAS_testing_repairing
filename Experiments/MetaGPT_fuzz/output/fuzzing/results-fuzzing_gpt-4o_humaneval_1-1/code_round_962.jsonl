{"task_id": "HumanEval/55", "prompt": "def fib(n: int):\t\n'''Return n-th Fibonacci number. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones.\n>>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    '''", "entry_point": "fib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "test": ["def check(fib):\n\tassert fib(29) == 514229", "def check(fib):\n\tassert fib(25) == 75025", "def check(fib):\n\tassert fib(34) == 5702887", "def check(fib):\n\tassert fib(7) == 13", "def check(fib):\n\tassert fib(32) == 2178309", "def check(fib):\n\tassert fib(27) == 196418", "def check(fib):\n\tassert fib(16) == 987", "def check(fib):\n\tassert fib(14) == 377", "def check(fib):\n\tassert fib(33) == 3524578", "def check(fib):\n\tassert fib(20) == 6765", "def check(fib):\n\tassert fib(8) == 21", "def check(fib):\n\tassert fib(31) == 1346269", "def check(fib):\n\tassert fib(6) == 8", "def check(fib):\n\tassert fib(17) == 1597", "def check(fib):\n\tassert fib(2) == 1", "def check(fib):\n\tassert fib(1) == 1", "def check(fib):\n\tassert fib(30) == 832040", "def check(fib):\n\tassert fib(11) == 89", "def check(fib):\n\tassert fib(3) == 2", "def check(fib):\n\tassert fib(19) == 4181", "def check(fib):\n\tassert fib(21) == 10946", "def check(fib):\n\tassert fib(4) == 3", "def check(fib):\n\tassert fib(10) == 55", "def check(fib):\n\tassert fib(12) == 144", "def check(fib):\n\tassert fib(9) == 34", "def check(fib):\n\tassert fib(13) == 233", "def check(fib):\n\tassert fib(0) == 0", "def check(fib):\n\tassert fib(15) == 610", "def check(fib):\n\tassert fib(22) == 17711", "def check(fib):\n\tassert fib(24) == 46368", "def check(fib):\n\tassert fib(18) == 2584", "def check(fib):\n\tassert fib(28) == 317811", "def check(fib):\n\tassert fib(35) == 9227465"], "test_case_list": ["assert fib(29) == 514229", "assert fib(25) == 75025", "assert fib(34) == 5702887", "assert fib(7) == 13", "assert fib(32) == 2178309", "assert fib(27) == 196418", "assert fib(16) == 987", "assert fib(14) == 377", "assert fib(33) == 3524578", "assert fib(20) == 6765", "assert fib(8) == 21", "assert fib(31) == 1346269", "assert fib(6) == 8", "assert fib(17) == 1597", "assert fib(2) == 1", "assert fib(1) == 1", "assert fib(30) == 832040", "assert fib(11) == 89", "assert fib(3) == 2", "assert fib(19) == 4181", "assert fib(21) == 10946", "assert fib(4) == 3", "assert fib(10) == 55", "assert fib(12) == 144", "assert fib(9) == 34", "assert fib(13) == 233", "assert fib(0) == 0", "assert fib(15) == 610", "assert fib(22) == 17711", "assert fib(24) == 46368", "assert fib(18) == 2584", "assert fib(28) == 317811", "assert fib(35) == 9227465"], "nl": "Return n-th Fibonacci number.\n    ", "func": "def fib(n: int):", "examples": ">>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    ", "repair_prompt": ["def fib(n: int):\t\n'''Return n-th Fibonacci number. The Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones.\n>>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach with memoization.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (0-indexed).\n        \n    Returns:\n        int: The n-th Fibonacci number.\n        \n    Raises:\n        ValueError: If the input is a negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input cannot be negative. Fibonacci sequence is not defined for negative indices.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize memoization array\n    fib_numbers = [0] * (n + 1)\n    fib_numbers[0] = 0\n    fib_numbers[1] = 1\n    \n    # Iteratively compute Fibonacci numbers\n    for i in range(2, n + 1):\n        fib_numbers[i] = fib_numbers[i - 1] + fib_numbers[i - 2]\n    \n    return fib_numbers[n]\n\n# Example usage:\n# print(fib(10))  # Output: 55\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (1-indexed).\n        \n    Returns:\n        int: The n-th Fibonacci number.\n        \n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    \n    # Base cases\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Iterative calculation\n    prev, curr = 0, 1\n    for _ in range(3, n + 1):\n        prev, curr = curr, prev + curr\n    \n    return curr\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the usage of the fib function.\n    \"\"\"\n    try:\n        n = int(input(): \"))\n        result = fib(n)\n        print(f\"The {n}-th Fibonacci number is: {result}\")\n    except ValueError as e:\n        print(e)\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (1-indexed).\n        \n    Returns:\n        int: The n-th Fibonacci number.\n        \n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Base cases\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Iterative calculation\n    prev, curr = 0, 1\n    for _ in range(2, n):\n        prev, curr = curr, prev + curr\n    \n    return curr\n\n# Example usage:\n# To get the 10th Fibonacci number, call fib(10)\n# print(fib(10))  # Output: 34\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach with memoization.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence to calculate.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n\n    Example:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize memoization array with base cases\n    memo = [0, 1]\n\n    # Calculate Fibonacci numbers iteratively\n    for i in range(2, n + 1):\n        memo.append(memo[i - 1] + memo[i - 2])\n\n    return memo[n]\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        print(fib(10))  # Output: 55\n        print(fib(1))   # Output: 1\n        print(fib(8))   # Output: 21\n    except ValueError as e:\n        print(e)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n\n    Args:\n        n (int): Position in Fibonacci sequence (must be a non-negative integer).\n\n    Returns:\n        int: n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is negative or not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n\ndef main():\n    \"\"\"\n    Main function to demonstrate the usage of the fib function.\n    \"\"\"\n    try:\n        n = int(input())\n        result = fib(n)\n        print(f\"The {n}-th Fibonacci number is: {result}\")\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n", "from typing import List\n## main.py\n\nfrom functools import lru_cache\n\ndef fib(n: int) -> int:\n    \"\"\"Calculate the n-th Fibonacci number using memoization for efficiency.\n\n    Args:\n        n (int): The position in the Fibonacci sequence (must be a positive integer).\n\n    Returns:\n        int: The n-th Fibonacci number.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    @lru_cache(maxsize=None)\n    def fibonacci_memoized(k: int) -> int:\n        \"\"\"Helper function to calculate Fibonacci number using memoization.\n\n        Args:\n            k (int): The position in the Fibonacci sequence.\n\n        Returns:\n            int: The k-th Fibonacci number.\n        \"\"\"\n        if k == 1:\n            return 0\n        elif k == 2:\n            return 1\n        else:\n            return fibonacci_memoized(k - 1) + fibonacci_memoized(k - 2)\n\n    return fibonacci_memoized(n)\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach.\n    \n    Args:\n        n (int): The position in the Fibonacci sequence (1-indexed).\n        \n    Returns:\n        int: The n-th Fibonacci number.\n        \n    Raises:\n        ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Base cases\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Iterative calculation\n    prev, curr = 0, 1\n    for _ in range(3, n + 1):\n        prev, curr = curr, prev + curr\n    \n    return curr\n\n# Example usage:\n# print(fib(10))  # Output: 34\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"Calculate the n-th Fibonacci number using an iterative approach.\n\n    This function computes the Fibonacci sequence iteratively to optimize\n    performance for large input values. It avoids the overhead of recursive\n    calls and potential stack overflow issues.\n\n    Args:\n        n (int): The position in the Fibonacci sequence.\n\n    Returns:\n        int: The n-th Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n\n    prev, curr = 0, 1\n    for _ in range(2, n):\n        prev, curr = curr, prev + curr\n\n    return curr\n\n# Example usage:\n# print(fib(10))  # Output: 34\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach with memoization.\n\n    Parameters:\n    n (int): The position in the Fibonacci sequence to calculate.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    # Initialize memoization list\n    memo = [0] * (n + 1)\n    memo[0], memo[1] = 0, 1\n\n    # Iterate to compute Fibonacci numbers\n    for i in range(2, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2]\n\n    return memo[n]\n\n# Example usage\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n", "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach with memoization.\n    \n    Parameters:\n    n (int): The position in the Fibonacci sequence to compute.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n\n    # Initialize the base cases\n    prev, curr = 1, 1\n\n    # Iteratively compute the Fibonacci sequence up to the n-th number\n    for _ in range(3, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n"], "plans": ["requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1, and be optimized for larger values of n to prevent performance issues.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Provide comprehensive documentation and examples\n- Create a user-friendly interface for the function\n- Ensure compatibility with other systems and projects\nWe will implement the Fibonacci calculation using an iterative approach to optimize performance for large input values. This approach avoids the overhead of recursive function calls and is more efficient in terms of time complexity. We will also use memoization to store previously computed Fibonacci numbers to further enhance performance.\n", "requirement analysis:\nThe requirement is to implement a function that returns the n-th Fibonacci number. The function should be efficient and handle large values of n. It should also include examples to demonstrate its usage.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance\n- Include usage examples in the documentation\n- Provide a user-friendly interface\n- Ensure compatibility with mobile devices\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to optimize performance for large input values. This approach avoids the overhead of recursive function calls and reduces the time complexity to O(n). We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle edge cases such as small and large values of n and provide accurate results. The user interface should be intuitive, allowing users to easily input values and understand the output.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Design a user-friendly interface for input and output\n- Provide educational content on the Fibonacci sequence\n- Include example calculations for user reference\nWe will implement a function to compute the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task.\n", "requirement analysis:\nThe function should accurately compute the Fibonacci number for any integer input, ensuring performance optimization for large numbers and providing clear documentation for user understanding.\nrequirement pool:\n- Accurate Fibonacci calculation\n- Performance optimization for large inputs\n- Clear documentation\n- User-friendly interface\n- Support for additional sequence types\nWe will implement a function to calculate the n-th Fibonacci number using an iterative approach to optimize performance for large inputs. This approach avoids the overhead of recursive calls and stack overflow issues. We will also use memoization to store previously computed Fibonacci numbers to further enhance performance. The function will be well-documented to ensure clarity and understanding of the Fibonacci sequence generation.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1 correctly. The implementation should be optimized for performance, especially for large values of n.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for large input values\n- Provide comprehensive documentation and examples\n- Include error handling for invalid inputs\n- Create a user-friendly interface for demonstration\nWe will implement the Fibonacci calculation using an iterative approach to optimize performance for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities without external libraries, ensuring simplicity and efficiency. Comprehensive documentation will be provided to explain the function's usage and edge cases handling.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle both small and large input values and provide accurate results. The user interface should be intuitive, allowing users to easily input a number and receive the corresponding Fibonacci number.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Design a user-friendly interface for input and output\n- Optimize the function for performance with large numbers\n- Provide educational content on the Fibonacci sequence\n- Include example calculations for user reference\nWe will implement an efficient Fibonacci calculation function using memoization to optimize performance for large input values. The function will be simple and will not handle negative or non-integer inputs, as these are not typically part of the Fibonacci sequence. We will use Python's built-in capabilities to achieve this.\n", "requirement analysis:\nThe requirement is to develop a function that computes the n-th Fibonacci number efficiently. The function should handle edge cases such as small and large input values and provide accurate results. Additionally, the function should be easy to understand and maintain.\nrequirement pool:\n- Implement the Fibonacci calculation function\n- Optimize the function for performance with large inputs\n- Create a user-friendly interface for input and output\n- Provide educational content about the Fibonacci sequence\n- Ensure compatibility with mobile devices\nWe will implement a function to compute the n-th Fibonacci number using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will use Python's built-in capabilities without additional libraries, as they are sufficient for this task.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1, and be optimized for larger values of n to ensure quick computation.\nrequirement pool:\n- Implement the Fibonacci calculation algorithm\n- Optimize for large input values\n- Provide detailed documentation\n- Ensure code readability and maintainability\n- Include examples and edge case handling\nWe will implement the Fibonacci calculation using an iterative approach to optimize performance for large input values. This approach avoids the overhead of recursive calls and stack overflow issues. We will use Python's built-in capabilities to handle large integers efficiently.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should handle edge cases such as n=0 and n=1, and be optimized for larger values of n to ensure quick computation.\nrequirement pool:\n- Implement the Fibonacci calculation algorithm\n- Optimize the function for large input values\n- Provide examples and documentation\n- Ensure the function handles edge cases\n- Consider user interface for input and output\nWe will implement the Fibonacci calculation using an iterative approach to ensure efficiency, especially for large input values. This approach avoids the overhead of recursive function calls and stack overflow issues. We will also use memoization to store previously computed Fibonacci numbers to further optimize performance. The function will handle edge cases such as n=0 and n=1. We will provide clear documentation and examples to illustrate usage.\n", "requirement analysis:\nThe function should accurately compute the n-th Fibonacci number using an efficient algorithm. It should be easy to understand and maintain, with clear documentation. Performance optimization is crucial for handling large inputs.\nrequirement pool:\n- Implement the Fibonacci calculation algorithm\n- Optimize the algorithm for large inputs\n- Provide comprehensive documentation\n- Ensure the function is easy to understand\n- Test the function for various edge cases\nWe will implement the Fibonacci calculation using an iterative approach to optimize performance for large inputs. This approach avoids the overhead of recursive function calls and reduces the time complexity to O(n). We will also use memoization to store previously computed Fibonacci numbers to further enhance performance. The function will be documented clearly with examples to ensure ease of understanding.\n"], "scores": [1.0, 0.0, 0.0303, 0.9697, 1.0, 0.0303, 0.0303, 0.0303, 1.0, 0.9697], "pass_results": [true, false, false, false, true, false, false, false, true, false], "pass_test_cases_num": [33, 0, 1, 32, 33, 1, 1, 1, 33, 32], "completion": "from typing import List\n## main.py\n\ndef fib(n: int) -> int:\n    \"\"\"\n    Calculate the n-th Fibonacci number using an iterative approach with memoization.\n    \n    Parameters:\n    n (int): The position in the Fibonacci sequence to compute.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Examples:\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n\n    # Initialize the base cases\n    prev, curr = 1, 1\n\n    # Iteratively compute the Fibonacci sequence up to the n-th number\n    for _ in range(3, n + 1):\n        prev, curr = curr, prev + curr\n\n    return curr\n", "passed": true, "pass": true, "pass_num": 3, "round": 962, "mutate_method": "add_1_sentence_at_end", "parent_index": 255}
