{"task_id": "HumanEval/160", "prompt": "def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebric expression and return the evaluation of this expression. The basic algebra operations: Addition ( + ), Subtraction ( - ), Multiplication ( * ), Floor division ( // ), Exponentiation ( ** ).\nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": ["def check(do_algebra):\n\tassert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [8, 8, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [5, 1, 6]) == 5", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [12, 1, 6]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [2, 5, 7]) == 17", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [2, 3, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [6, 2, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [8, 2, 7]) == -120", "def check(do_algebra):\n\tassert do_algebra(['//', '**'], [4, 4, 4]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [5, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 2, 7]) == 71", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [9, 3, 8]) == 35", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "def check(do_algebra):\n\tassert do_algebra(['*', '-'], [6, 5, 7]) == 23", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "def check(do_algebra):\n\tassert do_algebra(['-', '*'], [3, 3, 6]) == -15", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 5, 2]) == -22", "def check(do_algebra):\n\tassert do_algebra(['+', '*'], [7, 3, 6]) == 25", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [3, 2, 8]) == 768", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [7, 3, 3]) == 189", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [8, 4, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [8, 2, 2]) == 128", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [3, 4, 4]) == 3", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [10, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [7, 3, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '-'], [6, 1, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [3, 7, 6]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "def check(do_algebra):\n\tassert do_algebra(['*', '*'], [5, 2, 7]) == 70", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 3, 4]) == -78", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [2, 7, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [10, 2, 8]) == 800", "def check(do_algebra):\n\tassert do_algebra(['+', '//'], [3, 6, 4]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 3, 5]) == 250", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [7, 3, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [3, 2, 4]) == 19", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "def check(do_algebra):\n\tassert do_algebra(['**', '-'], [3, 2, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "def check(do_algebra):\n\tassert do_algebra(['+', '+'], [4, 4, 1]) == 9", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [10, 7, 1]) == 4", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [8, 4, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [4, 8, 4]) == 36", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "test_case_list": ["assert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "assert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "assert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "assert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "assert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "assert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "assert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "assert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "assert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "assert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "assert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "assert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "assert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "assert do_algebra(['//', '//'], [8, 8, 7]) == 0", "assert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "assert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "assert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "assert do_algebra(['*', '**'], [5, 1, 6]) == 5", "assert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "assert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "assert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "assert do_algebra(['**', '//'], [12, 1, 6]) == 2", "assert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "assert do_algebra(['*', '+'], [2, 5, 7]) == 17", "assert do_algebra(['**', '*'], [2, 3, 1]) == 8", "assert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "assert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "assert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "assert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "assert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "assert do_algebra(['-', '**'], [6, 2, 2]) == 2", "assert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "assert do_algebra(['-', '**'], [8, 2, 7]) == -120", "assert do_algebra(['//', '**'], [4, 4, 4]) == 0", "assert do_algebra(['-', '//'], [5, 3, 8]) == 5", "assert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "assert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "assert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "assert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "assert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "assert do_algebra(['**', '+'], [8, 2, 7]) == 71", "assert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "assert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "assert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "assert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "assert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "assert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "assert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "assert do_algebra(['*', '+'], [9, 3, 8]) == 35", "assert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "assert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "assert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "assert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "assert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "assert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "assert do_algebra(['*', '-'], [6, 5, 7]) == 23", "assert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "assert do_algebra(['-', '*'], [3, 3, 6]) == -15", "assert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "assert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "assert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "assert do_algebra(['-', '**'], [3, 5, 2]) == -22", "assert do_algebra(['+', '*'], [7, 3, 6]) == 25", "assert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "assert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "assert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "assert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "assert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "assert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "assert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "assert do_algebra(['*', '**'], [3, 2, 8]) == 768", "assert do_algebra(['*', '**'], [7, 3, 3]) == 189", "assert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "assert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "assert do_algebra(['-', '+'], [8, 4, 3]) == 7", "assert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "assert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "assert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "assert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "assert do_algebra(['**', '*'], [8, 2, 2]) == 128", "assert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "assert do_algebra(['-', '+'], [3, 4, 4]) == 3", "assert do_algebra(['+', '-'], [10, 3, 8]) == 5", "assert do_algebra(['//', '*'], [7, 3, 4]) == 8", "assert do_algebra(['//', '-'], [6, 1, 2]) == 4", "assert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "assert do_algebra(['+', '-'], [3, 7, 6]) == 4", "assert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "assert do_algebra(['*', '*'], [5, 2, 7]) == 70", "assert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "assert do_algebra(['-', '**'], [3, 3, 4]) == -78", "assert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "assert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "assert do_algebra(['//', '//'], [2, 7, 1]) == 0", "assert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "assert do_algebra(['**', '*'], [10, 2, 8]) == 800", "assert do_algebra(['+', '//'], [3, 6, 4]) == 4", "assert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "assert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "assert do_algebra(['+', '**'], [7, 3, 5]) == 250", "assert do_algebra(['-', '//'], [7, 3, 2]) == 6", "assert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "assert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "assert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "assert do_algebra(['+', '**'], [3, 2, 4]) == 19", "assert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "assert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "assert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "assert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "assert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "assert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "assert do_algebra(['**', '-'], [3, 2, 9]) == 0", "assert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "assert do_algebra(['+', '+'], [4, 4, 1]) == 9", "assert do_algebra(['-', '+'], [10, 7, 1]) == 4", "assert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "assert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "assert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "assert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "assert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "assert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "assert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "assert do_algebra(['//', '*'], [8, 4, 2]) == 4", "assert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "assert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "assert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "assert do_algebra(['*', '+'], [4, 8, 4]) == 36", "assert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "nl": "\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    ", "func": "def do_algebra(operator, operand):", "examples": "Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    ", "repair_prompt": ["def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list has basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebric expression and return the evaluation of this expression. The basic algebra operations: Addition ( + ), Subtraction ( - ), Multiplication ( * ), Floor division ( // ), Exponentiation ( ** ).\nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''"], "completions": ["from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Constructs and evaluates an algebraic expression from the given operators and operands.\n\n    Parameters:\n    operator (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the specified requirements.\n    \"\"\"\n    # Validate input lists\n    if not operator or not operand:\n        raise ValueError(\"Operator and operand lists must not be empty.\")\n    \n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    valid_operators = {'+', '-', '*', '//', '**'}\n    for op in operator:\n        if op not in valid_operators:\n            raise ValueError(f\"Unsupported operator: {op}\")\n\n    # Construct expression string\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        expression += f\" {op} {operand[i + 1]}\"\n\n    # Evaluate expression using eval\n    try:\n        # Using eval safely by ensuring only valid operators and operands are used\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ValueError(\"Division by zero is not allowed.\")\n    except Exception as e:\n        raise ValueError(f\"An error occurred during evaluation: {e}\")\n\n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Constructs and evaluates an algebraic expression from the given operators and operands.\n    \n    Args:\n        operator: List of algebraic operators as strings ('+', '-', '*', '//', '**').\n        operand: List of integers to be used in the expression.\n    \n    Returns:\n        The result of the evaluated expression as an integer.\n    \n    Raises:\n        ValueError: If the number of operators is not one less than the number of operands.\n        ValueError: If an invalid operator is provided.\n    \"\"\"\n    # Validate input lengths\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Validate operators\n    valid_operators = {'+', '-', '*', '//', '**'}\n    for op in operator:\n        if op not in valid_operators:\n            raise ValueError(f\"Invalid operator: {op}\")\n    \n    # Construct the expression string\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        expression += f\" {op} {operand[i + 1]}\"\n    \n    # Evaluate the expression\n    try:\n        result = eval(expression)\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {e}\")\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers to be used in the expression.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Define a mapping from operator strings to functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Validate input\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate through operators and operands to compute the result\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        \n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of algebraic operators as strings ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \n    Raises:\n    ValueError: If the operators and operands lists are not of compatible lengths.\n    ZeroDivisionError: If a division by zero is attempted.\n    \"\"\"\n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Validate input lengths\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate over operators and operands to evaluate the expression\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Invalid operator: {op}\")\n        \n        # Get the corresponding function for the operator\n        operation = operator_map[op]\n        \n        # Perform the operation and update the result\n        try:\n            result = operation(result, operands[i + 1])\n        except ZeroDivisionError:\n            raise ZeroDivisionError(\"Division by zero is not allowed.\")\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n\n    Parameters:\n    operators (list of str): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operands (list of int): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    if not operands:\n        raise ValueError(\"Operands list cannot be empty.\")\n    \n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate over operators and operands to evaluate the expression\n    for i, operator in enumerate(operators):\n        if operator not in ['+', '-', '*', '//', '**']:\n            raise ValueError(f\"Unsupported operator: {operator}\")\n        \n        if operator == '//':\n            if operands[i + 1] == 0:\n                raise ZeroDivisionError(\"Division by zero is not allowed.\")\n        \n        # Perform the operation based on the current operator\n        if operator == '+':\n            result += operands[i + 1]\n        elif operator == '-':\n            result -= operands[i + 1]\n        elif operator == '*':\n            result *= operands[i + 1]\n        elif operator == '//':\n            result //= operands[i + 1]\n        elif operator == '**':\n            result **= operands[i + 1]\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of algebraic operators as strings.\n    operands (list[int]): A list of integers to be used as operands.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \n    Raises:\n    ValueError: If the input lists do not meet the required conditions.\n    \"\"\"\n    \n    # Validate input lists\n    if not operators or not operands:\n        raise ValueError(\"Operators and operands lists cannot be empty.\")\n    \n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Mapping of string operators to functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '/': operator.truediv,\n        '%': operator.mod,\n        '**': operator.pow\n    }\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Construct and evaluate the expression\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        \n        # Get the corresponding function for the operator\n        operation = operator_map[op]\n        \n        # Perform the operation\n        result = operation(result, operands[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers representing the operands.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    \n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate through the operators and operands\n    for i, op in enumerate(operators):\n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers to be used in the expression.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    \n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Basic error checking\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate through operators and operands to compute the result\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Invalid operator: {op}\")\n        \n        # Check for division by zero\n        if op == '//' and operands[i + 1] == 0:\n            raise ZeroDivisionError(\"Division by zero is not allowed.\")\n        \n        # Apply the operator\n        result = operator_map[op](result, operands[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n    \n    Parameters:\n    operators (List[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (List[int]): A list of integers to be used in the expression.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Validate input\n    if not operands or len(operators) != len(operands) - 1:\n        raise ValueError(\"Invalid input: The number of operators must be one less than the number of operands.\")\n    \n    # Initialize the result with the first operand\n    result = operands[0]\n    \n    # Iterate through operators and operands to compute the result\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        \n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n    \n    return result\n\n# Example usage:\n# result = do_algebra(['+', '*', '-'], [3, 5, 2, 4])\n# print(result)  # Output should be 13\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the specified conditions.\n    \"\"\"\n    # Validate input\n    if not operands or len(operators) != len(operands) - 1:\n        raise ValueError(\"Invalid input: The number of operators must be one less than the number of operands.\")\n    \n    valid_operators = {'+', '-', '*', '//', '**'}\n    \n    for op in operators:\n        if op not in valid_operators:\n            raise ValueError(f\"Invalid operator: {op}. Allowed operators are {valid_operators}.\")\n\n    # Construct the expression\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        expression += f\" {operator} {operands[i + 1]}\"\n    \n    # Evaluate the expression\n    try:\n        result = eval(expression)\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {e}\")\n\n    return result\n"], "plans": ["requirement analysis:\nThe function should accurately compute algebraic expressions using provided operators and operands. It must handle basic operations and ensure the input lists are correctly formatted. Performance optimization is crucial for handling large lists.\nrequirement pool:\n- Implement basic algebraic operations\n- Ensure input validation for operators and operands\n- Optimize performance for large input lists\n- Provide clear error messages for invalid inputs\n- Develop intuitive UI for user input\nWe will implement a function that constructs and evaluates an algebraic expression from two lists: one containing operators and the other containing operands. The function will validate inputs to ensure they meet the specified requirements. We will use Python's built-in eval function to evaluate the expression, ensuring that the input is sanitized to prevent security risks. The function will handle basic operations: addition, subtraction, multiplication, floor division, and exponentiation. We will also include error handling to provide clear messages for invalid inputs.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently.\nrequirement pool:\n- Implement the main function to evaluate expressions using operators and operands.\n- Develop a user interface for inputting operators and operands.\n- Ensure the function handles edge cases, such as division by zero.\n- Provide detailed error messages for invalid inputs.\n- Optimize the function for performance with large input sizes.\nWe will implement a function that constructs and evaluates an algebraic expression from two lists: one containing operators and the other containing operands. The function will ensure the correct order of operations is applied. We will use Python's built-in eval function to evaluate the expression string, which will be constructed by iterating over the operators and operands. This approach is simple and leverages Python's capabilities to handle operator precedence.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The user interface should be intuitive, allowing easy input and correction of data.\nrequirement pool:\n- Implement the core algebraic expression evaluation logic.\n- Design a user-friendly interface for inputting data.\n- Ensure the application handles large numbers and complex expressions efficiently.\n- Provide detailed feedback on the order of operations applied.\n- Allow users to easily correct their input.\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operators in the correct order. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring correct order of operations. The function will handle basic error checking for input validation.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently.\nrequirement pool:\n- Implement the main function to evaluate expressions using operators and operands.\n- Ensure the function handles edge cases, such as division by zero.\n- Create a user-friendly interface for inputting data.\n- Optimize the function for performance with large input sizes.\n- Provide detailed error messages for invalid inputs.\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression from these lists and evaluate it. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring correct order of operations. The function will handle basic error checking, such as ensuring the lists are of appropriate lengths and handling division by zero.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The input constraints ensure that the function will always have a valid expression to evaluate.\nrequirement pool:\n- Implement the main function to evaluate expressions using given operators and operands.\n- Ensure the function handles all specified operations correctly.\n- Optimize the function for performance with large input sizes.\n- Create a user-friendly interface for inputting data.\n- Provide clear documentation and examples for users.\nWe will implement a function that iteratively constructs and evaluates the algebraic expression using the provided operators and operands. The function will respect the order of operations by evaluating the expression from left to right, as the operators are given in sequence. We will use Python's built-in capabilities to handle arithmetic operations efficiently.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle basic operations and ensure the input lists are of appropriate lengths. The solution should be efficient and provide clear feedback for incorrect inputs.\nrequirement pool:\n- Implement the main algebra evaluation function\n- Develop a user-friendly interface for input\n- Ensure performance optimization for large inputs\n- Provide detailed error messages for invalid inputs\n- Include step-by-step evaluation explanation\nWe will implement a function that evaluates an algebraic expression based on two lists: one containing operators and the other containing operands. The function will validate the input lists to ensure they meet the requirements, then construct and evaluate the expression using Python's built-in capabilities. We will use the 'operator' module to map string operators to their corresponding functions for efficient evaluation. This approach ensures clarity and performance, especially with large numbers.\n", "requirement analysis:\nThe requirement is to create a function that evaluates an algebraic expression based on a list of operators and operands. The function should handle basic operations like addition, subtraction, multiplication, floor division, and exponentiation. The challenge is to ensure the correct order of operations and provide a clear result.\nrequirement pool:\n- Implement the main function to evaluate expressions\n- Develop a user interface for inputting operators and operands\n- Ensure the function handles edge cases like division by zero\n- Provide a step-by-step explanation of the evaluation process\n- Optimize the function for performance\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct the algebraic expression by iterating through the lists and applying the operations in the correct order. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring correct evaluation of the expression.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently.\nrequirement pool:\n- Implement the core function to evaluate expressions using operators and operands\n- Design a simple UI for inputting operators and operands\n- Ensure the function handles edge cases, such as division by zero\n- Provide detailed error messages for invalid inputs\n- Optimize the function for performance with large input sizes\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct the algebraic expression by iterating through the lists and applying the operators in the correct order. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring correct order of operations. The function will handle basic error checking, such as ensuring the lists are of appropriate lengths and that division by zero is avoided.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The user interface should be intuitive, allowing users to input data easily and see results quickly.\nrequirement pool:\n- Implement the main algebra evaluation function\n- Design a user-friendly interface for input\n- Optimize the function for performance\n- Add error handling for invalid inputs\n- Provide a detailed explanation of the evaluation process\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operators in sequence to the operands. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring correct order of operations. This approach will be efficient and straightforward, leveraging Python's built-in capabilities for handling arithmetic operations.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle various operations and ensure the order of operations is respected. The input validation is crucial to prevent errors and ensure the lists meet the specified conditions.\nrequirement pool:\n- Implement the main algebraic evaluation function\n- Develop a user interface for inputting operators and operands\n- Ensure the function handles large numbers efficiently\n- Provide clear error messages for invalid inputs\n- Optimize performance for quick computation\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operators in sequence. We will use Python's built-in eval function to evaluate the expression, ensuring that the order of operations is respected. Input validation will be implemented to handle cases such as empty lists or invalid operators. The function will also handle large numbers efficiently by leveraging Python's inherent support for arbitrary-precision integers.\n"], "scores": [1.0, 1.0, 0.6124, 0.6124, 0.6124, 0.3488, 0.6124, 0.6124, 0.6124, 1.0], "pass_results": [true, true, false, false, false, false, false, false, false, true], "pass_test_cases_num": [129, 129, 79, 79, 79, 45, 79, 79, 79, 129], "completion": "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the specified conditions.\n    \"\"\"\n    # Validate input\n    if not operands or len(operators) != len(operands) - 1:\n        raise ValueError(\"Invalid input: The number of operators must be one less than the number of operands.\")\n    \n    valid_operators = {'+', '-', '*', '//', '**'}\n    \n    for op in operators:\n        if op not in valid_operators:\n            raise ValueError(f\"Invalid operator: {op}. Allowed operators are {valid_operators}.\")\n\n    # Construct the expression\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        expression += f\" {operator} {operands[i + 1]}\"\n    \n    # Evaluate the expression\n    try:\n        result = eval(expression)\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {e}\")\n\n    return result\n", "passed": true, "pass": true, "pass_num": 3, "round": 720, "mutate_method": "condense_two2one", "parent_index": 315}
