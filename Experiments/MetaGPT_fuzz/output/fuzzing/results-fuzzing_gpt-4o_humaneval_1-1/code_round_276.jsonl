{"task_id": "HumanEval/77", "prompt": "def iscube(a):\t\n'''Write a function that takes an integer a and returns True if this ingeger is a cube of some integer number. This means that there should be an integer b such that b * b * b equals a. Note: you may assume the input is always valid.\nExamples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''", "entry_point": "iscube", "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "test": ["def check(iscube):\n\tassert iscube(68921) == True", "def check(iscube):\n\tassert iscube(1000000) == True", "def check(iscube):\n\tassert iscube(205379) == True", "def check(iscube):\n\tassert iscube(216) == True", "def check(iscube):\n\tassert iscube(314432) == True", "def check(iscube):\n\tassert iscube(274625) == True", "def check(iscube):\n\tassert iscube(157464) == True", "def check(iscube):\n\tassert iscube(941192) == True", "def check(iscube):\n\tassert iscube(178) == False", "def check(iscube):\n\tassert iscube(250047) == True", "def check(iscube):\n\tassert iscube(3) == False", "def check(iscube):\n\tassert iscube(179) == False", "def check(iscube):\n\tassert iscube(857375) == True", "def check(iscube):\n\tassert iscube(512) == True", "def check(iscube):\n\tassert iscube(405224) == True", "def check(iscube):\n\tassert iscube(176) == False", "def check(iscube):\n\tassert iscube(238328) == True", "def check(iscube):\n\tassert iscube(1) == True, \"First test error: \" + str(iscube(1))", "def check(iscube):\n\tassert iscube(1000) == True", "def check(iscube):\n\tassert iscube(4913) == True", "def check(iscube):\n\tassert iscube(373248) == True", "def check(iscube):\n\tassert iscube(262144) == True", "def check(iscube):\n\tassert iscube(2) == False, \"Second test error: \" + str(iscube(2))", "def check(iscube):\n\tassert iscube(0) == True, \"1st edge test error: \" + str(iscube(0))", "def check(iscube):\n\tassert iscube(2197) == True", "def check(iscube):\n\tassert iscube(2744) == True", "def check(iscube):\n\tassert iscube(175) == False", "def check(iscube):\n\tassert iscube(103823) == True", "def check(iscube):\n\tassert iscube(13824) == True", "def check(iscube):\n\tassert iscube(474552) == True", "def check(iscube):\n\tassert iscube(658503) == True", "def check(iscube):\n\tassert iscube(636056) == True", "def check(iscube):\n\tassert iscube(5) == False", "def check(iscube):\n\tassert iscube(4) == False", "def check(iscube):\n\tassert iscube(21952) == True", "def check(iscube):\n\tassert iscube(42875) == True", "def check(iscube):\n\tassert iscube(681472) == True", "def check(iscube):\n\tassert iscube(1) == True", "def check(iscube):\n\tassert iscube(884736) == True", "def check(iscube):\n\tassert iscube(12167) == True", "def check(iscube):\n\tassert iscube(180) == False, \"Fifth test error: \" + str(iscube(180))", "def check(iscube):\n\tassert iscube(1000) == True, \"Sixth test error: \" + str(iscube(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.", "def check(iscube):\n\tassert iscube(729) == True", "def check(iscube):\n\tassert iscube(753571) == True", "def check(iscube):\n\tassert iscube(54872) == True", "def check(iscube):\n\tassert iscube(1331) == True", "def check(iscube):\n\tassert iscube(185193) == True", "def check(iscube):\n\tassert iscube(438976) == True", "def check(iscube):\n\tassert iscube(180) == False", "def check(iscube):\n\tassert iscube(7) == False", "def check(iscube):\n\tassert iscube(8) == True", "def check(iscube):\n\tassert iscube(2) == False", "def check(iscube):\n\tassert iscube(1729) == False, \"2nd edge test error: \" + str(iscube(1728))", "def check(iscube):\n\tassert iscube(493039) == True", "def check(iscube):\n\tassert iscube(729000) == True", "def check(iscube):\n\tassert iscube(328509) == True", "def check(iscube):\n\tassert iscube(85184) == True", "def check(iscube):\n\tassert iscube(704969) == True", "def check(iscube):\n\tassert iscube(287496) == True", "def check(iscube):\n\tassert iscube(15625) == True", "def check(iscube):\n\tassert iscube(3375) == True", "def check(iscube):\n\tassert iscube(226981) == True", "def check(iscube):\n\tassert iscube(19683) == True", "def check(iscube):\n\tassert iscube(64) == True, \"Fourth test error: \" + str(iscube(64))", "def check(iscube):\n\tassert iscube(571787) == True", "def check(iscube):\n\tassert iscube(181) == False", "def check(iscube):\n\tassert iscube(185) == False", "def check(iscube):\n\tassert iscube(551368) == True", "def check(iscube):\n\tassert iscube(64) == True", "def check(iscube):\n\tassert iscube(-1) == True, \"Third test error: \" + str(iscube(-1))", "def check(iscube):\n\tassert iscube(74088) == True", "def check(iscube):\n\tassert iscube(8000) == True"], "test_case_list": ["assert iscube(68921) == True", "assert iscube(1000000) == True", "assert iscube(205379) == True", "assert iscube(216) == True", "assert iscube(314432) == True", "assert iscube(274625) == True", "assert iscube(157464) == True", "assert iscube(941192) == True", "assert iscube(178) == False", "assert iscube(250047) == True", "assert iscube(3) == False", "assert iscube(179) == False", "assert iscube(857375) == True", "assert iscube(512) == True", "assert iscube(405224) == True", "assert iscube(176) == False", "assert iscube(238328) == True", "assert iscube(1) == True, \"First test error: \" + str(iscube(1))", "assert iscube(1000) == True", "assert iscube(4913) == True", "assert iscube(373248) == True", "assert iscube(262144) == True", "assert iscube(2) == False, \"Second test error: \" + str(iscube(2))", "assert iscube(0) == True, \"1st edge test error: \" + str(iscube(0))", "assert iscube(2197) == True", "assert iscube(2744) == True", "assert iscube(175) == False", "assert iscube(103823) == True", "assert iscube(13824) == True", "assert iscube(474552) == True", "assert iscube(658503) == True", "assert iscube(636056) == True", "assert iscube(5) == False", "assert iscube(4) == False", "assert iscube(21952) == True", "assert iscube(42875) == True", "assert iscube(681472) == True", "assert iscube(1) == True", "assert iscube(884736) == True", "assert iscube(12167) == True", "assert iscube(180) == False, \"Fifth test error: \" + str(iscube(180))", "assert iscube(1000) == True, \"Sixth test error: \" + str(iscube(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.", "assert iscube(729) == True", "assert iscube(753571) == True", "assert iscube(54872) == True", "assert iscube(1331) == True", "assert iscube(185193) == True", "assert iscube(438976) == True", "assert iscube(180) == False", "assert iscube(7) == False", "assert iscube(8) == True", "assert iscube(2) == False", "assert iscube(1729) == False, \"2nd edge test error: \" + str(iscube(1728))", "assert iscube(493039) == True", "assert iscube(729000) == True", "assert iscube(328509) == True", "assert iscube(85184) == True", "assert iscube(704969) == True", "assert iscube(287496) == True", "assert iscube(15625) == True", "assert iscube(3375) == True", "assert iscube(226981) == True", "assert iscube(19683) == True", "assert iscube(64) == True, \"Fourth test error: \" + str(iscube(64))", "assert iscube(571787) == True", "assert iscube(181) == False", "assert iscube(185) == False", "assert iscube(551368) == True", "assert iscube(64) == True", "assert iscube(-1) == True, \"Third test error: \" + str(iscube(-1))", "assert iscube(74088) == True", "assert iscube(8000) == True"], "nl": "\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    ", "func": "def iscube(a):", "examples": "Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    ", "repair_prompt": ["def iscube(a):\t\n'''Write a function that takes an integer a and returns True if this ingeger is a cube of some integer number. This means that there should be an integer b such that b * b * b equals a. Note: you may assume the input is always valid.\nExamples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''"], "completions": ["from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"Check if the given integer is a perfect cube.\n\n    Args:\n        a (int): The integer to check.\n\n    Returns:\n        bool: True if 'a' is a perfect cube, otherwise False.\n    \"\"\"\n    if a == 0:\n        return True\n\n    # Calculate the cube root of the absolute value of 'a'\n    cube_root = round(abs(a) ** (1/3))\n\n    # Check if the cube of the cube_root equals the absolute value of 'a'\n    is_perfect_cube = (cube_root ** 3 == abs(a))\n\n    # If 'a' is negative, ensure the cube root is also negative\n    if a < 0:\n        return is_perfect_cube and cube_root == -round(abs(a) ** (1/3))\n    \n    return is_perfect_cube\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"Check if a given integer is a perfect cube.\n\n    This function calculates the cube root of the absolute value of the number\n    and checks if the result is an integer. It handles both positive and negative\n    integers correctly.\n\n    Args:\n        a (int): The integer to check.\n\n    Returns:\n        bool: True if 'a' is a perfect cube, otherwise False.\n    \"\"\"\n    # Calculate the cube root of the absolute value of 'a'\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the cube_root equals the absolute value of 'a'\n    is_perfect_cube = (cube_root ** 3 == abs(a))\n    \n    return is_perfect_cube\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Function to determine if the given integer is a perfect cube.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root of the absolute value of the number\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if the cube of the cube root equals the absolute value of the number\n    if cube_root ** 3 == abs(a):\n        return True\n    else:\n        return False\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Takes an integer a and returns True if it is a perfect cube.\n    \n    Args:\n        a (int): Integer to check.\n        \n    Returns:\n        bool: True if a is a perfect cube, False otherwise.\n    \"\"\"\n    if a == 0:\n        return True\n    \n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the rounded cube root equals the absolute value of a\n    is_perfect_cube = (cube_root ** 3 == abs(a))\n    \n    # If a is negative, ensure the cube root is also negative\n    if a < 0:\n        return is_perfect_cube and cube_root * cube_root * cube_root == a\n    \n    return is_perfect_cube\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determine if the given integer is a perfect cube.\n\n    This function calculates the cube root of the absolute value of the number,\n    rounds it to the nearest integer, and checks if the cube of this rounded\n    result equals the original number. This approach handles both positive and\n    negative integers correctly.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if the integer is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root of the absolute value of the number\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if the cube of the rounded cube root equals the original number\n    return cube_root ** 3 == abs(a)\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determine if the given integer is a perfect cube.\n\n    This function calculates the cube root of the absolute value of the integer,\n    rounds the result, and checks if cubing the rounded result equals the original integer.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root of the absolute value of the integer\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if cubing the rounded cube root equals the original integer\n    return cube_root ** 3 == abs(a)\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determine if the given integer is a perfect cube.\n\n    This function calculates the cube root of the absolute value of the input,\n    rounds the result, and checks if cubing the rounded result returns the\n    original number. This approach ensures that both positive and negative\n    integers are handled correctly.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root of the absolute value of 'a'\n    abs_a = abs(a)\n    cube_root = round(abs_a ** (1/3))\n\n    # Check if cubing the rounded result equals the absolute value of 'a'\n    if cube_root ** 3 == abs_a:\n        return True\n    else:\n        return False\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Determine if the given integer is a perfect cube.\n\n    This function calculates the cube root of the given integer and checks if it is an integer.\n    It handles both positive and negative integers and uses integer arithmetic to avoid floating-point precision issues.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if 'a' is a perfect cube, False otherwise.\n    \"\"\"\n    if a < 0:\n        # For negative numbers, take the cube root of the absolute value and then negate the result\n        cube_root = -int(round(abs(a) ** (1/3)))\n    else:\n        # For non-negative numbers, directly calculate the cube root\n        cube_root = int(round(a ** (1/3)))\n\n    # Check if the cube of the calculated cube root equals the original number\n    return cube_root ** 3 == a\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Takes an integer a and returns True if this integer is a cube of some integer number.\n    \n    Args:\n        a (int): Integer to check.\n        \n    Returns:\n        bool: True if a is a perfect cube, False otherwise.\n    \"\"\"\n    if a == 0:\n        return True\n    \n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the cube_root equals the absolute value of a\n    if cube_root ** 3 == abs(a):\n        # If a is negative, ensure the cube root is also negative\n        return a < 0 and cube_root < 0 or a > 0 and cube_root > 0\n    \n    return False\n", "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Takes an integer a and returns True if it is a perfect cube, otherwise False.\n    \n    Args:\n        a (int): Integer to check.\n        \n    Returns:\n        bool: Boolean indicating if a is a perfect cube.\n    \"\"\"\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if the cube of the cube_root equals the absolute value of a\n    is_perfect_cube = cube_root ** 3 == abs(a)\n    \n    return is_perfect_cube\n"], "plans": ["requirement analysis:\nThe function should accurately determine if an integer is a perfect cube by checking if there exists another integer whose cube equals the input. It should handle both positive and negative integers, including zero, and provide a boolean output.\nrequirement pool:\n- Implement cube detection logic\n- Optimize for performance with large integers\n- Ensure compatibility with negative numbers\n- Provide detailed error handling\n- Include comprehensive test cases\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if the result is an integer. We will use Python's built-in capabilities to handle this efficiently, ensuring compatibility with both positive and negative numbers, as well as zero.\n", "requirement analysis:\nThe function should efficiently determine if a given integer is a perfect cube by checking if there exists an integer whose cube equals the input. It should handle both positive and negative integers and return a boolean value indicating the result.\nrequirement pool:\n- Implement cube detection logic\n- Optimize for performance with large integers\n- Ensure correct handling of negative numbers\n- Provide detailed documentation\n- Include test cases for edge scenarios\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root of the absolute value of the number and checking if the result is an integer. We will use Python's built-in functions to achieve this efficiently, ensuring the function handles both positive and negative integers correctly.\n", "requirement analysis:\nThe function should efficiently determine if a given integer is a perfect cube by checking if there exists an integer whose cube equals the input. The solution should handle both positive and negative integers, including zero, and should be optimized for performance.\nrequirement pool:\n- Implement the cube detection algorithm\n- Optimize the function for performance\n- Ensure the function handles edge cases like zero and negative numbers\n- Document the function with examples and usage\n- Write unit tests to validate the function's accuracy\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root of the absolute value of the number and checking if the result is an integer. We will use the built-in Python math library for efficient computation. The function will handle both positive and negative integers, including zero, and will be optimized for performance by avoiding unnecessary computations.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube by checking if there exists an integer whose cube equals the input. It should handle both positive and negative integers and be optimized for performance.\nrequirement pool:\n- Implement the cube detection algorithm\n- Optimize the function for large integer inputs\n- Ensure the function handles negative numbers correctly\n- Document the function with examples and edge cases\n- Test the function with a variety of inputs\nWe will implement a function to check if a given integer is a perfect cube by calculating the cube root and verifying if the cube of the rounded result equals the original number. We will use the built-in math library for efficient computation, ensuring the function handles both positive and negative integers correctly.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube by checking if there exists an integer whose cube equals the input. It should handle both positive and negative integers and be optimized for performance.\nrequirement pool:\n- Implement the core function to check for perfect cubes.\n- Optimize the function for performance with large integers.\n- Ensure the function handles both positive and negative integers.\n- Provide comprehensive documentation and examples.\n- Conduct performance testing and optimization.\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root of the absolute value of the number and checking if the cube of the rounded result equals the original number. This approach ensures that both positive and negative integers are handled correctly. We will use the built-in Python math library for efficient computation.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube by checking if there exists an integer whose cube equals the input. The solution should handle both positive and negative integers efficiently.\nrequirement pool:\n- Implement the cube detection algorithm\n- Optimize for performance with large integers\n- Include comprehensive test cases\n- Document the function with examples\n- Ensure compatibility with Python 3.x\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root of the absolute value of the number and checking if the cube of the rounded result equals the original number. This approach ensures compatibility with both positive and negative integers. We will use the built-in Python math library for efficient computation.\n", "requirement analysis:\nThe function should efficiently determine if a given integer is a perfect cube by checking if there exists an integer whose cube equals the input. It should handle both positive and negative integers and return results quickly, especially for large numbers.\nrequirement pool:\n- Implement efficient cube detection algorithm\n- Ensure function handles negative integers correctly\n- Optimize performance for large integer inputs\n- Provide comprehensive documentation\n- Include unit tests for various edge cases\nWe will implement an efficient cube detection algorithm by leveraging the math library for integer operations. The function will calculate the cube root of the absolute value of the input and check if cubing the rounded result returns the original number. This approach ensures that both positive and negative integers are handled correctly, and it is optimized for performance with large integers.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube by checking if there exists an integer whose cube equals the input. It should handle both positive and negative integers and be optimized for performance with large numbers.\nrequirement pool:\n- Accurate cube detection for any integer\n- Performance optimization for large integers\n- Handle negative integers correctly\n- Provide clear documentation and examples\n- Ensure compatibility with various Python versions\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root and verifying if it is an integer. We will use the `math` library for efficient computation and handle both positive and negative integers. The function will be optimized to handle large numbers by using integer arithmetic to avoid floating-point precision issues.\n", "requirement analysis:\nThe function should accurately determine if a given integer is a perfect cube by checking if there exists an integer whose cube equals the input. It should handle both positive and negative integers and be optimized for performance.\nrequirement pool:\n- Implement the cube detection algorithm\n- Optimize the function for performance\n- Ensure the function handles negative numbers correctly\n- Provide comprehensive documentation and examples\n- Include unit tests for various edge cases\nWe will implement a function to check if a given integer is a perfect cube by calculating the cube root and verifying if the result is an integer. The function will handle both positive and negative integers efficiently using the built-in math library for cube root calculation, which is optimized for performance.\n", "requirement analysis:\nThe function should accurately determine if an integer is a perfect cube by checking if there exists an integer whose cube equals the input. It should handle both positive and negative integers, as well as zero, efficiently.\nrequirement pool:\n- Accurate cube detection for all integer inputs\n- Performance optimization for large integers\n- Handle negative and zero values correctly\n- Easy integration into larger projects\n- Provide clear and concise output\nWe will implement a function that checks if a given integer is a perfect cube by calculating the cube root of the absolute value of the number and checking if the result is an integer. We will use the 'math' library for efficient computation. The function will handle both positive and negative integers, as well as zero.\n"], "scores": [0.9861, 1.0, 1.0, 0.9861, 1.0, 1.0, 1.0, 1.0, 0.9861, 1.0], "pass_results": [false, true, true, false, true, true, true, true, false, true], "pass_test_cases_num": [71, 72, 72, 71, 72, 72, 72, 72, 71, 72], "completion": "from typing import List\n## main.py\n\nimport math\n\ndef iscube(a: int) -> bool:\n    \"\"\"\n    Takes an integer a and returns True if it is a perfect cube, otherwise False.\n    \n    Args:\n        a (int): Integer to check.\n        \n    Returns:\n        bool: Boolean indicating if a is a perfect cube.\n    \"\"\"\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(math.pow(abs(a), 1/3))\n    \n    # Check if the cube of the cube_root equals the absolute value of a\n    is_perfect_cube = cube_root ** 3 == abs(a)\n    \n    return is_perfect_cube\n", "passed": true, "pass": true, "pass_num": 7, "round": 276, "mutate_method": "expand_one2two", "parent_index": 156}
