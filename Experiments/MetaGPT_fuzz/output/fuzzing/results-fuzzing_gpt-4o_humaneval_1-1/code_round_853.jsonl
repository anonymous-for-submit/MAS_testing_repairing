{"task_id": "HumanEval/160", "prompt": "def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list contains fundamental algebra operations, and the second list is a list of integers. Use the two given lists to build the algebric expression and return the evaluation of this expression.\n\nThe basic algebra operations: Addition ( + ) Subtraction ( - ) Multiplication ( * ) Floor division ( // ) Exponentiation ( ** )\nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": ["def check(do_algebra):\n\tassert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [8, 8, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [5, 1, 6]) == 5", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [12, 1, 6]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [2, 5, 7]) == 17", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [2, 3, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [6, 2, 2]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [8, 2, 7]) == -120", "def check(do_algebra):\n\tassert do_algebra(['//', '**'], [4, 4, 4]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [5, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "def check(do_algebra):\n\tassert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [8, 2, 7]) == 71", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [9, 3, 8]) == 35", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "def check(do_algebra):\n\tassert do_algebra(['*', '-'], [6, 5, 7]) == 23", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "def check(do_algebra):\n\tassert do_algebra(['-', '*'], [3, 3, 6]) == -15", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 5, 2]) == -22", "def check(do_algebra):\n\tassert do_algebra(['+', '*'], [7, 3, 6]) == 25", "def check(do_algebra):\n\tassert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [3, 2, 8]) == 768", "def check(do_algebra):\n\tassert do_algebra(['*', '**'], [7, 3, 3]) == 189", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "def check(do_algebra):\n\tassert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [8, 4, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "def check(do_algebra):\n\tassert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [8, 2, 2]) == 128", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [3, 4, 4]) == 3", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [10, 3, 8]) == 5", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [7, 3, 4]) == 8", "def check(do_algebra):\n\tassert do_algebra(['//', '-'], [6, 1, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "def check(do_algebra):\n\tassert do_algebra(['+', '-'], [3, 7, 6]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "def check(do_algebra):\n\tassert do_algebra(['*', '*'], [5, 2, 7]) == 70", "def check(do_algebra):\n\tassert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "def check(do_algebra):\n\tassert do_algebra(['-', '**'], [3, 3, 4]) == -78", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "def check(do_algebra):\n\tassert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "def check(do_algebra):\n\tassert do_algebra(['//', '//'], [2, 7, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "def check(do_algebra):\n\tassert do_algebra(['**', '*'], [10, 2, 8]) == 800", "def check(do_algebra):\n\tassert do_algebra(['+', '//'], [3, 6, 4]) == 4", "def check(do_algebra):\n\tassert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "def check(do_algebra):\n\tassert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 3, 5]) == 250", "def check(do_algebra):\n\tassert do_algebra(['-', '//'], [7, 3, 2]) == 6", "def check(do_algebra):\n\tassert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [3, 2, 4]) == 19", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "def check(do_algebra):\n\tassert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "def check(do_algebra):\n\tassert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "def check(do_algebra):\n\tassert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "def check(do_algebra):\n\tassert do_algebra(['**', '-'], [3, 2, 9]) == 0", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "def check(do_algebra):\n\tassert do_algebra(['+', '+'], [4, 4, 1]) == 9", "def check(do_algebra):\n\tassert do_algebra(['-', '+'], [10, 7, 1]) == 4", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "def check(do_algebra):\n\tassert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "def check(do_algebra):\n\tassert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "def check(do_algebra):\n\tassert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "def check(do_algebra):\n\tassert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "def check(do_algebra):\n\tassert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '*'], [8, 4, 2]) == 4", "def check(do_algebra):\n\tassert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "def check(do_algebra):\n\tassert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "def check(do_algebra):\n\tassert do_algebra(['*', '+'], [4, 8, 4]) == 36", "def check(do_algebra):\n\tassert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "test_case_list": ["assert do_algebra(['**', '//', '-'], [5, 6, 6, 1]) == 2603", "assert do_algebra(['**', '-', '-'], [7, 1, 4, 9]) == -6", "assert do_algebra(['+', '**', '*'], [6, 2, 1, 1]) == 8", "assert do_algebra(['+', '+', '+'], [1, 4, 9, 9]) == 23", "assert do_algebra(['//', '-', '-'], [3, 3, 3, 6]) == -8", "assert do_algebra(['-', '*', '-'], [1, 1, 2, 3]) == -4", "assert do_algebra(['//', '-', '*'], [7, 2, 7, 5]) == -32", "assert do_algebra(['//', '*', '+'], [3, 5, 2, 3]) == 3", "assert do_algebra(['//', '**', '+'], [3, 7, 9, 3]) == 3", "assert do_algebra(['*', '//', '//'], [5, 2, 7, 9]) == 0", "assert do_algebra(['-', '//', '-'], [6, 8, 1, 10]) == -12", "assert do_algebra(['//', '**', '-'], [3, 7, 7, 1]) == -1", "assert do_algebra(['**', '*', '+'], [2, 3, 4, 5]) == 37", "assert do_algebra(['//', '//'], [8, 8, 7]) == 0", "assert do_algebra(['//', '//', '*'], [2, 1, 7, 6]) == 0", "assert do_algebra(['//', '//', '+'], [5, 2, 8, 2]) == 2", "assert do_algebra(['*', '+', '+'], [3, 2, 6, 5]) == 17", "assert do_algebra(['*', '**'], [5, 1, 6]) == 5", "assert do_algebra(['-', '+', '**'], [5, 3, 5, 6]) == 15627", "assert do_algebra(['-', '**', '//'], [1, 8, 3, 3]) == -169", "assert do_algebra(['**', '+', '-'], [3, 8, 1, 2]) == 6560", "assert do_algebra(['**', '//'], [12, 1, 6]) == 2", "assert do_algebra(['*', '+', '-'], [2, 2, 9, 6]) == 7", "assert do_algebra(['*', '+'], [2, 5, 7]) == 17", "assert do_algebra(['**', '*'], [2, 3, 1]) == 8", "assert do_algebra(['**', '//'], [7, 8, 8]) == 720600", "assert do_algebra(['-', '+', '-'], [3, 5, 9, 7]) == 0", "assert do_algebra(['**', '+'], [8, 4, 1]) == 4097", "assert do_algebra(['**', '*', '+'], [5, 2, 1, 9]) == 34", "assert do_algebra(['//', '-', '*'], [5, 4, 7, 1]) == -6", "assert do_algebra(['-', '**'], [6, 2, 2]) == 2", "assert do_algebra(['*', '+', '+'], [6, 3, 5, 5]) == 28", "assert do_algebra(['-', '**'], [8, 2, 7]) == -120", "assert do_algebra(['//', '**'], [4, 4, 4]) == 0", "assert do_algebra(['-', '//'], [5, 3, 8]) == 5", "assert do_algebra(['//', '**', '-'], [7, 2, 9, 3]) == -3", "assert do_algebra(['**', '-', '//'], [6, 1, 6, 7]) == 6", "assert do_algebra(['*', '//', '-'], [7, 1, 5, 10]) == -9", "assert do_algebra(['//', '*', '**'], [7, 6, 2, 1]) == 2", "assert do_algebra(['*', '*', '-'], [7, 8, 1, 9]) == 47", "assert do_algebra(['**', '+'], [8, 2, 7]) == 71", "assert do_algebra(['**', '//'], [9, 5, 9]) == 6561", "assert do_algebra(['**', '-', '*'], [5, 1, 2, 3]) == -1", "assert do_algebra(['*', '//', '+'], [7, 1, 8, 9]) == 9", "assert do_algebra(['//', '//', '+'], [2, 5, 8, 8]) == 8", "assert do_algebra(['*', '-', '+'], [6, 7, 4, 4]) == 42", "assert do_algebra(['-', '**', '-'], [7, 4, 1, 8]) == -5", "assert do_algebra(['+', '**', '+'], [4, 2, 7, 1]) == 133", "assert do_algebra(['*', '+'], [9, 3, 8]) == 35", "assert do_algebra(['*', '-', '//'], [4, 4, 2, 6]) == 16", "assert do_algebra(['*', '//', '//'], [7, 7, 6, 6]) == 1", "assert do_algebra(['**', '//', '//'], [1, 7, 6, 2]) == 0", "assert do_algebra(['*', '-', '**'], [2, 7, 7, 1]) == 7", "assert do_algebra(['+', '*', '**'], [6, 8, 1, 2]) == 14", "assert do_algebra(['**', '//', '+'], [5, 8, 3, 3]) == 130211", "assert do_algebra(['*', '-'], [6, 5, 7]) == 23", "assert do_algebra(['*', '*', '+'], [1, 3, 2, 9]) == 15", "assert do_algebra(['-', '*'], [3, 3, 6]) == -15", "assert do_algebra(['//', '-', '**'], [4, 8, 2, 2]) == -4", "assert do_algebra(['-', '**', '-'], [4, 5, 5, 9]) == -3130", "assert do_algebra(['**', '+', '*'], [1, 5, 5, 1]) == 6", "assert do_algebra(['-', '**'], [3, 5, 2]) == -22", "assert do_algebra(['+', '*'], [7, 3, 6]) == 25", "assert do_algebra(['*', '-', '**'], [5, 5, 2, 8]) == -231", "assert do_algebra(['+', '-', '**'], [6, 8, 4, 10]) == -1048562", "assert do_algebra(['+', '//', '*'], [7, 3, 7, 1]) == 7", "assert do_algebra(['**', '-', '//'], [7, 8, 1, 10]) == 5764801", "assert do_algebra(['//', '//', '+'], [1, 2, 8, 10]) == 10", "assert do_algebra(['*', '*', '-'], [3, 4, 1, 4]) == 8", "assert do_algebra(['//', '+', '**'], [7, 1, 5, 1]) == 12", "assert do_algebra(['*', '**'], [3, 2, 8]) == 768", "assert do_algebra(['*', '**'], [7, 3, 3]) == 189", "assert do_algebra(['+', '**', '-'], [5, 2, 5, 9]) == 28", "assert do_algebra(['-', '**', '*'], [5, 2, 7, 8]) == -1019", "assert do_algebra(['-', '+'], [8, 4, 3]) == 7", "assert do_algebra(['+', '-', '//'], [5, 4, 6, 2]) == 6", "assert do_algebra(['//', '+', '//'], [5, 1, 9, 4]) == 7", "assert do_algebra(['*', '**', '+'], [7, 1, 5, 1]) == 8", "assert do_algebra(['*', '+', '//'], [4, 6, 7, 10]) == 24", "assert do_algebra(['+', '*', '-'], [2, 3, 4, 5]) == 9", "assert do_algebra(['**', '*'], [8, 2, 2]) == 128", "assert do_algebra(['**', '-', '*'], [6, 4, 5, 1]) == 1291", "assert do_algebra(['-', '+'], [3, 4, 4]) == 3", "assert do_algebra(['+', '-'], [10, 3, 8]) == 5", "assert do_algebra(['//', '*'], [7, 3, 4]) == 8", "assert do_algebra(['//', '-'], [6, 1, 2]) == 4", "assert do_algebra(['**', '+'], [10, 3, 5]) == 1005", "assert do_algebra(['+', '-'], [3, 7, 6]) == 4", "assert do_algebra(['**', '//'], [9, 5, 2]) == 29524", "assert do_algebra(['*', '*'], [5, 2, 7]) == 70", "assert do_algebra(['*', '+', '**'], [5, 5, 2, 9]) == 537", "assert do_algebra(['-', '**'], [3, 3, 4]) == -78", "assert do_algebra(['**', '*', '*'], [7, 2, 4, 7]) == 1372", "assert do_algebra(['**', '*', '-'], [7, 6, 4, 6]) == 470590", "assert do_algebra(['//', '//'], [2, 7, 1]) == 0", "assert do_algebra(['+', '**', '+'], [6, 6, 4, 7]) == 1309", "assert do_algebra(['**', '*'], [10, 2, 8]) == 800", "assert do_algebra(['+', '//'], [3, 6, 4]) == 4", "assert do_algebra(['**', '+', '-'], [1, 5, 1, 1]) == 1", "assert do_algebra(['+', '-', '*'], [6, 8, 6, 1]) == 8", "assert do_algebra(['+', '**'], [7, 3, 5]) == 250", "assert do_algebra(['-', '//'], [7, 3, 2]) == 6", "assert do_algebra(['//', '+', '*'], [2, 6, 4, 4]) == 16", "assert do_algebra(['//', '//', '**'], [7, 1, 9, 1]) == 0", "assert do_algebra(['+', '*', '//'], [6, 5, 1, 3]) == 7", "assert do_algebra(['+', '**'], [3, 2, 4]) == 19", "assert do_algebra(['-', '*', '-'], [2, 7, 3, 9]) == -28", "assert do_algebra(['*', '*', '-'], [2, 1, 8, 4]) == 12", "assert do_algebra(['+', '**'], [7, 6, 6]) == 46663", "assert do_algebra(['**', '-', '-'], [1, 7, 7, 10]) == -16", "assert do_algebra(['**', '//', '//'], [1, 7, 4, 8]) == 0", "assert do_algebra(['-', '*', '*'], [7, 4, 7, 8]) == -217", "assert do_algebra(['**', '-'], [3, 2, 9]) == 0", "assert do_algebra(['-', '+', '**'], [5, 4, 2, 3]) == 9", "assert do_algebra(['+', '+'], [4, 4, 1]) == 9", "assert do_algebra(['-', '+'], [10, 7, 1]) == 4", "assert do_algebra(['-', '+', '*'], [5, 5, 4, 8]) == 32", "assert do_algebra(['//', '//', '*'], [4, 8, 9, 6]) == 0", "assert do_algebra(['+', '**', '-'], [1, 1, 9, 4]) == -2", "assert do_algebra(['+', '//', '+'], [5, 8, 2, 1]) == 10", "assert do_algebra(['-', '//', '**'], [4, 5, 8, 3]) == 4", "assert do_algebra(['+', '//', '*'], [5, 4, 8, 10]) == 5", "assert do_algebra(['**', '-', '+'], [2, 1, 7, 9]) == 4", "assert do_algebra(['//', '*'], [8, 4, 2]) == 4", "assert do_algebra(['//', '-', '*'], [4, 3, 3, 1]) == -2", "assert do_algebra(['-', '+', '+'], [1, 1, 9, 9]) == 18", "assert do_algebra(['-', '+', '**'], [1, 4, 2, 7]) == 125", "assert do_algebra(['*', '+'], [4, 8, 4]) == 36", "assert do_algebra(['*', '//', '*'], [7, 3, 1, 10]) == 210"], "nl": "\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    ", "func": "def do_algebra(operator, operand):", "examples": "Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    ", "repair_prompt": ["def do_algebra(operator, operand):\t\n'''Given two lists operator, and operand. The first list contains fundamental algebra operations, and the second list is a list of integers. Use the two given lists to build the algebric expression and return the evaluation of this expression.\n\nThe basic algebra operations: Addition ( + ) Subtraction ( - ) Multiplication ( * ) Floor division ( // ) Exponentiation ( ** )\nExample:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    '''"], "completions": ["from typing import List\n## main.py\n\nimport operator\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n\n    # Initial result is the first operand\n    result = operands[0]\n\n    # Iterate through operators and operands to compute the result\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        \n        # Check for division by zero\n        if op == '//' and operands[i + 1] == 0:\n            raise ZeroDivisionError(\"Division by zero is not allowed.\")\n        \n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n\n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Constructs and evaluates an algebraic expression from the given operators and operands.\n\n    Parameters:\n    operator (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operand (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    if not operator or not operand:\n        raise ValueError(\"Operators and operands lists cannot be empty.\")\n    \n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Construct the expression string\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        if op not in ['+', '-', '*', '//', '**']:\n            raise ValueError(f\"Unsupported operator: {op}\")\n        expression += f\" {op} {operand[i + 1]}\"\n    \n    try:\n        # Evaluate the expression\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ZeroDivisionError(\"Division by zero occurred in the expression.\")\n    except Exception as e:\n        raise RuntimeError(f\"An error occurred while evaluating the expression: {e}\")\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators.\n    operands (list[int]): A list of integers representing the operands.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Validate input lengths\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Construct the expression string\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        if operator not in {'+', '-', '*', '/'}:\n            raise ValueError(f\"Unsupported operator: {operator}\")\n        expression += f\" {operator} {operands[i + 1]}\"\n\n    # Evaluate the expression\n    try:\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ZeroDivisionError(\"Division by zero is not allowed.\")\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {e}\")\n\n    return int(result)\n\n# Example usage:\n# result = do_algebra(['+', '*', '-'], [3, 5, 2, 4])\n# print(result)  # Output should be 9\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operators (list of str): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operands (list of int): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    if not operators or not operands:\n        raise ValueError(\"Operators and operands lists cannot be empty.\")\n    \n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Start with the first operand\n    result = operands[0]\n    \n    # Iterate over operators and corresponding operands\n    for i, operator in enumerate(operators):\n        if operator == '+':\n            result += operands[i + 1]\n        elif operator == '-':\n            result -= operands[i + 1]\n        elif operator == '*':\n            result *= operands[i + 1]\n        elif operator == '//':\n            if operands[i + 1] == 0:\n                raise ZeroDivisionError(\"Division by zero is not allowed.\")\n            result //= operands[i + 1]\n        elif operator == '**':\n            result **= operands[i + 1]\n        else:\n            raise ValueError(f\"Unsupported operator: {operator}\")\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operations ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Validate input lengths\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n    \n    # Validate operators\n    for op in operators:\n        if op not in operator_map:\n            raise ValueError(f\"Unsupported operator: {op}\")\n    \n    # Start with the first operand\n    result = operands[0]\n    \n    # Iterate through operators and operands to compute the result\n    for i, op in enumerate(operators):\n        # Get the corresponding function from the operator map\n        operation = operator_map[op]\n        # Apply the operation to the current result and the next operand\n        result = operation(result, operands[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\nimport operator\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    '''\n    Evaluates an algebraic expression constructed from the given operators and operands.\n    \n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n    \n    Returns:\n    int: The result of the evaluated expression.\n    \n    Raises:\n    ValueError: If an invalid operator is encountered.\n    IndexError: If there are not enough operands for the operators.\n    '''\n    \n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n    \n    # Initial result is the first operand\n    if not operands:\n        raise ValueError(\"Operands list cannot be empty.\")\n    \n    result = operands[0]\n    \n    # Iterate through operators and operands\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Invalid operator: {op}\")\n        \n        # Ensure there is a corresponding operand\n        if i + 1 >= len(operands):\n            raise IndexError(\"Not enough operands for the operators provided.\")\n        \n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n    \n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n    \n    Args:\n        operator: A list of strings representing algebraic operators.\n        operand: A list of integers representing operands.\n    \n    Returns:\n        The result of the evaluated expression as an integer.\n    \n    Raises:\n        ValueError: If there is a division by zero or invalid operators.\n    \"\"\"\n    if not operator or not operand:\n        raise ValueError(\"Operators and operands cannot be empty.\")\n    \n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"Number of operators must be one less than number of operands.\")\n    \n    # Construct the expression string\n    expression = str(operand[0])\n    for i, op in enumerate(operator):\n        if op not in ['+', '-', '*', '/']:\n            raise ValueError(f\"Invalid operator: {op}\")\n        if op == '/' and operand[i + 1] == 0:\n            raise ValueError(\"Division by zero is not allowed.\")\n        expression += f\" {op} {operand[i + 1]}\"\n    \n    try:\n        # Evaluate the expression using eval\n        result = eval(expression)\n    except Exception as e:\n        raise ValueError(f\"Error evaluating expression: {e}\")\n    \n    return int(result)\n", "from typing import List\n## main.py\n\nimport operator\nfrom typing import List\n\ndef do_algebra(operators: List[str], operands: List[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression based on the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of strings representing algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of integers to be used in the expression.\n\n    Returns:\n    int: The result of the evaluated expression.\n    \"\"\"\n    # Mapping of string operators to actual functions\n    operator_map = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '//': operator.floordiv,\n        '**': operator.pow\n    }\n\n    # Validate input\n    if not operators or not operands:\n        raise ValueError(\"Operators and operands lists cannot be empty.\")\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Initialize the result with the first operand\n    result = operands[0]\n\n    # Iterate through operators and operands to compute the result\n    for i, op in enumerate(operators):\n        if op not in operator_map:\n            raise ValueError(f\"Invalid operator: {op}\")\n        # Apply the operator to the current result and the next operand\n        result = operator_map[op](result, operands[i + 1])\n\n    return result\n\n# Example usage:\n# result = do_algebra(['+', '*', '-'], [3, 5, 2, 4])\n# print(result)  # Output should be 13\n", "from typing import List\n## main.py\n\ndef do_algebra(operators: list[str], operands: list[int]) -> int:\n    \"\"\"\n    Evaluates an algebraic expression constructed from the given operators and operands.\n\n    Parameters:\n    operators (list[str]): A list of algebraic operators ('+', '-', '*', '//', '**').\n    operands (list[int]): A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated expression.\n\n    Raises:\n    ValueError: If the operators list is not one less than the operands list.\n    ZeroDivisionError: If division by zero is attempted.\n    \"\"\"\n    # Validate input lengths\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Construct the expression string\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        if operator not in ['+', '-', '*', '//', '**']:\n            raise ValueError(f\"Invalid operator: {operator}\")\n        expression += f\" {operator} {operands[i + 1]}\"\n\n    # Evaluate the expression\n    try:\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ZeroDivisionError(\"Division by zero is not allowed.\")\n\n    return result\n", "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates algebraic expressions using the provided operators and operands.\n\n    Parameters:\n    operator: A list of strings representing algebraic operations ('+', '-', '*', '//', '**').\n    operand: A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated algebraic expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the required format.\n    \"\"\"\n    # Validate input lengths\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Validate operand types\n    if not all(isinstance(op, int) and op >= 0 for op in operand):\n        raise ValueError(\"All operands must be non-negative integers.\")\n\n    # Validate operator types\n    valid_operators = {'+', '-', '*', '//', '**'}\n    if not all(op in valid_operators for op in operator):\n        raise ValueError(f\"Operators must be one of {valid_operators}.\")\n\n    # Initialize result with the first operand\n    result = operand[0]\n\n    # Perform operations sequentially\n    for i, op in enumerate(operator):\n        if op == '+':\n            result += operand[i + 1]\n        elif op == '-':\n            result -= operand[i + 1]\n        elif op == '*':\n            result *= operand[i + 1]\n        elif op == '//':\n            if operand[i + 1] == 0:\n                raise ValueError(\"Division by zero is not allowed.\")\n            result //= operand[i + 1]\n        elif op == '**':\n            result **= operand[i + 1]\n\n    return result\n"], "plans": ["requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The user interface should be intuitive, allowing users to easily input their data.\nrequirement pool:\n- Implement the core algebra evaluation function\n- Design a user-friendly interface for input\n- Ensure the function handles all basic operations correctly\n- Optimize the function for performance\n- Provide clear error messages for invalid inputs\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operators in sequence to the operands. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring correct order of operations.\n", "requirement analysis:\nThe function should correctly parse and evaluate the algebraic expression using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently.\nrequirement pool:\n- Implement the main algebra evaluation function\n- Develop a user-friendly interface for input\n- Ensure the function handles edge cases and errors gracefully\n- Optimize the function for performance\n- Provide detailed documentation and examples\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operators in sequence to the operands. We will use Python's built-in eval function to evaluate the constructed expression, ensuring that the order of operations is respected. We will handle potential errors such as division by zero by using try-except blocks.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle basic operations such as addition, subtraction, multiplication, floor division, and exponentiation. The input constraints ensure that the number of operators is one less than the number of operands, which simplifies parsing.\nrequirement pool:\n- Implement the core algebraic expression evaluation logic.\n- Design a user-friendly interface for inputting operators and operands.\n- Ensure the application handles errors gracefully, such as invalid inputs.\n- Optimize the performance for large input sizes.\n- Add support for additional algebraic operations in the future.\nWe will implement a function that takes two lists: one for operators and one for operands. The function will iterate through the operators and operands to construct and evaluate the algebraic expression. We will use Python's built-in eval function to handle the expression evaluation, ensuring that the input is sanitized to prevent security risks. The function will be simple and efficient, leveraging Python's capabilities to handle basic arithmetic operations.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The input constraints ensure that there are always enough operands for the operators, simplifying error handling.\nrequirement pool:\n- Implement the main algebraic evaluation function\n- Develop a user-friendly interface for input\n- Optimize the function for performance\n- Add detailed error messages for invalid inputs\n- Provide a step-by-step explanation of the evaluation process\nWe will implement a function that iteratively constructs and evaluates the algebraic expression using the provided operators and operands. The function will respect the order of operations by using Python's built-in arithmetic operators. We will ensure that the function is efficient and handles the input constraints correctly, assuming all inputs are valid as per the constraints.\n", "requirement analysis:\nThe function should accurately evaluate algebraic expressions using the provided operators and operands. It must handle various operations and ensure the order of operations is respected. The user interface should allow easy input and display results clearly.\nrequirement pool:\n- Implement core algebraic computation logic\n- Develop user interface for input and output\n- Optimize performance for handling large operand lists\n- Include step-by-step evaluation display\n- Ensure compatibility with various devices\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operations in the order they appear, respecting the order of operations (PEMDAS/BODMAS). We will use the 'operator' module from Python's standard library to map string representations of operations to actual functions, ensuring efficient and accurate computation.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently. The user interface should be intuitive, allowing users to input data easily and see results quickly.\nrequirement pool:\n- Implement the core algebra evaluation function\n- Design a user-friendly interface for input\n- Optimize the function for performance\n- Add error handling for invalid inputs\n- Provide a detailed explanation of the evaluation process\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through the lists and applying the operators in sequence to the operands. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring correct order of operations. This approach will handle basic algebra operations efficiently and accurately.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently.\nrequirement pool:\n- Implement the main algebra evaluation function\n- Develop a user interface for inputting operators and operands\n- Ensure the function handles edge cases, such as division by zero\n- Provide detailed error messages for invalid inputs\n- Optimize the function for performance with large input sizes\nWe will implement a function that evaluates algebraic expressions using the provided operators and operands. The function will handle the order of operations correctly by using Python's built-in eval function after constructing the expression string. We will ensure that the function checks for division by zero and invalid inputs, providing appropriate error messages.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle the order of operations correctly and return the result efficiently.\nrequirement pool:\n- Implement the main algebraic computation logic\n- Design a user-friendly interface for input\n- Ensure the function handles edge cases like division by zero\n- Optimize for performance with large lists\n- Provide clear error messages for invalid inputs\nWe will implement a function that takes two lists: one for operators and one for operands. The function will iterate through the lists, applying each operator to the operands in sequence, respecting the order of operations. We will use the 'operator' module from Python's standard library to map string representations of operators to their corresponding functions, ensuring efficient and correct computation.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle basic operations and ensure the order of operations is respected. The input constraints must be validated to prevent errors.\nrequirement pool:\n- Implement the core algebraic expression evaluation logic\n- Develop a user-friendly interface for input\n- Ensure performance optimization for quick calculations\n- Add error handling for invalid inputs\n- Provide user guidance and feedback on input errors\nWe will implement a function that takes two lists: one for operators and one for operands. The function will construct an algebraic expression by iterating through these lists and applying the operations in sequence. We will use Python's built-in eval function to evaluate the expression, ensuring that the order of operations is respected. We will also include error handling for division by zero and invalid operator inputs.\n", "requirement analysis:\nThe function should correctly parse and evaluate algebraic expressions using the provided operators and operands. It must handle basic operations such as addition, subtraction, multiplication, floor division, and exponentiation. The input validation is crucial to ensure the operators and operands lists are of correct lengths and types.\nrequirement pool:\n- Implement the core algebraic evaluation logic.\n- Develop a user-friendly interface for input.\n- Ensure input validation and error handling.\n- Optimize performance for handling large numbers.\n- Provide detailed error messages for incorrect inputs.\nWe will implement a function that evaluates algebraic expressions using the provided operators and operands. The function will validate the input to ensure the operators and operands lists are of correct lengths and types. We will use Python's built-in capabilities for arithmetic operations, ensuring efficient handling of large numbers. The function will also provide detailed error messages for incorrect inputs.\n"], "scores": [0.6124, 1.0, 0.2326, 0.6124, 0.6124, 0.6124, 0.2326, 0.6124, 1.0, 0.6124], "pass_results": [false, true, false, false, false, false, false, false, true, false], "pass_test_cases_num": [79, 129, 30, 79, 79, 79, 30, 79, 129, 79], "completion": "from typing import List\n## main.py\n\ndef do_algebra(operator: list[str], operand: list[int]) -> int:\n    \"\"\"\n    Evaluates algebraic expressions using the provided operators and operands.\n\n    Parameters:\n    operator: A list of strings representing algebraic operations ('+', '-', '*', '//', '**').\n    operand: A list of non-negative integers.\n\n    Returns:\n    int: The result of the evaluated algebraic expression.\n\n    Raises:\n    ValueError: If the input lists do not meet the required format.\n    \"\"\"\n    # Validate input lengths\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"The number of operators must be one less than the number of operands.\")\n\n    # Validate operand types\n    if not all(isinstance(op, int) and op >= 0 for op in operand):\n        raise ValueError(\"All operands must be non-negative integers.\")\n\n    # Validate operator types\n    valid_operators = {'+', '-', '*', '//', '**'}\n    if not all(op in valid_operators for op in operator):\n        raise ValueError(f\"Operators must be one of {valid_operators}.\")\n\n    # Initialize result with the first operand\n    result = operand[0]\n\n    # Perform operations sequentially\n    for i, op in enumerate(operator):\n        if op == '+':\n            result += operand[i + 1]\n        elif op == '-':\n            result -= operand[i + 1]\n        elif op == '*':\n            result *= operand[i + 1]\n        elif op == '//':\n            if operand[i + 1] == 0:\n                raise ValueError(\"Division by zero is not allowed.\")\n            result //= operand[i + 1]\n        elif op == '**':\n            result **= operand[i + 1]\n\n    return result\n", "passed": true, "pass": true, "pass_num": 2, "round": 853, "mutate_method": "rephrase_one", "parent_index": 131}
